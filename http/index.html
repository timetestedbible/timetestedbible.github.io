---
layout: null
title: "Lunar Sabbath Calendar"
---
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#1a3a5c">
  <meta name="description" content="A time-tested lunar calendar for tracking Sabbaths and appointed times">
  <title>{{ page.title }}</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@600;700;900&display=swap" rel="stylesheet">
  <link rel="icon" type="image/svg+xml" href="/icons/icon.svg">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/icon-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/icon-16.png">
  <link rel="manifest" href="/manifest.json">
  <link rel="apple-touch-icon" href="/icons/icon-192.png">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #1a3a5c;
      min-height: 100vh;
    }

* {
  box-sizing: border-box;
}

/* Top Navigation Bar */
.top-nav {
  position: sticky;
  top: 0;
  z-index: 1000;
  background: linear-gradient(180deg, #0d2840 0%, #1a3a5c 100%);
  border-bottom: 1px solid rgba(255,255,255,0.1);
}

.top-nav-inner {
  max-width: 900px;
  margin: 0 auto;
  padding: 10px 15px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.top-nav-brand {
  display: flex;
  align-items: center;
  gap: 10px;
}

.top-nav-icon {
  font-size: 1.8em;
}

.top-nav-text {
  display: flex;
  flex-direction: column;
}

.top-nav-title {
  font-size: 1.3em;
  color: #7ec8e3;
  font-weight: bold;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
  font-family: 'Georgia', serif;
}

.top-nav-tagline {
  font-size: 0.75em;
  color: #d4a017;
  font-style: italic;
  font-family: 'Georgia', serif;
}

.hamburger-btn {
  background: none;
  border: none;
  color: #7ec8e3;
  font-size: 28px;
  cursor: pointer;
  padding: 8px;
  line-height: 1;
  border-radius: 8px;
  transition: background 0.2s;
}

.hamburger-btn:hover {
  background: rgba(255,255,255,0.1);
}

/* Hamburger Menu Dropdown */
.nav-menu-overlay {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0,0,0,0.5);
  z-index: 999;
}

.nav-menu-overlay.open {
  display: block;
}

.nav-menu {
  position: fixed;
  top: 0;
  right: -280px;
  width: 280px;
  height: 100%;
  background: linear-gradient(180deg, #1a3a5c 0%, #0d2840 100%);
  z-index: 1001;
  transition: right 0.3s ease;
  box-shadow: -4px 0 20px rgba(0,0,0,0.5);
  display: flex;
  flex-direction: column;
}

.nav-menu.open {
  right: 0;
}

.nav-menu-header {
  padding: 15px 20px;
  border-bottom: 1px solid rgba(255,255,255,0.1);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.nav-menu-header h3 {
  margin: 0;
  color: #7ec8e3;
  font-family: 'Georgia', serif;
}

.nav-menu-close {
  background: none;
  border: none;
  color: #7ec8e3;
  font-size: 24px;
  cursor: pointer;
  padding: 4px 8px;
}

.nav-menu-items {
  flex: 1;
  padding: 10px 0;
  overflow-y: auto;
}

.nav-menu-item {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 10px 20px;
  color: white;
  text-decoration: none;
  font-size: 1.1em;
  font-family: 'Georgia', serif;
  border: none;
  background: none;
  width: 100%;
  text-align: left;
  cursor: pointer;
  transition: background 0.2s;
}

.nav-menu-item:hover {
  background: rgba(255,255,255,0.1);
}

.nav-menu-item .icon {
  font-size: 1.3em;
  width: 30px;
  text-align: center;
}

.nav-menu-item.active {
  background: rgba(212, 160, 23, 0.2);
  border-left: 3px solid #d4a017;
}

.nav-menu-divider {
  height: 1px;
  background: rgba(255,255,255,0.1);
  margin: 10px 20px;
}

/* Book advertisement in nav menu */
.book-ad {
  margin: 15px 40px;
  padding: 12px 8px;
  background: linear-gradient(135deg, #f8f4e8 0%, #fff 50%, #f8f4e8 100%);
  border-radius: 8px;
  text-align: center;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  border: 1px solid rgba(212, 160, 23, 0.3);
  aspect-ratio: 5 / 7;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  align-items: center;
}

.book-ad-text {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin-bottom: 8px;
}

.book-ad-top {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding-top: 10px;
}

.book-ad-bottom {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding-bottom: 10px;
}

.book-ad-title {
  font-family: 'Playfair Display', 'Times New Roman', Georgia, serif;
  font-size: 2.7em;
  font-weight: 900;
  color: #111;
  letter-spacing: 0.08em;
  line-height: 1;
  margin-bottom: 2px;
  text-align: center;
}

.book-ad-subtitle {
  font-family: 'Playfair Display', 'Times New Roman', Georgia, serif;
  font-size: 1.05em;
  font-weight: 700;
  color: #111;
  letter-spacing: 0.01em;
  margin-bottom: 2px;
  text-align: center;
}

.book-ad-tagline {
  font-family: 'Playfair Display', 'Times New Roman', Georgia, serif;
  font-size: 0.55em;
  font-weight: 600;
  color: #333;
  letter-spacing: 0;
  margin-bottom: 0;
  text-align: center;
  white-space: nowrap;
}

.book-ad-author {
  font-family: 'Playfair Display', 'Times New Roman', Georgia, serif;
  font-size: 0.8em;
  font-style: italic;
  color: #555;
  margin-bottom: 12px;
}

.book-ad-download {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 8px 16px;
  background: linear-gradient(135deg, #d4a017 0%, #b8860b 100%);
  color: #fff;
  text-decoration: none;
  border-radius: 6px;
  font-weight: 600;
  font-size: 0.9em;
  transition: all 0.2s ease;
  box-shadow: 0 2px 6px rgba(0,0,0,0.2);
}

.book-ad-download:hover {
  background: linear-gradient(135deg, #e6b422 0%, #d4a017 100%);
  transform: translateY(-1px);
  box-shadow: 0 4px 10px rgba(0,0,0,0.3);
}

.book-ad-download .icon {
  font-size: 1.1em;
}

.calendar-app {
  max-width: 900px;
  margin: 0 auto;
  padding: 8px;
  font-family: 'Georgia', serif;
  min-height: 100vh;
}

.calendar-controls {
  display: flex;
  flex-wrap: wrap;
  gap: 15px;
  margin-bottom: 20px;
  padding: 15px;
  background: #1a3a5c;
  border-radius: 8px;
  color: white;
}

.control-group {
  display: flex;
  flex-direction: column;
  gap: 5px;
}

.control-group label {
  font-size: 0.85em;
  opacity: 0.9;
}

.control-group input, .control-group select {
  padding: 8px 12px;
  border: none;
  border-radius: 4px;
  font-size: 1em;
}

.btn {
  padding: 10px 20px;
  background: #d4a017;
  color: #1a3a5c;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-weight: bold;
  align-self: flex-end;
}

.btn:hover {
  background: #e8b830;
}

/* Month Calendar Container */
.month-calendar {
  background: linear-gradient(180deg, #1a3a5c 0%, #2a5a8c 100%);
  overflow: hidden;
  margin-bottom: 0;
  border-radius: 12px;
}

/* Header Section - New 2-row grid layout */
.calendar-header {
  display: grid;
  grid-template-columns: 1fr auto;
  grid-template-rows: auto auto;
  padding: 0;
  background: linear-gradient(180deg, #0d2840 0%, #1a3a5c 100%);
  color: white;
  gap: 0;
  width: 100%;
  overflow: hidden;
}

/* Row 1: Profile name */
.header-row-1 {
  grid-column: 1;
  grid-row: 1;
  padding: 8px 12px 4px;
}

/* Row 2: Year | Month | Time | Location */
.header-row-2 {
  grid-column: 1;
  grid-row: 2;
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 4px 12px 8px;
  flex-wrap: wrap;
}

/* Day 1 cell spans both rows */
.new-moon-box {
  grid-column: 2;
  grid-row: 1 / 3;
}

/* Dropdown item styles */
.header-dropdown {
  display: flex;
  align-items: center;
  gap: 4px;
  cursor: pointer;
  padding: 4px 8px;
  border-radius: 6px;
  transition: background 0.2s;
  white-space: nowrap;
}

.header-dropdown:hover {
  background: rgba(255,255,255,0.1);
}

.header-dropdown .dropdown-arrow {
  font-size: 0.7em;
  opacity: 0.7;
}

.header-dropdown.profile {
  color: #7ec8e3;
  font-size: 1.95em;
  font-weight: bold;
  gap: 8px;
}

.header-dropdown.profile .profile-moon {
  font-size: 1em;
  line-height: 1;
}

.header-dropdown.year {
  color: #7ec8e3;
  font-weight: bold;
  font-size: 1.3em;
}

.header-dropdown.month {
  color: #d4a017;
  font-weight: bold;
  font-size: 1.3em;
}

.header-dropdown.time {
  color: #d4a017;
  font-size: 1.3em;
}

.header-dropdown.location {
  color: #7ec8e3;
  font-size: 1.3em;
}

.header-separator {
  color: rgba(255,255,255,0.3);
  font-size: 0.8em;
}

/* Legacy support - keep for compatibility */
.header-left {
  display: none;
}

.calendar-title {
  text-align: left;
  padding: 5px 10px;
  display: flex;
  flex-direction: column;
  justify-content: flex-end;
}

.calendar-title .site-title {
  font-size: 1.6em;
  color: #7ec8e3;
  font-weight: bold;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
  margin-bottom: 2px;
}

.calendar-title .site-tagline .book-link {
  text-decoration: none;
  font-size: 1.1em;
  margin-left: 6px;
  opacity: 0.8;
  transition: opacity 0.2s;
}

.calendar-title .site-tagline .book-link:hover {
  opacity: 1;
}

.calendar-title .site-tagline {
  font-size: 0.85em;
  color: #d4a017;
  font-style: italic;
  margin-bottom: 4px;
}

.calendar-title .profile-name {
  font-size: 0.85em;
  color: #7ec8e3;
  margin-bottom: 2px;
}

.calendar-title .month-name {
  font-size: 1.2em;
  color: #d4a017;
  display: flex;
  align-items: center;
  gap: 6px;
}

.calendar-title .dropdown-arrow {
  font-size: 0.6em;
  opacity: 0.7;
}

.calendar-title .year-display {
  font-size: 1em;
  color: #7ec8e3;
  font-weight: bold;
}

.calendar-title .year .location-link {
  cursor: pointer;
  text-decoration: underline;
  text-decoration-style: dotted;
  text-underline-offset: 2px;
}

.calendar-title .location-link:hover {
  text-decoration-style: solid;
  color: #a0e0ff;
}

.month-picker-target {
  cursor: pointer;
  padding: 8px 12px;
  padding-bottom: 5px;
  border-radius: 8px;
  transition: background 0.2s;
}

.month-picker-target:hover {
  background: rgba(255,255,255,0.1);
}

.year-display {
  color: rgba(255,255,255,0.7);
  font-size: 0.85em;
  margin-top: 2px;
}

/* Time display in header */
.time-display {
  display: flex;
  align-items: center;
  gap: 4px;
  cursor: pointer;
  padding: 2px 6px;
  border-radius: 4px;
  transition: background 0.2s;
  font-size: 0.85em;
  color: rgba(255,255,255,0.8);
}

.time-display:hover {
  background: rgba(255,255,255,0.1);
}


/* Time picker modal */
.time-picker-modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0,0,0,0.7);
  z-index: 1100;
  align-items: center;
  justify-content: center;
}

.time-picker-content {
  background: #1a3a5c;
  border-radius: 12px;
  padding: 20px;
  min-width: 280px;
  max-width: 350px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.5);
}

.time-picker-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
}

.time-picker-header h3 {
  margin: 0;
  color: #fff;
  font-size: 1.1em;
}

.time-picker-form {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.time-picker-row {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.time-picker-row label {
  color: rgba(255,255,255,0.7);
  font-size: 0.9em;
}

.time-picker-row input {
  padding: 10px;
  border-radius: 6px;
  border: 1px solid rgba(255,255,255,0.2);
  background: rgba(0,0,0,0.3);
  color: #fff;
  font-size: 1em;
}

.time-picker-buttons {
  display: flex;
  gap: 8px;
  margin-top: 8px;
}

.time-picker-buttons .btn {
  flex: 1;
}

.location-display {
  color: rgba(255,255,255,0.7);
  font-size: 0.85em;
  margin-top: 4px;
  padding-left: 12px;
}

.location-time-col {
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  justify-content: flex-end;
  padding-right: 10px;
  padding-bottom: 5px;
  text-align: right;
  flex: 1;
}

.location-time-col .time-display {
  font-size: 1.2em;
  color: #d4a017;
  font-weight: bold;
}

.location-time-col .location-link {
  font-size: 1em;
  cursor: pointer;
  text-decoration: underline;
  text-decoration-style: dotted;
  color: #7ec8e3;
  font-weight: bold;
}

.location-time-col .location-link:hover {
  color: #fff;
}

/* Month Picker Popup */
.month-picker-overlay {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0,0,0,0.5);
  z-index: 1000;
}

.month-picker-overlay.open {
  display: block;
}

.month-picker {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: #1a3a5c;
  border-radius: 20px;
  padding: 28px;
  z-index: 1001;
  width: 70%;
  max-width: 630px;
  box-shadow: 0 10px 40px rgba(0,0,0,0.5);
}

.month-picker-header {
  display: flex;
  justify-content: center;
  align-items: center;
  margin-bottom: 24px;
  padding-bottom: 16px;
  border-bottom: 1px solid rgba(255,255,255,0.2);
  position: relative;
}

.month-picker-header h3 {
  margin: 0;
  color: #7ec8e3;
  font-size: 1.5em;
}

.month-picker .close-btn {
  position: absolute;
  top: -8px;
  right: -8px;
  background: rgba(255,255,255,0.1);
  border: none;
  color: #fff;
  font-size: 1.3em;
  cursor: pointer;
  padding: 12px 16px;
  line-height: 1;
  border-radius: 10px;
  min-width: 48px;
  min-height: 48px;
}

.month-picker .close-btn:hover {
  background: rgba(255,255,255,0.2);
}

.year-nav {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 20px;
  margin-bottom: 20px;
}

.year-nav button {
  background: #0d2840;
  border: none;
  color: #d4a017;
  padding: 16px 24px;
  border-radius: 12px;
  cursor: pointer;
  font-size: 1.5em;
  min-width: 58px;
  min-height: 58px;
}

.year-nav button:hover {
  background: #2a5a8c;
}

.year-nav .year-display {
  color: #fff;
  font-size: 1.5em;
  font-weight: bold;
  min-width: 130px;
  text-align: center;
  cursor: pointer;
  padding: 8px 12px;
  border-radius: 8px;
  transition: background 0.2s;
}

.year-nav .year-display:hover {
  background: rgba(255,255,255,0.1);
}

.year-display-container {
  position: relative;
  min-width: 120px;
  height: 50px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.year-nav .year-display {
  font-size: 2em;
  font-weight: bold;
  cursor: pointer;
  padding: 8px 16px;
  color: #fff;
}

.year-nav .year-input {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  font-size: 1.5em;
  font-weight: bold;
  width: 100%;
  text-align: center;
  padding: 8px 12px;
  border: 2px solid #d4a017;
  border-radius: 8px;
  background: #0d2840;
  color: #fff;
  font-family: inherit;
  display: none;
  box-sizing: border-box;
}

.year-nav .year-input.visible {
  display: block;
}

.era-select {
  background: #0d2840;
  border: 2px solid rgba(212, 160, 23, 0.5);
  border-radius: 12px;
  color: #d4a017;
  padding: 12px 16px;
  font-size: 1.2em;
  font-weight: bold;
  cursor: pointer;
  margin-left: 16px;
  appearance: none;
  -webkit-appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23d4a017' d='M6 8L2 4h8z'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 10px center;
  padding-right: 32px;
  min-height: 52px;
}

.era-select:hover {
  border-color: #d4a017;
}

.era-select:focus {
  outline: none;
  border-color: #d4a017;
  box-shadow: 0 0 0 2px rgba(212, 160, 23, 0.2);
}

.era-select option {
  background: #0d2840;
  color: #fff;
}

.month-grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 12px;
}

.month-grid button {
  background: #0d2840;
  border: none;
  color: #fff;
  padding: 18px 10px;
  border-radius: 12px;
  cursor: pointer;
  font-size: 1.1em;
  transition: all 0.2s;
  min-height: 58px;
}

.month-grid button:hover {
  background: #2a5a8c;
}

.month-grid button.active {
  background: #d4a017;
  color: #1a3a5c;
  font-weight: bold;
}

.month-grid button.disabled {
  opacity: 0.3;
  cursor: not-allowed;
}

.month-grid .today-btn {
  background: #d4a017;
  border: none;
  color: #1a3a5c;
  font-weight: bold;
}

.month-grid .today-btn:hover {
  background: #e5b828;
}

/* City Picker Modal */
.city-picker-overlay {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0,0,0,0.7);
  z-index: 1000;
}

.city-picker-overlay.visible {
  display: block;
}

.city-picker {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: #1a3a5c;
  border-radius: 20px;
  padding: 24px;
  z-index: 1001;
  width: 90%;
  max-width: 600px;
  max-height: 85vh;
  overflow-y: auto;
  box-shadow: 0 10px 40px rgba(0,0,0,0.5);
}

.city-picker-header {
  display: flex;
  justify-content: center;
  align-items: center;
  margin-bottom: 16px;
  padding-bottom: 12px;
  border-bottom: 1px solid rgba(255,255,255,0.2);
  position: relative;
}

.city-picker-header h3 {
  margin: 0;
  color: #7ec8e3;
  font-size: 1.3em;
}

.city-picker .close-btn {
  position: absolute;
  right: 0;
  top: 50%;
  transform: translateY(-50%);
  background: none;
  border: none;
  color: #7ec8e3;
  font-size: 1.5em;
  cursor: pointer;
  padding: 0;
  line-height: 1;
}

#city-picker-map {
  margin-bottom: 16px;
  border-radius: 8px;
  overflow: hidden;
}

#city-picker-map .dateline-map {
  cursor: crosshair !important;
}

.city-picker-controls {
  display: flex;
  gap: 12px;
  margin-bottom: 12px;
}

.city-action-btn {
  background: rgba(126, 200, 227, 0.2);
  border: 1px solid rgba(126, 200, 227, 0.4);
  color: #7ec8e3;
  padding: 10px 16px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.95em;
  white-space: nowrap;
}

.city-action-btn:hover {
  background: rgba(126, 200, 227, 0.3);
}

.city-picker-select {
  flex: 1;
  padding: 10px 12px;
  border: 1px solid rgba(126, 200, 227, 0.3);
  border-radius: 6px;
  background: rgba(0,0,0,0.2);
  color: #fff;
  font-size: 0.95em;
  cursor: pointer;
}

.city-picker-select option {
  background: #1a3a5c;
  color: #fff;
}

.city-picker-controls {
  margin-bottom: 16px;
}

.city-picker-profile-row {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 12px;
  padding-bottom: 12px;
  border-bottom: 1px solid rgba(255,255,255,0.1);
}

.city-picker-profile-row label {
  color: rgba(255,255,255,0.7);
  font-size: 0.9em;
  white-space: nowrap;
}

.city-picker-profile-row select {
  flex: 1;
}

.city-picker-confirm-row {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
  padding-top: 12px;
  margin-top: 12px;
  border-top: 1px solid rgba(255,255,255,0.1);
}

.city-picker-confirm-row .btn {
  min-width: 100px;
}

#city-picker-map {
  border-top: 1px solid rgba(255,255,255,0.1);
  padding-top: 12px;
}

/* Profile Picker Dropdown */
.profile-picker-overlay {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: transparent;
  z-index: 999;
}

.profile-picker-overlay.visible {
  display: block;
}

.profile-picker {
  position: fixed;
  background: #1a3a5c;
  border-radius: 12px;
  padding: 12px;
  z-index: 1001;
  min-width: 280px;
  max-width: 350px;
  max-height: 70vh;
  overflow-y: auto;
  box-shadow: 0 8px 32px rgba(0,0,0,0.5);
  border: 1px solid rgba(255,255,255,0.1);
}

.profile-picker-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
  padding-bottom: 8px;
  border-bottom: 1px solid rgba(255,255,255,0.1);
}

.profile-picker-header h3 {
  margin: 0;
  color: #fff;
  font-size: 1em;
}

.profile-picker-header .close-btn {
  display: none;
}

.profile-add-btn {
  width: 28px;
  height: 28px;
  border-radius: 50%;
  border: 2px solid rgba(255,255,255,0.3);
  background: transparent;
  color: #fff;
  font-size: 1.2em;
  font-weight: bold;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
}

.profile-add-btn:hover {
  background: rgba(255,255,255,0.1);
  border-color: #d4a017;
  color: #d4a017;
}

.profile-picker-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.profile-option {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px 12px;
  background: rgba(255,255,255,0.05);
  border: 2px solid transparent;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s;
}

.profile-option:hover {
  background: rgba(255,255,255,0.1);
}

.profile-option.selected {
  border-color: #d4a017;
  background: rgba(212, 160, 23, 0.15);
}

.profile-option-icon {
  font-size: 1.8em;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 1.8em;
  height: 1.8em;
}

.profile-option-icon img {
  width: 1.4em;
  height: 1.4em;
  object-fit: contain;
}

.profile-option-info {
  flex: 1;
}

.profile-option-name {
  color: #fff;
  font-weight: bold;
  font-size: 1.05em;
}

.profile-option-hint {
  color: rgba(255,255,255,0.6);
  font-size: 0.85em;
  margin-top: 2px;
}


/* Date Jump Popup */
.date-jump-overlay {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0,0,0,0.5);
  z-index: 1000;
}

.date-jump-overlay.open {
  display: block;
}

.date-jump-popup {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: #1a3a5c;
  border-radius: 20px;
  padding: 28px;
  z-index: 1001;
  width: 70%;
  max-width: 630px;
  box-shadow: 0 10px 40px rgba(0,0,0,0.5);
}

.date-jump-popup h3 {
  margin: 0 0 24px 0;
  color: #7ec8e3;
  font-size: 1.5em;
  text-align: center;
}

.date-jump-popup .close-btn {
  position: absolute;
  top: 16px;
  right: 16px;
  background: rgba(255,255,255,0.1);
  border: none;
  color: #fff;
  font-size: 1.3em;
  cursor: pointer;
  padding: 12px 16px;
  line-height: 1;
  border-radius: 10px;
  min-width: 48px;
  min-height: 48px;
}

.date-jump-popup .close-btn:hover {
  background: rgba(255,255,255,0.2);
}

.date-jump-popup input {
  width: 100%;
  padding: 18px;
  border: none;
  border-radius: 12px;
  background: #0d2840;
  color: #fff;
  font-size: 1.2em;
  margin-bottom: 20px;
  box-sizing: border-box;
  min-height: 60px;
}

.date-jump-popup .btn-row {
  display: flex;
  gap: 14px;
  margin-bottom: 24px;
}

.date-jump-popup .btn {
  flex: 1;
  padding: 18px;
  background: #d4a017;
  color: #1a3a5c;
  border: none;
  border-radius: 12px;
  cursor: pointer;
  font-weight: bold;
  font-size: 1.2em;
  min-height: 60px;
}

.date-jump-popup .btn:hover {
  background: #e5b328;
}

.date-jump-popup .btn.secondary {
  background: #2a5a8c;
  color: #fff;
}

.date-jump-popup .btn.secondary:hover {
  background: #3a6a9c;
}

.days-jump {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 12px;
  padding-top: 20px;
  margin-top: 8px;
  border-top: 1px solid rgba(255,255,255,0.2);
}

.days-jump input {
  width: 100px;
  text-align: center;
  margin-bottom: 0;
  min-height: 58px;
  font-size: 1.3em;
  border-radius: 12px;
}

.days-jump button {
  background: #0d2840;
  border: none;
  color: #d4a017;
  padding: 16px 24px;
  border-radius: 12px;
  cursor: pointer;
  font-size: 1.5em;
  min-height: 58px;
  min-width: 58px;
}

.days-jump button:hover {
  background: #2a5a8c;
}

.days-jump span {
  color: #ccc;
  font-size: 1.2em;
  margin-left: 4px;
}

/* Old jump button styles removed - button is now in day detail header */

.full-moon-info {
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  border-radius: 10px;
  padding: 6px;
  transition: background 0.2s;
  position: relative;
}

.full-moon-info:hover {
  background: rgba(255,255,255,0.1);
}

.full-moon-info .moon-icon {
  font-size: 68px;
  line-height: 1;
}

.moon-icon-wrapper {
  position: relative;
  display: inline-block;
}

.moon-gear-badge {
  position: absolute;
  bottom: -4px;
  right: -2px;
  font-size: 22px;
  color: #7ec8e3;
  opacity: 0.7;
  text-shadow: 0 1px 2px rgba(0,0,0,0.5);
}

.full-moon-info:hover .moon-gear-badge {
  opacity: 1;
}

/* Export/Feasts page specific styles */
html.feasts-open,
body.feasts-open {
  overflow: hidden !important;
  height: 100%;
}

/* Sabbath Tester page overflow control - hide body scroll, page has its own */
body.sabbath-tester-open {
  overflow: hidden !important;
}

#export-page {
  position: fixed;
  top: 55px; /* Below the top nav */
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 100;
  overflow-y: auto;
  border-radius: 0;
  margin: 0;
  background: linear-gradient(180deg, #1a3a5c 0%, #2a5a8c 100%);
}

#export-page .settings-page-header {
  position: sticky;
  top: 0;
  z-index: 10;
}

#export-page .export-header {
  display: flex;
  flex-wrap: nowrap;
  gap: 10px;
  align-items: center;
  justify-content: space-between;
  padding: 15px 20px;
}

#export-page .export-header h2 {
  flex: 1;
  text-align: left;
  font-size: 1.2em;
  margin: 0;
  line-height: 1.2;
}

#export-page .export-download-btn {
  padding: 10px 16px;
  font-size: 0.95em;
  white-space: nowrap;
  flex-shrink: 0;
}

.export-settings-context {
  background: rgba(0,0,0,0.3);
  padding: 12px 20px;
  font-size: 0.9em;
  color: #ccc;
  border-bottom: 1px solid rgba(255,255,255,0.1);
}

.export-settings-context span {
  display: flex;
  flex-wrap: wrap;
  gap: 8px 20px;
  justify-content: center;
}

.export-context-item {
  display: inline-flex;
  align-items: center;
  gap: 5px;
}

.export-context-label {
  color: #888;
}

.export-context-value {
  color: #d4a017;
  font-weight: 500;
}

/* Dateline Visualization */
.dateline-container {
  margin-top: 20px;
  padding: 15px;
  background: rgba(0,0,0,0.2);
  border-radius: 8px;
  width: 100%;
}

.dateline-label {
  font-size: 0.7em;
  color: #7ec8e3;
  margin-bottom: 5px;
}

.dateline-map {
  position: relative;
  aspect-ratio: 2 / 1;
  background: #1a3a5c;
  border-radius: 8px;
  overflow: hidden;
  cursor: crosshair;
  user-select: none;
  -webkit-user-select: none;
  -webkit-user-drag: none;
}

.dateline-map.disabled {
  cursor: not-allowed;
  opacity: 0.7;
}

.dateline-map-bg {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  /* Fallback gradient if image fails */
  background: linear-gradient(to bottom, 
    #1a4a6e 0%, 
    #2d6a4f 20%, 
    #2d6a4f 40%,
    #1a4a6e 50%,
    #2d6a4f 60%,
    #1a4a6e 100%);
}

.dateline-map-bg img {
  width: 100%;
  height: 100%;
  object-fit: fill;
  opacity: 0.85;
}

.dateline-location-marker {
  position: absolute;
  width: 14px;
  height: 14px;
  transform: translate(-50%, -50%);
  z-index: 5;
  pointer-events: none;
}

/* Vertical dashed line */
.dateline-location-marker::before {
  content: '';
  position: absolute;
  left: 50%;
  top: 0;
  width: 0;
  height: 100vh;
  border-left: 1px dashed rgba(255, 100, 100, 0.8);
  transform: translateX(-50%) translateY(-50vh);
}

/* Horizontal dashed line */
.dateline-location-marker::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 0;
  width: 100vw;
  height: 0;
  border-top: 1px dashed rgba(255, 100, 100, 0.8);
  transform: translateY(-50%) translateX(-50vw);
}

/* Central red dot */
.dateline-location-pin {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  width: 12px;
  height: 12px;
  background: #ff3333;
  border: 2px solid #fff;
  border-radius: 50%;
  box-shadow: 0 0 6px rgba(255, 0, 0, 0.8), 0 0 12px rgba(255, 50, 50, 0.5);
}

.dateline-click-hint {
  font-size: 0.6em;
  color: #7ec8e3;
  text-align: center;
  margin-top: 3px;
  font-style: italic;
}

.dateline-marker {
  position: absolute;
  top: 0;
  bottom: 0;
  width: 3px;
  background: linear-gradient(to bottom, #ffcc00, #ff6b6b);
  box-shadow: 0 0 15px rgba(255,107,107,0.8), 0 0 30px rgba(255,204,0,0.5);
  z-index: 10;
  pointer-events: none;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: space-between;
}

.dateline-marker-icon {
  position: absolute;
  top: 5px;
  left: 50%;
  transform: translateX(-50%);
  color: #ffcc00;
  font-size: 18px;
  text-shadow: 0 0 10px rgba(255,204,0,0.8);
}

.dateline-marker-label {
  position: absolute;
  bottom: 5px;
  left: 50%;
  transform: translateX(-50%);
  color: #ffcc00;
  font-size: 8px;
  font-weight: bold;
  text-shadow: 0 0 5px rgba(0,0,0,0.8);
  white-space: nowrap;
}

.dateline-cities {
  display: flex;
  justify-content: space-between;
  font-size: 0.65em;
  color: #7ec8e3;
  margin-top: 5px;
  padding: 0 5px;
}

.dateline-info {
  font-size: 0.65em;
  color: #d4a017;
  margin-top: 5px;
}


/* Day 1 in header - inherits from .day-cell */
.new-moon-box {
  aspect-ratio: unset;
  min-height: 80px;
  width: calc((min(100vw, 900px) - 16px) / 7);
  box-sizing: border-box;
  overflow: hidden;
  flex-shrink: 0;
}

.new-moon-box .gregorian {
  flex-direction: row;
  gap: 4px;
  white-space: nowrap;
}

.new-moon-box .gregorian .day-year {
  font-size: 0.85em;
}

/* Year Uncertainty Banner */
.year-uncertainty-banner {
  background: linear-gradient(90deg, #ff6b00 0%, #ff8c00 100%);
  color: white;
  text-align: center;
  padding: 6px 12px;
  font-size: 0.9em;
  font-weight: 600;
  cursor: help;
  border-bottom: 1px solid #cc5500;
}

/* Week Header */
.week-header {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  background: #1a3a5c;
  border-top: 2px solid #2a5a8c;
  border-left: 1px solid #2a5a8c;
  border-right: 1px solid #2a5a8c;
}

.week-header .day-label {
  padding: 10px 5px;
  text-align: center;
  color: white;
  font-size: 0.85em;
  border-right: 1px solid #2a5a8c;
}

.week-header .day-label:last-child {
  border-right: none;
}

.week-header .day-label.sabbath-header {
  background: #d4a017;
  color: #1a3a5c;
  font-weight: bold;
}

.week-header .day-label .day-name {
  font-weight: bold;
}

.week-header .day-label .weekday {
  font-size: 0.9em;
  opacity: 0.8;
}

/* Day Cycle Bar - shows daylight/night alignment with calendar days */
/* Gradient is generated dynamically based on actual sunrise/sunset times */
.day-cycle-bar {
  height: 6px;
  border-left: 1px solid #2a5a8c;
  border-right: 1px solid #2a5a8c;
}

/* Calendar Grid */
.calendar-grid {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  grid-template-rows: repeat(5, 1fr);
  background: #2a5a8c;
  aspect-ratio: 7 / 5;
}

.day-cell {
  aspect-ratio: 1;
  min-height: 70px;
  padding: 5px;
  background: #3a6a9c;
  border: 1px solid #2a5a8c;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  position: relative;
  color: white;
  cursor: pointer;
}

.day-cell:not(.empty):hover {
  background: #4a7aac;
}

.day-cell.empty {
  background: #2a5a8c;
}

.day-cell.quote-row-spacer {
  background: #0d2840;
}

.day-cell .gregorian {
  font-size: 1em;
  color: #fff;
  position: absolute;
  top: 5px;
  left: 5px;
  font-weight: 600;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
  display: flex;
  flex-direction: column;
  line-height: 1.2;
}

.day-cell .gregorian .day-year {
  font-size: 0.75em;
  color: #7ec8e3;
  font-weight: normal;
}

.day-cell .lunar-day {
  font-size: 2em;
  font-weight: bold;
  color: #e8e8e8;
}

.day-cell .moon-phase {
  font-size: 1.2em;
  position: absolute;
  top: 5px;
  right: 5px;
}

.day-cell .moon-phase.blood-moon {
  /* Blood red glow effect for lunar eclipse */
  filter: sepia(1) saturate(5) hue-rotate(320deg) brightness(0.9);
  text-shadow: 0 0 10px rgba(180, 0, 0, 1), 0 0 20px rgba(255, 50, 50, 0.8), 0 0 30px rgba(200, 0, 0, 0.6);
  background: rgba(139, 0, 0, 0.3);
  border-radius: 50%;
  padding: 2px 4px;
}

/* Sabbath Days - gold-tinted background for more contrast */
.day-cell.sabbath {
  background: linear-gradient(135deg, #4a5a6a 0%, #3a4a5a 100%);
  border: 1px solid #d4a01755;
}

.day-cell.sabbath .lunar-day {
  color: #ffd700;
  text-shadow: 0 0 8px rgba(212, 160, 23, 0.6), 1px 1px 2px rgba(0,0,0,0.5);
  font-weight: bold;
}

/* New Moon Day */
.day-cell.new-moon {
  background: linear-gradient(135deg, #1a4a7c 0%, #2a5a8c 100%);
}

.day-cell.new-moon .lunar-day {
  color: #7ec8e3;
}

/* New Moon that is also a Sabbath (fixed weekday sabbath falls on new moon) */
.day-cell.new-moon.sabbath {
  background: linear-gradient(135deg, #3a6a9c 0%, #2a5a8c 100%);
}

.day-cell.new-moon.sabbath .lunar-day {
  color: #d4a017;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
}

/* Highlighted/Selected Day */
.day-cell.highlighted {
  box-shadow: inset 0 0 0 3px #ff6b6b, 0 0 10px #ff6b6b;
  animation: pulse 1.5s ease-in-out 3;
}

@keyframes pulse {
  0%, 100% { box-shadow: inset 0 0 0 3px #ff6b6b, 0 0 10px #ff6b6b; }
  50% { box-shadow: inset 0 0 0 3px #ff6b6b, 0 0 20px #ff6b6b; }
}

/* Today's date - moderate warm highlight */
.day-cell.today {
  background: linear-gradient(135deg, #4a5535 0%, #3a4528 100%);
  border: 1px solid #7a9050;
}

.day-cell.today .gregorian {
  color: #b8d080;
}

/* When today is also a sabbath - combine both highlights */
.day-cell.today.sabbath {
  background: linear-gradient(135deg, #4a5535 0%, #3a4020 100%);
  border: 1px solid #7a9050;
}

.day-cell .feast-icons {
  font-size: 1em;
  position: absolute;
  bottom: 2px;
  right: 3px;
  text-align: right;
  line-height: 1;
  letter-spacing: 0.15em;
  line-height: 1.2;
  font-weight: bold;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
}

/* Scripture Quote - integrated into last row */
.scripture-quote {
  padding: 10px 15px;
  text-align: center;
  color: #d4a017;
  font-style: italic;
  background: #0d2840;
  font-size: 0.85em;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
}

.scripture-quote.span-4 {
  grid-column: span 4;
}

/* Month navigation cells in last row */
.month-nav-cell {
  background: #0d2840;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: background 0.2s;
}

.month-nav-cell:hover:not(.disabled) {
  background: #1a3a5c;
}

.month-nav-cell.disabled {
  cursor: default;
  opacity: 0.3;
}

.month-nav-cell .nav-arrow {
  color: #d4a017;
  font-size: 1.5em;
}

.scripture-quote .reference {
  color: #7ec8e3;
  font-style: normal;
  margin-left: 10px;
}

/* Settings Dialog */
/* Old settings overlay - now hidden, replaced by settings page */
.settings-overlay {
  display: none !important;
}

.settings-overlay.open {
  display: none !important;
}

/* Old settings dialog - now hidden, replaced by settings page */
.settings-dialog {
  display: none !important;
}

.settings-dialog.open {
  display: none !important;
}

.settings-header {
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 20px 24px 16px;
  color: white;
  border-bottom: 1px solid rgba(255,255,255,0.2);
  position: relative;
}

.settings-header h3 {
  margin: 0;
  font-size: 1.4em;
  color: #7ec8e3;
}

.settings-dialog .close-btn {
  position: absolute;
  top: 12px;
  right: 12px;
  background: rgba(255,255,255,0.1);
  border: none;
  color: white;
  font-size: 1.2em;
  cursor: pointer;
  padding: 12px 16px;
  line-height: 1;
  border-radius: 10px;
  min-width: 48px;
  min-height: 48px;
}

.settings-dialog .close-btn:hover {
  background: rgba(255,255,255,0.2);
}

.settings-content {
  padding: 24px;
}

.setting-group {
  margin-bottom: 24px;
}

.setting-group label {
  display: block;
  font-weight: bold;
  margin-bottom: 12px;
  color: #7ec8e3;
  font-size: 1.1em;
}

.setting-group select,
.setting-group input {
  width: 100%;
  padding: 16px;
  border: none;
  border-radius: 12px;
  font-size: 1.1em;
  box-sizing: border-box;
  background: #0d2840;
  color: #fff;
  min-height: 54px;
}

.city-select-styled {
  margin-top: 12px;
}

.setting-info {
  font-size: 0.95em;
  color: #aaa;
  padding-top: 16px;
  border-top: 1px solid rgba(255,255,255,0.2);
  text-align: center;
}

/* Moon Phase Buttons */
.moon-phase-buttons {
  display: flex;
  gap: 12px;
}

.moon-phase-btn {
  flex: 1;
  background: #0d2840;
  border: 3px solid transparent;
  border-radius: 14px;
  padding: 16px 10px;
  cursor: pointer;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  transition: all 0.2s;
  min-height: 90px;
}

.moon-phase-btn:hover {
  background: #2a5a8c;
}

.moon-phase-btn.active {
  border-color: #d4a017;
  background: #2a5a8c;
}

.moon-phase-btn .phase-icon {
  font-size: 2em;
}

.moon-phase-btn .phase-name {
  color: #fff;
  font-size: 0.85em;
  font-weight: bold;
}

/* Settings Map */
#settings-map-container {
  margin-bottom: 12px;
}

#settings-map-container .dateline-container {
  margin-top: 0;
  padding: 12px;
}


.location-btn {
  width: 100%;
  padding: 16px;
  background: #2a5a8c;
  color: #fff;
  border: none;
  border-radius: 12px;
  font-size: 1.1em;
  cursor: pointer;
  margin-top: 12px;
  min-height: 54px;
}

.location-btn:hover {
  background: #3a6a9c;
}

.location-btn {
  width: 100%;
  padding: 12px;
  background: #2a5a8c;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 1em;
  margin-bottom: 15px;
}

.location-btn:hover {
  background: #1a3a5c;
}

.location-btn:disabled {
  background: #ccc;
  cursor: not-allowed;
}


/* Month Navigation */
.month-nav {
  display: flex;
  justify-content: center;
  align-items: center;
  margin-bottom: 20px;
}

.month-buttons {
  display: flex;
  flex-wrap: nowrap;
  gap: 4px;
  justify-content: center;
  align-items: center;
  width: 100%;
}

.month-btn {
  flex: 1;
  min-width: 0;
  height: 40px;
  padding: 0;
  background: #1a3a5c;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 1em;
  font-weight: bold;
  transition: all 0.2s;
}

/* 13th month button with calendar icon overlay */
.month-btn.month-13 {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
}

.month-13-icon {
  font-size: 1.2em;
  position: relative;
}

.month-13-num {
  position: absolute;
  font-size: 0.6em;
  font-weight: bold;
  color: #1a3a5c;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -35%);
  text-shadow: 0 0 2px white, 0 0 2px white;
}

.month-btn:hover {
  background: #2a5a8c;
  transform: scale(1.05);
}

.month-btn.active {
  background: #d4a017;
  color: #1a3a5c;
}

.month-btn.disabled {
  opacity: 0.3;
  cursor: not-allowed;
}

/* Settings Page - Full Screen Slide-in */
.settings-page {
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  width: 100%;
  max-width: 500px;
  background: linear-gradient(180deg, #1a3a5c 0%, #0d1f33 100%);
  overflow-y: auto;
  z-index: 1000;
  transform: translateX(100%);
  transition: transform 0.3s ease-out;
  box-shadow: -5px 0 20px rgba(0, 0, 0, 0.5);
}

.settings-page.visible {
  transform: translateX(0);
}

.settings-page-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  z-index: 999;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s, visibility 0.3s;
}

.settings-page-overlay.visible {
  opacity: 1;
  visibility: visible;
}

@media (max-width: 500px) {
  .settings-page {
    max-width: 100%;
  }
}

.settings-page-header {
  display: flex;
  align-items: center;
  gap: 15px;
  padding: 15px 20px;
  background: linear-gradient(180deg, #0d2840 0%, #1a3a5c 100%);
  border-bottom: 2px solid #d4a017;
}

.settings-page-header h2 {
  margin: 0;
  color: #d4a017;
  font-size: 1.4em;
  flex: 1;
}

.settings-page-header .close-btn {
  background: rgba(255,255,255,0.1);
  border: none;
  color: #ccc;
  font-size: 1.2em;
  width: 36px;
  height: 36px;
  border-radius: 50%;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
}

.settings-page-header .close-btn:hover {
  background: rgba(255,255,255,0.2);
  color: white;
}

.profile-row {
  display: flex;
  gap: 8px;
  align-items: center;
}

.profile-row .profile-select {
  flex: 1;
}

.profile-icon-btn {
  background: rgba(255,255,255,0.1);
  border: 2px solid transparent;
  color: #fff;
  font-size: 1.4em;
  font-weight: bold;
  width: 44px;
  height: 44px;
  border-radius: 8px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
}

.profile-icon-btn:hover:not(:disabled) {
  background: rgba(255,255,255,0.2);
  border-color: #d4a017;
}

.profile-icon-btn:disabled {
  opacity: 0.3;
  cursor: not-allowed;
}

/* Profile Name Modal */
.profile-modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10000;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.2s, visibility 0.2s;
}

.profile-modal-overlay.visible {
  opacity: 1;
  visibility: visible;
}

.profile-modal {
  background: linear-gradient(135deg, #1a3a5c 0%, #0d1f33 100%);
  border: 1px solid #2a5a8c;
  border-radius: 12px;
  padding: 24px;
  min-width: 320px;
  max-width: 90vw;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
  transform: scale(0.9);
  transition: transform 0.2s;
}

.profile-modal-overlay.visible .profile-modal {
  transform: scale(1);
}

.profile-modal h3 {
  margin: 0 0 16px 0;
  color: #7ec8e3;
  font-size: 1.2em;
}

.profile-modal-input {
  width: 100%;
  padding: 12px 15px;
  font-size: 1.1em;
  background: rgba(0, 0, 0, 0.3);
  border: 1px solid #2a5a8c;
  border-radius: 8px;
  color: #fff;
  margin-bottom: 8px;
  box-sizing: border-box;
}

.profile-modal-input:focus {
  outline: none;
  border-color: #7ec8e3;
}

.profile-modal-error {
  color: #ff6b6b;
  font-size: 0.9em;
  margin-bottom: 12px;
  min-height: 1.2em;
}

.profile-modal-buttons {
  display: flex;
  gap: 12px;
  justify-content: flex-end;
}

.profile-modal-btn {
  padding: 10px 20px;
  border-radius: 8px;
  font-size: 1em;
  cursor: pointer;
  border: none;
  transition: background 0.2s;
}

.profile-modal-btn.cancel {
  background: rgba(255, 255, 255, 0.1);
  color: #aaa;
}

.profile-modal-btn.cancel:hover {
  background: rgba(255, 255, 255, 0.2);
}

.profile-modal-btn.save {
  background: #2a5a8c;
  color: #fff;
}

.profile-modal-btn.save:hover {
  background: #3a7ab8;
}

.settings-option-btn.disabled,
.settings-select.disabled,
.settings-location-btn.disabled {
  opacity: 0.4;
  cursor: not-allowed;
  pointer-events: none;
}

.settings-location-buttons {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 12px;
}

.settings-location-btn {
  background: rgba(126, 200, 227, 0.2);
  border: 1px solid rgba(126, 200, 227, 0.4);
  color: #7ec8e3;
  padding: 8px 16px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.9em;
  transition: all 0.2s;
}

.settings-location-btn:hover:not(:disabled) {
  background: rgba(126, 200, 227, 0.3);
  border-color: rgba(126, 200, 227, 0.6);
}

.settings-location-hint {
  font-size: 0.8em;
  color: rgba(255, 255, 255, 0.5);
  font-style: italic;
}

.settings-section {
  padding: 20px;
  border-bottom: 1px solid rgba(255,255,255,0.1);
}

.settings-section:last-child {
  border-bottom: none;
}

.settings-section h3 {
  margin: 0 0 8px 0;
  color: #7ec8e3;
  font-size: 1.2em;
}

.settings-description {
  margin: 0 0 15px 0;
  color: rgba(255,255,255,0.7);
  font-size: 0.9em;
}

.settings-info-box {
  margin-top: 15px;
  padding: 15px;
  background: rgba(126, 200, 227, 0.1);
  border-left: 3px solid #7ec8e3;
  border-radius: 0 8px 8px 0;
  font-size: 0.9em;
  line-height: 1.5;
}

.settings-info-box p {
  margin: 0 0 10px 0;
  color: rgba(255,255,255,0.9);
}

.settings-info-box p:last-child {
  margin-bottom: 0;
}

.settings-info-box blockquote {
  margin: 10px 0;
  padding: 10px 15px;
  background: rgba(0,0,0,0.2);
  border-radius: 4px;
  font-style: italic;
  color: rgba(255,255,255,0.8);
}

.settings-info-box em {
  color: #7ec8e3;
}

.settings-accordion {
  margin-top: 15px;
  border-top: 1px solid rgba(255,255,255,0.2);
  padding-top: 10px;
}

.settings-accordion summary {
  cursor: pointer;
  color: #7ec8e3;
  font-weight: 500;
  padding: 8px 0;
  list-style: none;
  display: flex;
  align-items: center;
  gap: 8px;
}

.settings-accordion summary::-webkit-details-marker {
  display: none;
}

.settings-accordion summary::before {
  content: 'â–¶';
  font-size: 0.7em;
  transition: transform 0.2s;
}

.settings-accordion[open] summary::before {
  transform: rotate(90deg);
}

.settings-accordion summary:hover {
  color: #a8dcf0;
}

.settings-accordion .accordion-content {
  padding: 15px 0 5px 0;
  animation: accordionOpen 0.2s ease-out;
}

@keyframes accordionOpen {
  from { opacity: 0; transform: translateY(-5px); }
  to { opacity: 1; transform: translateY(0); }
}

.settings-accordion .accordion-content p {
  margin: 0 0 10px 0;
}

.settings-accordion .accordion-content blockquote {
  margin: 10px 0;
  padding: 10px 15px;
  background: rgba(0,0,0,0.2);
  border-radius: 4px;
  font-style: italic;
  color: rgba(255,255,255,0.8);
}

.settings-options {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
}

.settings-row {
  display: flex;
  align-items: center;
  gap: 12px;
}

.settings-row-label {
  color: rgba(255,255,255,0.8);
  font-size: 0.95em;
  white-space: nowrap;
}

.settings-engine-info {
  margin-top: 15px;
  padding: 12px 15px;
  background: rgba(0,0,0,0.2);
  border-radius: 8px;
  border: 1px solid rgba(255,255,255,0.1);
}

.engine-info-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 4px 0;
}

.engine-info-row:not(:last-child) {
  border-bottom: 1px solid rgba(255,255,255,0.05);
}

.engine-info-label {
  color: rgba(255,255,255,0.6);
  font-size: 0.85em;
}

.engine-info-value {
  color: #7ec8e3;
  font-size: 0.9em;
  font-family: monospace;
}

.profile-select {
  width: 100%;
  padding: 12px 15px;
  font-size: 1.1em;
  background: #0d2840;
  color: #fff;
  border: 2px solid #d4a017;
  border-radius: 8px;
  cursor: pointer;
  font-family: inherit;
}

.profile-select:focus {
  outline: none;
  border-color: #7ec8e3;
}

.profile-select option {
  padding: 10px;
  background: #1a3a5c;
}

.settings-option-btn {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  padding: 15px 20px;
  background: rgba(255,255,255,0.1);
  border: 2px solid transparent;
  border-radius: 12px;
  color: white;
  cursor: pointer;
  flex: 1;
  min-width: 90px;
  transition: all 0.2s;
}

.settings-option-btn:hover {
  background: rgba(255,255,255,0.15);
}

.settings-option-btn.selected {
  border-color: #d4a017;
  background: rgba(212, 160, 23, 0.2);
}

.settings-option-btn .option-icon {
  font-size: 2.5em;
}

/* Moon phase icons in Month Starts section - extra large */
.settings-option-btn[data-phase] .option-icon {
  font-size: 3.5em;
}

.settings-option-btn .option-label {
  font-size: 0.85em;
  font-weight: 500;
}

.settings-option-btn .option-hint {
  font-size: 0.75em;
  opacity: 0.7;
  font-weight: normal;
}

#settings-page-map {
  margin-bottom: 15px;
}

#settings-page-map .dateline-container {
  margin-top: 0;
  padding: 12px;
  background: rgba(0,0,0,0.2);
  border-radius: 10px;
}

.settings-select {
  width: 100%;
  padding: 14px 16px;
  font-size: 1.1em;
  border: none;
  border-radius: 10px;
  background: rgba(255,255,255,0.1);
  color: white;
  cursor: pointer;
  margin-bottom: 12px;
}

.settings-select option,
.settings-select optgroup {
  background: #1a3a5c;
  color: white;
}

.settings-custom-coords {
  display: flex;
  gap: 10px;
  margin-bottom: 12px;
}

.settings-custom-coords input {
  flex: 1;
  padding: 12px 14px;
  font-size: 1em;
  border: none;
  border-radius: 8px;
  background: rgba(255,255,255,0.1);
  color: white;
}

.settings-custom-coords input::placeholder {
  color: rgba(255,255,255,0.5);
}

/* Day Detail Panel */
.day-detail-panel {
  background: linear-gradient(180deg, #0d2840 0%, #1a3a5c 100%);
  border-top: 3px solid #d4a017;
  padding: 15px 20px;
  margin-top: 0;
}

.day-detail-panel.hidden {
  display: none;
}

.day-detail-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 12px;
  flex-wrap: wrap;
  gap: 10px;
}

.day-detail-date {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.day-detail-header .day-detail-astro-times {
  display: flex;
  flex-direction: column;
  font-size: 0.85em;
  background: rgba(255, 200, 100, 0.1);
  padding: 8px 12px;
  border-radius: 8px;
  border: 1px solid rgba(255, 200, 100, 0.2);
}

.day-detail-header .astro-times-title {
  font-weight: 600;
  color: #f0c040;
  margin-bottom: 6px;
  font-size: 0.95em;
}

.day-detail-header .astro-times-row {
  display: flex;
  gap: 16px;
}

.day-detail-header .astro-times-group {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.day-detail-header .astro-time {
  display: flex;
  justify-content: space-between;
  gap: 12px;
  white-space: nowrap;
}

.day-detail-header .astro-label {
  color: #888;
  text-align: left;
}

.day-detail-header .astro-value {
  color: #ddd;
  font-family: monospace;
  text-align: right;
}

.day-detail-lunar {
  font-size: 1.4em;
  font-weight: bold;
  color: #d4a017;
}

.day-detail-gregorian {
  font-size: 1em;
  color: #7ec8e3;
}

.day-detail-gregorian-row {
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.day-detail-jump-btn {
  background: #d4a017;
  border: none;
  color: #1a3a5c;
  font-size: 1em;
  font-weight: bold;
  cursor: pointer;
  padding: 4px 10px;
  border-radius: 4px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  line-height: 1;
  transition: all 0.2s;
  white-space: nowrap;
  flex-shrink: 0;
}

.day-detail-jump-btn:hover {
  background: #e5b328;
  transform: scale(1.1);
}

.day-detail-content {
  color: #fff;
}

.day-detail-feasts {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.day-detail-feast-item {
  display: flex;
  align-items: flex-start;
  gap: 12px;
  padding: 10px 12px;
  background: rgba(42, 90, 140, 0.5);
  border-radius: 8px;
  border-left: 3px solid #28a745;
}

.day-detail-feast-icon {
  font-size: 1.5em;
  line-height: 1;
}

.day-detail-feast-icon.blood-moon-icon {
  filter: sepia(1) saturate(5) hue-rotate(320deg) brightness(0.9);
  text-shadow: 0 0 10px rgba(180, 0, 0, 1), 0 0 20px rgba(255, 50, 50, 0.8), 0 0 30px rgba(200, 0, 0, 0.6);
  background: rgba(139, 0, 0, 0.3);
  border-radius: 50%;
  padding: 4px 6px;
}

.day-detail-feast-info {
  flex: 1;
}

.day-detail-feast-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  gap: 10px;
  margin-bottom: 4px;
}

.day-detail-feast-name {
  font-weight: bold;
  color: #90ee90;
  font-size: 1.1em;
}

.day-detail-feast-header .stellarium-link {
  margin-top: 0;
  padding: 4px 8px;
  font-size: 0.8em;
  flex-shrink: 0;
}

.day-detail-feast-desc {
  color: #ccc;
  font-size: 0.95em;
  line-height: 1.4;
}

.day-detail-feast-link {
  display: inline-block;
  margin-top: 6px;
  color: #7ec8e3;
  text-decoration: none;
  font-size: 0.9em;
}

.day-detail-feast-link:hover {
  text-decoration: underline;
}

.equinox-link {
  color: #d4a017;
  text-decoration: none;
  font-weight: bold;
  cursor: pointer;
}

.equinox-link:hover {
  text-decoration: underline;
  color: #f0c040;
}

.day-detail-info {
  margin-top: 12px;
  padding-top: 12px;
  border-top: 1px solid rgba(126, 200, 227, 0.3);
  color: #aaa;
  font-size: 0.9em;
}

.stellarium-link {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  margin-top: 8px;
  padding: 6px 12px;
  background: rgba(100, 150, 200, 0.2);
  border: 1px solid rgba(100, 150, 200, 0.4);
  border-radius: 6px;
  color: #7ec8e3;
  text-decoration: none;
  font-size: 0.9em;
  transition: background 0.2s, border-color 0.2s;
}

.stellarium-link:hover {
  background: rgba(100, 150, 200, 0.35);
  border-color: rgba(100, 150, 200, 0.6);
  color: #fff;
}

.stellarium-link img {
  width: 16px;
  height: 16px;
}

.day-detail-dateline {
  margin-top: 16px;
  padding-top: 12px;
  border-top: 1px solid rgba(126, 200, 227, 0.3);
}

.day-detail-dateline .dateline-container {
  margin-top: 0;
  padding: 10px;
  background: rgba(0, 0, 0, 0.2);
  border-radius: 8px;
}

.day-detail-dateline .dateline-map {
  cursor: default;
  pointer-events: none;
}

.day-detail-dateline .dateline-click-hint {
  display: none;
}

.day-detail-profile-compare {
  margin-top: 16px;
  padding-top: 12px;
  border-top: 1px solid rgba(126, 200, 227, 0.3);
}

.profile-compare-title {
  font-size: 0.9em;
  color: #7ec8e3;
  margin-bottom: 8px;
  font-weight: 600;
}

.profile-compare-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
  gap: 8px;
}

.profile-compare-item {
  display: flex;
  flex-direction: column;
  padding: 8px 10px;
  background: rgba(0, 0, 0, 0.2);
  border-radius: 6px;
  font-size: 0.85em;
  cursor: pointer;
  transition: background 0.2s, border-color 0.2s;
  border: 1px solid transparent;
}

.profile-compare-item:hover {
  background: rgba(126, 200, 227, 0.15);
  border-color: rgba(126, 200, 227, 0.3);
}

.profile-compare-item.current {
  background: rgba(212, 160, 23, 0.15);
  border: 1px solid rgba(212, 160, 23, 0.3);
}

.profile-compare-item.current:hover {
  background: rgba(212, 160, 23, 0.2);
}

.profile-compare-name {
  color: #aaa;
  font-size: 0.9em;
  margin-bottom: 4px;
  display: flex;
  align-items: center;
  gap: 4px;
}

.profile-compare-name img {
  width: 1.2em;
  height: 1.2em;
  object-fit: contain;
  vertical-align: middle;
}

.profile-compare-item.current .profile-compare-name {
  color: #d4a017;
}

.profile-compare-day {
  color: #fff;
  font-weight: 600;
  font-size: 1em;
}

.profile-compare-feasts {
  margin-top: 4px;
  font-size: 1.1em;
  line-height: 1.2;
}

.profile-compare-location {
  font-size: 0.8em;
  color: #888;
  margin-top: 2px;
}

.profile-compare-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}

.world-clock-add-btn {
  width: 24px;
  height: 24px;
  border-radius: 50%;
  border: 2px solid rgba(126, 200, 227, 0.5);
  background: transparent;
  color: #7ec8e3;
  font-size: 1.1em;
  font-weight: bold;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
}

.world-clock-add-btn:hover {
  background: rgba(126, 200, 227, 0.2);
  border-color: #7ec8e3;
}

.profile-compare-item {
  position: relative;
}

.world-clock-remove-btn {
  position: absolute;
  top: 4px;
  right: 4px;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  border: none;
  background: rgba(255, 100, 100, 0.3);
  color: #ff6666;
  font-size: 14px;
  font-weight: bold;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0;
  transition: opacity 0.2s;
}

.profile-compare-item:hover .world-clock-remove-btn {
  opacity: 1;
}

.world-clock-remove-btn:hover {
  background: rgba(255, 100, 100, 0.5);
}

/* World Clock Add Modal */
.world-clock-add-modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0,0,0,0.7);
  z-index: 1100;
  align-items: center;
  justify-content: center;
}

.world-clock-add-content {
  background: #1a3a5c;
  border-radius: 12px;
  padding: 20px;
  min-width: 280px;
  max-width: 400px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.5);
}

.world-clock-add-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
}

.world-clock-add-header h3 {
  margin: 0;
  color: #fff;
  font-size: 1.1em;
}

.world-clock-add-form {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.world-clock-add-form label {
  color: rgba(255,255,255,0.7);
  font-size: 0.9em;
  margin-bottom: -6px;
}

.world-clock-add-form select {
  padding: 10px;
  border-radius: 6px;
  border: 1px solid rgba(255,255,255,0.2);
  background: rgba(0,0,0,0.3);
  color: #fff;
  font-size: 1em;
}

.world-clock-add-form .btn {
  margin-top: 8px;
}

/* Old astro-times styles removed - now styled in .day-detail-header */

.feast-basis {
  margin-top: 8px;
  padding: 8px 10px;
  background: rgba(0, 0, 0, 0.2);
  border-radius: 4px;
  font-size: 0.9em;
  color: #aaa;
  line-height: 1.5;
}

.feast-basis strong {
  color: #d4a017;
}

.feast-basis.virgo-rule-basis {
  margin-top: 12px;
  background: rgba(138, 43, 226, 0.15);
  border: 1px solid rgba(138, 43, 226, 0.3);
}

/* Uncertainty warning for ancient dates */
.uncertainty-warning {
  margin-top: 8px;
  padding: 8px 10px;
  background: rgba(255, 193, 7, 0.15);
  border: 1px solid rgba(255, 193, 7, 0.4);
  border-radius: 4px;
  font-size: 0.85em;
  color: #ffc107;
  line-height: 1.4;
}

.uncertainty-warning .warning-icon {
  margin-right: 6px;
}

/* Date uncertainty - gold colored Gregorian date text only */
.day-cell.date-uncertain .gregorian,
.new-moon-box.date-uncertain .gregorian {
  color: #ffc107;
  font-weight: bold;
}

.day-detail-sabbath {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  color: #d4a017;
  font-weight: bold;
  margin-bottom: 8px;
}

.day-detail-no-feast {
  color: #888;
  font-style: italic;
  padding: 10px 0;
}

/* Feast Table */
.feast-list {
  margin-top: 30px;
  padding: 0 10px;
}

.feast-list h3 {
  color: #1a3a5c;
  margin-bottom: 15px;
}

.feast-table {
  width: 100%;
  border-collapse: collapse;
  background: white;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  border-radius: 8px;
  overflow: hidden;
}

.feast-table th {
  background: #1a3a5c;
  color: white;
  padding: 12px;
  text-align: left;
}

.feast-table td {
  padding: 12px;
  border-bottom: 1px solid #eee;
}

.feast-table tr:hover {
  background: #f8f9fa;
}

.feast-table .feast-jump {
  cursor: pointer;
}

.feast-table .feast-jump:hover {
  text-decoration: underline !important;
}

.feast-table td a {
  display: block;
}

.info-box {
  background: #e7f3ff;
  border-left: 4px solid #1a3a5c;
  padding: 15px;
  margin: 20px 0;
  font-size: 0.95em;
  border-radius: 0 8px 8px 0;
}

@media (max-width: 768px) {
  .calendar-app {
    max-width: 100%;
    padding: 0;
  }
  
  .month-calendar,
  .settings-page {
    border-radius: 0;
  }
  
  .settings-dialog,
  .month-picker,
  .date-jump-popup {
    width: calc(100% - 16px);
    max-width: none;
  }
  
  .settings-page-header {
    padding: 12px 15px;
  }
  
  .settings-section {
    padding: 15px;
  }
  
  .settings-option-btn {
    padding: 12px 15px;
  }
  
  .settings-option-btn .option-icon {
    font-size: 2em;
  }
  
  .settings-option-btn[data-phase] .option-icon {
    font-size: 2.8em;
  }
  
  .calendar-controls {
    flex-direction: column;
    gap: 10px;
    padding: 10px;
  }
  
  .control-group {
    width: 100%;
  }
  
  .control-group input,
  .control-group select {
    width: 100%;
    min-height: 44px; /* Touch-friendly */
  }
  
  .btn {
    min-height: 44px;
    font-size: 1em;
    flex: 1;
  }
  
  .control-group div[style*="display: flex"] {
    width: 100%;
  }
  
  
  .month-buttons {
    gap: 3px;
  }
  
  .month-btn {
    min-height: 36px;
    padding: 6px 2px;
    font-size: 0.85em;
  }
  
  .month-btn.month-13:not(.has-13) {
    display: none; /* Hide 13th month button on mobile unless year has 13 months */
  }
  
  .calendar-header {
    grid-template-columns: 1fr minmax(55px, calc(100vw / 7));
    gap: 0;
    padding: 0;
  }
  
  .header-row-1 {
    padding: 6px 10px 2px;
  }
  
  .header-row-2 {
    padding: 2px 10px 6px;
    gap: 4px;
  }
  
  .header-dropdown {
    padding: 2px 4px;
    font-size: 0.95em !important;
  }
  
  .header-dropdown.profile {
    font-size: 1.35em !important;
  }
  
  .header-dropdown.profile .profile-moon {
    font-size: 1em;
  }
  
  .header-separator {
    font-size: 0.7em;
  }
  
  .new-moon-box {
    min-height: 60px;
    padding: 3px;
    width: calc(100vw / 7);
    min-width: 55px;
    flex-shrink: 0;
  }
  
  .new-moon-box .gregorian {
    font-size: 0.75em;
  }
  
  .new-moon-box .lunar-day {
    font-size: 1.1em;
  }
  
  .new-moon-box .feast-icons {
    font-size: 0.7em;
  }
  
  .week-header {
    font-size: 0.65em;
    gap: 2px;
  }
  
  .week-header > div {
    padding: 5px 2px;
  }
  
  .calendar-grid {
    gap: 2px;
  }
  
  .day-cell {
    min-height: 55px;
    padding: 3px;
  }
  
  .day-cell .lunar-day {
    font-size: 1.2em;
  }
  
  .day-cell .gregorian {
    font-size: 0.85em;
    color: #fff;
  }
  
  .day-cell .gregorian .day-year {
    font-size: 0.9em;
    color: #ffd700;
    font-weight: bold;
  }
  
  .day-cell .moon-phase {
    font-size: 0.65em;
  }
  
  .feast-icons {
    font-size: 0.85em !important;
  }
  
  .scripture-quote {
    font-size: 0.75em;
    padding: 8px;
  }
  
  .month-nav-cell .nav-arrow {
    font-size: 1.2em;
  }
  
  /* Feast table responsive */
  .feast-table-container {
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
  }
  
  .feast-table {
    font-size: 0.85em;
    min-width: 400px;
  }
  
  .feast-table th,
  .feast-table td {
    padding: 8px 6px;
  }
  
  /* Day detail panel mobile */
  .day-detail-panel {
    padding: 12px 15px;
  }
  
  .day-detail-lunar {
    font-size: 1.2em;
  }
  
  .day-detail-gregorian {
    font-size: 0.9em;
  }
  
  .day-detail-header {
    flex-direction: column;
    align-items: stretch;
  }
  
  .day-detail-header .day-detail-astro-times {
    width: 100%;
    font-size: 0.8em;
    padding: 8px 10px;
  }
  
  .day-detail-header .astro-times-row {
    justify-content: space-between;
  }
  
  /* Top nav mobile */
  .top-nav-inner {
    padding: 8px 12px;
  }
  
  .top-nav-title {
    font-size: 1.1em;
  }
  
  .top-nav-tagline {
    font-size: 0.65em;
  }
  
  .hamburger-btn {
    font-size: 24px;
    padding: 6px;
  }
}

@media (max-width: 480px) {
  .day-cell {
    min-height: 48px;
    padding: 2px;
  }
  
  .day-cell .lunar-day {
    font-size: 1em;
  }
  
  .day-cell .gregorian {
    font-size: 0.6em;
    color: #fff;
  }
  
  .day-cell .gregorian .day-year {
    display: none;
  }
  
  .day-cell .moon-phase {
    font-size: 0.4em;
  }
  
  .new-moon-box {
    min-height: 50px;
    padding: 2px;
    width: calc(100vw / 7);
  }
  
  .new-moon-box .gregorian {
    font-size: 0.55em;
  }
  
  .new-moon-box .gregorian .day-year {
    display: none;
  }
  
  .new-moon-box .lunar-day {
    font-size: 1em;
  }
  
  .new-moon-box .feast-icons {
    font-size: 0.6em;
  }
  
  .feast-icons {
    font-size: 0.7em !important;
  }
  
  .week-header {
    font-size: 0.55em;
  }
  
  .month-btn {
    min-height: 32px;
    padding: 4px 1px;
    font-size: 0.75em;
  }

  .header-row-1 {
    padding: 4px 8px 2px;
  }
  
  .header-row-2 {
    padding: 2px 8px 4px;
    gap: 2px;
  }
  
  .header-dropdown {
    padding: 2px 3px;
    font-size: 0.85em !important;
  }
  
  .header-dropdown.profile {
    font-size: 1.15em !important;
  }
  
  .header-dropdown.profile .profile-moon {
    font-size: 1em;
  }
  
  .header-dropdown .dropdown-arrow {
    font-size: 0.6em;
  }
  
  .header-separator {
    font-size: 0.55em;
  }

  .scripture-quote {
    font-size: 0.6em;
    padding: 3px;
  }
  
  .month-nav-cell .nav-arrow {
    font-size: 1em;
  }
  
  .full-moon-info .moon-icon {
    font-size: 42px;
  }
  
  .moon-gear-badge {
    font-size: 14px;
    bottom: -2px;
    right: 0px;
  }
}

/* Very small screens */
@media (max-width: 360px) {
  .day-cell .gregorian {
    font-size: 0.5em;
  }
  
  .new-moon-box .gregorian {
    font-size: 0.45em;
  }
  
  .day-cell .lunar-day {
    font-size: 0.9em;
  }
  
  .day-cell .moon-phase {
    display: none;
  }
  
  .week-header {
    font-size: 0.5em;
  }
  
  .header-dropdown {
    padding: 1px 2px;
    font-size: 0.75em !important;
  }
  
  .header-dropdown.profile {
    font-size: 1em !important;
  }
  
  .header-dropdown.profile .profile-moon {
    font-size: 1em;
  }
  
  .header-separator {
    font-size: 0.45em;
  }
}

@media print {
  .calendar-controls, .month-nav button, .info-box {
    display: none;
  }
  
  .month-calendar {
    break-inside: avoid;
  }
}

/* Sabbath Tester Page Styles */
#sabbath-tester-page {
  position: fixed;
  top: 55px;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(180deg, #1a3a5c 0%, #0d1f33 100%);
  overflow-y: auto;
  overflow-x: hidden;
  z-index: 100;
}

.sabbath-tester-header {
  position: sticky;
  top: 0;
  background: linear-gradient(180deg, #1a3a5c 0%, #0d1f33 50%);
  padding: 16px 20px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  z-index: 10;
  border-bottom: 1px solid rgba(126, 200, 227, 0.2);
}

.sabbath-tester-header h2 {
  margin: 0;
  font-size: 1.3em;
  color: #7ec8e3;
}

.sabbath-tester-content {
  padding: 20px;
  max-width: 900px;
  margin: 0 auto;
}

.sabbath-test-card {
  background: rgba(0, 0, 0, 0.3);
  border-radius: 12px;
  padding: 20px;
  margin-bottom: 24px;
  border: 1px solid rgba(126, 200, 227, 0.2);
}

.sabbath-test-title {
  font-size: 1.2em;
  color: #7ec8e3;
  margin-bottom: 8px;
  display: flex;
  align-items: center;
  gap: 10px;
}

.sabbath-test-date {
  font-size: 0.9em;
  color: #aaa;
  margin-bottom: 12px;
}

.sabbath-test-scripture {
  display: inline-block;
  background: rgba(126, 200, 227, 0.15);
  padding: 2px 8px;
  border-radius: 4px;
  font-size: 0.85em;
  color: #7ec8e3;
  margin-bottom: 12px;
}

.sabbath-test-description {
  color: #ccc;
  line-height: 1.6;
  margin-bottom: 16px;
  font-size: 0.95em;
}

/* Test Evidence Accordion */
.test-evidence-accordion {
  margin-bottom: 16px;
  background: rgba(126, 200, 227, 0.08);
  border-radius: 8px;
  border: 1px solid rgba(126, 200, 227, 0.2);
}

.test-evidence-accordion summary {
  cursor: pointer;
  color: #7ec8e3;
  font-weight: 500;
  padding: 12px 14px;
  list-style: none;
  display: flex;
  align-items: center;
  gap: 8px;
}

.test-evidence-accordion summary::-webkit-details-marker {
  display: none;
}

.test-evidence-accordion summary::before {
  content: 'â–¶';
  font-size: 0.7em;
  transition: transform 0.2s;
}

.test-evidence-accordion[open] summary::before {
  transform: rotate(90deg);
}

.test-evidence-accordion summary:hover {
  color: #a8dcf0;
  background: rgba(126, 200, 227, 0.05);
}

.test-evidence-content {
  padding: 0 14px 14px 14px;
  animation: accordionOpen 0.2s ease-out;
}

.test-evidence-content p {
  margin: 0 0 12px 0;
  color: rgba(255,255,255,0.9);
  line-height: 1.6;
}

.test-evidence-content ul {
  margin: 0 0 12px 0;
  padding-left: 20px;
  color: rgba(255,255,255,0.85);
}

.test-evidence-content li {
  margin-bottom: 10px;
  line-height: 1.5;
}

.test-evidence-content li strong {
  color: #7ec8e3;
}

.test-evidence-content a {
  color: #7ec8e3;
  text-decoration: none;
}

.test-evidence-content a:hover {
  text-decoration: underline;
}

.test-interpretation {
  margin-bottom: 16px;
  padding: 14px;
  background: rgba(255, 193, 7, 0.1);
  border-left: 3px solid #ffc107;
  border-radius: 0 8px 8px 0;
}

.test-interpretation p {
  margin: 0 0 10px 0;
  color: rgba(255,255,255,0.9);
}

.test-interpretation ul {
  margin: 0;
  padding-left: 20px;
  color: rgba(255,255,255,0.85);
}

.test-interpretation li {
  margin-bottom: 8px;
  line-height: 1.5;
}

.test-interpretation li strong {
  color: #ffc107;
}

.sabbath-test-expected {
  background: rgba(126, 200, 227, 0.1);
  padding: 10px 14px;
  border-radius: 8px;
  margin-bottom: 16px;
  color: #7ec8e3;
  font-weight: 500;
}

.sabbath-test-results-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.9em;
}

.sabbath-test-results-table th {
  text-align: left;
  padding: 10px 12px;
  background: rgba(0, 0, 0, 0.3);
  color: #7ec8e3;
  border-bottom: 1px solid rgba(126, 200, 227, 0.3);
}

.sabbath-test-results-table td {
  padding: 10px 12px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  color: #ddd;
}

.sabbath-test-results-table tr:last-child td {
  border-bottom: none;
}

.sabbath-test-results-table .result-pass {
  color: #4ade80;
  font-weight: 600;
}

.sabbath-test-results-table .result-fail {
  color: #f87171;
  font-weight: 600;
}

.sabbath-test-results-table .result-uncertain {
  color: #fbbf24;
  font-weight: 600;
}

.sabbath-test-date-link {
  color: #7ec8e3;
  text-decoration: none;
  cursor: pointer;
}

.sabbath-test-date-link:hover {
  text-decoration: underline;
}

.year-uncertainty-icon {
  color: #ff9800;
  font-size: 0.85em;
  cursor: help;
  white-space: nowrap;
}

/* Summary Scoreboard */
.sabbath-scoreboard {
  background: rgba(0, 0, 0, 0.4);
  border-radius: 12px;
  padding: 20px;
  margin-bottom: 24px;
  border: 1px solid rgba(126, 200, 227, 0.3);
}

.sabbath-scoreboard-title {
  font-size: 1.1em;
  color: #7ec8e3;
  margin-bottom: 16px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.sabbath-scoreboard-intro {
  margin-bottom: 20px;
  line-height: 1.6;
  color: rgba(255,255,255,0.85);
  font-size: 0.95em;
}

.sabbath-scoreboard-intro p {
  margin: 0 0 12px 0;
}

.scoreboard-conclusion {
  background: rgba(126, 200, 227, 0.1);
  border-left: 3px solid #7ec8e3;
  padding: 12px 16px;
  border-radius: 0 8px 8px 0;
  margin-top: 12px;
}

.scoreboard-conclusion p {
  margin: 0 0 8px 0;
}

.scoreboard-conclusion p:last-child {
  margin-bottom: 0;
}

.sabbath-scoreboard-table {
  width: 100%;
  border-collapse: collapse;
}

.sabbath-scoreboard-table th {
  text-align: left;
  padding: 10px 12px;
  background: rgba(126, 200, 227, 0.15);
  color: #7ec8e3;
  font-weight: 600;
}

.sabbath-scoreboard-table td {
  padding: 10px 12px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  color: #ddd;
}

.sabbath-scoreboard-table tr:last-child td {
  border-bottom: none;
}

.sabbath-scoreboard-table .score-perfect {
  color: #4ade80;
  font-weight: 600;
}

.sabbath-scoreboard-table .score-good {
  color: #a3e635;
  font-weight: 600;
}

.sabbath-scoreboard-table .score-medium {
  color: #fbbf24;
  font-weight: 600;
}

.sabbath-scoreboard-table .score-poor {
  color: #f87171;
  font-weight: 600;
}

.scoreboard-expandable {
  cursor: pointer;
  transition: background 0.2s;
}

.scoreboard-expandable:hover {
  background: rgba(126, 200, 227, 0.1);
}

.scoreboard-expandable .expand-arrow {
  display: inline-block;
  transition: transform 0.2s;
  font-size: 0.7em;
  margin-right: 6px;
}

.scoreboard-expandable.expanded .expand-arrow {
  transform: rotate(90deg);
}

.scoreboard-details td {
  background: rgba(0, 0, 0, 0.2);
  padding: 12px 16px !important;
}

.score-breakdown {
  font-size: 0.9em;
  line-height: 1.6;
}

.breakdown-section {
  margin-bottom: 6px;
}

.breakdown-section:last-child {
  margin-bottom: 0;
}

.breakdown-label {
  font-weight: 600;
}

/* Alt Score expandable in test tables */
.alt-score-details {
  cursor: pointer;
}

.alt-score-details summary {
  list-style: none;
  display: flex;
  align-items: center;
  gap: 4px;
}

.alt-score-details summary::-webkit-details-marker {
  display: none;
}

.alt-score-details summary::before {
  content: 'â–¶';
  font-size: 0.6em;
  transition: transform 0.2s;
}

.alt-score-details[open] summary::before {
  transform: rotate(90deg);
}

.alt-score-breakdown {
  margin-top: 8px;
  font-size: 0.85em;
  line-height: 1.5;
  padding: 8px;
  background: rgba(0,0,0,0.2);
  border-radius: 4px;
}

.alt-score-breakdown .breakdown-section {
  margin-bottom: 4px;
}

.sabbath-test-loading {
  text-align: center;
  padding: 40px;
  color: #7ec8e3;
}

@media (max-width: 600px) {
  .sabbath-test-results-table th,
  .sabbath-test-results-table td {
    padding: 8px 6px;
    font-size: 0.85em;
  }
  
  .sabbath-scoreboard-table th,
  .sabbath-scoreboard-table td {
    padding: 8px 6px;
    font-size: 0.85em;
  }
}

/* About Modal */
.about-modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.85);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10000;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s, visibility 0.3s;
  padding: 20px;
  box-sizing: border-box;
}

.about-modal-overlay.visible {
  opacity: 1;
  visibility: visible;
}

.about-modal {
  background: linear-gradient(145deg, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
  border-radius: 20px;
  max-width: 520px;
  width: 100%;
  max-height: 90vh;
  overflow-y: auto;
  overflow-x: hidden;
  box-shadow: 0 25px 80px rgba(0, 0, 0, 0.6), 0 0 60px rgba(212, 160, 23, 0.15);
  border: 1px solid rgba(212, 160, 23, 0.3);
  transform: scale(0.9) translateY(20px);
  transition: transform 0.3s ease-out;
  scrollbar-width: none; /* Firefox */
  -ms-overflow-style: none; /* IE/Edge */
}

.about-modal::-webkit-scrollbar {
  display: none; /* Chrome/Safari/Opera */
}

.about-modal-overlay.visible .about-modal {
  transform: scale(1) translateY(0);
}

.about-modal-header {
  text-align: center;
  padding: 30px 30px 20px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.about-modal-logo {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 8px;
  margin-bottom: 12px;
}

.about-modal-logo .moon-phase {
  font-size: 2.5em;
  opacity: 0.6;
  transition: transform 0.3s, opacity 0.3s;
}

.about-modal-logo .moon-phase.primary {
  font-size: 3.5em;
  opacity: 1;
}

.about-modal-title {
  font-size: 1.8em;
  font-weight: 700;
  color: #d4a017;
  margin: 0 0 8px 0;
  letter-spacing: 1px;
}

.about-modal-subtitle {
  color: rgba(255, 255, 255, 0.6);
  font-size: 0.95em;
  margin: 0;
}

.about-modal-content {
  padding: 25px 30px;
}

.about-features {
  list-style: none;
  padding: 0;
  margin: 0 0 20px 0;
}

.about-features li {
  display: flex;
  align-items: flex-start;
  gap: 12px;
  padding: 12px 0;
  border-bottom: 1px solid rgba(255, 255, 255, 0.06);
  color: rgba(255, 255, 255, 0.9);
  font-size: 0.95em;
  line-height: 1.4;
}

.about-features li:last-child {
  border-bottom: none;
}

.about-features .feature-icon {
  font-size: 1.3em;
  flex-shrink: 0;
  width: 28px;
  text-align: center;
}

.about-features .feature-text {
  flex: 1;
}

.about-features .feature-text strong {
  color: #fff;
}

.about-features .feature-img {
  width: 1.3em;
  height: 1.3em;
  object-fit: contain;
}

.about-start-btn {
  background: linear-gradient(135deg, #d4a017 0%, #b8860b 100%);
  color: #000;
  border: none;
  border-radius: 10px;
  padding: 14px 24px;
  font-size: 1.05em;
  font-weight: 600;
  cursor: pointer;
  transition: transform 0.2s, box-shadow 0.2s;
  width: 100%;
  margin-bottom: 16px;
}

.about-start-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(212, 160, 23, 0.4);
}

.about-start-btn:active {
  transform: translateY(0);
}

.about-cta {
  background: rgba(212, 160, 23, 0.1);
  border: 1px solid rgba(212, 160, 23, 0.2);
  border-radius: 12px;
  padding: 16px;
  text-align: center;
}

.about-cta p {
  margin: 0;
  color: rgba(255, 255, 255, 0.85);
  font-size: 0.9em;
}

/* iOS Install Instructions Modal */
.ios-install-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.85);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10000;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s, visibility 0.3s;
  padding: 20px;
  box-sizing: border-box;
}

.ios-install-overlay.visible {
  opacity: 1;
  visibility: visible;
}

.ios-install-modal {
  background: linear-gradient(145deg, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
  border-radius: 16px;
  max-width: 380px;
  width: 100%;
  padding: 24px;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
  border: 1px solid rgba(255, 255, 255, 0.1);
  position: relative;
  transform: scale(0.9) translateY(20px);
  transition: transform 0.3s ease-out;
}

.ios-install-overlay.visible .ios-install-modal {
  transform: scale(1) translateY(0);
}

.ios-install-close {
  position: absolute;
  top: 12px;
  right: 12px;
  background: rgba(255, 255, 255, 0.1);
  border: none;
  color: rgba(255, 255, 255, 0.6);
  width: 32px;
  height: 32px;
  border-radius: 50%;
  font-size: 18px;
  cursor: pointer;
  transition: background 0.2s, color 0.2s;
}

.ios-install-close:hover {
  background: rgba(255, 255, 255, 0.2);
  color: #fff;
}

.ios-install-header {
  text-align: center;
  margin-bottom: 16px;
}

.ios-install-icon {
  font-size: 2.5em;
  display: block;
  margin-bottom: 8px;
}

.ios-install-header h3 {
  margin: 0;
  color: #d4a017;
  font-size: 1.4em;
}

.ios-install-intro {
  text-align: center;
  color: rgba(255, 255, 255, 0.8);
  font-size: 0.95em;
  margin: 0 0 20px 0;
  line-height: 1.4;
}

.ios-install-steps {
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin-bottom: 20px;
}

.ios-install-step {
  display: flex;
  align-items: flex-start;
  gap: 12px;
  background: rgba(255, 255, 255, 0.05);
  padding: 12px;
  border-radius: 10px;
}

.step-number {
  background: #d4a017;
  color: #000;
  width: 28px;
  height: 28px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  font-size: 0.9em;
  flex-shrink: 0;
}

.step-content p {
  margin: 0;
  color: rgba(255, 255, 255, 0.9);
  font-size: 0.95em;
  line-height: 1.4;
}

.ios-share-icon {
  display: inline-block;
  background: rgba(0, 122, 255, 0.2);
  padding: 2px 6px;
  border-radius: 4px;
  font-size: 1.1em;
}

.ios-install-done-btn {
  width: 100%;
  background: linear-gradient(135deg, #d4a017 0%, #b8860b 100%);
  color: #000;
  border: none;
  border-radius: 10px;
  padding: 14px;
  font-size: 1.05em;
  font-weight: 600;
  cursor: pointer;
  transition: transform 0.2s, box-shadow 0.2s;
}

.ios-install-done-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(212, 160, 23, 0.4);
}

@media (max-width: 480px) {
  .about-modal {
    border-radius: 16px;
  }
  
  .about-modal-header {
    padding: 24px 20px 16px;
  }
  
  .about-modal-title {
    font-size: 1.5em;
  }
  
  .about-modal-content {
    padding: 20px;
  }
}
  </style>
</head>
<body>

<!-- About Modal -->
<div id="about-modal-overlay" class="about-modal-overlay" onclick="closeAboutModal(event)">
  <div class="about-modal" onclick="event.stopPropagation()">
    <div class="about-modal-header">
      <div class="about-modal-logo">
        <span class="moon-phase">ðŸŒ’</span>
        <span class="moon-phase primary">ðŸŒ•</span>
        <span class="moon-phase">ðŸŒ‘</span>
      </div>
      <h2 class="about-modal-title">LunarSabbath.net</h2>
      <p class="about-modal-subtitle">A Time Tested Tradition</p>
    </div>
    
    <div class="about-modal-content">
      <ul class="about-features">
        <li>
          <span class="feature-icon">ðŸŒ•</span>
          <span class="feature-text"><strong>Any Month Start</strong> â€” Full Moon, Dark Moon, or Crescent Moon</span>
        </li>
        <li>
          <span class="feature-icon">ðŸª</span>
          <span class="feature-text"><strong>Any Sabbath</strong> â€” Lunar, Saturday, or Custom cycles</span>
        </li>
        <li>
          <span class="feature-icon">ðŸŒ</span>
          <span class="feature-text"><strong>Any Location</strong> â€” Moon phases calculated for your coordinates</span>
        </li>
        <li>
          <span class="feature-icon">â˜€ï¸</span>
          <span class="feature-text"><strong>Any Day Start</strong> â€” Morning twilight or evening sunset</span>
        </li>
        <li>
          <span class="feature-icon">ðŸ“†</span>
          <span class="feature-text"><strong>Any Year</strong> â€” From Exodus to Christ's Return</span>
        </li>
        <li>
          <span class="feature-icon"><img src="/icons/menorah.png" alt="Menorah" class="feature-img"></span>
          <span class="feature-text"><strong>Export Feasts</strong> â€” Add feasts to your calendar app</span>
        </li>
        <li>
          <span class="feature-icon">ðŸ“²</span>
          <span class="feature-text"><strong>Installable App</strong> â€” Works offline on any device</span>
        </li>
      </ul>
      
      <button class="about-start-btn" onclick="closeAboutModal()">Test Everything</button>
      
      <div class="about-cta">
        <p>Discover which historical events align with different calendar interpretations and why communities chose their traditions.</p>
      </div>
    </div>
  </div>
</div>

<!-- Top Navigation Bar -->
<nav class="top-nav">
  <div class="top-nav-inner">
    <div class="top-nav-brand" onclick="navigateTo('calendar')" style="cursor: pointer;">
      <span class="top-nav-icon">ðŸŒ•</span>
      <div class="top-nav-text">
        <div class="top-nav-title">Lunar Sabbath</div>
        <div class="top-nav-tagline">a time tested tradition</div>
      </div>
    </div>
    <button class="hamburger-btn" onclick="toggleNavMenu()" aria-label="Menu">â˜°</button>
  </div>
</nav>

<!-- Navigation Menu Overlay -->
<div id="nav-menu-overlay" class="nav-menu-overlay" onclick="toggleNavMenu()"></div>

<!-- Navigation Menu -->
<div id="nav-menu" class="nav-menu">
  <div class="nav-menu-header">
    <h3>Menu</h3>
    <button class="nav-menu-close" onclick="toggleNavMenu()">âœ•</button>
  </div>
  <div class="nav-menu-items">
    <button class="nav-menu-item" onclick="navigateTo('calendar')">
      <span class="icon">ðŸ“…</span>
      <span>Calendar</span>
    </button>
    <button class="nav-menu-item" onclick="navigateTo('feasts')">
      <span class="icon">ðŸŽº</span>
      <span>Feasts</span>
    </button>
    <button class="nav-menu-item" onclick="navigateTo('settings')">
      <span class="icon">âš™ï¸</span>
      <span>Profiles</span>
    </button>
    <button class="nav-menu-item" onclick="navigateTo('sabbath-tester')">
      <span class="icon">ðŸ”¬</span>
      <span>Sabbath Tester</span>
    </button>
    <div class="nav-menu-divider"></div>
    <button class="nav-menu-item" id="install-app-btn" style="display: none;" onclick="handleInstallClick()">
      <span class="icon">ðŸ“²</span>
      <span>Install App</span>
    </button>
    <div class="book-ad">
      <div class="book-ad-top">
        <div class="book-ad-title">TIME</div>
        <div class="book-ad-subtitle">Tested Tradition</div>
        <div class="book-ad-tagline">The Renewed Biblical Calendar</div>
      </div>
      <div class="book-ad-bottom">
        <div class="book-ad-author">By Daniel Larimer</div>
        <a class="book-ad-download" href="/media/time-tested-tradition.pdf" download onclick="trackBookDownload()">
          <span class="icon">ðŸ“¥</span>
          <span>Download PDF</span>
        </a>
      </div>
    </div>
    <a class="nav-menu-item" href="/book/">
      <span class="icon">ðŸ“–</span>
      <span>Browse Book</span>
    </a>
    <button class="nav-menu-item" onclick="navigateTo('about')">
      <span class="icon">â„¹ï¸</span>
      <span>About</span>
    </button>
  </div>
</div>

<!-- iOS Install Instructions Modal -->
<div id="ios-install-overlay" class="ios-install-overlay" onclick="closeIOSInstallModal(event)">
  <div class="ios-install-modal" onclick="event.stopPropagation()">
    <button class="ios-install-close" onclick="closeIOSInstallModal()">âœ•</button>
    <div class="ios-install-header">
      <span class="ios-install-icon">ðŸ“²</span>
      <h3>Install LunarSabbath</h3>
    </div>
    <p class="ios-install-intro">Add this app to your home screen for quick access and an app-like experience.</p>
    <div class="ios-install-steps">
      <div class="ios-install-step">
        <div class="step-number">1</div>
        <div class="step-content">
          <p>Tap the <strong>Share</strong> button <span class="ios-share-icon">â¬†ï¸</span> in Safari's toolbar</p>
        </div>
      </div>
      <div class="ios-install-step">
        <div class="step-number">2</div>
        <div class="step-content">
          <p>Scroll down and tap <strong>"Add to Home Screen"</strong></p>
        </div>
      </div>
      <div class="ios-install-step">
        <div class="step-number">3</div>
        <div class="step-content">
          <p>Tap <strong>"Add"</strong> in the top right corner</p>
        </div>
      </div>
    </div>
    <button class="ios-install-done-btn" onclick="closeIOSInstallModal()">Got it!</button>
  </div>
</div>

<div class="calendar-app">
  <!-- Settings Dialog (hidden by default) -->
  <div id="settings-overlay" class="settings-overlay" onclick="if(event.target === this) toggleSettings()"></div>
  <div id="settings-dialog" class="settings-dialog">
    <div class="settings-header">
      <h3>Month Sign & Location</h3>
      <button onclick="toggleSettings()" class="close-btn">âœ•</button>
    </div>
    <div class="settings-content">
      <div class="setting-group">
        <label>Month Starts At</label>
        <div class="moon-phase-buttons">
          <button class="moon-phase-btn" data-phase="full" onclick="selectMoonPhase('full')">
            <span class="phase-icon">ðŸŒ•</span>
            <span class="phase-name">Full Moon</span>
          </button>
          <button class="moon-phase-btn" data-phase="dark" onclick="selectMoonPhase('dark')">
            <span class="phase-icon">ðŸŒ‘</span>
            <span class="phase-name">Dark Moon</span>
          </button>
          <button class="moon-phase-btn" data-phase="crescent" onclick="selectMoonPhase('crescent')">
            <span class="phase-icon">ðŸŒ’</span>
            <span class="phase-name">Crescent</span>
          </button>
        </div>
        <select id="moon-phase-select" style="display: none;">
          <option value="full">Full Moon</option>
          <option value="dark">Dark Moon (Conjunction)</option>
          <option value="crescent">Crescent Moon (First Visible)</option>
        </select>
      </div>
      
      <div class="setting-group">
        <label>Default Location</label>
        <div id="settings-map-container"></div>
        <select id="city-select" class="city-select-styled">
          <optgroup label="Biblical">
            <option value="31.7683,35.2137">Jerusalem</option>
          </optgroup>
          <optgroup label="United States">
            <option value="40.7128,-74.0060">New York (Eastern)</option>
            <option value="41.8781,-87.6298">Chicago (Central)</option>
            <option value="39.7392,-104.9903">Denver (Mountain)</option>
            <option value="34.0522,-118.2437">Los Angeles (Pacific)</option>
            <option value="61.2181,-149.9003">Anchorage (Alaska)</option>
            <option value="21.3069,-157.8583">Honolulu (Hawaii)</option>
          </optgroup>
          <optgroup label="International">
            <option value="51.5074,-0.1278">London</option>
            <option value="48.8566,2.3522">Paris</option>
            <option value="35.6762,139.6503">Tokyo</option>
            <option value="-33.8688,151.2093">Sydney</option>
          </optgroup>
          <option value="">Custom Coordinates...</option>
        </select>
        <div class="setting-group" id="custom-coords" style="display: none;">
          <div style="display: flex; gap: 10px; margin-top: 10px;">
            <input type="number" id="lat-input" value="31.7683" step="0.0001" placeholder="Latitude">
            <input type="number" id="lon-input" value="35.2137" step="0.0001" placeholder="Longitude">
          </div>
        </div>
        <button type="button" class="location-btn" onclick="useCurrentLocation()">ðŸ“ Use My Current Location</button>
      </div>
      
      <div class="setting-info">
        The location determines when the lunar day begins for you.
      </div>
    </div>
  </div>

  <!-- Hidden inputs for state -->
  <input type="number" id="year-input" value="2026" min="-4000" max="4000" style="display: none;">
  <span id="year-display" style="display: none;"></span>
  <input type="datetime-local" id="goto-date" step="60" style="display: none;">
  <input type="number" id="add-days" value="1" min="1" style="display: none;">
  
  <!-- Month Picker Popup -->
  <div id="month-picker-overlay" class="month-picker-overlay" onclick="if(event.target === this) toggleMonthPicker()"></div>
  <div id="month-picker" class="month-picker" style="display: none;">
    <div class="month-picker-header">
      <h3>Select Month</h3>
      <button class="close-btn" onclick="toggleMonthPicker()">âœ•</button>
    </div>
    <div class="year-nav">
      <button onclick="changePickerYear(-1)">â—€</button>
      <div class="year-display-container">
        <span id="picker-year" class="year-display" onclick="showYearInput()" title="Click to enter year"></span>
        <input type="number" id="picker-year-input" class="year-input" min="1" max="4000"
               onkeydown="if(event.key==='Enter') applyYearInput(); if(event.key==='Escape') hideYearInput();"
               onblur="applyYearInput()">
      </div>
      <button onclick="changePickerYear(1)">â–¶</button>
      <select id="era-select" class="era-select" onchange="changeEra(this.value)">
        <option value="AD">AD</option>
        <option value="BC">BC</option>
      </select>
    </div>
    <div id="month-grid" class="month-grid"></div>
  </div>
  
  <!-- City Picker Modal -->
  <div id="city-picker-overlay" class="city-picker-overlay" onclick="if(event.target === this) toggleCityPicker()"></div>
  <div id="city-picker" class="city-picker" style="display: none;">
    <div class="city-picker-header">
      <h3>Select Location</h3>
      <button class="close-btn" onclick="toggleCityPicker()">âœ•</button>
    </div>
    <div class="city-picker-controls">
      <button class="city-action-btn" onclick="useMyLocationFromPicker()">ðŸ“ Use My Location</button>
      <select id="city-picker-select" class="city-picker-select" onchange="selectCityFromDropdown(this.value)">
        <option value="">-- Select a city --</option>
      </select>
    </div>
    <div id="city-picker-map"></div>
  </div>
  
  <!-- Profile Picker Modal -->
  <div id="profile-picker-overlay" class="profile-picker-overlay" onclick="if(event.target === this) toggleProfilePicker()"></div>
  <div id="profile-picker" class="profile-picker" style="display: none;">
    <div class="profile-picker-header">
      <h3>Select Calendar Profile</h3>
      <button class="profile-add-btn" onclick="toggleProfilePicker(); navigateTo('settings');" title="Customize Settings">+</button>
    </div>
    <div id="profile-picker-list" class="profile-picker-list">
      <!-- Populated by JavaScript -->
    </div>
  </div>
  
  <!-- Date Jump Popup -->
  <div id="date-jump-overlay" class="date-jump-overlay" onclick="if(event.target === this) toggleDateJump()"></div>
  <div id="date-jump-popup" class="date-jump-popup" style="display: none;">
    <button class="close-btn" onclick="toggleDateJump()">âœ•</button>
    <h3>Jump to Date</h3>
    <div id="jump-ancient-display" style="display: none; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 4px; margin-bottom: 10px; text-align: center;">
      <div style="color: #d4a017; font-size: 1.1em;" id="jump-ancient-date"></div>
      <div style="color: #888; font-size: 0.85em; margin-top: 4px;">Date picker unavailable for BC dates</div>
    </div>
    <input type="datetime-local" id="jump-datetime" step="60">
    <div class="btn-row">
      <button class="btn secondary" onclick="jumpToTodayFromPopup()">Jump to Today</button>
    </div>
    <div class="days-jump">
      <button onclick="addDaysFromPopup(-1)">â—€</button>
      <input type="number" id="jump-days" value="1" min="1">
      <button onclick="addDaysFromPopup(1)">â–¶</button>
      <span>days</span>
    </div>
  </div>
  
  <!-- Hidden month buttons container (for compatibility) -->
  <div id="month-buttons" style="display: none;"></div>

  <div id="calendar-output"></div>

  <!-- Settings Page Overlay -->
  <div id="settings-page-overlay" class="settings-page-overlay" onclick="toggleSettings()"></div>
  
  <!-- Settings Page - slides in from right -->
  <div id="settings-page" class="settings-page">
    <div class="settings-page-header">
      <h2>Profiles</h2>
      <button class="close-btn" onclick="navigateTo('calendar')" aria-label="Close">âœ•</button>
    </div>
    
    <div class="settings-section">
      <h3>Profile</h3>
      <p class="settings-description">Select a preset or customize settings below.</p>
      <div class="profile-row">
        <select id="profile-select" class="profile-select" onchange="onProfileSelectChange(this.value)">
          <option value="timeTested">ðŸŒ• Time-Tested â€” Full Moon, Morning Twilight, Lunar Sabbath</option>
          <option value="ancientTraditional">ðŸŒ’ Ancient Traditional â€” Crescent, Evening, Saturday</option>
          <option value="ministries119">ðŸŒ‘ 119 Ministries â€” Dark Moon, Evening, Saturday</option>
        </select>
        <button id="profile-clone-btn" class="profile-icon-btn" onclick="cloneProfile()" title="Clone as new profile">+</button>
        <button id="profile-edit-btn" class="profile-icon-btn" onclick="editProfileName()" title="Rename profile" disabled>âœï¸</button>
        <button id="profile-delete-btn" class="profile-icon-btn" onclick="deleteCustomProfile()" title="Delete profile" disabled>ðŸ—‘ï¸</button>
      </div>
    </div>
    
    <div class="settings-section">
      <h3>Month Starts At</h3>
      <p class="settings-description">Choose which lunar phase marks the beginning of each month.</p>
      <div class="settings-options">
        <button class="settings-option-btn" data-phase="full" onclick="selectMoonPhase('full')">
          <span class="option-icon">ðŸŒ•</span>
          <span class="option-label">Full Moon</span>
        </button>
        <button class="settings-option-btn" data-phase="dark" onclick="selectMoonPhase('dark')">
          <span class="option-icon">ðŸŒ‘</span>
          <span class="option-label">Dark Moon</span>
        </button>
        <button class="settings-option-btn" data-phase="crescent" onclick="selectMoonPhase('crescent')">
          <span class="option-icon">ðŸŒ’</span>
          <span class="option-label">Crescent</span>
        </button>
      </div>
    </div>
    
    <div id="crescent-threshold-section" class="settings-section" style="display: none;">
      <h3>Crescent Visibility Timing</h3>
      <p class="settings-description">Hours after conjunction when crescent moon is considered visible.</p>
      <div class="settings-options">
        <button class="settings-option-btn" data-threshold="12" onclick="selectCrescentThreshold(12)">
          <span class="option-label">12h Optimistic</span>
          <span class="option-hint">Perfect conditions + optical aids</span>
        </button>
        <button class="settings-option-btn" data-threshold="15.5" onclick="selectCrescentThreshold(15.5)">
          <span class="option-label">15.5h Minimum</span>
          <span class="option-hint">Naked-eye record, ideal conditions</span>
        </button>
        <button class="settings-option-btn" data-threshold="18" onclick="selectCrescentThreshold(18)">
          <span class="option-label">18h Typical</span>
          <span class="option-hint">Standard naked-eye visibility</span>
        </button>
        <button class="settings-option-btn" data-threshold="24" onclick="selectCrescentThreshold(24)">
          <span class="option-label">24h Conservative</span>
          <span class="option-hint">Easily visible to anyone</span>
        </button>
      </div>
    </div>
    
    <div class="settings-section">
      <h3>Day Starts At</h3>
      <p class="settings-description">Choose when each day begins.</p>
      <div class="settings-options" style="margin-bottom: 15px;">
        <button class="settings-option-btn" data-daystart="evening" onclick="selectDayStartTime('evening')">
          <span class="option-icon">ðŸŒ…</span>
          <span class="option-label">Evening</span>
        </button>
        <button class="settings-option-btn" data-daystart="morning" onclick="selectDayStartTime('morning')">
          <span class="option-icon">ðŸŒ„</span>
          <span class="option-label">Morning</span>
        </button>
      </div>
      <p class="settings-description">Sun position below horizon:</p>
      <div class="settings-options">
        <button class="settings-option-btn" data-angle="0" onclick="selectDayStartAngle(0)">
          <span class="option-label">0Â° Horizon</span>
          <span class="option-hint">Sun at horizon</span>
        </button>
        <button class="settings-option-btn" data-angle="6" onclick="selectDayStartAngle(6)">
          <span class="option-label">6Â° Civil</span>
          <span class="option-hint">Bright stars visible</span>
        </button>
        <button class="settings-option-btn" data-angle="12" onclick="selectDayStartAngle(12)">
          <span class="option-label">12Â° Nautical</span>
          <span class="option-hint">Most stars visible</span>
        </button>
        <button class="settings-option-btn" data-angle="18" onclick="selectDayStartAngle(18)">
          <span class="option-label">18Â° Astronomical</span>
          <span class="option-hint">Fully dark</span>
        </button>
      </div>
    </div>
    
    <div class="settings-section">
      <h3>Year Starts At</h3>
      <p class="settings-description">Choose the rule for determining the first month of the year.</p>
      <div class="settings-options">
        <button class="settings-option-btn" data-yearstart="equinox" onclick="selectYearStartRule('equinox')">
          <span class="option-icon" id="yearstart-equinox-icon">ðŸŒ•</span>
          <span class="option-label">Renewed Moon after Equinox</span>
          <span class="option-hint" id="yearstart-equinox-hint">Month 1 starts after spring equinox</span>
        </button>
        <button class="settings-option-btn" data-yearstart="13daysBefore" onclick="selectYearStartRule('13daysBefore')">
          <span class="option-icon">ðŸ‘</span>
          <span class="option-label">Passover after Equinox</span>
          <span class="option-hint" id="yearstart-passover-hint">Day 15 (Unleavened) on or after equinox</span>
        </button>
        <button class="settings-option-btn" data-yearstart="virgoFeet" onclick="selectYearStartRule('virgoFeet')">
          <span class="option-icon">â™</span>
          <span class="option-label">Moon Under Virgo's Feet</span>
          <span class="option-hint" id="yearstart-virgo-hint">Full moon below Spica (Rev 12:1)</span>
        </button>
      </div>
      <div class="settings-info-box" id="equinox-rule-explanation" style="display: none;">
        <!-- Content populated dynamically by updateYearStartButtons() using getEquinoxMethodologyHtml() -->
      </div>
      <div class="settings-info-box" id="lamb-rule-explanation" style="display: none;">
        <!-- Content populated dynamically by updateYearStartButtons() using getPassoverMethodologyHtml() -->
      </div>
      <div class="settings-info-box" id="virgo-rule-explanation" style="display: none;">
        <!-- Content populated dynamically by updateYearStartButtons() using getVirgoMethodologyHtml() -->
      </div>
    </div>
    
    <div class="settings-section">
      <h3>Sabbath Day</h3>
      <p class="settings-description">Choose how the Sabbath day is determined and highlighted.</p>
      <div class="settings-options">
        <button class="settings-option-btn" data-sabbath="lunar" onclick="selectSabbathMode('lunar')">
          <span class="option-icon">ðŸŒ•</span>
          <span class="option-label">Lunar Sabbath</span>
          <span class="option-hint">Days 8, 15, 22, 29 of each month</span>
        </button>
        <button class="settings-option-btn" data-sabbath="saturday" onclick="selectSabbathMode('saturday')">
          <span class="option-icon">ðŸª</span>
          <span class="option-label">Saturday</span>
          <span class="option-hint">Fixed weekly Sabbath</span>
        </button>
        <button class="settings-option-btn" data-sabbath="sunday" onclick="selectSabbathMode('sunday')">
          <span class="option-icon">â˜€ï¸</span>
          <span class="option-label">Sunday</span>
          <span class="option-hint">Christian day of rest</span>
        </button>
      </div>
      <div class="settings-row" style="margin-top: 15px;">
        <label class="settings-row-label">Other fixed day:</label>
        <select id="sabbath-day-select" class="settings-select" onchange="selectSabbathDayFromDropdown(this.value)">
          <option value="">â€” Choose â€”</option>
          <option value="none">None</option>
          <option value="monday">Monday</option>
          <option value="tuesday">Tuesday</option>
          <option value="wednesday">Wednesday</option>
          <option value="thursday">Thursday</option>
          <option value="friday">Friday</option>
        </select>
      </div>
    </div>
    
    <div class="settings-section">
      <h3>Default Location</h3>
      <p class="settings-description">The default location determines the timing of sunrise, sunset, and twilight for this profile.</p>
      <div id="settings-page-map"></div>
      <div class="settings-location-buttons">
        <button type="button" class="exact-location-btn settings-location-btn" onclick="getExactLocation()">ðŸ“ Use My Location</button>
        <span class="settings-location-hint">Saves as your default location</span>
      </div>
      <select id="settings-city-select" class="settings-select">
        <option value="current">ðŸ“ Auto-detect via IP (approximate)</option>
        <optgroup label="Biblical">
          <option value="31.7683,35.2137">Jerusalem</option>
        </optgroup>
        <optgroup label="United States">
          <option value="40.7128,-74.0060">New York (Eastern)</option>
          <option value="41.8781,-87.6298">Chicago (Central)</option>
          <option value="39.7392,-104.9903">Denver (Mountain)</option>
          <option value="34.0522,-118.2437">Los Angeles (Pacific)</option>
          <option value="61.2181,-149.9003">Anchorage (Alaska)</option>
          <option value="21.3069,-157.8583">Honolulu (Hawaii)</option>
        </optgroup>
        <optgroup label="International">
          <option value="51.5074,-0.1278">London</option>
          <option value="48.8566,2.3522">Paris</option>
          <option value="35.6762,139.6503">Tokyo</option>
          <option value="-33.8688,151.2093">Sydney</option>
        </optgroup>
        <option value="custom">Custom Coordinates...</option>
      </select>
      <div id="settings-custom-coords" class="settings-custom-coords" style="display: none;">
        <input type="number" id="settings-lat-input" step="0.0001" placeholder="Latitude">
        <input type="number" id="settings-lon-input" step="0.0001" placeholder="Longitude">
      </div>
    </div>
    
    <div class="settings-section">
      <h3>Astronomy Engine & Î”T Uncertainty</h3>
      <p class="settings-description">Technical details about astronomical calculations and historical date accuracy.</p>
      
      <div id="astro-engine-info" class="settings-engine-info">
        <div class="engine-info-row">
          <span class="engine-info-label">Library:</span>
          <span id="astro-engine-name" class="engine-info-value">astronomy-engine v2.1.19</span>
        </div>
        <div class="engine-info-row">
          <span class="engine-info-label">Î”T Model:</span>
          <span id="astro-engine-delta" class="engine-info-value">NASA Eclipse with historical calibration</span>
        </div>
      </div>
      
      <div class="settings-info-box" style="display: block; margin-top: 15px;">
        <p><strong>What is Î”T (Delta T)?</strong></p>
        <p>Î”T is the difference between <em>Terrestrial Time</em> (uniform, based on atomic clocks) and <em>Universal Time</em> (based on Earth's rotation). Earth's rotation is gradually slowing due to tidal friction, causing Î”T to grow over centuries.</p>
        
        <p><strong>Why does this matter for ancient calendars?</strong></p>
        <p>When calculating ancient lunar phases, the uncertainty in Î”T means we cannot know the <em>exact</em> moment a conjunction or full moon occurred. If the moon event was close to sunset, this uncertainty could shift whether Day 1 started on that evening or the next.</p>
        
        <p><strong>Î”T Uncertainty Thresholds Used:</strong></p>
        <table style="width: 100%; border-collapse: collapse; margin: 10px 0; font-size: 0.9em;">
          <thead>
            <tr style="border-bottom: 1px solid rgba(255,255,255,0.3);">
              <th style="text-align: left; padding: 5px;">Era</th>
              <th style="text-align: right; padding: 5px;">Uncertainty</th>
              <th style="text-align: left; padding: 5px 5px 5px 15px;">Notes</th>
            </tr>
          </thead>
          <tbody style="color: rgba(255,255,255,0.8);">
            <tr><td style="padding: 4px 5px;">1600â€“2100 AD</td><td style="text-align: right; padding: 4px 5px;">~0 hours</td><td style="padding: 4px 5px 4px 15px;">Modern records, negligible error</td></tr>
            <tr><td style="padding: 4px 5px;">1000â€“1600 AD</td><td style="text-align: right; padding: 4px 5px;">Â±0.25 hours</td><td style="padding: 4px 5px 4px 15px;">Medieval eclipse records</td></tr>
            <tr><td style="padding: 4px 5px;">500â€“1000 AD</td><td style="text-align: right; padding: 4px 5px;">Â±0.5 hours</td><td style="padding: 4px 5px 4px 15px;">Late antiquity</td></tr>
            <tr><td style="padding: 4px 5px;">1â€“500 AD</td><td style="text-align: right; padding: 4px 5px;">Â±1 hour</td><td style="padding: 4px 5px 4px 15px;">Roman era</td></tr>
            <tr><td style="padding: 4px 5px;">500â€“1 BC</td><td style="text-align: right; padding: 4px 5px;">Â±1.5 hours</td><td style="padding: 4px 5px 4px 15px;">Classical antiquity</td></tr>
            <tr><td style="padding: 4px 5px;">1000â€“500 BC</td><td style="text-align: right; padding: 4px 5px;">Â±2 hours</td><td style="padding: 4px 5px 4px 15px;">Iron Age, Babylonian records</td></tr>
            <tr><td style="padding: 4px 5px;">1500â€“1000 BC</td><td style="text-align: right; padding: 4px 5px;">Â±3 hours</td><td style="padding: 4px 5px 4px 15px;">Late Bronze Age (Exodus era)</td></tr>
            <tr><td style="padding: 4px 5px;">2000â€“1500 BC</td><td style="text-align: right; padding: 4px 5px;">Â±4 hours</td><td style="padding: 4px 5px 4px 15px;">Middle Bronze Age</td></tr>
            <tr><td style="padding: 4px 5px;">Before 2000 BC</td><td style="text-align: right; padding: 4px 5px;">Â±5+ hours</td><td style="padding: 4px 5px 4px 15px;">Early Bronze Age and earlier</td></tr>
          </tbody>
        </table>
        
        <p style="font-size: 0.85em; color: rgba(255,255,255,0.6); margin-top: 10px;">
          <strong>Source:</strong> Based on NASA eclipse calibration data and Espenak-Meeus polynomial models. 
          See <a href="https://eclipse.gsfc.nasa.gov/SEcat5/deltat.html" target="_blank" style="color: #7ec8e3;">NASA Î”T page</a>.
        </p>
      </div>
    </div>
  </div>

  <!-- Day Detail Panel - slides up when a day is selected -->
  <div id="day-detail-panel" class="day-detail-panel hidden">
    <div class="day-detail-header">
      <div class="day-detail-date">
        <span class="day-detail-lunar"></span>
        <span class="day-detail-gregorian-row">
          <span class="day-detail-gregorian"></span>
          <button class="day-detail-jump-btn" onclick="toggleDateJump()" title="Jump to another date">â‡¥</button>
        </span>
      </div>
      <div class="day-detail-astro-times"></div>
    </div>
    <div class="day-detail-content">
      <div class="day-detail-feasts"></div>
      <div class="day-detail-info"></div>
      <div class="day-detail-dateline"></div>
      <div class="day-detail-profile-compare"></div>
    </div>
  </div>

  <!-- Feast table hidden from main page - shown in export modal -->
  <div class="feast-list" style="display: none;">
    <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px; margin-bottom: 15px;">
      <h3 style="margin: 0;">Appointed Times for <span id="feast-year">2026</span></h3>
      <button class="btn" onclick="openInCalendar()" title="Download all Sabbaths and Feasts for this year">ðŸ“… Export Year to Calendar App</button>
    </div>
    <div class="feast-table-container">
    <table class="feast-table">
      <thead>
        <tr>
          <th>Feast</th>
          <th>Date</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody id="feast-tbody"></tbody>
    </table>
    </div>
  </div>
</div>

<!-- Profile Name Modal -->
<div id="profile-modal-overlay" class="profile-modal-overlay" onclick="closeProfileModal(event)">
  <div class="profile-modal" onclick="event.stopPropagation()">
    <h3 id="profile-modal-title">Create New Profile</h3>
    <input type="text" id="profile-modal-input" class="profile-modal-input" placeholder="Enter profile name" onkeydown="handleProfileModalKeydown(event)">
    <div id="profile-modal-error" class="profile-modal-error"></div>
    <div class="profile-modal-buttons">
      <button class="profile-modal-btn cancel" onclick="closeProfileModal()">Cancel</button>
      <button id="profile-modal-save-btn" class="profile-modal-btn save" onclick="saveProfileModal()">Create</button>
    </div>
  </div>
</div>

<!-- Sabbath Tester Page -->
<div id="sabbath-tester-page" style="display: none;">
  <div class="sabbath-tester-header">
    <h2>ðŸ”¬ Sabbath Theory Tester</h2>
    <button class="close-btn" onclick="navigateTo('calendar')" aria-label="Close">âœ•</button>
  </div>
  <div class="sabbath-tester-content">
    <div class="sabbath-tester-intro" style="background: rgba(0,0,0,0.2); padding: 16px; border-radius: 10px; margin-bottom: 20px; color: #ccc; line-height: 1.6;">
      <p style="margin: 0 0 10px 0;">This tool tests various <strong style="color: #7ec8e3;">lunar calendar theories</strong> against historical biblical events where specific weekdays are mentioned in Scripture.</p>
      <p style="margin: 0 0 14px 0;">All tests assume a <strong style="color: #7ec8e3;">fixed Saturday Sabbath</strong> and <strong style="color: #7ec8e3;">Jerusalem location</strong>. The goal is to determine which combination of moon phase (Full, Dark, or Crescent) and day-start time (Daybreak or Sunset) produces dates that align with the biblical record.</p>
      <div style="display: flex; flex-wrap: wrap; gap: 16px; padding-top: 10px; border-top: 1px solid rgba(126, 200, 227, 0.2);">
        <div style="display: flex; align-items: center; gap: 6px;">
          <span style="font-size: 1.2em;">âš–ï¸</span>
          <span><strong style="color: #7ec8e3;">Scale</strong> â€” New Moon on or after Spring Equinox</span>
        </div>
        <div style="display: flex; align-items: center; gap: 6px;">
          <span style="font-size: 1.2em;">ðŸ‘</span>
          <span><strong style="color: #7ec8e3;">Lamb</strong> â€” Day 15 (Unleavened) on or after Spring Equinox</span>
        </div>
      </div>
    </div>
    <div id="sabbath-tester-loading" class="sabbath-test-loading">
      Loading tests...
    </div>
    <div id="sabbath-tester-results"></div>
  </div>
</div>

<!-- Export/Feasts Page -->
<div id="export-page" class="export-page" style="display: none;">
  <div class="settings-page-header export-header">
    <h2>Appointed Times for <span id="export-year">2026</span></h2>
    <button class="btn export-download-btn" onclick="openInCalendar()">ðŸ“… Export</button>
  </div>
  <div class="export-settings-context">
    <span id="export-context-text">Loading settings...</span>
  </div>
  <div class="settings-content" style="padding-top: 0;">
    <div class="feast-table-container">
      <table class="feast-table">
        <thead>
          <tr>
            <th>Feast</th>
            <th>Date</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody id="export-feast-tbody"></tbody>
      </table>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/astronomy-engine@2.1.19/astronomy.browser.min.js"></script>
<!-- offline-geocode-city: Currently has browser compatibility bug (GitHub issue #2)
     Keeping reference for when it's fixed. Falls back to CITY_SLUGS. -->
<!-- <script src="https://cdn.jsdelivr.net/npm/offline-geocode-city@1.0.2/dist/index.iife.js"></script> -->
<script src="/lunar-calendar-engine.js"></script>
<script>
// ============================================================================
// ASTRONOMY ENGINE ABSTRACTION LAYER
// ============================================================================
// This abstraction allows switching between different astronomy calculation
// libraries (astronomy-engine, Swiss Ephemeris WASM, etc.) without changing
// the rest of the codebase.

// Available engines registry
const AstroEngines = {
  // Cache for Virgo rule calculations, keyed by year
  virgoCache: {}
};

// Currently active engine instance
let activeAstroEngine = null;

// Engine interface definition (for documentation):
// {
//   name: string,                          // Human-readable name
//   version: string,                       // Library version
//   deltaTModel: string,                   // Î”T model used
//   isLoaded: boolean,                     // Whether engine is ready
//   
//   // Core methods:
//   searchMoonPhase(phase, startDate, limitDays) => { date: Date } | null
//   getSeasons(year) => { mar_equinox: { date: Date }, ... }
//   searchRiseSet(body, observer, direction, startDate, limitDays) => { date: Date } | null
//   searchAltitude(body, observer, direction, startDate, limitDays, altitude) => { date: Date } | null
//   getEquator(body, date, observer) => { ra: number, dec: number }
//   getHorizon(date, observer, ra, dec) => { altitude: number, azimuth: number }
//   getDeltaT(date) => number (in seconds)
//   createObserver(lat, lon, elevation) => observer object
// }

// ============================================================================
// ASTRONOMY-ENGINE IMPLEMENTATION
// ============================================================================
AstroEngines.astronomyEngine = {
  name: 'astronomy-engine',
  version: '2.1.19',
  deltaTModel: 'Espenak-Meeus polynomial',
  deltaTNote: 'Good for modern dates; ~9.5h Î”T uncertainty at 1500 BC',
  isLoaded: true, // Loaded synchronously via script tag
  
  searchMoonPhase(phase, startDate, limitDays) {
    return Astronomy.SearchMoonPhase(phase, startDate, limitDays);
  },
  
  getSeasons(year) {
    return Astronomy.Seasons(year);
  },
  
  searchRiseSet(body, observer, direction, startDate, limitDays) {
    const astroBody = body === 'sun' ? Astronomy.Body.Sun : Astronomy.Body.Moon;
    return Astronomy.SearchRiseSet(astroBody, observer, direction, startDate, limitDays);
  },
  
  searchAltitude(body, observer, direction, startDate, limitDays, altitude) {
    const astroBody = body === 'sun' ? Astronomy.Body.Sun : Astronomy.Body.Moon;
    return Astronomy.SearchAltitude(astroBody, observer, direction, startDate, limitDays, altitude);
  },
  
  getEquator(body, date, observer) {
    // Validate date before calling astronomy-engine
    if (!date || isNaN(date.getTime())) {
      return { ra: 0, dec: 0 };
    }
    try {
      const astroBody = body === 'sun' ? Astronomy.Body.Sun : Astronomy.Body.Moon;
      const result = Astronomy.Equator(astroBody, date, observer, true, true);
      
      // Validate result
      if (result && isFinite(result.ra) && isFinite(result.dec)) {
        return result;
      }
      return { ra: 0, dec: 0 };
    } catch (err) {
      return { ra: 0, dec: 0 };
    }
  },
  
  getHorizon(date, observer, ra, dec) {
    // Validate inputs before calling astronomy-engine
    if (!date || isNaN(date.getTime()) || !isFinite(ra) || !isFinite(dec)) {
      return { altitude: 0, azimuth: 0 };
    }
    try {
      const result = Astronomy.Horizon(date, observer, ra, dec, 'normal');
      if (result && isFinite(result.altitude) && isFinite(result.azimuth)) {
        return result;
      }
      return { altitude: 0, azimuth: 0 };
    } catch (err) {
      return { altitude: 0, azimuth: 0 };
    }
  },
  
  getDeltaT(date) {
    // astronomy-engine doesn't expose DeltaT directly, but we can calculate it
    // from the difference between TT and UT
    const astroTime = new Astronomy.AstroTime(date);
    return (astroTime.tt - astroTime.ut) * 86400; // Convert days to seconds
  },
  
  createObserver(lat, lon, elevation = 0) {
    return new Astronomy.Observer(lat, lon, elevation);
  }
};

// ============================================================================
// SWISS EPHEMERIS WASM IMPLEMENTATION (@swisseph/browser - self-hosted)
// ============================================================================
AstroEngines.swissEphemeris = {
  name: 'Swiss Ephemeris',
  version: 'Loading...',
  deltaTModel: 'Moshier Ephemeris',
  deltaTNote: 'Built-in analytical ephemeris; good for dates from 3000 BC to 3000 AD',
  isLoaded: false,
  _swe: null,
  _module: null,
  _loadPromise: null,
  
  async load() {
    if (this.isLoaded) return true;
    if (this._loadPromise) return this._loadPromise;
    
    this._loadPromise = (async () => {
      try {
        // Dynamic import of self-hosted @swisseph/browser
        const module = await import('/lib/swisseph/swisseph-browser.js');
        this._module = module;
        
        // Create SwissEphemeris instance and initialize WASM with explicit path
        this._swe = new module.SwissEphemeris();
        await this._swe.init('/lib/swisseph/swisseph.wasm');
        
        this.version = '1.1.0';
        this.isLoaded = true;
        console.log('Swiss Ephemeris WASM loaded successfully');
        return true;
      } catch (err) {
        console.error('Failed to load Swiss Ephemeris WASM:', err);
        this.isLoaded = false;
        return false;
      }
    })();
    
    return this._loadPromise;
  },
  
  // Julian Day conversion helpers
  _dateToJD(date) {
    const y = date.getUTCFullYear();
    const m = date.getUTCMonth() + 1;
    const d = date.getUTCDate();
    const h = date.getUTCHours() + date.getUTCMinutes() / 60 + date.getUTCSeconds() / 3600;
    
    const a = Math.floor((14 - m) / 12);
    const yy = y + 4800 - a;
    const mm = m + 12 * a - 3;
    
    // Julian calendar for dates before Oct 15, 1582
    // Gregorian calendar for dates on or after Oct 15, 1582
    let jdn;
    if (y < 1582 || (y === 1582 && (m < 10 || (m === 10 && d < 15)))) {
      jdn = d + Math.floor((153 * mm + 2) / 5) + 365 * yy + Math.floor(yy / 4) - 32083;
    } else {
      jdn = d + Math.floor((153 * mm + 2) / 5) + 365 * yy + Math.floor(yy / 4) - Math.floor(yy / 100) + Math.floor(yy / 400) - 32045;
    }
    return jdn + (h - 12) / 24;
  },
  
  _jdToDate(jd) {
    // Helper to create Date with proper year handling (including negative years)
    const createDate = (year, month, day, h, min, sec) => {
      // JavaScript Date.UTC interprets years 0-99 as 1900-1999
      // We need to use setUTCFullYear for ancient dates
      const date = new Date(Date.UTC(2000, month - 1, day, h, min, sec));
      date.setUTCFullYear(year);
      return date;
    };
    
    if (!this._swe) {
      // Manual Julian Day to calendar date conversion
      const z = Math.floor(jd + 0.5);
      const f = jd + 0.5 - z;
      let a = z;
      if (z >= 2299161) {
        const alpha = Math.floor((z - 1867216.25) / 36524.25);
        a = z + 1 + alpha - Math.floor(alpha / 4);
      }
      const b = a + 1524;
      const c = Math.floor((b - 122.1) / 365.25);
      const d = Math.floor(365.25 * c);
      const e = Math.floor((b - d) / 30.6001);
      
      const day = b - d - Math.floor(30.6001 * e);
      const month = e < 14 ? e - 1 : e - 13;
      const year = month > 2 ? c - 4716 : c - 4715;
      
      const hours = f * 24;
      const h = Math.floor(hours);
      const minutes = (hours - h) * 60;
      const min = Math.floor(minutes);
      const sec = Math.floor((minutes - min) * 60);
      
      return createDate(year, month, day, h, min, sec);
    }
    
    // Use library's conversion
    try {
      const cal = this._swe.julianDayToDate(jd);
      // The library might return hours as a decimal or separate hour/minute/second fields
      let h = 0, min = 0, sec = 0;
      if (typeof cal.hours === 'number') {
        h = Math.floor(cal.hours);
        min = Math.floor((cal.hours % 1) * 60);
        sec = Math.floor(((cal.hours % 1) * 60 % 1) * 60);
      } else if (typeof cal.hour === 'number') {
        h = cal.hour;
        min = cal.minute || 0;
        sec = Math.floor(cal.second || 0);
      }
      
      return createDate(cal.year, cal.month, cal.day, h, min, sec);
    } catch (err) {
      console.warn('Swiss Ephemeris julianDayToDate failed, using manual conversion:', err);
      // Fall through to manual calculation
      const z = Math.floor(jd + 0.5);
      const f = jd + 0.5 - z;
      let a = z;
      if (z >= 2299161) {
        const alpha = Math.floor((z - 1867216.25) / 36524.25);
        a = z + 1 + alpha - Math.floor(alpha / 4);
      }
      const b = a + 1524;
      const c = Math.floor((b - 122.1) / 365.25);
      const d = Math.floor(365.25 * c);
      const e = Math.floor((b - d) / 30.6001);
      
      const day = b - d - Math.floor(30.6001 * e);
      const month = e < 14 ? e - 1 : e - 13;
      const year = month > 2 ? c - 4716 : c - 4715;
      
      const hours = f * 24;
      const hh = Math.floor(hours);
      const minutes = (hours - hh) * 60;
      const mm = Math.floor(minutes);
      const ss = Math.floor((minutes - mm) * 60);
      
      return createDate(year, month, day, hh, mm, ss);
    }
  },
  
  // Get Moon-Sun elongation for phase calculations
  _getMoonSunElongation(jd) {
    if (!this._swe || !this._module) return null;
    
    try {
      const Planet = this._module.Planet;
      const sunPos = this._swe.calculatePosition(jd, Planet.Sun);
      const moonPos = this._swe.calculatePosition(jd, Planet.Moon);
      
      if (sunPos.longitude === undefined || moonPos.longitude === undefined) {
        return null;
      }
      
      let elongation = moonPos.longitude - sunPos.longitude;
      while (elongation < 0) elongation += 360;
      while (elongation >= 360) elongation -= 360;
      return elongation;
    } catch (err) {
      return null;
    }
  },
  
  searchMoonPhase(phase, startDate, limitDays) {
    if (!this.isLoaded || !this._swe) {
      return AstroEngines.astronomyEngine.searchMoonPhase(phase, startDate, limitDays);
    }
    
    const startJD = this._dateToJD(startDate);
    const endJD = startJD + limitDays;
    const step = 1;
    
    let prevJD = startJD;
    let prevElong = this._getMoonSunElongation(prevJD);
    if (prevElong === null) {
      return AstroEngines.astronomyEngine.searchMoonPhase(phase, startDate, limitDays);
    }
    
    const targetPhase = phase % 360;
    
    for (let jd = startJD + step; jd <= endJD; jd += step) {
      let elong = this._getMoonSunElongation(jd);
      if (elong === null) continue;
      
      // Check for phase crossing (handling 360â†’0 wrap)
      let crossed = false;
      if (targetPhase === 0) {
        // New moon: elongation wraps from ~359Â° down to ~1Â° (crosses 0Â°)
        // This happens when prevElong is high (>300) and elong is low (<60)
        if (prevElong > 300 && elong < 60) crossed = true;
      } else if (targetPhase === 180) {
        // Full moon: elongation crossing 180 from below
        if (prevElong < 180 && elong >= 180) crossed = true;
      } else {
        // Other phases
        if ((prevElong < targetPhase && elong >= targetPhase) ||
            (prevElong > targetPhase && elong <= targetPhase && Math.abs(prevElong - elong) < 180)) {
          crossed = true;
        }
      }
      
      if (crossed) {
        // Refine with bisection
        let lo = prevJD, hi = jd;
        for (let i = 0; i < 20; i++) { // ~1 second precision
          const mid = (lo + hi) / 2;
          const midElong = this._getMoonSunElongation(mid);
          if (midElong === null) break;
          
          if (targetPhase === 0) {
            // New moon: we want to find where elongation is closest to 0
            // If midElong > 180, we're before the crossing (moon catching up)
            if (midElong > 180) lo = mid; else hi = mid;
          } else if (targetPhase === 180) {
            if (midElong < 180) lo = mid; else hi = mid;
          } else {
            if (midElong < targetPhase) lo = mid; else hi = mid;
          }
        }
        
        const resultJD = (lo + hi) / 2;
        return { date: this._jdToDate(resultJD), jd: resultJD };
      }
      
      prevJD = jd;
      prevElong = elong;
    }
    
    return null;
  },
  
  getSeasons(year) {
    if (!this.isLoaded || !this._swe || !this._module) {
      return AstroEngines.astronomyEngine.getSeasons(year);
    }
    
    try {
      const Planet = this._module.Planet;
      
      // Start search around March 1
      // Use setUTCFullYear for proper handling of negative/ancient years
      const startDate = new Date(Date.UTC(2000, 2, 1));
      startDate.setUTCFullYear(year);
      let jd = this._dateToJD(startDate);
      const endJD = jd + 30;
      
      let prevLon = null;
      for (; jd <= endJD; jd += 0.5) {
        const sunPos = this._swe.calculatePosition(jd, Planet.Sun);
        const lon = sunPos.longitude;
        
        // Spring equinox: Sun crossing 0Â° from ~359Â° to ~1Â°
        if (prevLon !== null && prevLon > 350 && lon < 10) {
          // Refine with bisection
          let lo = jd - 0.5, hi = jd;
          for (let i = 0; i < 20; i++) {
            const mid = (lo + hi) / 2;
            const midPos = this._swe.calculatePosition(mid, Planet.Sun);
            const midLon = midPos.longitude;
            if (midLon > 180) lo = mid; else hi = mid;
          }
          
          return {
            mar_equinox: { date: this._jdToDate((lo + hi) / 2) }
          };
        }
        prevLon = lon;
      }
    } catch (err) {
      console.warn('Error finding equinox with Swiss Ephemeris:', err);
    }
    
    // Fallback
    return AstroEngines.astronomyEngine.getSeasons(year);
  },
  
  searchRiseSet(body, observer, direction, startDate, limitDays) {
    // Swiss Ephemeris rise/set calculation is complex, use fallback for now
    return AstroEngines.astronomyEngine.searchRiseSet(body, observer, direction, startDate, limitDays);
  },
  
  searchAltitude(body, observer, direction, startDate, limitDays, altitude) {
    return AstroEngines.astronomyEngine.searchAltitude(body, observer, direction, startDate, limitDays, altitude);
  },
  
  getEquator(body, date, observer) {
    if (!this.isLoaded || !this._swe || !this._module) {
      return AstroEngines.astronomyEngine.getEquator(body, date, observer);
    }
    
    try {
      const Planet = this._module.Planet;
      const CalculationFlag = this._module.CalculationFlag;
      const planet = body === 'sun' ? Planet.Sun : Planet.Moon;
      const jd = this._dateToJD(date);
      
      // Get equatorial coordinates
      const pos = this._swe.calculatePosition(jd, planet, CalculationFlag.Equatorial);
      
      // Validate result - if invalid, fall back to astronomy-engine
      if (pos && isFinite(pos.rightAscension) && isFinite(pos.declination)) {
        return {
          ra: pos.rightAscension / 15, // Convert degrees to hours
          dec: pos.declination
        };
      }
      
      // Invalid result, fall back
      return AstroEngines.astronomyEngine.getEquator(body, date, observer);
    } catch (err) {
      return AstroEngines.astronomyEngine.getEquator(body, date, observer);
    }
  },
  
  getHorizon(date, observer, ra, dec) {
    // Use astronomy-engine for horizon conversion (simpler)
    return AstroEngines.astronomyEngine.getHorizon(date, observer, ra, dec);
  },
  
  getDeltaT(date) {
    if (!this.isLoaded || !this._swe) {
      return AstroEngines.astronomyEngine.getDeltaT(date);
    }
    
    try {
      const jd = this._dateToJD(date);
      const deltaT = this._swe.deltaT(jd);
      return deltaT * 86400; // Convert days to seconds
    } catch (err) {
      return AstroEngines.astronomyEngine.getDeltaT(date);
    }
  },
  
  createObserver(lat, lon, elevation = 0) {
    // Use astronomy-engine observer format for compatibility
    return new Astronomy.Observer(lat, lon, elevation);
  }
};

// ============================================================================
// HYBRID ENGINE: Swiss Ephemeris calibrated against NASA Eclipse anchors
// ============================================================================
// This approach uses Swiss Ephemeris for precise local calculations, but
// calibrates the Î”T model against NASA eclipse data to reduce drift for 
// ancient dates. NASA eclipses are observable historical events with known
// times, providing ground truth for Î”T corrections.
// ============================================================================
AstroEngines.nasaEclipse = {
  name: 'Hybrid (Swiss Eph + NASA)',
  version: '1.0',
  deltaTModel: 'NASA Eclipse Calibrated',
  deltaTNote: 'Swiss Ephemeris calculations aligned to NASA eclipse anchors',
  isLoaded: false,
  _eclipses: null,  // Array of {jd, y, t} where t='n' (new) or 'f' (full)
  _loadPromise: null,
  _offsetCache: new Map(), // Cache offset calculations by year
  
  async load() {
    if (this.isLoaded) return true;
    if (this._loadPromise) return this._loadPromise;
    
    this._loadPromise = (async () => {
      try {
        const response = await fetch('/data/eclipses.json');
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        this._eclipses = await response.json();
        this.isLoaded = true;
        console.log(`NASA Eclipse data loaded: ${this._eclipses.length} eclipses`);
        return true;
      } catch (err) {
        console.error('Failed to load NASA eclipse data:', err);
        this.isLoaded = false;
        return false;
      }
    })();
    
    return this._loadPromise;
  },
  
  // Julian Day conversion (handles both Julian and Gregorian calendars)
  _dateToJD(date) {
    const y = date.getUTCFullYear();
    const m = date.getUTCMonth() + 1;
    const d = date.getUTCDate();
    const h = date.getUTCHours() + date.getUTCMinutes() / 60 + date.getUTCSeconds() / 3600;
    
    const a = Math.floor((14 - m) / 12);
    const yy = y + 4800 - a;
    const mm = m + 12 * a - 3;
    
    // Julian calendar for dates before Oct 15, 1582
    // Gregorian calendar for dates on or after Oct 15, 1582
    let jdn;
    if (y < 1582 || (y === 1582 && (m < 10 || (m === 10 && d < 15)))) {
      // Julian calendar
      jdn = d + Math.floor((153 * mm + 2) / 5) + 365 * yy + Math.floor(yy / 4) - 32083;
    } else {
      // Gregorian calendar
      jdn = d + Math.floor((153 * mm + 2) / 5) + 365 * yy + Math.floor(yy / 4) - Math.floor(yy / 100) + Math.floor(yy / 400) - 32045;
    }
    return jdn + (h - 12) / 24;
  },
  
  _jdToDate(jd) {
    const createDate = (year, month, day, h, min, sec) => {
      const date = new Date(Date.UTC(2000, month - 1, day, h, min, sec));
      date.setUTCFullYear(year);
      return date;
    };
    
    const z = Math.floor(jd + 0.5);
    const f = jd + 0.5 - z;
    let a = z;
    if (z >= 2299161) {
      const alpha = Math.floor((z - 1867216.25) / 36524.25);
      a = z + 1 + alpha - Math.floor(alpha / 4);
    }
    const b = a + 1524;
    const c = Math.floor((b - 122.1) / 365.25);
    const d = Math.floor(365.25 * c);
    const e = Math.floor((b - d) / 30.6001);
    
    const day = b - d - Math.floor(30.6001 * e);
    const month = e < 14 ? e - 1 : e - 13;
    const year = month > 2 ? c - 4716 : c - 4715;
    
    const hours = f * 24;
    const hh = Math.floor(hours);
    const minutes = (hours - hh) * 60;
    const mm = Math.floor(minutes);
    const ss = Math.floor((minutes - mm) * 60);
    
    return createDate(year, month, day, hh, mm, ss);
  },
  
  // Find eclipse of given type before or after a JD
  _findEclipse(targetJD, type, direction) {
    if (!this._eclipses) return null;
    
    // Binary search for approximate position
    let lo = 0, hi = this._eclipses.length - 1;
    while (lo < hi) {
      const mid = Math.floor((lo + hi) / 2);
      if (this._eclipses[mid].jd < targetJD) lo = mid + 1;
      else hi = mid;
    }
    
    if (direction < 0) {
      // Search backward for eclipse of this type
      for (let i = lo - 1; i >= 0; i--) {
        if (this._eclipses[i].t === type) return this._eclipses[i];
      }
    } else {
      // Search forward for eclipse of this type
      for (let i = lo; i < this._eclipses.length; i++) {
        if (this._eclipses[i].t === type) return this._eclipses[i];
      }
    }
    return null;
  },
  
  // Find the nearest eclipse (any type) to a given JD
  _findNearestEclipse(targetJD) {
    if (!this._eclipses || this._eclipses.length === 0) return null;
    
    let lo = 0, hi = this._eclipses.length - 1;
    while (lo < hi) {
      const mid = Math.floor((lo + hi) / 2);
      if (this._eclipses[mid].jd < targetJD) lo = mid + 1;
      else hi = mid;
    }
    
    // Check both lo and lo-1 to find closest
    const candidates = [];
    if (lo > 0) candidates.push(this._eclipses[lo - 1]);
    if (lo < this._eclipses.length) candidates.push(this._eclipses[lo]);
    
    let nearest = null;
    let minDist = Infinity;
    for (const e of candidates) {
      const dist = Math.abs(e.jd - targetJD);
      if (dist < minDist) {
        minDist = dist;
        nearest = e;
      }
    }
    return nearest;
  },
  
  // Check if a given date has a lunar eclipse (blood moon)
  // Returns true if there's a lunar eclipse within 0.5 days of the given date
  hasLunarEclipse(date) {
    if (!this._eclipses) {
      return false;
    }
    
    const jd = this._dateToJD(date);
    
    // Binary search to find nearby eclipses
    let lo = 0, hi = this._eclipses.length - 1;
    while (lo < hi) {
      const mid = Math.floor((lo + hi) / 2);
      if (this._eclipses[mid].jd < jd) lo = mid + 1;
      else hi = mid;
    }
    
    // Check nearby eclipses (within a day on either side)
    for (let i = Math.max(0, lo - 2); i < Math.min(this._eclipses.length, lo + 3); i++) {
      const e = this._eclipses[i];
      const diff = Math.abs(e.jd - jd);
      if (e.t === 'f' && diff < 1.0) {
        return true;
      }
    }
    return false;
  },
  
  // Get the exact time of a lunar eclipse for a given date
  // Returns a Date object or null if no eclipse found
  getLunarEclipseTime(date) {
    if (!this._eclipses) {
      return null;
    }
    
    const jd = this._dateToJD(date);
    
    // Binary search to find nearby eclipses
    let lo = 0, hi = this._eclipses.length - 1;
    while (lo < hi) {
      const mid = Math.floor((lo + hi) / 2);
      if (this._eclipses[mid].jd < jd) lo = mid + 1;
      else hi = mid;
    }
    
    // Check nearby eclipses (within a day on either side)
    for (let i = Math.max(0, lo - 2); i < Math.min(this._eclipses.length, lo + 3); i++) {
      const e = this._eclipses[i];
      const diff = Math.abs(e.jd - jd);
      if (e.t === 'f' && diff < 1.0) {
        // Convert JD to Date
        return this._jdToDate(e.jd);
      }
    }
    return null;
  },
  
  // Helper to create Date with proper year handling (including negative years)
  _createDate(year, month, day, hour, minute, second) {
    // JavaScript Date.UTC interprets years 0-99 as 1900-1999
    // We need to use setUTCFullYear for all dates to be safe
    const date = new Date(Date.UTC(2000, month - 1, day, hour || 0, minute || 0, second || 0));
    date.setUTCFullYear(year);
    return date;
  },
  
  // Calculate the Î”T offset between Swiss Ephemeris and NASA eclipse
  // This is the key to the hybrid approach
  _calculateOffset(nearYear, eclipseType) {
    const cacheKey = `${nearYear}_${eclipseType}`;
    if (this._offsetCache.has(cacheKey)) {
      return this._offsetCache.get(cacheKey);
    }
    
    if (!AstroEngines.swissEphemeris.isLoaded) {
      return 0;
    }
    
    // Find a NASA eclipse near the target year
    const midYearDate = this._createDate(nearYear, 7, 1, 0, 0, 0);
    const approxJD = this._dateToJD(midYearDate);
    
    const nasaEclipse = this._findEclipse(approxJD, eclipseType, -1) || 
                        this._findEclipse(approxJD, eclipseType, 1);
    
    if (!nasaEclipse) {
      return 0;
    }
    
    // Get what Swiss Ephemeris calculates for this same moon phase
    const searchStart = this._jdToDate(nasaEclipse.jd - 3);
    const phase = eclipseType === 'n' ? 0 : 180;
    
    try {
      const sweResult = AstroEngines.swissEphemeris.searchMoonPhase(phase, searchStart, 10);
      if (!sweResult || !sweResult.date) {
        return 0;
      }
      
      // Use JD directly if available (avoids Date round-trip issues with ancient dates)
      const sweJD = sweResult.jd || this._dateToJD(sweResult.date);
      
      // Sanity check - offset should be reasonable (less than a few days)
      const offset = nasaEclipse.jd - sweJD;
      if (!isFinite(offset) || Math.abs(offset) > 5) {
        return 0;
      }
      
      this._offsetCache.set(cacheKey, offset);
      return offset;
    } catch (err) {
      console.warn(`Error calculating offset for year ${nearYear}:`, err);
      return 0;
    }
  },
  
  // Hybrid moon phase search:
  // 1. Use Swiss Ephemeris for precise phase calculation
  // 2. Apply Î”T correction from nearest NASA eclipse anchor
  searchMoonPhase(phase, startDate, limitDays) {
    try {
      if (!AstroEngines.swissEphemeris.isLoaded) {
        return this._searchMoonPhaseInterpolate(phase, startDate, limitDays);
      }
      
      if (!this.isLoaded || !this._eclipses) {
        return AstroEngines.swissEphemeris.searchMoonPhase(phase, startDate, limitDays);
      }
      
      const sweResult = AstroEngines.swissEphemeris.searchMoonPhase(phase, startDate, limitDays);
      if (!sweResult || !sweResult.date) return null;
      
      if (isNaN(sweResult.date.getTime())) {
        return this._searchMoonPhaseInterpolate(phase, startDate, limitDays);
      }
      
      // For modern dates (1600-2100 CE), Swiss Eph is already accurate
      const year = sweResult.date.getUTCFullYear();
      if (year >= 1600 && year <= 2100) {
        return sweResult;
      }
      
      // For ancient/future dates, apply NASA eclipse calibration
      const eclipseType = (phase === 0 || phase === 360) ? 'n' : 'f';
      const offset = this._calculateOffset(year, eclipseType);
      
      if (!isFinite(offset) || Math.abs(offset) < 0.001) {
        return sweResult;
      }
      
      // Apply the offset correction using JD directly if available
      const sweJD = sweResult.jd || this._dateToJD(sweResult.date);
      const correctedJD = sweJD + offset;
      
      if (!isFinite(correctedJD)) {
        return sweResult;
      }
      
      return { date: this._jdToDate(correctedJD) };
    } catch (err) {
      return this._searchMoonPhaseInterpolate(phase, startDate, limitDays);
    }
  },
  
  // Pure interpolation fallback (original algorithm)
  _searchMoonPhaseInterpolate(phase, startDate, limitDays) {
    if (!this.isLoaded || !this._eclipses) {
      return AstroEngines.astronomyEngine.searchMoonPhase(phase, startDate, limitDays);
    }
    
    const targetJD = this._dateToJD(startDate);
    const endJD = targetJD + limitDays;
    const SYNODIC_MONTH = 29.530588853;
    
    const wantNewMoon = (phase === 0 || phase === 360);
    const eclipseType = wantNewMoon ? 'n' : 'f';
    
    const eclipseBefore = this._findEclipse(targetJD, eclipseType, -1);
    const eclipseAfter = this._findEclipse(targetJD, eclipseType, 1);
    
    if (!eclipseBefore && !eclipseAfter) {
      return AstroEngines.astronomyEngine.searchMoonPhase(phase, startDate, limitDays);
    }
    
    let localSynodicMonth = SYNODIC_MONTH;
    if (eclipseBefore && eclipseAfter) {
      const span = eclipseAfter.jd - eclipseBefore.jd;
      const lunations = Math.round(span / SYNODIC_MONTH);
      if (lunations > 0) {
        localSynodicMonth = span / lunations;
      }
    }
    
    let anchorEclipse, direction;
    if (!eclipseBefore) {
      anchorEclipse = eclipseAfter;
      direction = -1;
    } else if (!eclipseAfter) {
      anchorEclipse = eclipseBefore;
      direction = 1;
    } else {
      const distBefore = targetJD - eclipseBefore.jd;
      const distAfter = eclipseAfter.jd - targetJD;
      if (distBefore <= distAfter) {
        anchorEclipse = eclipseBefore;
        direction = 1;
      } else {
        anchorEclipse = eclipseAfter;
        direction = -1;
      }
    }
    
    let resultJD;
    if (direction > 0) {
      const lunationsFromAnchor = Math.ceil((targetJD - anchorEclipse.jd) / localSynodicMonth);
      resultJD = anchorEclipse.jd + lunationsFromAnchor * localSynodicMonth;
    } else {
      const lunationsFromAnchor = Math.ceil((anchorEclipse.jd - targetJD) / localSynodicMonth);
      resultJD = anchorEclipse.jd - (lunationsFromAnchor - 1) * localSynodicMonth;
    }
    
    while (resultJD < targetJD) resultJD += localSynodicMonth;
    if (resultJD > endJD) return null;
    
    return { date: this._jdToDate(resultJD) };
  },
  
  // Use Swiss Ephemeris or astronomy-engine for other calculations
  getSeasons(year) {
    return AstroEngines.swissEphemeris.isLoaded 
      ? AstroEngines.swissEphemeris.getSeasons(year)
      : AstroEngines.astronomyEngine.getSeasons(year);
  },
  
  searchRiseSet(body, observer, direction, startDate, limitDays) {
    return AstroEngines.astronomyEngine.searchRiseSet(body, observer, direction, startDate, limitDays);
  },
  
  searchAltitude(body, observer, direction, startDate, limitDays, altitude) {
    return AstroEngines.astronomyEngine.searchAltitude(body, observer, direction, startDate, limitDays, altitude);
  },
  
  getEquator(body, date, observer) {
    return AstroEngines.swissEphemeris.isLoaded 
      ? AstroEngines.swissEphemeris.getEquator(body, date, observer)
      : AstroEngines.astronomyEngine.getEquator(body, date, observer);
  },
  
  getHorizon(date, observer, ra, dec) {
    return AstroEngines.astronomyEngine.getHorizon(date, observer, ra, dec);
  },
  
  getDeltaT(date) {
    // We don't have direct Î”T values, but the eclipse times incorporate it
    return AstroEngines.swissEphemeris.isLoaded 
      ? AstroEngines.swissEphemeris.getDeltaT(date)
      : AstroEngines.astronomyEngine.getDeltaT(date);
  },
  
  createObserver(lat, lon, elevation = 0) {
    return new Astronomy.Observer(lat, lon, elevation);
  },
  
  // Estimate Î”T uncertainty in hours based on year
  // Since we use NASA eclipse anchors for calibration, uncertainty is reduced
  // compared to raw Î”T models. These values represent residual uncertainty.
  // Reference: https://eclipse.gsfc.nasa.gov/SEcat5/uncertainty.html
  getDeltaTUncertainty(year) {
    // Modern dates (1600-2100): uncertainty is negligible
    if (year >= 1600 && year <= 2100) {
      return 0;
    }
    
    // For ancient dates, uncertainty grows but our hybrid calibration helps
    // These are practical estimates for when day-boundary could be affected:
    // - 500 BC: ~0.5 hours
    // - 1000 BC: ~1 hour
    // - 2000 BC: ~2 hours
    // - 3000 BC: ~3-4 hours
    const yearsFromPresent = Math.abs(year - 2000);
    
    if (yearsFromPresent <= 500) return 0.25;
    if (yearsFromPresent <= 1000) return 0.5;
    if (yearsFromPresent <= 1500) return 1;
    if (yearsFromPresent <= 2000) return 1.5;
    if (yearsFromPresent <= 2500) return 2;
    if (yearsFromPresent <= 3000) return 2.5;
    if (yearsFromPresent <= 4000) return 3;
    if (yearsFromPresent <= 5000) return 4;
    return 6; // Very ancient dates
  }
};

// ============================================================================
// ENGINE MANAGEMENT FUNCTIONS
// ============================================================================

function getAstroEngine() {
  if (!activeAstroEngine) {
    activeAstroEngine = AstroEngines.astronomyEngine;
  }
  return activeAstroEngine;
}

async function setAstroEngine(engineId) {
  const engine = AstroEngines[engineId];
  if (!engine) {
    console.error(`Unknown astronomy engine: ${engineId}`);
    return false;
  }
  
  // If engine needs async loading, do it
  if (engine.load && !engine.isLoaded) {
    const loaded = await engine.load();
    if (!loaded) {
      console.error(`Failed to load engine: ${engineId}`);
      return false;
    }
  }
  
  activeAstroEngine = engine;
  state.astronomyEngine = engineId;
  saveState();
  
  // Update UI
  updateAstroEngineUI();
  
  return true;
}

function updateAstroEngineUI() {
  const engine = getAstroEngine();
  
  // Update engine info display
  const nameEl = document.getElementById('astro-engine-name');
  const deltaEl = document.getElementById('astro-engine-delta');
  
  if (nameEl) nameEl.textContent = `${engine.name} v${engine.version}`;
  if (deltaEl) deltaEl.textContent = engine.deltaTModel;
  
  // Update button states
  document.querySelectorAll('.astro-engine-btn').forEach(btn => {
    btn.classList.toggle('selected', btn.dataset.engine === state.astronomyEngine);
  });
}

// UI handler for selecting astronomy engine (currently disabled - Swiss Ephemeris requires self-hosting)
// The abstraction layer is in place for future engine support
function selectAstroEngine(engineId) {
  if (engineId !== 'astronomyEngine') {
    console.log('Swiss Ephemeris WASM requires self-hosting. Using astronomy-engine.');
  }
}

// Initialize astronomy engine - Hybrid approach combines Swiss Ephemeris precision with NASA eclipse calibration
async function initializeAstroEngine() {
  // Load Swiss Ephemeris for precise calculations
  let sweLoaded = false;
  try {
    sweLoaded = await AstroEngines.swissEphemeris.load();
  } catch (err) {
    console.warn('Swiss Ephemeris not available:', err.message);
  }
  
  // Load NASA Eclipse data for Î”T calibration
  let nasaLoaded = false;
  try {
    nasaLoaded = await AstroEngines.nasaEclipse.load();
  } catch (err) {
    console.warn('NASA Eclipse data not available:', err.message);
  }
  
  // Choose the best available engine configuration
  if (nasaLoaded && sweLoaded) {
    // Best case: Hybrid mode - Swiss Ephemeris calibrated against NASA eclipses
    activeAstroEngine = AstroEngines.nasaEclipse;
    state.astronomyEngine = 'nasaEclipse';
    console.log('Using Hybrid mode: Swiss Ephemeris + NASA Eclipse calibration');
    console.log('  - Modern dates (1600-2100): Swiss Ephemeris direct');
    console.log('  - Ancient dates: Swiss Ephemeris with NASA Î”T correction');
  } else if (nasaLoaded) {
    // NASA data but no Swiss Eph - use interpolation fallback
    activeAstroEngine = AstroEngines.nasaEclipse;
    state.astronomyEngine = 'nasaEclipse';
    console.log('Using NASA Eclipse interpolation (Swiss Ephemeris not available)');
  } else if (sweLoaded) {
    // Swiss Eph but no NASA data - use Swiss Eph alone
    activeAstroEngine = AstroEngines.swissEphemeris;
    state.astronomyEngine = 'swissEphemeris';
    console.log('Using Swiss Ephemeris (no NASA calibration)');
  } else {
    // Fallback to astronomy-engine
    activeAstroEngine = AstroEngines.astronomyEngine;
    state.astronomyEngine = 'astronomyEngine';
    console.log('Using astronomy-engine for calculations');
  }
  
  updateAstroEngineUI();
}

// Make these available globally
window.AstroEngines = AstroEngines;
window.getAstroEngine = getAstroEngine;
window.setAstroEngine = setAstroEngine;
window.updateAstroEngineUI = updateAstroEngineUI;
window.selectAstroEngine = selectAstroEngine;
window.initializeAstroEngine = initializeAstroEngine;

const MONTH_NAMES = [
  '1st Month', '2nd Month', '3rd Month', '4th Month', '5th Month', '6th Month',
  '7th Month', '8th Month', '9th Month', '10th Month', '11th Month', '12th Month', '13th Month'
];

// Shofar SVG icon for Renewed Moon - larger and more distinct
const SHOFAR_ICON = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 20" width="1.4em" height="1.2em" style="vertical-align:middle"><path fill="#A67C00" stroke="#5C4300" stroke-width="1" d="M21 3c-1 0-2 .5-3 1.2c-1.5 1-3 2.5-4 4.3c-1 1.8-2 3.5-3.5 5c-1.5 1.5-3.5 2.5-6 2.5c-1.5 0-2.5 1-2.5 2s1 2 2.5 2c2 0 4-.5 5.5-1.5c1.5-1 3-2.5 4-4c1-1.5 2-3 3-4.5c1-1.5 2-2.5 3-3c.8-.4 1.5-1 1.5-2S22 3 21 3z"/><circle fill="#5C4300" cx="4" cy="17" r="1.2"/></svg>';

// Order matters: single-day feasts should come AFTER multi-day feasts so they take priority
// Order matters for overlapping feasts: specific single-day feasts listed AFTER multi-day feasts take priority
const FEASTS = [
  // Renewed Moon Day - first day of every month (first light after full moon when waning moon is 12Â°+ above western horizon)
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 1, day: 1, description: 'First light after full moon â€” waning moon 12Â°+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 2, day: 1, description: 'First light after full moon â€” waning moon 12Â°+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 3, day: 1, description: 'First light after full moon â€” waning moon 12Â°+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 4, day: 1, description: 'First light after full moon â€” waning moon 12Â°+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 5, day: 1, description: 'First light after full moon â€” waning moon 12Â°+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 6, day: 1, description: 'First light after full moon â€” waning moon 12Â°+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 7, day: 1, description: 'First light after full moon â€” waning moon 12Â°+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 8, day: 1, description: 'First light after full moon â€” waning moon 12Â°+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 9, day: 1, description: 'First light after full moon â€” waning moon 12Â°+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 10, day: 1, description: 'First light after full moon â€” waning moon 12Â°+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 11, day: 1, description: 'First light after full moon â€” waning moon 12Â°+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 12, day: 1, description: 'First light after full moon â€” waning moon 12Â°+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 13, day: 1, description: 'First light after full moon â€” waning moon 12Â°+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  // Specific feasts
  { name: 'Last Supper', shortName: 'Last Supper', icon: 'ðŸžðŸ·', month: 1, day: 13, description: 'The Last Supper - bread and wine', chapter: '/chapters/18-appointed-times/#passover' },
  { name: 'Passover', shortName: 'Passover', icon: 'ðŸ‘â€ ', month: 1, day: 14, description: 'Lamb slain at twilight', chapter: '/chapters/18-appointed-times/#passover' },
  { name: 'Unleavened Bread', shortName: 'Unleavened', icon: 'ðŸ«“', month: 1, day: 15, endDay: 21, description: 'High Sabbath, no leaven for 7 days', chapter: '/chapters/18-appointed-times/#unleavened-bread' },
  { name: 'First Fruits', shortName: 'First Fruits', icon: 'ðŸŒ¾', month: 1, day: 16, description: 'Wave sheaf offering (also Unleavened 2)', chapter: '/chapters/18-appointed-times/#first-fruits-of-barley' },
  { name: 'Atzeret of Unleavened', shortName: 'Atzeret', icon: 'ðŸ•', month: 1, day: 21, description: 'Solemn assembly - 7th day of Unleavened Bread', chapter: '/chapters/18-appointed-times/#unleavened-bread' },
  { name: 'Shavuot', shortName: 'Shavuot', icon: 'ðŸŒ¾', month: 3, day: 16, description: '7 complete weeks after First Fruits', chapter: '/chapters/18-appointed-times/#shavuot---first-fruits-of-wheat' },
  { name: 'Trumpets', shortName: 'Trumpets', icon: 'ðŸŽº', month: 7, day: 1, description: 'Day of shouting/blowing', chapter: '/chapters/18-appointed-times/#trumpets---first-fruits-of-oil' },
  { name: 'Atonement', shortName: 'Atonement', icon: 'ðŸ©¸', month: 7, day: 10, description: 'Yom Kippur - day of fasting', chapter: '/chapters/18-appointed-times/#day-of-atonement' },
  { name: 'Tabernacles', shortName: 'Tabernacles', icon: 'â›º', month: 7, day: 15, endDay: 21, description: 'Feast of Booths', chapter: '/chapters/18-appointed-times/#tabernacles' },
  { name: 'Atzeret', shortName: 'Atzeret', icon: 'ðŸ•', month: 7, day: 22, description: 'Shemini Atzeret - Last Great Day', chapter: '/chapters/18-appointed-times/#atzeret---last-great-day' },
  { name: 'Hanukkah', shortName: 'Hanukkah', icon: 'ðŸ•Ž', month: 9, day: 25, endDay: 30, description: 'Festival of Dedication (8 days)', chapter: '/chapters/18-appointed-times/#hanukkah', continuesNextMonth: true },
  { name: 'Hanukkah', shortName: 'Hanukkah', icon: 'ðŸ•Ž', month: 10, day: 1, endDay: 2, description: 'Festival of Dedication (continued)', chapter: '/chapters/18-appointed-times/#hanukkah', startDayNum: 7 },
  { name: 'Atzeret of Hanukkah', shortName: 'Atzeret', icon: 'ðŸ•', month: 10, day: 2, description: 'Atzeret - 8th day of Hanukkah', chapter: '/chapters/18-appointed-times/#hanukkah' },
  { name: 'Purim', shortName: 'Purim', icon: 'ðŸ“œ', month: 12, day: 14, endDay: 15, description: 'Feast of Lots - deliverance from Haman', chapter: '/chapters/18-appointed-times/#purim' }
];

const SCRIPTURES = [
  { text: "It shall be established forever like the moon, even like the trustworthy witness in the sky.", ref: "Psalms 89:37" },
  { text: "He appointed the moon for seasons; the sun knows its going down.", ref: "Psalms 104:19" },
  { text: "And God said, Let there be lights in the firmament... for signs, and for seasons, and for days, and years.", ref: "Genesis 1:14" },
  { text: "Blow the trumpet at the new moon, at the full moon, on our feast day.", ref: "Psalms 81:3" }
];

// Central state object with defaults
const defaultState = {
  year: new Date().getFullYear(),
  lat: 31.7683,
  lon: 35.2137,
  city: '31.7683,35.2137', // Store the city select value directly
  moonPhase: 'full',
  dayStartTime: 'morning',  // 'evening' or 'morning'
  dayStartAngle: 12,        // 0, 6, 12, or 18 degrees below horizon
  yearStartRule: 'equinox', // 'equinox', '13daysBefore', or 'virgoFeet'
  crescentThreshold: 18,    // Hours after conjunction for crescent visibility (12, 15.5, 18, or 24)
  sabbathMode: 'lunar',     // 'lunar', 'saturday', 'sunday', 'friday', 'none'
  selectedProfile: 'timeTested', // Currently selected profile ID
  astronomyEngine: 'astronomyEngine', // 'astronomyEngine' or 'swissEphemeris'
  lunarMonths: [],
  currentMonthIndex: 0,
  highlightedLunarDay: 1,  // Default to day 1
  selectedTimestamp: null,  // UTC timestamp of selected moment
  pendingNavigationDate: null,  // Used when switching profiles to navigate to same Gregorian date
  viewTime: null  // Custom view time (null = use current time)
};

// Migrate old crescentThreshold values (degrees) to new format (hours)
// Old format: 5, 8, 10, 12 degrees
// New format: 12, 15.5, 18, 24 hours
function migrateCrescentThreshold(value) {
  if (value === undefined) return 18; // Default
  // Valid new values
  if (value === 12 || value === 15.5 || value === 18 || value === 24) return value;
  // Old values that need migration - default to 18h
  if (value === 5 || value === 8 || value === 10) return 18;
  // Unknown value, use default
  return 18;
}

// Load saved state from localStorage or use defaults
function loadState() {
  const saved = localStorage.getItem('lunarCalendarState');
  if (saved) {
    try {
      const parsed = JSON.parse(saved);
      return {
        ...defaultState,
        year: parsed.year || defaultState.year,
        lat: parsed.lat || defaultState.lat,
        lon: parsed.lon || defaultState.lon,
        city: parsed.city || '',
        moonPhase: parsed.moonPhase || defaultState.moonPhase,
        dayStartTime: parsed.dayStartTime || defaultState.dayStartTime,
        dayStartAngle: parsed.dayStartAngle !== undefined ? parsed.dayStartAngle : defaultState.dayStartAngle,
        yearStartRule: parsed.yearStartRule || defaultState.yearStartRule,
        crescentThreshold: migrateCrescentThreshold(parsed.crescentThreshold),
        sabbathMode: parsed.sabbathMode || defaultState.sabbathMode,
        selectedProfile: parsed.selectedProfile || defaultState.selectedProfile
        // astronomyEngine is always 'astronomyEngine' for now (Swiss Ephemeris requires self-hosting)
      };
    } catch (e) {
      return { ...defaultState };
    }
  }
  return { ...defaultState };
}

// ============================================================================
// WORLD CLOCK - Profile + Location combinations for comparison
// ============================================================================

// Get default world clock entries (stable - not dependent on current navigation state)
function getDefaultWorldClockEntries() {
  const entries = [];
  const seen = new Set();
  
  // Helper to add unique entries
  const addEntry = (profileId, locationSlug, locationName) => {
    const key = `${profileId}:${locationSlug}`;
    if (seen.has(key)) return;
    seen.add(key);
    entries.push({ profileId, locationSlug, locationName });
  };
  
  // User's saved GPS location (from localStorage) - stable across navigation
  const savedLoc = getSavedUserLocation();
  if (savedLoc) {
    const savedSlug = getClosestCitySlug(savedLoc.lat, savedLoc.lon, Infinity) || 'jerusalem';
    const savedName = savedLoc.city || formatCitySlug(savedSlug);
    // Add Time-Tested at user's location first
    addEntry('timeTested', savedSlug, savedName);
  }
  
  // All presets in Jerusalem
  for (const [profileId, profile] of Object.entries(PRESET_PROFILES)) {
    addEntry(profileId, 'jerusalem', 'Jerusalem');
  }
  
  return entries;
}

// Load world clock entries from localStorage
function loadWorldClockEntries() {
  try {
    const saved = localStorage.getItem('worldClockEntries');
    if (saved) {
      return JSON.parse(saved);
    }
  } catch (e) {
    console.error('Error loading world clock entries:', e);
  }
  return null;  // null means use defaults
}

// Save world clock entries to localStorage
function saveWorldClockEntries(entries) {
  try {
    localStorage.setItem('worldClockEntries', JSON.stringify(entries));
  } catch (e) {
    console.error('Error saving world clock entries:', e);
  }
}

// Get current world clock entries (saved or defaults)
// Once defaults are generated, they're saved to keep the list stable
function getWorldClockEntries() {
  let entries = loadWorldClockEntries();
  if (!entries) {
    entries = getDefaultWorldClockEntries();
    saveWorldClockEntries(entries);  // Save so list stays stable
  }
  return entries;
}

// Add a world clock entry
function addWorldClockEntry(profileId, locationSlug, locationName) {
  const entries = getWorldClockEntries();
  const key = `${profileId}:${locationSlug}`;
  
  // Check for duplicates
  const exists = entries.some(e => `${e.profileId}:${e.locationSlug}` === key);
  if (exists) return false;
  
  entries.push({ profileId, locationSlug, locationName });
  saveWorldClockEntries(entries);
  return true;
}

// Remove a world clock entry
function removeWorldClockEntry(index) {
  const entries = getWorldClockEntries();
  if (index >= 0 && index < entries.length) {
    entries.splice(index, 1);
    saveWorldClockEntries(entries);
    return true;
  }
  return false;
}

// Reset world clock to defaults
function resetWorldClockEntries() {
  localStorage.removeItem('worldClockEntries');
}

// Format city slug for display
function formatCitySlug(slug) {
  return slug.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
}

// ============================================================================
// VIEW TIME - Current time being viewed (for "This Moment" comparisons)
// ============================================================================

let viewTimeInterval = null;

// Get the current view time - returns UTC timestamp
function getViewTime() {
  if (!state.viewTime) {
    return new Date();  // Current UTC time
  }
  return new Date(state.viewTime);
}

// Get current local time at the set location
function getLocalTimeAtCurrentLocation() {
  const now = new Date();
  const tzOffsetHours = Math.round(state.lon / 15);
  const localMs = now.getTime() + (tzOffsetHours * 60 * 60 * 1000);
  return new Date(localMs);
}

// Start live time updates - DISABLED: time only updates on explicit user action
function startLiveTimeUpdates() {
  // No longer auto-update - time is set once and stays until user changes it
  // User must explicitly click "Use Current Time" to update to now
}

// ============================================================================
// ABOUT MODAL
// ============================================================================

function showAboutModal() {
  const overlay = document.getElementById('about-modal-overlay');
  if (overlay) {
    overlay.classList.add('visible');
  }
}

function closeAboutModal(event) {
  // If called from overlay click, only close if clicking the overlay itself
  if (event && event.target !== event.currentTarget) return;
  
  const overlay = document.getElementById('about-modal-overlay');
  
  // Always mark as shown so it only appears once
  localStorage.setItem('hideAboutModal', 'true');
  
  if (overlay) {
    overlay.classList.remove('visible');
  }
  
  // If URL is /about, navigate back to calendar
  if (window.location.pathname === '/about' || window.location.pathname === '/about/') {
    updateURL();
  }
}

function shouldShowAboutModal() {
  return localStorage.getItem('hideAboutModal') !== 'true';
}

function resetAboutModal() {
  localStorage.removeItem('hideAboutModal');
}

// ============================================================================
// PWA INSTALL FUNCTIONALITY
// ============================================================================

let deferredInstallPrompt = null;

// Check if running as installed PWA
function isInstalledPWA() {
  return window.matchMedia('(display-mode: standalone)').matches ||
         window.navigator.standalone === true;
}

// Check if iOS
function isIOS() {
  return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
}

// Initialize install button visibility
function initInstallButton() {
  const installBtn = document.getElementById('install-app-btn');
  if (!installBtn) return;
  
  // Don't show if already installed
  if (isInstalledPWA()) {
    installBtn.style.display = 'none';
    return;
  }
  
  // On iOS, always show (since no beforeinstallprompt)
  if (isIOS()) {
    installBtn.style.display = '';
    return;
  }
  
  // On other platforms, wait for beforeinstallprompt event
  // Button stays hidden until event fires
}

// Listen for the beforeinstallprompt event
window.addEventListener('beforeinstallprompt', (e) => {
  // Prevent the mini-infobar from appearing on mobile
  e.preventDefault();
  // Stash the event so it can be triggered later
  deferredInstallPrompt = e;
  // Show the install button
  const installBtn = document.getElementById('install-app-btn');
  if (installBtn) {
    installBtn.style.display = '';
  }
});

// Listen for successful install
window.addEventListener('appinstalled', () => {
  // Hide the install button
  const installBtn = document.getElementById('install-app-btn');
  if (installBtn) {
    installBtn.style.display = 'none';
  }
  deferredInstallPrompt = null;
  console.log('PWA was installed');
});

// Handle install button click
async function handleInstallClick() {
  // Close the menu
  const menu = document.getElementById('nav-menu');
  const overlay = document.getElementById('nav-menu-overlay');
  if (menu.classList.contains('open')) {
    menu.classList.remove('open');
    overlay.classList.remove('open');
  }
  
  // iOS - show instructions modal
  if (isIOS()) {
    showIOSInstallModal();
    return;
  }
  
  // Other platforms - use the deferred prompt
  if (!deferredInstallPrompt) {
    // Fallback: show generic instructions or the prompt wasn't available
    console.log('Install prompt not available');
    return;
  }
  
  // Show the install prompt
  deferredInstallPrompt.prompt();
  
  // Wait for the user's response
  const { outcome } = await deferredInstallPrompt.userChoice;
  console.log(`User response to install prompt: ${outcome}`);
  
  // Clear the deferred prompt - it can only be used once
  deferredInstallPrompt = null;
  
  // Hide the install button if accepted
  if (outcome === 'accepted') {
    const installBtn = document.getElementById('install-app-btn');
    if (installBtn) {
      installBtn.style.display = 'none';
    }
  }
}

// iOS install modal functions
function showIOSInstallModal() {
  const overlay = document.getElementById('ios-install-overlay');
  if (overlay) {
    overlay.classList.add('visible');
  }
}

function closeIOSInstallModal(event) {
  if (event && event.target !== event.currentTarget) return;
  const overlay = document.getElementById('ios-install-overlay');
  if (overlay) {
    overlay.classList.remove('visible');
  }
}

// Update the time display in the header (shows local time at current location)
function updateTimeDisplay() {
  const timeDisplay = document.getElementById('header-time-display');
  if (!timeDisplay) return;
  
  // Get local time at the current location
  const localTime = getLocalTimeForLocation(state.lat, state.lon);
  timeDisplay.innerHTML = `<span>${localTime}</span><span class="dropdown-arrow">â–¼</span>`;
}

// Show time picker modal
function showTimePicker() {
  let modal = document.getElementById('time-picker-modal');
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'time-picker-modal';
    modal.className = 'time-picker-modal';
    modal.innerHTML = `
      <div class="time-picker-content">
        <div class="time-picker-header">
          <h3>Set Date Time</h3>
          <button class="close-btn" onclick="hideTimePicker()">Ã—</button>
        </div>
        <div class="time-picker-form">
          <div class="time-picker-row">
            <label>Date:</label>
            <input type="date" id="time-picker-date">
          </div>
          <div class="time-picker-row">
            <label id="time-picker-time-label">Time:</label>
            <input type="time" id="time-picker-time">
          </div>
          <div class="time-picker-buttons">
            <button class="btn secondary" onclick="setTimeToNowInPicker()">Set to Now</button>
            <button class="btn primary" onclick="applyTimePickerAndClose()">Apply</button>
          </div>
        </div>
      </div>
    `;
    document.body.appendChild(modal);
  }
  
  // Pre-fill with currently selected calendar date and view time
  // Get the date from the currently highlighted day in the calendar
  const monthData = state.lunarMonths?.[state.currentMonthIndex];
  const dayData = monthData?.days?.find(d => d.lunarDay === state.highlightedLunarDay);
  
  let displayDate;
  if (dayData?.gregorianDate) {
    // Use the gregorian date of the highlighted day
    displayDate = new Date(dayData.gregorianDate);
  } else {
    // Fallback to view time
    displayDate = getViewTime();
  }
  
  // Get time component from view time (or current time if live)
  const viewTime = getViewTime();
  const tzOffsetHours = Math.round(state.lon / 15);
  const localTimeMs = viewTime.getTime() + (tzOffsetHours * 60 * 60 * 1000);
  const localTime = new Date(localTimeMs);
  
  // Update the time label to show the current location
  const locationName = getCurrentLocationName();
  const timeLabel = document.getElementById('time-picker-time-label');
  if (timeLabel) {
    timeLabel.textContent = `${locationName} Time:`;
  }
  
  // Format date as YYYY-MM-DD
  const year = displayDate.getFullYear();
  const month = String(displayDate.getMonth() + 1).padStart(2, '0');
  const day = String(displayDate.getDate()).padStart(2, '0');
  document.getElementById('time-picker-date').value = `${year}-${month}-${day}`;
  
  // Format time as HH:MM (from view time converted to local)
  const hours = String(localTime.getUTCHours()).padStart(2, '0');
  const minutes = String(localTime.getUTCMinutes()).padStart(2, '0');
  document.getElementById('time-picker-time').value = `${hours}:${minutes}`;
  
  modal.style.display = 'flex';
}

// Hide time picker
function hideTimePicker() {
  const modal = document.getElementById('time-picker-modal');
  if (modal) modal.style.display = 'none';
}

// Update the picker inputs to show current date/time (doesn't change state)
function setTimeToNowInPicker() {
  const now = new Date();
  const tzOffsetHours = Math.round(state.lon / 15);
  const localMs = now.getTime() + (tzOffsetHours * 60 * 60 * 1000);
  const localDate = new Date(localMs);
  
  // Format date as YYYY-MM-DD
  const year = localDate.getUTCFullYear();
  const month = String(localDate.getUTCMonth() + 1).padStart(2, '0');
  const day = String(localDate.getUTCDate()).padStart(2, '0');
  document.getElementById('time-picker-date').value = `${year}-${month}-${day}`;
  
  // Format time as HH:MM
  const hours = String(localDate.getUTCHours()).padStart(2, '0');
  const minutes = String(localDate.getUTCMinutes()).padStart(2, '0');
  document.getElementById('time-picker-time').value = `${hours}:${minutes}`;
}

// Apply the picker values to state and close the dialog
function applyTimePickerAndClose() {
  const dateVal = document.getElementById('time-picker-date').value;
  const timeVal = document.getElementById('time-picker-time').value;
  
  if (dateVal && timeVal) {
    // Parse as local time at current location
    const [year, month, day] = dateVal.split('-').map(Number);
    const [hours, minutes] = timeVal.split(':').map(Number);
    const localMs = Date.UTC(year, month - 1, day, hours, minutes, 0);
    
    // Convert from location's local time back to UTC
    const tzOffsetHours = Math.round(state.lon / 15);
    const utcMs = localMs - (tzOffsetHours * 60 * 60 * 1000);
    
    state.viewTime = utcMs;
    
    // Navigate to the selected date
    navigateToTimestamp(utcMs, year, month - 1, day);
    updateTimeDisplay();
  }
  
  hideTimePicker();
}

// Navigate calendar to a specific timestamp (UTC)
function navigateToTimestamp(utcTimestamp, targetYear, targetMonth, targetDay) {
  // Determine which lunar year this date belongs to
  const springEquinox = getAstroEngine().getSeasons(targetYear).mar_equinox.date;
  const lunarYear = utcTimestamp < springEquinox.getTime() ? targetYear - 1 : targetYear;
  
  // Update state year
  state.year = lunarYear;
  
  // Update UI
  updateUI();
  
  // Generate calendar for this lunar year
  generateCalendar();
  
  // Find the target date in the generated months
  for (let m = 0; m < state.lunarMonths.length; m++) {
    const month = state.lunarMonths[m];
    for (let d = 0; d < month.days.length; d++) {
      const day = month.days[d];
      const gd = day.gregorianDate;
      if (gd.getFullYear() === targetYear && 
          gd.getMonth() === targetMonth && 
          gd.getDate() === targetDay) {
        state.currentMonthIndex = m;
        state.highlightedLunarDay = day.lunarDay;
        renderMonth(state.lunarMonths[state.currentMonthIndex]);
        updateURL();
        return;
      }
    }
  }
  
  // If not found, just render the first month
  state.currentMonthIndex = 0;
  state.highlightedLunarDay = 1;
  if (state.lunarMonths.length > 0) {
    renderMonth(state.lunarMonths[0]);
  }
  updateURL();
}

// Get current UTC time
function getCurrentUTCTime() {
  return new Date();
}

// Get local time string for a location based on longitude
function getLocalTimeForLocation(lat, lon) {
  const viewTime = getViewTime();
  // Approximate timezone from longitude (1 hour per 15 degrees)
  const tzOffsetHours = Math.round(lon / 15);
  // Convert UTC time to local time at that longitude
  const utcMs = viewTime.getTime();
  const localMs = utcMs + (tzOffsetHours * 60 * 60 * 1000);
  const localDate = new Date(localMs);
  // Format as HH:MM using UTC methods since we already adjusted
  const hours = localDate.getUTCHours();
  const minutes = localDate.getUTCMinutes();
  const ampm = hours >= 12 ? 'PM' : 'AM';
  const h12 = hours % 12 || 12;
  return `${h12}:${minutes.toString().padStart(2, '0')} ${ampm}`;
}

// Navigate to a world clock entry
function navigateToWorldClockEntry(profileId, locationSlug) {
  const profile = PROFILES[profileId] || PRESET_PROFILES[profileId];
  const coords = CITY_SLUGS[locationSlug];
  if (!profile || !coords) return;
  
  // Apply profile
  state.moonPhase = profile.moonPhase;
  state.dayStartTime = profile.dayStartTime;
  state.dayStartAngle = profile.dayStartAngle;
  state.yearStartRule = profile.yearStartRule;
  state.crescentThreshold = profile.crescentThreshold ?? 18;
  state.sabbathMode = profile.sabbathMode;
  state.selectedProfile = profileId;
  
  // Apply location
  state.lat = coords.lat;
  state.lon = coords.lon;
  
  // Regenerate and navigate
  saveState();
  regenerateCalendarPreservingScroll();
}

// Remove world clock entry and refresh the UI
function removeWorldClockEntryAndRefresh(index) {
  removeWorldClockEntry(index);
  refreshDayDetailIfVisible();
}

// ============================================================================
// UNIFIED LOCATION PICKER - Used for header location and World Clock
// ============================================================================

// Current picker mode and callback
let locationPickerMode = 'header';  // 'header' or 'worldclock'
let locationPickerCallback = null;

// Open location picker for header (changes current location)
function openLocationPickerForHeader() {
  locationPickerMode = 'header';
  locationPickerCallback = null;  // Changes applied during preview
  showUnifiedLocationPicker('Select Location', false);
}

// Open location picker for World Clock (adds new entry)
function openLocationPickerForWorldClock() {
  locationPickerMode = 'worldclock';
  locationPickerCallback = (locationSlug, locationName, coords, profileId) => {
    if (addWorldClockEntry(profileId, locationSlug, locationName)) {
      refreshDayDetailIfVisible();
    } else {
      alert('This calendar is already in your list.');
    }
  };
  showUnifiedLocationPicker('Add Calendar', true);
}

// Show the unified location picker
function showUnifiedLocationPicker(title, showProfileSelect) {
  const picker = document.getElementById('city-picker');
  const overlay = document.getElementById('city-picker-overlay');
  const header = picker.querySelector('.city-picker-header h3');
  
  // Reset preview state
  previewedLocationSlug = null;
  previewedLocationCoords = null;
  
  // Update title
  if (header) header.textContent = title;
  
  // Show/hide profile selector
  let profileRow = document.getElementById('city-picker-profile-row');
  if (showProfileSelect) {
    if (!profileRow) {
      // Create profile selector row
      profileRow = document.createElement('div');
      profileRow.id = 'city-picker-profile-row';
      profileRow.className = 'city-picker-profile-row';
      profileRow.innerHTML = `
        <label>Profile:</label>
        <select id="city-picker-profile-select" class="city-picker-select"></select>
      `;
      const controls = picker.querySelector('.city-picker-controls');
      controls.parentNode.insertBefore(profileRow, controls);
    }
    profileRow.style.display = 'flex';
    populatePickerProfileSelect();
  } else if (profileRow) {
    profileRow.style.display = 'none';
  }
  
  // Show/hide confirm button for World Clock mode
  let confirmRow = document.getElementById('city-picker-confirm-row');
  if (showProfileSelect) {
    if (!confirmRow) {
      confirmRow = document.createElement('div');
      confirmRow.id = 'city-picker-confirm-row';
      confirmRow.className = 'city-picker-confirm-row';
      confirmRow.innerHTML = `
        <button class="btn secondary" onclick="toggleCityPicker()">Cancel</button>
        <button class="btn primary" onclick="confirmWorldClockAdd()">Add Calendar</button>
      `;
      picker.appendChild(confirmRow);
    }
    confirmRow.style.display = 'flex';
  } else if (confirmRow) {
    confirmRow.style.display = 'none';
  }
  
  picker.style.display = 'block';
  overlay.classList.add('visible');
  document.body.style.overflow = 'hidden';
  renderCityPickerMap();
  populateCityDropdown();
  updateCityPickerLocationName();
}

// Confirm adding a World Clock entry
function confirmWorldClockAdd() {
  // Use the previewed location, or current selection from dropdown
  let slug = previewedLocationSlug;
  let coords = previewedLocationCoords;
  
  if (!slug) {
    // Fallback to dropdown selection
    const select = document.getElementById('city-picker-select');
    slug = select ? select.value : null;
    coords = slug ? CITY_SLUGS[slug] : null;
  }
  
  if (!slug || !coords) {
    alert('Please select a location first.');
    return;
  }
  
  const locationName = formatCitySlug(slug);
  confirmLocationSelection(slug, locationName, coords);
}

// Populate profile select in the picker
function populatePickerProfileSelect() {
  const select = document.getElementById('city-picker-profile-select');
  if (!select) return;
  
  select.innerHTML = '';
  for (const [id, profile] of Object.entries(PROFILES)) {
    const opt = document.createElement('option');
    opt.value = id;
    opt.textContent = `${renderProfileIconText(profile)} ${profile.name}`;
    if (id === (state.selectedProfile || 'timeTested')) {
      opt.selected = true;
    }
    select.appendChild(opt);
  }
}

// Get currently selected profile in picker (for World Clock mode)
function getPickerSelectedProfile() {
  const select = document.getElementById('city-picker-profile-select');
  return select ? select.value : (state.selectedProfile || 'timeTested');
}

// Called when a location is confirmed in the picker
function confirmLocationSelection(locationSlug, locationName, coords) {
  if (locationPickerCallback) {
    const profileId = locationPickerMode === 'worldclock' ? getPickerSelectedProfile() : null;
    locationPickerCallback(locationSlug, locationName, coords, profileId);
  }
  toggleCityPicker();
}

// Show modal to add new world clock entry (now uses unified picker)
function showAddWorldClockModal() {
  openLocationPickerForWorldClock();
}

// Legacy function for compatibility
function hideAddWorldClockModal() {
  toggleCityPicker();
}

// Legacy function kept for old modal (no longer used but kept for safety)
function addWorldClockFromModal() {
  // Now handled by confirmLocationSelection
}

// Save settings to localStorage
function saveState() {
  const toSave = {
    year: state.year,
    lat: state.lat,
    lon: state.lon,
    city: state.city,
    moonPhase: state.moonPhase,
    dayStartTime: state.dayStartTime,
    dayStartAngle: state.dayStartAngle,
    yearStartRule: state.yearStartRule,
    crescentThreshold: state.crescentThreshold,
    sabbathMode: state.sabbathMode,
    selectedProfile: state.selectedProfile
    // astronomyEngine not saved - always uses astronomy-engine for now
  };
  localStorage.setItem('lunarCalendarState', JSON.stringify(toSave));
}

// Update URL with current calendar state for sharing (uses SEO-friendly paths)
function updateURL() {
  updatePathURL();
}

// Load state from URL (supports both path-based and legacy query params)
function loadFromURL() {
  // Parse the new path-based URL
  const urlState = parsePathURL();
  
  // Handle special views
  if (urlState.view === 'about') {
    showAboutModal();
    return;
  }
  
  if (urlState.view === 'sabbath-tester') {
    const sabbathTesterPage = document.getElementById('sabbath-tester-page');
    const calendarOutput = document.getElementById('calendar-output');
    const dayDetailPanel = document.getElementById('day-detail-panel');
    calendarOutput.style.display = 'none';
    dayDetailPanel.style.display = 'none';
    sabbathTesterPage.style.display = 'block';
    renderSabbathTester();
    return;
  }
  
  if (urlState.view === 'feasts') {
    toggleExportModal(true);
    return;
  }
  
  // Handle Gregorian date lookup - find lunar date and redirect
  if (urlState.view === 'gregorian-lookup') {
    handleGregorianLookup(urlState);
    return;
  }
  
  // Redirect pre-Gregorian dates to Julian URL
  if (urlState.view === 'redirect-to-julian') {
    const yearStr = formatYearForURL(urlState.gregorianYear);
    const month = urlState.gregorianMonth || 1;
    const day = urlState.gregorianDay || 1;
    window.location.replace(`/julian/${yearStr}/${month}/${day}/`);
    return;
  }
  
  // Handle Julian date lookup - convert to Gregorian internally
  if (urlState.view === 'julian-lookup') {
    handleJulianLookup(urlState);
    return;
  }
  
  // If URL needs redirect to canonical format, do it after calendar loads
  if (urlState.needsRedirect) {
    // Will redirect to canonical URL after initial load
    setTimeout(() => {
      const canonicalURL = buildPathURL();
      window.history.replaceState({}, '', canonicalURL);
    }, 100);
  }
  
  // Apply URL state to app state
  const { needsRegenerate, month, day, view } = applyURLState(urlState);
  
  // Regenerate if settings changed
  if (needsRegenerate) {
    updateUI();
    generateCalendar();
  }
  
  // Apply month after calendar generation
  if (month !== null && month !== undefined) {
    const monthIndex = month - 1; // Convert to 0-indexed
    if (monthIndex >= 0 && monthIndex < state.lunarMonths.length) {
      state.currentMonthIndex = monthIndex;
    }
  }
  
  // Apply day - default to 1 if not specified
  const effectiveDay = (day !== null && day !== undefined) ? day : 1;
  state.highlightedLunarDay = effectiveDay;
  const monthData = state.lunarMonths[state.currentMonthIndex];
  const dayObj = monthData?.days.find(d => d.lunarDay === effectiveDay);
  if (dayObj) {
    state.selectedTimestamp = getSunriseTimestamp(dayObj.gregorianDate);
    const gotoDate = document.getElementById('goto-date');
    if (gotoDate) gotoDate.value = formatLocalDatetime(state.selectedTimestamp);
    showDayDetail(dayObj, monthData);
  }
  
  // Re-render
  renderMonth(state.lunarMonths[state.currentMonthIndex]);
  updateMonthButtons();
}

const state = loadState();

// Track which profile is being edited in the settings page (separate from active calendar profile)
let editingProfileId = null;

// Update UI to reflect current state
function updateUI() {
  document.getElementById('year-input').value = state.year;
  // Show BC label only when needed (no AD suffix)
  const yearVal = state.year;
  if (yearVal <= 0) {
    document.getElementById('year-display').textContent = `(${Math.abs(yearVal - 1)} BC)`;
  } else {
    document.getElementById('year-display').textContent = '';  // No AD suffix for positive years
  }
  document.getElementById('feast-year').textContent = formatYear(state.year);
  document.getElementById('lat-input').value = state.lat;
  document.getElementById('lon-input').value = state.lon;
  document.getElementById('moon-phase-select').value = state.moonPhase;
  document.getElementById('city-select').value = state.city || '';
  
  // Update all button states
  updateMoonPhaseButtons();
  updateDayStartButtons();
  updateYearStartButtons();
  updateCrescentThresholdVisibility();
  updateCrescentThresholdButtons();
  updateProfileButtons();
  
  // Show/hide custom coordinates
  const customCoords = document.getElementById('custom-coords');
  if (customCoords) {
    customCoords.style.display = state.city === '' ? 'block' : 'none';
  }
}

// Navigation Menu Functions
function toggleNavMenu() {
  const overlay = document.getElementById('nav-menu-overlay');
  const menu = document.getElementById('nav-menu');
  
  if (menu.classList.contains('open')) {
    menu.classList.remove('open');
    overlay.classList.remove('open');
  } else {
    menu.classList.add('open');
    overlay.classList.add('open');
  }
}

function navigateTo(page) {
  // Close the menu if it's open (don't toggle)
  const menu = document.getElementById('nav-menu');
  const overlay = document.getElementById('nav-menu-overlay');
  if (menu.classList.contains('open')) {
    menu.classList.remove('open');
    overlay.classList.remove('open');
  }
  
  const calendarOutput = document.getElementById('calendar-output');
  const dayDetailPanel = document.getElementById('day-detail-panel');
  const settingsPage = document.getElementById('settings-page');
  const settingsOverlay = document.getElementById('settings-page-overlay');
  const exportPage = document.getElementById('export-page');
  const sabbathTesterPage = document.getElementById('sabbath-tester-page');
  
  // Hide all pages and reset body state
  document.documentElement.classList.remove('feasts-open');
  document.body.classList.remove('feasts-open');
  document.body.classList.remove('sabbath-tester-open');
  document.body.style.overflow = ''; // Restore scrolling
  
  // Close settings slide-in
  settingsPage.classList.remove('visible');
  settingsOverlay.classList.remove('visible');
  
  // Hide export page and sabbath tester
  exportPage.style.display = 'none';
  sabbathTesterPage.style.display = 'none';
  
  switch(page) {
    case 'calendar':
      calendarOutput.style.display = 'block';
      if (state.highlightedLunarDay !== null) {
        dayDetailPanel.classList.remove('hidden');
        dayDetailPanel.style.display = '';
        refreshDayDetailIfVisible();
      }
      updateURL();
      break;
    case 'feasts':
      document.documentElement.classList.add('feasts-open');
      document.body.classList.add('feasts-open');
      calendarOutput.style.display = 'none';
      dayDetailPanel.style.display = 'none';
      exportPage.style.display = 'block';
      exportPage.scrollTop = 0;
      updateExportTable();
      updateURLWithView('feasts');
      break;
    case 'settings':
      // Show calendar in background, open settings slide-in
      calendarOutput.style.display = 'block';
      if (state.highlightedLunarDay !== null) {
        dayDetailPanel.classList.remove('hidden');
        dayDetailPanel.style.display = '';
      }
      settingsPage.classList.add('visible');
      settingsOverlay.classList.add('visible');
      document.body.style.overflow = 'hidden'; // Prevent background scrolling
      updateSettingsPageState();
      settingsPage.scrollTop = 0;
      break;
    case 'sabbath-tester':
      calendarOutput.style.display = 'none';
      dayDetailPanel.style.display = 'none';
      sabbathTesterPage.style.display = 'block';
      sabbathTesterPage.scrollTop = 0;
      document.body.classList.add('sabbath-tester-open');
      renderSabbathTester();
      updateURLWithView('sabbath-tester');
      break;
    case 'about':
      // Show calendar in background, open about modal
      calendarOutput.style.display = 'block';
      if (state.highlightedLunarDay !== null) {
        dayDetailPanel.classList.remove('hidden');
        dayDetailPanel.style.display = '';
      }
      showAboutModal();
      updateURLWithView('about');
      break;
  }
}

function toggleSettings() {
  const settingsPage = document.getElementById('settings-page');
  const settingsOverlay = document.getElementById('settings-page-overlay');
  
  const isOpening = !settingsPage.classList.contains('visible');
  
  if (isOpening) {
    // Show settings slide-in
    settingsPage.classList.add('visible');
    settingsOverlay.classList.add('visible');
    document.body.style.overflow = 'hidden'; // Prevent background scrolling
    
    // Initialize editing profile to current active profile
    editingProfileId = state.selectedProfile || 'timeTested';
    
    // Update dropdown to show current profile
    const select = document.getElementById('profile-select');
    if (select) select.value = editingProfileId;
    
    // Update settings page state
    updateSettingsPageState();
    displayProfileSettings(editingProfileId);
  } else {
    // Hide settings slide-in
    settingsPage.classList.remove('visible');
    settingsOverlay.classList.remove('visible');
    document.body.style.overflow = ''; // Restore scrolling
    
    // Refresh day detail if visible
    refreshDayDetailIfVisible();
  }
}

// Open the location picker (for header - changes current location)
function openLocationPicker() {
  openLocationPickerForHeader();
}

// Profile Picker Functions
function toggleProfilePicker(event) {
  const picker = document.getElementById('profile-picker');
  const overlay = document.getElementById('profile-picker-overlay');
  
  if (picker.style.display === 'none') {
    // Position dropdown near the moon icon
    const moonIcon = document.querySelector('.full-moon-info');
    if (moonIcon) {
      const rect = moonIcon.getBoundingClientRect();
      picker.style.top = (rect.bottom + 8) + 'px';
      picker.style.left = Math.max(8, rect.left) + 'px';
      
      // Make sure it doesn't go off screen to the right
      const pickerWidth = 320;
      if (rect.left + pickerWidth > window.innerWidth) {
        picker.style.left = (window.innerWidth - pickerWidth - 8) + 'px';
      }
    }
    
    picker.style.display = 'block';
    overlay.classList.add('visible');
    populateProfilePicker();
  } else {
    picker.style.display = 'none';
    overlay.classList.remove('visible');
  }
}

function populateProfilePicker() {
  const list = document.getElementById('profile-picker-list');
  if (!list) return;
  
  const currentProfileId = getCurrentProfileId();
  
  let html = '';
  for (const [id, profile] of Object.entries(PROFILES)) {
    const isSelected = id === currentProfileId;
    // Generate hint from settings if not provided
    const hint = profile.hint || generateProfileHint(profile);
    html += `
      <div class="profile-option${isSelected ? ' selected' : ''}" onclick="selectProfile('${id}')">
        <div class="profile-option-icon">${renderProfileIcon(profile)}</div>
        <div class="profile-option-info">
          <div class="profile-option-name">${profile.name}</div>
          <div class="profile-option-hint">${hint}</div>
        </div>
        ${isSelected ? '<span style="color: #d4a017;">âœ“</span>' : ''}
      </div>
    `;
  }
  
  list.innerHTML = html;
}

// Generate a hint string from profile settings
function generateProfileHint(profile) {
  const parts = [];
  
  // Moon phase
  switch (profile.moonPhase) {
    case 'full': parts.push('Full Moon'); break;
    case 'dark': parts.push('Dark Moon'); break;
    case 'crescent': parts.push('Crescent Moon'); break;
  }
  
  // Day start
  if (profile.dayStartTime === 'evening') {
    parts.push(profile.dayStartAngle === 0 ? 'Sunset' : 'Evening');
  } else {
    parts.push(profile.dayStartAngle === 0 ? 'Sunrise' : 'Morning');
  }
  
  // Year start
  switch (profile.yearStartRule) {
    case 'virgoFeet': parts.push('Virgo Rule'); break;
    case '13daysBefore': parts.push('Passover Rule'); break;
  }
  
  // Sabbath
  switch (profile.sabbathMode) {
    case 'lunar': parts.push('Lunar Sabbath'); break;
    case 'saturday': parts.push('Saturday Sabbath'); break;
    case 'sunday': parts.push('Sunday Sabbath'); break;
    case 'friday': parts.push('Friday Sabbath'); break;
  }
  
  return parts.join(', ');
}

function getCurrentProfileId() {
  // First check if we have an explicitly selected profile that still exists
  if (state.selectedProfile && PROFILES[state.selectedProfile]) {
    return state.selectedProfile;
  }
  
  // Otherwise, check which profile matches current state settings
  for (const [id, profile] of Object.entries(PROFILES)) {
    if (state.moonPhase === profile.moonPhase &&
        state.dayStartTime === profile.dayStartTime &&
        state.dayStartAngle === profile.dayStartAngle &&
        state.yearStartRule === profile.yearStartRule &&
        state.sabbathMode === profile.sabbathMode &&
        (profile.moonPhase !== 'crescent' || state.crescentThreshold === profile.crescentThreshold)) {
      return id;
    }
  }
  return 'custom';
}

function selectProfile(profileId) {
  const profile = PROFILES[profileId];
  if (!profile) return;
  
  // Apply profile settings to state
  state.moonPhase = profile.moonPhase;
  state.dayStartTime = profile.dayStartTime;
  state.dayStartAngle = profile.dayStartAngle;
  state.yearStartRule = profile.yearStartRule;
  state.crescentThreshold = profile.crescentThreshold ?? 18;
  state.sabbathMode = profile.sabbathMode;
  state.selectedProfile = profileId;
  
  // Update the profile dropdown in settings page if it exists
  const select = document.getElementById('profile-select');
  if (select) {
    select.value = profileId;
  }
  
  // Close picker and regenerate
  toggleProfilePicker();
  saveState();
  regenerateCalendarPreservingScroll();
}

function toggleCityPicker() {
  const picker = document.getElementById('city-picker');
  const overlay = document.getElementById('city-picker-overlay');
  
  if (picker.style.display === 'none') {
    picker.style.display = 'block';
    overlay.classList.add('visible');
    document.body.style.overflow = 'hidden';
    renderCityPickerMap();
    populateCityDropdown();
    updateCityPickerLocationName();
  } else {
    picker.style.display = 'none';
    overlay.classList.remove('visible');
    document.body.style.overflow = '';
  }
}

function renderCityPickerMap() {
  const container = document.getElementById('city-picker-map');
  if (!container) return;
  
  // Get current moon event for the map visualization
  let moonEvent = new Date();
  if (state.lunarMonths && state.lunarMonths[state.currentMonthIndex]) {
    moonEvent = state.lunarMonths[state.currentMonthIndex].moonEvent;
  }
  
  container.innerHTML = renderDatelineVisualization(moonEvent);
  
  // Override the click handler on the map for city picker
  const map = container.querySelector('.dateline-map');
  if (map) {
    map.style.cursor = 'crosshair';
    // Remove inline onclick and set our handler
    map.removeAttribute('onclick');
    map.addEventListener('click', handleCityPickerMapClick);
  }
}

function handleCityPickerMapClick(event) {
  event.preventDefault();
  event.stopPropagation();
  
  const rect = event.currentTarget.getBoundingClientRect();
  const x = event.clientX - rect.left;
  const y = event.clientY - rect.top;
  
  // Convert click position to lat/lon
  const clickLon = (x / rect.width) * 360 - 180;
  const clickLat = 90 - (y / rect.height) * 180;
  
  // Snap to nearest city
  const nearestSlug = getClosestCitySlug(clickLat, clickLon, Infinity);
  if (nearestSlug && CITY_SLUGS[nearestSlug]) {
    const coords = CITY_SLUGS[nearestSlug];
    // Always preview - don't close dialog
    previewLocationSelection(nearestSlug, coords);
  }
}

// Track the currently previewed location for World Clock mode
let previewedLocationSlug = null;
let previewedLocationCoords = null;

function previewLocationSelection(slug, coords) {
  previewedLocationSlug = slug;
  previewedLocationCoords = coords;
  
  // Update the map marker to show preview
  state.lat = coords.lat;
  state.lon = coords.lon;
  renderCityPickerMap();
  updateCityPickerLocationName();
  updateCityDropdownSelection();
  
  // For header mode, apply changes immediately (but don't close dialog)
  if (locationPickerMode === 'header') {
    state.locationSource = 'url';
    regenerateCalendarPreservingScroll();
    const newURL = buildPathURL();
    window.history.replaceState({}, '', newURL);
    updateTimeDisplay();
  }
}

function updateCityDropdownSelection() {
  const select = document.getElementById('city-picker-select');
  if (!select) return;
  
  const lat = state.lat ?? 31.7683;
  const lon = state.lon ?? 35.2137;
  
  // Find closest city (no distance limit since we snap to cities)
  const currentSlug = getClosestCitySlug(lat, lon, Infinity);
  
  if (!currentSlug) {
    select.value = '';
    return;
  }
  
  // Check if option exists in dropdown
  let option = select.querySelector(`option[value="${currentSlug}"]`);
  
  if (!option && CITY_SLUGS[currentSlug]) {
    // City exists but not in dropdown - dynamically add it
    const displayName = currentSlug.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
    
    // Check if "Current Location" optgroup exists
    let currentLocGroup = select.querySelector('optgroup[label="Current Location"]');
    if (!currentLocGroup) {
      // Create new optgroup at the top (after the placeholder)
      currentLocGroup = document.createElement('optgroup');
      currentLocGroup.label = 'Current Location';
      select.insertBefore(currentLocGroup, select.firstChild.nextSibling);
    }
    
    // Clear old options in Current Location group and add new one
    currentLocGroup.innerHTML = `<option value="${currentSlug}">${displayName}</option>`;
    option = currentLocGroup.querySelector('option');
  }
  
  if (option) {
    select.value = currentSlug;
  }
}

// Curated list of main cities for dropdown (kept small and manageable)
const DROPDOWN_CITIES = {
  'Biblical': ['jerusalem', 'bethlehem', 'nazareth', 'jericho', 'hebron', 'ramses', 'goshen', 'wilderness-of-sin', 'cairo', 'alexandria', 'mt-sinai-saudi', 'mecca', 'medina'],
  'Middle East': ['tel-aviv', 'dubai', 'amman', 'baghdad', 'tehran', 'riyadh', 'istanbul', 'ankara', 'damascus', 'beirut'],
  'Americas': ['new-york', 'los-angeles', 'chicago', 'houston', 'phoenix', 'dallas', 'denver', 'miami', 'atlanta', 'seattle', 'boston', 'san-francisco', 'toronto', 'vancouver', 'mexico-city', 'sao-paulo', 'buenos-aires', 'lima', 'bogota'],
  'Europe': ['london', 'paris', 'berlin', 'rome', 'madrid', 'amsterdam', 'vienna', 'moscow', 'kiev', 'warsaw', 'athens', 'lisbon', 'dublin', 'stockholm', 'oslo', 'helsinki', 'zurich', 'brussels', 'prague', 'budapest'],
  'Asia': ['tokyo', 'beijing', 'shanghai', 'hong-kong', 'singapore', 'mumbai', 'delhi', 'bangalore', 'seoul', 'bangkok', 'jakarta', 'manila', 'kuala-lumpur', 'taipei', 'osaka', 'hanoi', 'karachi'],
  'Africa': ['johannesburg', 'lagos', 'nairobi', 'addis-ababa', 'casablanca', 'accra', 'dar-es-salaam', 'cape-town'],
  'Oceania': ['sydney', 'melbourne', 'brisbane', 'perth', 'auckland', 'wellington']
};

// Check if a city slug is in the curated dropdown list
function isInDropdownList(slug) {
  for (const cities of Object.values(DROPDOWN_CITIES)) {
    if (cities.includes(slug)) return true;
  }
  return false;
}

function populateCityDropdown() {
  const select = document.getElementById('city-picker-select');
  if (!select) return;
  
  // Find current city slug (no distance limit since we snap to cities)
  const currentSlug = getClosestCitySlug(state.lat ?? 31.7683, state.lon ?? 35.2137, Infinity);
  
  let html = '<option value="">-- Select a city --</option>';
  
  // If current location is a city not in the curated list, add it at the top
  if (currentSlug && CITY_SLUGS[currentSlug] && !isInDropdownList(currentSlug)) {
    const displayName = currentSlug.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
    html += `<optgroup label="Current Location">`;
    html += `<option value="${currentSlug}" selected>${displayName}</option>`;
    html += `</optgroup>`;
  }
  
  // Add curated cities by region
  for (const [region, cities] of Object.entries(DROPDOWN_CITIES)) {
    html += `<optgroup label="${region}">`;
    for (const slug of cities) {
      if (!CITY_SLUGS[slug]) continue;
      const displayName = slug.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
      const selected = slug === currentSlug ? ' selected' : '';
      html += `<option value="${slug}"${selected}>${displayName}</option>`;
    }
    html += '</optgroup>';
  }
  
  select.innerHTML = html;
}

function selectCityFromDropdown(slug) {
  if (!slug) return;
  
  const coords = CITY_SLUGS[slug];
  if (!coords) return;
  
  // Always preview - don't close dialog
  previewLocationSelection(slug, coords);
}

function useMyLocationFromPicker() {
  if (!navigator.geolocation) {
    alert('Geolocation is not supported by your browser');
    return;
  }
  
  // Show loading state
  const btn = document.querySelector('#city-picker .city-action-btn');
  const originalText = btn.textContent;
  btn.textContent = 'ðŸ“ Locating...';
  btn.disabled = true;
  
  navigator.geolocation.getCurrentPosition(
    (position) => {
      const gpsLat = position.coords.latitude;
      const gpsLon = position.coords.longitude;
      
      // Find nearest city to snap to
      const nearestSlug = getClosestCitySlug(gpsLat, gpsLon, Infinity);
      const coords = nearestSlug ? CITY_SLUGS[nearestSlug] : { lat: 31.7683, lon: 35.2137 };
      const locationName = nearestSlug ? formatCitySlug(nearestSlug) : 'Jerusalem';
      const slug = nearestSlug || 'jerusalem';
      
      // Save as user's default location
      saveUserLocation(coords.lat, coords.lon, locationName);
      
      // Reset button
      btn.textContent = originalText;
      btn.disabled = false;
      
      // Always preview - don't close dialog
      previewLocationSelection(slug, coords);
    },
    (error) => {
      btn.textContent = originalText;
      btn.disabled = false;
      console.warn('Geolocation failed:', error);
      alert('Could not get your location. Please select a city from the dropdown or click on the map.');
    },
    { enableHighAccuracy: true, timeout: 10000 }
  );
}

function updateCityPickerLocationName() {
  const nameSpan = document.getElementById('city-picker-location-name');
  if (nameSpan) {
    const name = getCurrentLocationName();
    const lat = state.lat ?? 31.7683;
    const lon = state.lon ?? 35.2137;
    const coordStr = `${lat.toFixed(2)}Â°${lat >= 0 ? 'N' : 'S'}, ${Math.abs(lon).toFixed(2)}Â°${lon >= 0 ? 'E' : 'W'}`;
    nameSpan.textContent = `${name} (${coordStr})`;
  }
}

function toggleExportModal(skipUrlUpdate = false) {
  const calendarOutput = document.getElementById('calendar-output');
  const dayDetailPanel = document.getElementById('day-detail-panel');
  const exportPage = document.getElementById('export-page');
  const settingsPage = document.getElementById('settings-page');
  const settingsOverlay = document.getElementById('settings-page-overlay');
  
  const isOpening = exportPage.style.display === 'none';
  
  if (isOpening) {
    // Hide calendar and settings, show export
    calendarOutput.style.display = 'none';
    dayDetailPanel.style.display = 'none';
    
    // Close settings slide-in if open
    settingsPage.classList.remove('visible');
    settingsOverlay.classList.remove('visible');
    document.body.style.overflow = ''; // Restore scrolling temporarily
    
    exportPage.style.display = 'block';
    
    // Scroll to top of page (with timeout to ensure DOM update)
    window.scrollTo(0, 0);
    document.documentElement.scrollTop = 0;
    document.body.scrollTop = 0;
    setTimeout(() => {
      window.scrollTo(0, 0);
      exportPage.scrollTop = 0;
    }, 0);
    
    // Update export table with current feast data
    updateExportTable();
    
    // Update URL with view=feasts
    if (!skipUrlUpdate) {
      updateURLWithView('feasts');
    }
  } else {
    // Show calendar, hide export
    calendarOutput.style.display = 'block';
    exportPage.style.display = 'none';
    
    // Reset day detail panel display and refresh if a day was selected
    dayDetailPanel.style.display = '';  // Reset inline style
    if (state.highlightedLunarDay !== null) {
      dayDetailPanel.classList.remove('hidden');
      refreshDayDetailIfVisible();
    }
    
    // Remove view parameter from URL
    if (!skipUrlUpdate) {
      updateURL();
    }
  }
}

function updateURLWithView(view) {
  let newURL;
  if (view === 'sabbath-tester') {
    newURL = '/sabbath-tester/';
  } else if (view === 'feasts') {
    // Build feasts URL with profile/year/location
    const profile = getCurrentProfileSlug();
    const location = getLocationSlug();
    newURL = `/feasts/${profile}/${state.year}/${location}/`;
  } else {
    // Calendar view - use standard path URL
    newURL = buildPathURL();
  }
  
  // Use pushState for navigation views so back button works
  window.history.pushState({ view: view }, '', newURL);
}

function updateExportTable() {
  // Update the year display
  document.getElementById('export-year').textContent = formatYear(state.year);
  
  // Update settings context
  const contextEl = document.getElementById('export-context-text');
  if (contextEl) {
    const moonLabel = getMoonLabel();
    const dayStartLabel = getDayStartLabel();
    const yearStartLabel = getYearStartLabel();
    
    // Get location name with coordinates
    const locationName = getCurrentLocationName();
    const coordStr = `${state.lat.toFixed(2)}Â°${state.lat >= 0 ? 'N' : 'S'}, ${Math.abs(state.lon).toFixed(2)}Â°${state.lon >= 0 ? 'E' : 'W'}`;
    // Show city name with coordinates, or just coordinates if it's a timezone region
    const locationLabel = !locationName.includes('/') 
      ? `${locationName} (${coordStr})`
      : coordStr;
    
    contextEl.innerHTML = `
      <span class="export-context-item">
        <span class="export-context-label">Month Start:</span>
        <span class="export-context-value">${moonLabel}</span>
      </span>
      <span class="export-context-item">
        <span class="export-context-label">Day Start:</span>
        <span class="export-context-value">${dayStartLabel}</span>
      </span>
      <span class="export-context-item">
        <span class="export-context-label">Year Start:</span>
        <span class="export-context-value">${yearStartLabel}</span>
      </span>
      <span class="export-context-item">
        <span class="export-context-label">Location:</span>
        <span class="export-context-value">${locationLabel}</span>
      </span>
    `;
  }
  
  // Copy the feast table content to the export modal
  const sourceTbody = document.getElementById('feast-tbody');
  const targetTbody = document.getElementById('export-feast-tbody');
  
  if (sourceTbody && targetTbody) {
    targetTbody.innerHTML = sourceTbody.innerHTML;
  }
}

function updateSettingsPageState() {
  // Update profile buttons
  updateProfileButtons();
  
  // Update moon phase buttons
  document.querySelectorAll('.settings-option-btn[data-phase]').forEach(btn => {
    btn.classList.toggle('selected', btn.dataset.phase === state.moonPhase);
  });
  
  // Update crescent threshold visibility and buttons
  updateCrescentThresholdVisibility();
  updateCrescentThresholdButtons();
  
  // Update day start buttons
  updateDayStartButtons();
  
  // Update year start buttons
  updateYearStartButtons();
  
  // Update sabbath buttons
  updateSabbathButtons();
  
  // Update city select - use the editing profile's location
  const profileId = editingProfileId || state.selectedProfile;
  const profile = PROFILES[profileId];
  const profileLat = profile?.lat ?? state.lat;
  const profileLon = profile?.lon ?? state.lon;
  
  const citySelect = document.getElementById('settings-city-select');
  const coordValue = `${profileLat},${profileLon}`;
  let found = false;
  
  for (let option of citySelect.options) {
    if (option.value === coordValue) {
      citySelect.value = coordValue;
      found = true;
      break;
    }
  }
  
  if (!found) {
    citySelect.value = 'custom';
    document.getElementById('settings-custom-coords').style.display = 'flex';
    document.getElementById('settings-lat-input').value = profileLat;
    document.getElementById('settings-lon-input').value = profileLon;
  } else {
    document.getElementById('settings-custom-coords').style.display = 'none';
  }
  
  // Render the map
  renderSettingsPageMap();
  
  // Update settings editability based on current profile
  updateSettingsEditability();
}

function renderSettingsPageMap() {
  const container = document.getElementById('settings-page-map');
  if (container && state.lunarMonths && state.lunarMonths[state.currentMonthIndex]) {
    const month = state.lunarMonths[state.currentMonthIndex];
    
    // Use the editing profile's location for the map marker
    const profileId = editingProfileId || state.selectedProfile;
    const profile = PROFILES[profileId];
    const mapOptions = profile ? { lat: profile.lat, lon: profile.lon } : {};
    
    container.innerHTML = renderDatelineVisualization(month.moonEvent, mapOptions);
    // Update map editability after rendering
    updateMapEditability();
  }
}

function updateMoonPhaseButtons() {
  // For main calendar UI, use state
  document.querySelectorAll('.moon-phase-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.phase === state.moonPhase);
  });
  // For settings page, use the editing profile
  const profileId = editingProfileId || state.selectedProfile;
  const profile = PROFILES[profileId];
  const editingPhase = profile ? profile.moonPhase : state.moonPhase;
  document.querySelectorAll('.settings-option-btn[data-phase]').forEach(btn => {
    btn.classList.toggle('selected', btn.dataset.phase === editingPhase);
  });
}

function selectMoonPhase(phase) {
  // Don't allow changes on preset profiles
  const profileId = editingProfileId || state.selectedProfile;
  if (PRESET_PROFILES[profileId]) return;
  
  // Update the editing profile
  if (PROFILES[profileId]) {
    PROFILES[profileId].moonPhase = phase;
    PROFILES[profileId].icon = getProfileIcon(phase);
    saveCustomProfiles();
  }
  
  document.getElementById('moon-phase-select').value = phase;
  updateMoonPhaseButtons();
  updateCrescentThresholdVisibility();
  updateYearStartButtons();  // Update year start icon to match moon phase
  
  // Only update state if editing the active profile
  if (profileId === state.selectedProfile) {
    state.moonPhase = phase;
    saveState();
    regenerateCalendarPreservingScroll();
  }
}

// ============================================================================
// ARCHITECTURE OVERVIEW
// ============================================================================
//
// PROFILES vs STATE:
//   - Profile = Calendar interpretation rules (how to calculate the calendar)
//   - State = Viewing context (what you're looking at: when, where)
//
// PROFILE FORMAT (compatible with LunarCalendarEngine.configure()):
//   {
//     // Engine configuration (required)
//     moonPhase: 'full' | 'dark' | 'crescent',
//     dayStartTime: 'morning' | 'evening',
//     dayStartAngle: 0 | 6 | 12 | 18,  // degrees below horizon
//     yearStartRule: 'equinox' | '13daysBefore' | 'virgoFeet',
//     sabbathMode: 'lunar' | 'saturday',  // not used by engine, UI only
//
//     // Crescent-specific (only used when moonPhase === 'crescent')
//     crescentThreshold: 18,  // hours after conjunction for visibility
//
//     // UI metadata
//     name: string,
//     icon: string,
//     hint: string,
//
//     // Location behavior
//     useLocalLocation: true,  // For presets: use saved/IP location
//     // OR for custom profiles with fixed location:
//     lat: number,
//     lon: number,
//     city: string
//   }
//
// STATE FORMAT (viewing context + active config):
//   {
//     selectedProfile: string,  // Profile ID
//     year: number,
//     currentMonthIndex: number,
//     highlightedLunarDay: number | null,
//     selectedTimestamp: number | null,
//     lat: number,
//     lon: number,
//     locationSource: 'saved' | 'ip' | 'gps' | 'url' | 'fixed',
//     lunarMonths: [...],  // Generated calendar data
//
//     // Active engine config (copied from profile or custom)
//     moonPhase, dayStartTime, dayStartAngle, yearStartRule, sabbathMode,
//     crescentThreshold,  // Only relevant when moonPhase === 'crescent'
//   }
//
// URL FORMAT:
//   Preset profiles: /profile/year/[month/[day/]]location/
//   Custom profiles: /custom/moon/[threshold?]/dayStart/sabbath/yearStart/year/[month/[day/]]location/
//
//   - Profile segment uses URL slugs (time-tested, ancient-traditional, 119-ministries)
//   - Custom profile encodes settings in path:
//     - moon: full, dark, crescent
//     - threshold (crescent only): opt (12h), min (15.5h), con (24h), or omitted (18h default)
//     - dayStart: morning, evening
//     - sabbath: lunar, saturday, sunday, friday, none
//     - yearStart: equinox, passover
//   - Location is city slug or lat,lon coordinates
//   - ?angle=N query param for dayStartAngle (0, 6, 12, 18)
//
// URL EXAMPLES:
//   /time-tested/2025/jerusalem/
//   /custom/full/morning/lunar/equinox/2025/jerusalem/
//   /custom/crescent/opt/evening/saturday/passover/2025/jerusalem/
//   /custom/crescent/evening/lunar/equinox/2025/jerusalem/ (default 18h threshold)
//
// URL CANONICALIZATION:
//   - If custom URL params match a built-in profile â†’ redirect to canonical URL
//   - This prevents duplicate content for SEO
//
// ============================================================================

// Preset profiles (built-in, cannot be deleted)
// timeTested is first as it's the default
const PRESET_PROFILES = {
  timeTested: {
    name: 'Time-Tested',
    hint: 'Full Moon, Morning Twilight, Lunar Sabbath',
    icon: 'ðŸŒ•',
    moonPhase: 'full',
    dayStartTime: 'morning',
    dayStartAngle: 12,
    yearStartRule: 'equinox',
    crescentThreshold: 18,
    sabbathMode: 'lunar',
    useLocalLocation: true  // Uses saved location or IP detection
  },
  ancientTraditional: {
    name: 'Ancient Traditional',
    hint: 'Crescent Moon, Evening, Saturday Sabbath, Passover Rule',
    icon: 'ðŸŒ’',
    moonPhase: 'crescent',
    dayStartTime: 'evening',
    dayStartAngle: 0,
    yearStartRule: '13daysBefore',
    crescentThreshold: 18,
    sabbathMode: 'saturday',
    useLocalLocation: true
  },
  ministries119: {
    name: '119 Ministries',
    hint: 'Dark Moon, Evening, Saturday Sabbath',
    icon: 'ðŸŒ‘',
    moonPhase: 'dark',
    dayStartTime: 'evening',
    dayStartAngle: 0,
    yearStartRule: 'equinox',
    crescentThreshold: 18,
    sabbathMode: 'saturday',
    useLocalLocation: true
  },
  creatorsCalendar: {
    name: "Creator's Calendar",
    hint: 'Full Moon, Evening, Virgo Rule, Lunar Sabbath',
    icon: 'ðŸŒ•',
    moonPhase: 'full',
    dayStartTime: 'evening',
    dayStartAngle: 0,
    yearStartRule: 'virgoFeet',
    crescentThreshold: 18,
    sabbathMode: 'lunar',
    useLocalLocation: true
  },
  traditionalLunar: {
    name: 'Traditional Lunar',
    hint: 'Crescent Moon, Evening, Lunar Sabbath',
    icon: 'ðŸŒ’',
    moonPhase: 'crescent',
    dayStartTime: 'evening',
    dayStartAngle: 0,
    yearStartRule: 'equinox',
    crescentThreshold: 18,
    sabbathMode: 'lunar',
    useLocalLocation: true
  }
};

// Combined profiles (presets + user-saved)
let PROFILES = { ...PRESET_PROFILES };

// Load custom profiles from localStorage
function loadCustomProfiles() {
  try {
    const saved = localStorage.getItem('customProfiles');
    if (saved) {
      const customProfiles = JSON.parse(saved);
      PROFILES = { ...PRESET_PROFILES, ...customProfiles };
    }
  } catch (e) {
    console.error('Error loading custom profiles:', e);
  }
}

// Save custom profiles to localStorage
function saveCustomProfiles() {
  const customProfiles = {};
  for (const [id, profile] of Object.entries(PROFILES)) {
    if (!PRESET_PROFILES[id]) {
      customProfiles[id] = profile;
    }
  }
  localStorage.setItem('customProfiles', JSON.stringify(customProfiles));
}

// Rebuild profile dropdown with all profiles
function rebuildProfileDropdown() {
  const select = document.getElementById('profile-select');
  if (!select) return;
  
  select.innerHTML = '';
  
  // Add preset profiles
  for (const [id, profile] of Object.entries(PRESET_PROFILES)) {
    const option = document.createElement('option');
    option.value = id;
    option.textContent = `${renderProfileIconText(profile)} ${profile.name} â€” ${profile.hint}`;
    select.appendChild(option);
  }
  
  // Add custom profiles (user-saved)
  const customIds = Object.keys(PROFILES).filter(id => !PRESET_PROFILES[id]);
  if (customIds.length > 0) {
    for (const id of customIds) {
      const profile = PROFILES[id];
      const option = document.createElement('option');
      option.value = id;
      option.textContent = `${renderProfileIconText(profile)} ${profile.name}`;
      select.appendChild(option);
    }
  }
  
  // Restore selection from state if valid, otherwise default to timeTested
  const profileToSelect = state.selectedProfile || 'timeTested';
  if ([...select.options].some(o => o.value === profileToSelect)) {
    select.value = profileToSelect;
  } else {
    select.value = 'timeTested';
    state.selectedProfile = 'timeTested';
  }
}

// Get the icon for a moon phase
function getProfileIcon(phase) {
  if (phase === 'full') return 'ðŸŒ•';
  if (phase === 'dark') return 'ðŸŒ‘';
  if (phase === 'crescent') return 'ðŸŒ’';
  return 'ðŸŒ•';
}

// Render profile icon HTML (supports both emoji and favicon URLs)
function renderProfileIcon(profile) {
  if (profile.faviconUrl) {
    return `<img src="${profile.faviconUrl}" alt="${profile.name}" onerror="this.style.display='none';this.nextSibling.style.display='inline'"><span style="display:none">${profile.icon || 'ðŸ“…'}</span>`;
  }
  return profile.icon || 'ðŸ“…';
}

// Render profile icon for plain text contexts (dropdown options)
function renderProfileIconText(profile) {
  // For text contexts (like <option>), we can only use emoji, not images
  return profile.icon || 'ðŸ“…';
}

// Extract engine-compatible config from a profile
// This is what gets passed to LunarCalendarEngine.configure()
function getEngineConfig(profile) {
  return {
    moonPhase: profile.moonPhase,
    dayStartTime: profile.dayStartTime,
    dayStartAngle: profile.dayStartAngle,
    yearStartRule: profile.yearStartRule,
    crescentThreshold: profile.crescentThreshold || 18
  };
}

// Check if current state matches a named profile's engine settings
function matchesProfile(profileId) {
  const profile = PROFILES[profileId];
  if (!profile) return false;
  
  const baseMatch = state.moonPhase === profile.moonPhase &&
         state.dayStartTime === profile.dayStartTime &&
         state.dayStartAngle === profile.dayStartAngle &&
         state.yearStartRule === profile.yearStartRule &&
         state.sabbathMode === (profile.sabbathMode || 'lunar');
  
  // For crescent profiles, also check crescentThreshold
  if (profile.moonPhase === 'crescent') {
    return baseMatch && state.crescentThreshold === (profile.crescentThreshold || 18);
  }
  
  return baseMatch;
}

// Get the name of the currently selected profile (active on calendar)
function getCurrentProfileName() {
  const profileId = state.selectedProfile || 'timeTested';
  const profile = PROFILES[profileId];
  return profile ? profile.name : '';
}

// Known city coordinates for display lookup
const CITY_NAMES = {
  '31.7683,35.2137': 'Jerusalem',
  '40.7128,-74.006': 'New York',
  '34.0522,-118.2437': 'Los Angeles',
  '41.8781,-87.6298': 'Chicago',
  '29.7604,-95.3698': 'Houston',
  '33.749,-84.388': 'Atlanta',
  '47.6062,-122.3321': 'Seattle',
  '25.7617,-80.1918': 'Miami',
  '39.7392,-104.9903': 'Denver',
  '33.4484,-112.074': 'Phoenix',
  '51.5074,-0.1278': 'London',
  '48.8566,2.3522': 'Paris',
  '52.52,13.405': 'Berlin',
  '41.9028,12.4964': 'Rome',
  '55.7558,37.6173': 'Moscow',
  '35.6762,139.6503': 'Tokyo',
  '31.2304,121.4737': 'Shanghai',
  '22.3193,114.1694': 'Hong Kong',
  '1.3521,103.8198': 'Singapore',
  '-33.8688,151.2093': 'Sydney',
  '-23.5505,-46.6333': 'SÃ£o Paulo',
  '19.4326,-99.1332': 'Mexico City',
  '-34.6037,-58.3816': 'Buenos Aires',
  '30.0444,31.2357': 'Cairo',
  '28.6139,77.209': 'New Delhi',
  '-1.2921,36.8219': 'Nairobi'
};

// ========================================
// SEO-FRIENDLY URL ROUTING
// ========================================

// City slugs for URL routing (slug -> coordinates)
const CITY_SLUGS = {
  // Biblical / Middle East
  'jerusalem': { lat: 31.7683, lon: 35.2137 },
  'bethlehem': { lat: 31.7054, lon: 35.2024 },
  'nazareth': { lat: 32.6996, lon: 35.3035 },
  'jericho': { lat: 31.8500, lon: 35.4500 },
  'hebron': { lat: 31.5326, lon: 35.0998 },
  'ramses': { lat: 30.7879, lon: 31.8332 },  // Pi-Ramesses, ancient Egyptian capital (near modern Qantir)
  'goshen': { lat: 30.7833, lon: 31.5000 },  // Land of Goshen, eastern Nile Delta
  'wilderness-of-sin': { lat: 29.1500, lon: 33.4000 },  // Between Elim and Sinai
  'cairo': { lat: 30.0444, lon: 31.2357 },
  'baghdad': { lat: 33.3152, lon: 44.3661 },
  'damascus': { lat: 33.5138, lon: 36.2765 },
  'amman': { lat: 31.9454, lon: 35.9284 },
  'beirut': { lat: 33.8938, lon: 35.5018 },
  'tel-aviv': { lat: 32.0853, lon: 34.7818 },
  'alexandria': { lat: 31.2001, lon: 29.9187 },
  'mt-sinai-saudi': { lat: 28.5653, lon: 35.4058 },  // Jabal al-Maqla (Ron Wyatt site), Jabal al-Lawz range
  'mecca': { lat: 21.4225, lon: 39.8262 },
  'medina': { lat: 24.5247, lon: 39.5692 },
  'riyadh': { lat: 24.7136, lon: 46.6753 },
  'istanbul': { lat: 41.0082, lon: 28.9784 },
  'tehran': { lat: 35.6892, lon: 51.3890 },
  // North America
  'new-york': { lat: 40.7128, lon: -74.006 },
  'los-angeles': { lat: 34.0522, lon: -118.2437 },
  'chicago': { lat: 41.8781, lon: -87.6298 },
  'houston': { lat: 29.7604, lon: -95.3698 },
  'phoenix': { lat: 33.4484, lon: -112.074 },
  'philadelphia': { lat: 39.9526, lon: -75.1652 },
  'san-antonio': { lat: 29.4241, lon: -98.4936 },
  'san-diego': { lat: 32.7157, lon: -117.1611 },
  'dallas': { lat: 32.7767, lon: -96.7970 },
  'san-jose': { lat: 37.3382, lon: -121.8863 },
  'austin': { lat: 30.2672, lon: -97.7431 },
  'jacksonville': { lat: 30.3322, lon: -81.6557 },
  'fort-worth': { lat: 32.7555, lon: -97.3308 },
  'columbus': { lat: 39.9612, lon: -82.9988 },
  'charlotte': { lat: 35.2271, lon: -80.8431 },
  'san-francisco': { lat: 37.7749, lon: -122.4194 },
  'indianapolis': { lat: 39.7684, lon: -86.1581 },
  'seattle': { lat: 47.6062, lon: -122.3321 },
  'denver': { lat: 39.7392, lon: -104.9903 },
  'washington-dc': { lat: 38.9072, lon: -77.0369 },
  'boston': { lat: 42.3601, lon: -71.0589 },
  'nashville': { lat: 36.1627, lon: -86.7816 },
  'detroit': { lat: 42.3314, lon: -83.0458 },
  'portland': { lat: 45.5152, lon: -122.6784 },
  'las-vegas': { lat: 36.1699, lon: -115.1398 },
  'memphis': { lat: 35.1495, lon: -90.0490 },
  'louisville': { lat: 38.2527, lon: -85.7585 },
  'baltimore': { lat: 39.2904, lon: -76.6122 },
  'milwaukee': { lat: 43.0389, lon: -87.9065 },
  'albuquerque': { lat: 35.0844, lon: -106.6504 },
  'tucson': { lat: 32.2226, lon: -110.9747 },
  'atlanta': { lat: 33.749, lon: -84.388 },
  'miami': { lat: 25.7617, lon: -80.1918 },
  'minneapolis': { lat: 44.9778, lon: -93.2650 },
  'salt-lake-city': { lat: 40.7608, lon: -111.8910 },
  'anchorage': { lat: 61.2181, lon: -149.9003 },
  'honolulu': { lat: 21.3069, lon: -157.8583 },
  'toronto': { lat: 43.6532, lon: -79.3832 },
  'vancouver': { lat: 49.2827, lon: -123.1207 },
  'montreal': { lat: 45.5017, lon: -73.5673 },
  'mexico-city': { lat: 19.4326, lon: -99.1332 },
  // Europe
  'london': { lat: 51.5074, lon: -0.1278 },
  'paris': { lat: 48.8566, lon: 2.3522 },
  'berlin': { lat: 52.52, lon: 13.405 },
  'madrid': { lat: 40.4168, lon: -3.7038 },
  'rome': { lat: 41.9028, lon: 12.4964 },
  'vienna': { lat: 48.2082, lon: 16.3738 },
  'amsterdam': { lat: 52.3676, lon: 4.9041 },
  'brussels': { lat: 50.8503, lon: 4.3517 },
  'stockholm': { lat: 59.3293, lon: 18.0686 },
  'oslo': { lat: 59.9139, lon: 10.7522 },
  'copenhagen': { lat: 55.6761, lon: 12.5683 },
  'helsinki': { lat: 60.1699, lon: 24.9384 },
  'dublin': { lat: 53.3498, lon: -6.2603 },
  'lisbon': { lat: 38.7223, lon: -9.1393 },
  'barcelona': { lat: 41.3851, lon: 2.1734 },
  'munich': { lat: 48.1351, lon: 11.5820 },
  'milan': { lat: 45.4642, lon: 9.1900 },
  'zurich': { lat: 47.3769, lon: 8.5417 },
  'geneva': { lat: 46.2044, lon: 6.1432 },
  'moscow': { lat: 55.7558, lon: 37.6173 },
  'saint-petersburg': { lat: 59.9311, lon: 30.3609 },
  'kiev': { lat: 50.4501, lon: 30.5234 },
  'warsaw': { lat: 52.2297, lon: 21.0122 },
  'prague': { lat: 50.0755, lon: 14.4378 },
  'budapest': { lat: 47.4979, lon: 19.0402 },
  'bucharest': { lat: 44.4268, lon: 26.1025 },
  'athens': { lat: 37.9838, lon: 23.7275 },
  // Asia
  'tokyo': { lat: 35.6762, lon: 139.6503 },
  'osaka': { lat: 34.6937, lon: 135.5023 },
  'seoul': { lat: 37.5665, lon: 126.9780 },
  'beijing': { lat: 39.9042, lon: 116.4074 },
  'shanghai': { lat: 31.2304, lon: 121.4737 },
  'hong-kong': { lat: 22.3193, lon: 114.1694 },
  'taipei': { lat: 25.0330, lon: 121.5654 },
  'singapore': { lat: 1.3521, lon: 103.8198 },
  'bangkok': { lat: 13.7563, lon: 100.5018 },
  'kuala-lumpur': { lat: 3.1390, lon: 101.6869 },
  'jakarta': { lat: -6.2088, lon: 106.8456 },
  'manila': { lat: 14.5995, lon: 120.9842 },
  'hanoi': { lat: 21.0285, lon: 105.8542 },
  'ho-chi-minh': { lat: 10.8231, lon: 106.6297 },
  'mumbai': { lat: 19.0760, lon: 72.8777 },
  'new-delhi': { lat: 28.6139, lon: 77.209 },
  'bangalore': { lat: 12.9716, lon: 77.5946 },
  'kolkata': { lat: 22.5726, lon: 88.3639 },
  'chennai': { lat: 13.0827, lon: 80.2707 },
  'karachi': { lat: 24.8607, lon: 67.0011 },
  'lahore': { lat: 31.5204, lon: 74.3587 },
  'dhaka': { lat: 23.8103, lon: 90.4125 },
  // Oceania
  'sydney': { lat: -33.8688, lon: 151.2093 },
  'melbourne': { lat: -37.8136, lon: 144.9631 },
  'brisbane': { lat: -27.4698, lon: 153.0251 },
  'perth': { lat: -31.9505, lon: 115.8605 },
  'auckland': { lat: -36.8485, lon: 174.7633 },
  'wellington': { lat: -41.2865, lon: 174.7762 },
  // South America
  'sao-paulo': { lat: -23.5505, lon: -46.6333 },
  'rio-de-janeiro': { lat: -22.9068, lon: -43.1729 },
  'buenos-aires': { lat: -34.6037, lon: -58.3816 },
  'bogota': { lat: 4.7110, lon: -74.0721 },
  'lima': { lat: -12.0464, lon: -77.0428 },
  'santiago': { lat: -33.4489, lon: -70.6693 },
  'caracas': { lat: 10.4806, lon: -66.9036 },
  // Africa
  'johannesburg': { lat: -26.2041, lon: 28.0473 },
  'cape-town': { lat: -33.9249, lon: 18.4241 },
  'lagos': { lat: 6.5244, lon: 3.3792 },
  'nairobi': { lat: -1.2921, lon: 36.8219 },
  'addis-ababa': { lat: 9.0320, lon: 38.7469 },
  'casablanca': { lat: 33.5731, lon: -7.5898 },
  'tunis': { lat: 36.8065, lon: 10.1815 },
  'algiers': { lat: 36.7538, lon: 3.0588 },
  'accra': { lat: 5.6037, lon: -0.1870 },
  'dakar': { lat: 14.7167, lon: -17.4677 }
};

// Reverse lookup: coordinates to slug
const COORDS_TO_SLUG = {};
for (const [slug, coords] of Object.entries(CITY_SLUGS)) {
  COORDS_TO_SLUG[`${coords.lat},${coords.lon}`] = slug;
}

// Named profile configurations for short URLs
// IMPORTANT: When adding new profiles, also update calendarRoutes in 404.html
// to enable client-side routing for the new profile URLs!
const PROFILE_CONFIGS = {
  'time-tested': {
    moonPhase: 'full',
    dayStartTime: 'morning',
    dayStartAngle: 12,
    sabbathMode: 'lunar',
    yearStartRule: 'equinox'
  },
  'ancient-traditional': {
    moonPhase: 'crescent',
    dayStartTime: 'evening',
    dayStartAngle: 0,
    sabbathMode: 'saturday',
    yearStartRule: '13daysBefore'  // "passover" rule - Day 15 on or after equinox
  },
  '119-ministries': {
    moonPhase: 'dark',
    dayStartTime: 'evening',
    dayStartAngle: 0,
    sabbathMode: 'saturday',
    yearStartRule: 'equinox'
  },
  'creators-calendar': {
    moonPhase: 'full',
    dayStartTime: 'evening',
    dayStartAngle: 0,
    sabbathMode: 'lunar',
    yearStartRule: 'virgoFeet'
  },
  'traditional-lunar': {
    moonPhase: 'crescent',
    dayStartTime: 'evening',
    dayStartAngle: 0,
    sabbathMode: 'lunar',
    yearStartRule: 'equinox'
  }
};

// URL to internal value mappings
const YEAR_START_URL_MAP = {
  'equinox': 'equinox',
  'passover': '13daysBefore',
  'lamb': '13daysBefore',
  'virgo': 'virgoFeet',
  'virgo-feet': 'virgoFeet',
  'creators': 'virgoFeet'
};
const YEAR_START_INTERNAL_TO_URL = {
  'equinox': 'equinox',
  '13daysBefore': 'passover',
  'virgoFeet': 'virgo'
};

// Crescent threshold URL mappings (18h is default, omitted from URL)
const CRESCENT_THRESHOLD_TO_URL = {
  12: 'opt',      // Optimistic (optical aids)
  15.5: 'min',    // Minimum naked-eye
  24: 'con'       // Conservative
};
const CRESCENT_THRESHOLD_FROM_URL = {
  'opt': 12,
  'min': 15.5,
  'con': 24
};

// Find closest city slug from coordinates (within ~100km)
function getClosestCitySlug(lat, lon, maxDistKm = 500) {
  let closestSlug = null;
  let closestDist = Infinity;
  
  for (const [slug, coords] of Object.entries(CITY_SLUGS)) {
    const dist = haversineDistance(lat, lon, coords.lat, coords.lon);
    if (dist < closestDist && dist < maxDistKm) {
      closestDist = dist;
      closestSlug = slug;
    }
  }
  
  return closestSlug;
}

// Haversine distance in km
function haversineDistance(lat1, lon1, lat2, lon2) {
  const R = 6371; // Earth's radius in km
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
            Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

// Get current profile slug based on state
function getCurrentProfileSlug() {
  for (const [slug, config] of Object.entries(PROFILE_CONFIGS)) {
    if (state.moonPhase === config.moonPhase &&
        state.dayStartTime === config.dayStartTime &&
        state.dayStartAngle === config.dayStartAngle &&
        state.sabbathMode === config.sabbathMode &&
        state.yearStartRule === config.yearStartRule) {
      return slug;
    }
  }
  return 'custom';
}

// Get location slug for URL
function getLocationSlug() {
  // Default to Jerusalem if location not set
  const lat = state.lat ?? 31.7683;
  const lon = state.lon ?? 35.2137;
  
  // Try exact match first
  const coordKey = `${lat},${lon}`;
  if (COORDS_TO_SLUG[coordKey]) {
    return COORDS_TO_SLUG[coordKey];
  }
  
  // Find closest city (no distance limit)
  const closest = getClosestCitySlug(lat, lon, Infinity);
  if (closest) {
    return closest;
  }
  
  // Ultimate fallback
  return 'jerusalem';
}

// Build SEO-friendly URL from current state
function buildPathURL(options = {}) {
  const profile = getCurrentProfileSlug();
  const locationSlug = getLocationSlug();
  
  // Build segments - always include profile, year, and location for clear SEO URLs
  const segments = [];
  
  // Profile always included (explicit is better for SEO/analytics)
  segments.push(profile);
  
  // For custom profiles, encode settings in path segments
  // Format: /custom/moon/[threshold?]/dayStart/sabbath/yearStart/year/location/
  if (profile === 'custom') {
    // Moon phase: full, dark, crescent
    segments.push(state.moonPhase);
    
    // Crescent threshold (only if crescent and non-default)
    if (state.moonPhase === 'crescent' && state.crescentThreshold !== 18) {
      const thresholdSlug = CRESCENT_THRESHOLD_TO_URL[state.crescentThreshold];
      if (thresholdSlug) {
        segments.push(thresholdSlug);
      }
    }
    
    // Day start time: morning, evening
    segments.push(state.dayStartTime);
    
    // Sabbath mode: lunar, saturday, etc.
    segments.push(state.sabbathMode);
    
    // Year start rule: equinox, passover
    segments.push(YEAR_START_INTERNAL_TO_URL[state.yearStartRule] || 'equinox');
  }
  
  // Year always included (use BC format for negative years)
  segments.push(formatYearForURL(state.year));
  
  // Month (lunar month number, 1-indexed) - always include
  const monthNum = (state.currentMonthIndex || 0) + 1;
  segments.push(monthNum.toString());
  
  // Day (lunar day) - always include, default to 1
  const lunarDay = state.highlightedLunarDay || 1;
  segments.push(lunarDay.toString());
  
  // Location always included (explicit is better for SEO/analytics)
  segments.push(locationSlug);
  
  // Build path
  let path = '/' + segments.join('/');
  if (!path.endsWith('/')) {
    path += '/';
  }
  
  // Query params (only for time or dayStartAngle which isn't in path)
  const params = new URLSearchParams();
  
  // dayStartAngle is not easily encodable in path, keep as query param for custom
  if (profile === 'custom' && state.dayStartAngle !== 0) {
    params.set('angle', state.dayStartAngle);
  }
  
  // Time parameter if specific time is set
  if (options.includeTime && state.selectedTimestamp) {
    const d = new Date(state.selectedTimestamp);
    params.set('time', `${d.getHours()}:${String(d.getMinutes()).padStart(2, '0')}`);
  }
  
  const queryString = params.toString();
  return queryString ? `${path}?${queryString}` : path;
}

// Parse year from URL segment
// Supports: 2025, 32 (literal year 32 AD), -1445, 1446BC, 1446bc
// Returns internal year representation (1 BC = 0, 2 BC = -1, etc.)
function parseYearFromURL(yearStr) {
  if (!yearStr) return null;
  
  // Check for BC suffix (e.g., "1446BC", "1446bc")
  const bcMatch = yearStr.match(/^(\d+)[Bb][Cc]$/);
  if (bcMatch) {
    const bcYear = parseInt(bcMatch[1]);
    // Convert BC to internal: 1 BC = 0, 2 BC = -1, 1446 BC = -1445
    return -(bcYear - 1);
  }
  
  // Check for negative year (already in internal format)
  if (/^-\d+$/.test(yearStr)) {
    return parseInt(yearStr);
  }
  
  // Positive integer - treat as literal year (32 = year 32 AD, not 1932)
  if (/^\d+$/.test(yearStr)) {
    return parseInt(yearStr);
  }
  
  return null;
}

// Format year for URL (reverse of parseYearFromURL)
function formatYearForURL(year) {
  if (year <= 0) {
    // Convert internal to BC: 0 = 1BC, -1 = 2BC, -1445 = 1446BC
    const bcYear = Math.abs(year - 1);
    return `${bcYear}bc`;
  }
  return year.toString();
}

// Parse SEO-friendly URL path into state
function parsePathURL() {
  const path = window.location.pathname;
  const segments = path.split('/').filter(s => s.length > 0);
  const params = new URLSearchParams(window.location.search);
  
  // Check for special views first
  if (segments[0] === 'about') {
    return { view: 'about' };
  }
  if (segments[0] === 'sabbath-tester') {
    return { view: 'sabbath-tester' };
  }
  if (segments[0] === 'feasts') {
    return { view: 'feasts', segments: segments.slice(1) };
  }
  
  // Handle Gregorian date lookup: /gregorian/year/month/day/
  // Only valid for 1582 and later (Gregorian calendar start)
  if (segments[0] === 'gregorian') {
    const result = {
      view: 'gregorian-lookup',
      profile: 'time-tested',
      gregorianYear: null,
      gregorianMonth: null,
      gregorianDay: null
    };
    
    if (segments.length >= 2) {
      const parsedYear = parseYearFromURL(segments[1]);
      if (parsedYear !== null) result.gregorianYear = parsedYear;
    }
    if (segments.length >= 3) {
      const month = parseInt(segments[2]);
      if (month >= 1 && month <= 12) result.gregorianMonth = month;
    }
    if (segments.length >= 4) {
      const day = parseInt(segments[3]);
      if (day >= 1 && day <= 31) result.gregorianDay = day;
    }
    
    // If year is before Gregorian calendar (1582), redirect to Julian
    if (result.gregorianYear !== null && result.gregorianYear < 1582) {
      result.view = 'redirect-to-julian';
    }
    
    return result;
  }
  
  // Handle Julian date lookup: /julian/year/month/day/
  // Julian dates are converted to Gregorian internally but URL stays Julian
  if (segments[0] === 'julian') {
    const result = {
      view: 'julian-lookup',
      profile: 'time-tested',
      julianYear: null,
      julianMonth: null,
      julianDay: null
    };
    
    if (segments.length >= 2) {
      const parsedYear = parseYearFromURL(segments[1]);
      if (parsedYear !== null) result.julianYear = parsedYear;
    }
    if (segments.length >= 3) {
      const month = parseInt(segments[2]);
      if (month >= 1 && month <= 12) result.julianMonth = month;
    }
    if (segments.length >= 4) {
      const day = parseInt(segments[3]);
      if (day >= 1 && day <= 31) result.julianDay = day;
    }
    
    return result;
  }
  
  // Default state
  const result = {
    profile: 'time-tested',
    year: new Date().getFullYear(),
    month: null,
    day: null,
    location: 'jerusalem',
    view: 'calendar',
    needsRedirect: false
  };
  
  if (segments.length === 0) {
    // Root URL - redirect to canonical
    result.needsRedirect = true;
    return result;
  }
  
  let segmentIndex = 0;
  
  // First segment MUST be a profile name
  const first = segments[0];
  if (PROFILE_CONFIGS[first]) {
    result.profile = first;
    segmentIndex++;
  } else if (first === 'custom') {
    result.profile = 'custom';
    segmentIndex++;
    
    // For custom profiles, parse path segments:
    // /custom/moon/[threshold?]/dayStart/sabbath/yearStart/year/location/
    
    // Parse moon phase: full, dark, crescent
    if (segmentIndex < segments.length) {
      const moonSeg = segments[segmentIndex];
      if (moonSeg === 'full' || moonSeg === 'dark' || moonSeg === 'crescent') {
        result.moonPhase = moonSeg;
        segmentIndex++;
        
        // If crescent, check for threshold: opt, min, con
        if (moonSeg === 'crescent' && segmentIndex < segments.length) {
          const thresholdSeg = segments[segmentIndex];
          if (CRESCENT_THRESHOLD_FROM_URL[thresholdSeg] !== undefined) {
            result.crescentThreshold = CRESCENT_THRESHOLD_FROM_URL[thresholdSeg];
            segmentIndex++;
          }
          // else: default 18h, don't consume segment
        }
      }
    }
    
    // Parse dayStart: morning, evening
    if (segmentIndex < segments.length) {
      const dayStartSeg = segments[segmentIndex];
      if (dayStartSeg === 'morning' || dayStartSeg === 'evening') {
        result.dayStartTime = dayStartSeg;
        segmentIndex++;
      }
    }
    
    // Parse sabbath: lunar, saturday, sunday, friday, none
    if (segmentIndex < segments.length) {
      const sabbathSeg = segments[segmentIndex];
      if (['lunar', 'saturday', 'sunday', 'friday', 'none'].includes(sabbathSeg)) {
        result.sabbathMode = sabbathSeg;
        segmentIndex++;
      }
    }
    
    // Parse yearStart: equinox, passover
    if (segmentIndex < segments.length) {
      const yearStartSeg = segments[segmentIndex];
      if (yearStartSeg === 'equinox' || yearStartSeg === 'passover') {
        result.yearStartRule = YEAR_START_URL_MAP[yearStartSeg] || yearStartSeg;
        segmentIndex++;
      }
    }
  } else {
    // Not a valid profile - redirect to canonical URL with defaults
    result.needsRedirect = true;
    return result;
  }
  
  // Next segment: year (required)
  // Supports: 2025, 32, -1445, 1446BC, 1446bc
  if (segmentIndex < segments.length) {
    const yearStr = segments[segmentIndex];
    const parsedYear = parseYearFromURL(yearStr);
    if (parsedYear !== null) {
      result.year = parsedYear;
      segmentIndex++;
    }
  }
  
  // Parse remaining segments: could be month, day, or location
  // Format: .../year/[month/[day/]]location/
  const remaining = segments.slice(segmentIndex);
  
  if (remaining.length === 1) {
    // Just location
    result.location = remaining[0];
  } else if (remaining.length === 2) {
    // month + location
    if (/^\d+$/.test(remaining[0]) && parseInt(remaining[0]) >= 1 && parseInt(remaining[0]) <= 13) {
      result.month = parseInt(remaining[0]);
    }
    result.location = remaining[1];
  } else if (remaining.length >= 3) {
    // month + day + location
    if (/^\d+$/.test(remaining[0]) && parseInt(remaining[0]) >= 1 && parseInt(remaining[0]) <= 13) {
      result.month = parseInt(remaining[0]);
    }
    if (/^\d+$/.test(remaining[1]) && parseInt(remaining[1]) >= 1 && parseInt(remaining[1]) <= 30) {
      result.day = parseInt(remaining[1]);
    }
    result.location = remaining[2];
  }
  
  // Validate location - if not recognized, flag for redirect
  if (result.location && !CITY_SLUGS[result.location] && !/^-?\d+\.?\d*,-?\d+\.?\d*$/.test(result.location)) {
    result.needsRedirect = true;
  }
  
  // Parse query params (dayStartAngle still uses query param)
  if (params.has('angle')) result.dayStartAngle = parseInt(params.get('angle'));
  if (params.has('threshold')) result.crescentThreshold = parseInt(params.get('threshold'));
  if (params.has('time')) result.time = params.get('time');
  
  return result;
}

// Apply parsed URL state to app state
function applyURLState(urlState) {
  let needsRegenerate = false;
  
  // Apply profile settings
  if (urlState.profile && PROFILE_CONFIGS[urlState.profile]) {
    const config = PROFILE_CONFIGS[urlState.profile];
    if (state.moonPhase !== config.moonPhase) {
      state.moonPhase = config.moonPhase;
      needsRegenerate = true;
    }
    if (state.dayStartTime !== config.dayStartTime) {
      state.dayStartTime = config.dayStartTime;
      needsRegenerate = true;
    }
    if (state.dayStartAngle !== config.dayStartAngle) {
      state.dayStartAngle = config.dayStartAngle;
      needsRegenerate = true;
    }
    if (state.sabbathMode !== config.sabbathMode) {
      state.sabbathMode = config.sabbathMode;
      needsRegenerate = true;
    }
    if (state.yearStartRule !== config.yearStartRule) {
      state.yearStartRule = config.yearStartRule;
      needsRegenerate = true;
    }
  }
  
  // Apply custom settings from query params
  if (urlState.moonPhase) { state.moonPhase = urlState.moonPhase; needsRegenerate = true; }
  if (urlState.dayStartTime) { state.dayStartTime = urlState.dayStartTime; needsRegenerate = true; }
  if (urlState.dayStartAngle !== undefined) { state.dayStartAngle = urlState.dayStartAngle; needsRegenerate = true; }
  if (urlState.sabbathMode) { state.sabbathMode = urlState.sabbathMode; needsRegenerate = true; }
  if (urlState.yearStartRule) { state.yearStartRule = urlState.yearStartRule; needsRegenerate = true; }
  if (urlState.crescentThreshold !== undefined) { state.crescentThreshold = urlState.crescentThreshold; needsRegenerate = true; }
  
  // Apply year
  if (urlState.year && urlState.year !== state.year) {
    state.year = urlState.year;
    needsRegenerate = true;
  }
  
  // Apply location
  if (urlState.location) {
    let lat, lon;
    if (CITY_SLUGS[urlState.location]) {
      lat = CITY_SLUGS[urlState.location].lat;
      lon = CITY_SLUGS[urlState.location].lon;
    }
    if (lat !== undefined && lon !== undefined && (lat !== state.lat || lon !== state.lon)) {
      state.lat = lat;
      state.lon = lon;
      needsRegenerate = true;
    }
  }
  
  return { needsRegenerate, month: urlState.month, day: urlState.day, view: urlState.view };
}

// Update browser URL without reload
function updatePathURL() {
  const newURL = buildPathURL();
  if (window.location.pathname + window.location.search !== newURL) {
    window.history.replaceState({}, '', newURL);
  }
}

// Navigate with path URL and push to history
function navigateToPathURL(options = {}) {
  const newURL = buildPathURL(options);
  window.history.pushState({}, '', newURL);
}

// Convert Julian date to Gregorian date
// Julian calendar lags behind Gregorian by a growing number of days
function julianToGregorian(year, month, day) {
  // Calculate Julian Day Number for Julian calendar date
  let a = Math.floor((14 - month) / 12);
  let y = year + 4800 - a;
  let m = month + 12 * a - 3;
  
  // Julian calendar JDN formula
  let jdn = day + Math.floor((153 * m + 2) / 5) + 365 * y + Math.floor(y / 4) - 32083;
  
  // Convert JDN back to Gregorian calendar
  let b = jdn + 32044;
  let c = Math.floor((4 * b + 3) / 146097);
  let d = b - Math.floor(146097 * c / 4);
  let e = Math.floor((4 * d + 3) / 1461);
  let f = d - Math.floor(1461 * e / 4);
  let g = Math.floor((5 * f + 2) / 153);
  
  let gregDay = f - Math.floor((153 * g + 2) / 5) + 1;
  let gregMonth = g + 3 - 12 * Math.floor(g / 10);
  let gregYear = 100 * c + e - 4800 + Math.floor(g / 10);
  
  return { year: gregYear, month: gregMonth, day: gregDay };
}

// Handle Gregorian date lookup - find lunar date and redirect
async function handleGregorianLookup(urlState) {
  const { gregorianYear, gregorianMonth, gregorianDay } = urlState;
  
  // Default to today if not specified
  const now = new Date();
  const year = gregorianYear !== null ? gregorianYear : now.getFullYear();
  const month = gregorianMonth !== null ? gregorianMonth : (now.getMonth() + 1);
  const day = gregorianDay !== null ? gregorianDay : now.getDate();
  
  // Set state to the year containing this Gregorian date
  state.year = year;
  
  // Generate calendar for this year
  updateUI();
  await generateCalendar();
  
  // Find the Gregorian date in the lunar calendar
  const targetDate = new Date(year, month - 1, day, 12, 0, 0);
  const targetDateStr = targetDate.toISOString().split('T')[0];
  
  let foundMonth = null;
  let foundDay = null;
  
  for (let m = 0; m < state.lunarMonths.length; m++) {
    const lunarMonth = state.lunarMonths[m];
    for (let d = 0; d < lunarMonth.days.length; d++) {
      const lunarDay = lunarMonth.days[d];
      if (lunarDay.gregorianDate.toISOString().split('T')[0] === targetDateStr) {
        foundMonth = m;
        foundDay = lunarDay.lunarDay;
        break;
      }
    }
    if (foundMonth !== null) break;
  }
  
  if (foundMonth !== null) {
    state.currentMonthIndex = foundMonth;
    state.highlightedLunarDay = foundDay;
    
    // Show the day
    const lunarMonth = state.lunarMonths[foundMonth];
    const dayObj = lunarMonth.days.find(d => d.lunarDay === foundDay);
    if (dayObj) {
      renderMonth(lunarMonth);
      showDayDetail(dayObj, lunarMonth);
    }
  }
  
  // Redirect to canonical lunar URL
  const canonicalURL = buildPathURL();
  window.history.replaceState({}, '', canonicalURL);
}

// Handle Julian date lookup - convert to Gregorian and find lunar date
async function handleJulianLookup(urlState) {
  const { julianYear, julianMonth, julianDay } = urlState;
  
  // Default to today if not specified (in Julian)
  const now = new Date();
  const year = julianYear !== null ? julianYear : now.getFullYear();
  const month = julianMonth !== null ? julianMonth : (now.getMonth() + 1);
  const day = julianDay !== null ? julianDay : now.getDate();
  
  // Convert Julian to Gregorian
  const greg = julianToGregorian(year, month, day);
  
  // Set state to the year containing this Gregorian date
  state.year = greg.year;
  
  // Generate calendar for this year
  updateUI();
  await generateCalendar();
  
  // Find the Gregorian date in the lunar calendar
  const targetDate = new Date(greg.year, greg.month - 1, greg.day, 12, 0, 0);
  const targetDateStr = targetDate.toISOString().split('T')[0];
  
  let foundMonth = null;
  let foundDay = null;
  
  for (let m = 0; m < state.lunarMonths.length; m++) {
    const lunarMonth = state.lunarMonths[m];
    for (let d = 0; d < lunarMonth.days.length; d++) {
      const lunarDay = lunarMonth.days[d];
      if (lunarDay.gregorianDate.toISOString().split('T')[0] === targetDateStr) {
        foundMonth = m;
        foundDay = lunarDay.lunarDay;
        break;
      }
    }
    if (foundMonth !== null) break;
  }
  
  if (foundMonth !== null) {
    state.currentMonthIndex = foundMonth;
    state.highlightedLunarDay = foundDay;
    
    // Show the day
    const lunarMonth = state.lunarMonths[foundMonth];
    const dayObj = lunarMonth.days.find(d => d.lunarDay === foundDay);
    if (dayObj) {
      renderMonth(lunarMonth);
      showDayDetail(dayObj, lunarMonth);
    }
  }
  
  // Redirect to canonical lunar URL
  const canonicalURL = buildPathURL();
  window.history.replaceState({}, '', canonicalURL);
}

// Get timezone name from longitude
function getTimezoneFromLongitude(lon) {
  // Calculate UTC offset based on longitude (15 degrees per hour)
  const offsetHours = Math.round(lon / 15);
  if (offsetHours === 0) {
    return 'Atlantic';
  } else if (offsetHours > 0) {
    // Eastern hemisphere regions
    if (offsetHours <= 3) return 'Europe';
    if (offsetHours <= 5) return 'Middle East';
    if (offsetHours <= 8) return 'South Asia';
    if (offsetHours <= 10) return 'East Asia';
    return 'Pacific';
  } else {
    // Western hemisphere regions  
    if (offsetHours >= -4) return 'Eastern Americas';
    if (offsetHours >= -7) return 'Central Americas';
    if (offsetHours >= -9) return 'Western Americas';
    return 'Pacific';
  }
}

// Get a display name for the current location
// Always shows the actual location name, never "Your Area (via IP)" etc.
// Optionally accepts lat/lon to look up a specific location
function getCurrentLocationName(optLat, optLon) {
  // Use provided coordinates or fall back to state
  const lat = optLat ?? state.lat ?? 31.7683;
  const lon = optLon ?? state.lon ?? 35.2137;
  
  // First, try to find city name from known cities (exact match)
  const coordValue = `${lat},${lon}`;
  if (CITY_NAMES[coordValue]) {
    return CITY_NAMES[coordValue];
  }
  
  // Try to find closest city slug match (500km radius)
  const slug = getClosestCitySlug(lat, lon, 500);
  if (slug && CITY_SLUGS[slug]) {
    // Convert slug to display name (capitalize, replace hyphens)
    return slug.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
  }
  
  // If still no match, find the absolute closest city (no limit)
  const closestSlug = getClosestCitySlug(lat, lon, Infinity);
  if (closestSlug && CITY_SLUGS[closestSlug]) {
    const cityName = closestSlug.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
    return `Near ${cityName}`;
  }
  
  // Last resort: region name based on longitude
  return getTimezoneFromLongitude(lon);
}

// Refresh location via IP if the current profile uses "Your Location"
function refreshLocationIfNeeded() {
  const profileId = state.selectedProfile || 'timeTested';
  const profile = PROFILES[profileId];
  
  // Only refresh for profiles with useCurrentLocation
  if (!profile || !profile.useCurrentLocation) return;
  
  // Use IP-based geolocation (no permission prompt)
  getLocationFromIP()
    .then(location => {
      if (location) {
        const newLat = Math.round(location.lat * 10000) / 10000;
        const newLon = Math.round(location.lon * 10000) / 10000;
        
        // Only update if location has changed significantly (>0.01 degrees â‰ˆ 1km)
        if (Math.abs(newLat - state.lat) > 0.01 || Math.abs(newLon - state.lon) > 0.01) {
          state.lat = newLat;
          state.lon = newLon;
          state.city = 'ip-based';
          state.locationSource = 'ip';
          
          // Update UI
          document.getElementById('lat-input').value = state.lat;
          document.getElementById('lon-input').value = state.lon;
          
          // Regenerate calendar with new location
          saveState();
          generateCalendar({ preserveMonth: true });
          renderSettingsPageMap();
        }
      }
    })
    .catch(error => {
      // Silently fail - keep existing location
      console.log('IP geolocation refresh failed, keeping saved location');
    });
}

// Check if a profile name is unique
function isProfileNameUnique(name, excludeId = null) {
  const normalizedName = name.trim().toLowerCase();
  for (const [id, profile] of Object.entries(PROFILES)) {
    if (id !== excludeId && profile.name.toLowerCase() === normalizedName) {
      return false;
    }
  }
  return true;
}

// Track modal mode: 'create' or 'edit'
let profileModalMode = 'create';
let profileModalEditId = null;

// Clone current profile settings as a new custom profile
function cloneProfile() {
  const profileId = editingProfileId || state.selectedProfile;
  const currentProfile = PROFILES[profileId];
  
  // Suggest a name based on current profile
  const suggestedName = currentProfile ? currentProfile.name + ' Copy' : 'My Profile';
  
  showProfileModal('create', suggestedName);
}

// Edit the name of the current custom profile
function editProfileName() {
  const profileId = editingProfileId || state.selectedProfile;
  
  // Can't edit presets
  if (PRESET_PROFILES[profileId]) return;
  
  const currentProfile = PROFILES[profileId];
  if (!currentProfile) return;
  
  showProfileModal('edit', currentProfile.name, profileId);
}

function showProfileModal(mode, defaultName, editId = null) {
  profileModalMode = mode;
  profileModalEditId = editId;
  
  const overlay = document.getElementById('profile-modal-overlay');
  const input = document.getElementById('profile-modal-input');
  const error = document.getElementById('profile-modal-error');
  const title = document.getElementById('profile-modal-title');
  const saveBtn = document.getElementById('profile-modal-save-btn');
  
  title.textContent = mode === 'edit' ? 'Rename Profile' : 'Create New Profile';
  saveBtn.textContent = mode === 'edit' ? 'Save' : 'Create';
  
  input.value = defaultName || '';
  error.textContent = '';
  overlay.classList.add('visible');
  
  // Focus and select the input text
  setTimeout(() => {
    input.focus();
    input.select();
  }, 100);
}

function closeProfileModal(event) {
  // If event exists and target is not the overlay itself, don't close
  if (event && event.target !== event.currentTarget) return;
  
  const overlay = document.getElementById('profile-modal-overlay');
  overlay.classList.remove('visible');
  profileModalMode = 'create';
  profileModalEditId = null;
}

function handleProfileModalKeydown(event) {
  if (event.key === 'Enter') {
    saveProfileModal();
  } else if (event.key === 'Escape') {
    closeProfileModal();
  }
}

function saveProfileModal() {
  const input = document.getElementById('profile-modal-input');
  const error = document.getElementById('profile-modal-error');
  const select = document.getElementById('profile-select');
  
  let name = input.value.trim();
  
  if (!name) {
    error.textContent = 'Please enter a profile name.';
    input.focus();
    return;
  }
  
  // Check for unique name (exclude current profile when editing)
  if (!isProfileNameUnique(name, profileModalEditId)) {
    error.textContent = 'A profile with this name already exists.';
    input.focus();
    return;
  }
  
  // Get the profile being cloned from (editing profile, not necessarily active profile)
  const sourceProfileId = editingProfileId || state.selectedProfile;
  const sourceProfile = PROFILES[sourceProfileId] || {};
  
  if (profileModalMode === 'edit' && profileModalEditId) {
    // Edit existing profile name
    PROFILES[profileModalEditId].name = name;
    saveCustomProfiles();
    rebuildProfileDropdown();
    if (select) select.value = profileModalEditId;
    editingProfileId = profileModalEditId;
  } else {
    // Create new profile based on the currently editing profile's settings
    const id = 'custom_' + Date.now();
    PROFILES[id] = {
      name: name,
      icon: sourceProfile.icon || getProfileIcon(sourceProfile.moonPhase || 'full'),
      moonPhase: sourceProfile.moonPhase || 'full',
      dayStartTime: sourceProfile.dayStartTime || 'morning',
      dayStartAngle: sourceProfile.dayStartAngle ?? 12,
      yearStartRule: sourceProfile.yearStartRule || 'equinox',
      crescentThreshold: sourceProfile.crescentThreshold ?? 18,
      sabbathMode: sourceProfile.sabbathMode || 'lunar',
      lat: sourceProfile.lat ?? state.lat,
      lon: sourceProfile.lon ?? state.lon,
      city: sourceProfile.city || state.city
    };
    
    saveCustomProfiles();
    
    // Switch to editing the new profile (don't apply to calendar yet)
    editingProfileId = id;
    rebuildProfileDropdown();
    if (select) select.value = id;
  }
  
  updateProfileButtonStates();
  updateSettingsEditability();
  
  // Close the modal
  closeProfileModal();
}

// Delete the currently selected custom profile
function deleteCustomProfile() {
  const profileId = editingProfileId || state.selectedProfile;
  
  // Can't delete presets
  if (PRESET_PROFILES[profileId]) return;
  
  const profile = PROFILES[profileId];
  if (!confirm(`Delete profile "${profile.name}"?`)) return;
  
  delete PROFILES[profileId];
  saveCustomProfiles();
  
  // If we deleted the active profile, switch to Time-Tested
  if (profileId === state.selectedProfile) {
    state.selectedProfile = 'timeTested';
    applyProfile('timeTested');
  }
  
  // Reset editing to first available profile
  editingProfileId = 'timeTested';
  rebuildProfileDropdown();
  
  // Switch to Time-Tested preset (Jerusalem)
  applyProfile('timeTested');
}

// Update delete and edit button states based on editing profile
function updateProfileButtonStates() {
  const deleteBtn = document.getElementById('profile-delete-btn');
  const editBtn = document.getElementById('profile-edit-btn');
  
  const profileId = editingProfileId || state.selectedProfile;
  const isPreset = !!PRESET_PROFILES[profileId];
  
  // Delete and edit enabled only for user-saved profiles (not presets)
  if (deleteBtn) deleteBtn.disabled = isPreset;
  if (editBtn) editBtn.disabled = isPreset;
}

// Enable/disable settings controls based on whether editing profile is editable
function updateSettingsEditability() {
  const profileId = editingProfileId || state.selectedProfile;
  const isPreset = !!PRESET_PROFILES[profileId];
  
  // Get all settings controls
  const settingsContainer = document.getElementById('settings-page');
  if (!settingsContainer) return;
  
  // Toggle disabled state on settings buttons and selects (but not profile controls)
  const controls = settingsContainer.querySelectorAll('.settings-option-btn, .settings-select:not(#profile-select), #settings-lat-input, #settings-lon-input');
  controls.forEach(control => {
    if (isPreset) {
      control.disabled = true;
      control.classList.add('disabled');
    } else {
      control.disabled = false;
      control.classList.remove('disabled');
    }
  });
  
  // Also disable/enable the location button
  const locationBtn = settingsContainer.querySelector('.settings-location-btn');
  if (locationBtn) {
    locationBtn.disabled = isPreset;
    locationBtn.classList.toggle('disabled', isPreset);
  }
  
  // Update all maps to show disabled state
  updateMapEditability();
}

// Update map click hint and disabled state based on editing profile
function updateMapEditability() {
  const profileId = editingProfileId || state.selectedProfile;
  const isPreset = !!PRESET_PROFILES[profileId];
  
  // Update all dateline maps
  document.querySelectorAll('.dateline-map').forEach(map => {
    map.classList.toggle('disabled', isPreset);
  });
  
  // Update click hints
  document.querySelectorAll('.dateline-click-hint').forEach(hint => {
    if (isPreset) {
      hint.style.display = 'none';
    } else {
      hint.style.display = '';
    }
  });
}

// Initialize custom profiles on load
loadCustomProfiles();

// Get feast icons for a given lunar month and day
function getFeastIconsForLunarDay(month, day) {
  const icons = [];
  for (const f of FEASTS) {
    if (f.month === month) {
      if (f.endDay) {
        // Multi-day feast
        if (day >= f.day && day <= f.endDay) {
          if (!icons.includes(f.icon)) icons.push(f.icon);
        }
      } else if (f.day === day) {
        // Single-day feast
        if (!icons.includes(f.icon)) icons.push(f.icon);
      }
    }
  }
  return icons;
}

// Switch to a profile and navigate to the same Gregorian date
function switchToProfileAndNavigate(profileId, timestamp) {
  // Store the target date to navigate to after calendar regenerates
  state.pendingNavigationDate = new Date(timestamp);
  
  // Apply the profile (this will trigger calendar regeneration)
  applyProfile(profileId);
}

// Navigate to a pending date after calendar regeneration
function navigateToPendingDate() {
  if (!state.pendingNavigationDate) return;
  
  const targetDateStr = state.pendingNavigationDate.toISOString().split('T')[0];
  state.pendingNavigationDate = null; // Clear the pending navigation
  
  // Find this Gregorian date in the new calendar
  for (let m = 0; m < state.lunarMonths.length; m++) {
    const month = state.lunarMonths[m];
    for (let d = 0; d < month.days.length; d++) {
      const day = month.days[d];
      if (day.gregorianDate.toISOString().split('T')[0] === targetDateStr) {
        state.currentMonthIndex = m;
        state.highlightedLunarDay = day.lunarDay;
        renderMonth(month);
        showDayDetail(day, month);
        return;
      }
    }
  }
}

function applyProfile(profileId) {
  const profile = PROFILES[profileId];
  if (!profile) return;
  
  state.selectedProfile = profileId;
  state.moonPhase = profile.moonPhase;
  state.dayStartTime = profile.dayStartTime;
  state.dayStartAngle = profile.dayStartAngle;
  state.yearStartRule = profile.yearStartRule;
  state.crescentThreshold = profile.crescentThreshold;
  state.sabbathMode = profile.sabbathMode || 'lunar';
  
  if (profile.useLocalLocation) {
    // Use saved location first, then fall back to IP detection
    const savedLocation = getSavedUserLocation();
    if (savedLocation) {
      state.lat = savedLocation.lat;
      state.lon = savedLocation.lon;
      state.city = savedLocation.city || 'saved';
      state.locationSource = 'saved';
      updateLocationUI();
      finishApplyProfile();
    } else {
      // No saved location - use IP-based geolocation
      getLocationFromIP()
        .then(location => {
          if (location) {
            state.lat = location.lat;
            state.lon = location.lon;
            state.city = 'ip-based';
            state.locationSource = 'ip';
            updateLocationUI();
          }
          finishApplyProfile();
        })
        .catch(error => {
          console.log('IP geolocation error, keeping current location');
          finishApplyProfile();
        });
    }
  } else if (profile.lat !== undefined) {
    // Custom profile with fixed location
    state.lat = profile.lat;
    state.lon = profile.lon;
    state.city = profile.city;
    state.locationSource = 'fixed';
    updateLocationUI();
    finishApplyProfile();
  } else {
    finishApplyProfile();
  }
}

// Get saved user location from localStorage
function getSavedUserLocation() {
  try {
    const saved = localStorage.getItem('userDefaultLocation');
    if (saved) {
      return JSON.parse(saved);
    }
  } catch (e) {
    console.error('Error loading saved location:', e);
  }
  return null;
}

// Save user location preference to localStorage
function saveUserLocation(lat, lon, city) {
  try {
    localStorage.setItem('userDefaultLocation', JSON.stringify({ lat, lon, city }));
  } catch (e) {
    console.error('Error saving location:', e);
  }
}

// Get approximate location from IP (no permission required)
async function getLocationFromIP() {
  try {
    // Try ipapi.co first (HTTPS, reliable)
    const response = await fetch('https://ipapi.co/json/', { 
      timeout: 5000,
      cache: 'no-store'
    });
    if (response.ok) {
      const data = await response.json();
      if (data.latitude && data.longitude) {
        return { 
          lat: data.latitude, 
          lon: data.longitude,
          city: data.city,
          country: data.country_name
        };
      }
    }
  } catch (e) {
    console.log('IP geolocation failed:', e);
  }
  return null;
}

// Get exact GPS location (requires user permission) - used in profile editor
function getExactLocation() {
  const profileId = editingProfileId || state.selectedProfile;
  
  // Don't allow changes on preset profiles
  if (PRESET_PROFILES[profileId]) return;
  
  if (!navigator.geolocation) {
    alert('GPS is not available on this device');
    return;
  }
  
  // Show loading indicator
  const btn = document.querySelector('.exact-location-btn');
  if (btn) {
    btn.textContent = 'ðŸ“ Getting location...';
    btn.disabled = true;
  }
  
  navigator.geolocation.getCurrentPosition(
    (position) => {
      const lat = Math.round(position.coords.latitude * 10000) / 10000;
      const lon = Math.round(position.coords.longitude * 10000) / 10000;
      
      // Find nearest city to snap to
      const nearestSlug = getClosestCitySlug(lat, lon, Infinity);
      const nearestCoords = nearestSlug ? CITY_SLUGS[nearestSlug] : { lat, lon };
      const finalLat = nearestCoords.lat;
      const finalLon = nearestCoords.lon;
      
      // Profile editor only updates the profile's location
      if (PROFILES[profileId]) {
        PROFILES[profileId].lat = finalLat;
        PROFILES[profileId].lon = finalLon;
        PROFILES[profileId].city = nearestSlug || 'gps';
        saveCustomProfiles();
      }
      
      // Update settings page inputs
      const settingsLatInput = document.getElementById('settings-lat-input');
      const settingsLonInput = document.getElementById('settings-lon-input');
      const settingsCitySelect = document.getElementById('settings-city-select');
      const settingsCustomCoords = document.getElementById('settings-custom-coords');
      
      // Try to select the nearest city in the dropdown
      const coordValue = `${finalLat},${finalLon}`;
      let found = false;
      if (settingsCitySelect) {
        for (let option of settingsCitySelect.options) {
          if (option.value === coordValue) {
            settingsCitySelect.value = coordValue;
            found = true;
            break;
          }
        }
      }
      
      if (!found) {
        if (settingsCitySelect) settingsCitySelect.value = 'custom';
        if (settingsCustomCoords) settingsCustomCoords.style.display = 'flex';
        if (settingsLatInput) settingsLatInput.value = finalLat;
        if (settingsLonInput) settingsLonInput.value = finalLon;
      } else {
        if (settingsCustomCoords) settingsCustomCoords.style.display = 'none';
      }
      
      renderSettingsPageMap();
      
      // Update button
      if (btn) {
        btn.textContent = 'ðŸ“ Location Saved!';
        setTimeout(() => {
          btn.textContent = 'ðŸ“ Use My Location';
          btn.disabled = false;
        }, 2000);
      }
    },
    (error) => {
      console.log('GPS error:', error);
      alert('Could not get your exact location. Please check your browser permissions.');
      if (btn) {
        btn.textContent = 'ðŸ“ Use Exact Location';
        btn.disabled = false;
      }
    },
    { enableHighAccuracy: true, timeout: 10000 }
  );
}

function updateLocationUI() {
  document.getElementById('lat-input').value = state.lat;
  document.getElementById('lon-input').value = state.lon;
  document.getElementById('city-select').value = state.city || '';
  const settingsCitySelect = document.getElementById('settings-city-select');
  if (settingsCitySelect) settingsCitySelect.value = state.city || '';
}

function finishApplyProfile() {
  // Update all UI elements
  document.getElementById('moon-phase-select').value = state.moonPhase;
  updateMoonPhaseButtons();
  updateDayStartButtons();
  updateYearStartButtons();
  updateCrescentThresholdVisibility();
  updateCrescentThresholdButtons();
  updateSabbathButtons();
  updateProfileButtons();
  updateSettingsEditability();
  
  // Save and regenerate (preserving scroll position)
  saveState();
  regenerateCalendarPreservingScroll();
}

function getMatchingProfile() {
  // Determine which profile matches current state (if any)
  for (const [id, profile] of Object.entries(PROFILES)) {
    if (profile.moonPhase === state.moonPhase &&
        profile.dayStartTime === state.dayStartTime &&
        profile.dayStartAngle === state.dayStartAngle &&
        profile.yearStartRule === state.yearStartRule &&
        profile.crescentThreshold === state.crescentThreshold &&
        (profile.sabbathMode || 'lunar') === state.sabbathMode) {
      // Check location match for non-current-location profiles
      if (profile.useCurrentLocation) {
        // For "current location" profiles, any location works
        return id;
      } else if (Math.abs(profile.lat - state.lat) < 0.01 && Math.abs(profile.lon - state.lon) < 0.01) {
        return id;
      }
    }
  }
  return null; // No matching profile
}

function updateProfileButtons() {
  // Profile settings are now saved directly by individual setting functions
  // This just updates UI state
  updateProfileButtonStates();
}

function onProfileSelectChange(profileId) {
  // Only change which profile is being edited in settings, don't apply to calendar state
  editingProfileId = profileId;
  displayProfileSettings(profileId);
  updateSettingsEditability();
  updateProfileButtonStates();
}

// Display a profile's settings in the settings UI without applying to state
function displayProfileSettings(profileId) {
  const profile = PROFILES[profileId];
  if (!profile) return;
  
  // Update UI to show this profile's settings
  const moonPhaseSelect = document.getElementById('moon-phase-select');
  if (moonPhaseSelect) moonPhaseSelect.value = profile.moonPhase;
  
  // Update moon phase buttons (use 'selected' class for settings buttons)
  document.querySelectorAll('.settings-option-btn[data-phase]').forEach(btn => {
    btn.classList.toggle('selected', btn.dataset.phase === profile.moonPhase);
  });
  
  // Update day start buttons
  document.querySelectorAll('.settings-option-btn[data-day-start]').forEach(btn => {
    btn.classList.toggle('selected', btn.dataset.dayStart === profile.dayStartTime);
  });
  document.querySelectorAll('.settings-option-btn[data-angle]').forEach(btn => {
    const angle = parseInt(btn.dataset.angle);
    btn.classList.toggle('selected', angle === profile.dayStartAngle);
  });
  
  // Update year start buttons
  document.querySelectorAll('.settings-option-btn[data-year-start]').forEach(btn => {
    btn.classList.toggle('selected', btn.dataset.yearStart === profile.yearStartRule);
  });
  
  // Update crescent threshold buttons
  document.querySelectorAll('.settings-option-btn[data-threshold]').forEach(btn => {
    const threshold = parseFloat(btn.dataset.threshold);
    btn.classList.toggle('selected', threshold === (profile.crescentThreshold ?? 18));
  });
  
  // Update sabbath buttons
  document.querySelectorAll('.settings-option-btn[data-sabbath]').forEach(btn => {
    btn.classList.toggle('selected', btn.dataset.sabbath === profile.sabbathMode);
  });
  
  // Update crescent threshold visibility
  const crescentSection = document.getElementById('crescent-threshold-section');
  if (crescentSection) {
    crescentSection.style.display = profile.moonPhase === 'crescent' ? 'block' : 'none';
  }
  
  // Update year start explanations
  const equinoxExplanation = document.getElementById('equinox-rule-explanation');
  if (equinoxExplanation) {
    if (profile.yearStartRule === 'equinox') {
      equinoxExplanation.innerHTML = getEquinoxMethodologyHtml({ showCalculation: false });
      equinoxExplanation.style.display = 'block';
    } else {
      equinoxExplanation.style.display = 'none';
    }
  }
  
  const lambExplanation = document.getElementById('lamb-rule-explanation');
  if (lambExplanation) {
    if (profile.yearStartRule === '13daysBefore') {
      lambExplanation.innerHTML = getPassoverMethodologyHtml({ showCalculation: false });
      lambExplanation.style.display = 'block';
    } else {
      lambExplanation.style.display = 'none';
    }
  }
  
  const virgoExplanation = document.getElementById('virgo-rule-explanation');
  if (virgoExplanation) {
    if (profile.yearStartRule === 'virgoFeet') {
      const virgoCalc = getVirgoCalculation(state.year);
      virgoExplanation.innerHTML = getVirgoMethodologyHtml({ 
        showCalculation: !!virgoCalc, 
        virgoCalc: virgoCalc 
      });
      virgoExplanation.style.display = 'block';
    } else {
      virgoExplanation.style.display = 'none';
    }
  }
  
  // Update location display for this profile
  const profileLat = profile.lat ?? state.lat;
  const profileLon = profile.lon ?? state.lon;
  const citySelect = document.getElementById('settings-city-select');
  const coordValue = `${profileLat},${profileLon}`;
  let found = false;
  
  if (citySelect) {
    for (let option of citySelect.options) {
      if (option.value === coordValue) {
        citySelect.value = coordValue;
        found = true;
        break;
      }
    }
    
    if (!found && (profileLat !== undefined && profileLon !== undefined)) {
      citySelect.value = 'custom';
      document.getElementById('settings-custom-coords').style.display = 'flex';
      document.getElementById('settings-lat-input').value = profileLat;
      document.getElementById('settings-lon-input').value = profileLon;
    } else if (found) {
      document.getElementById('settings-custom-coords').style.display = 'none';
    }
  }
  
  // Update the map to show this profile's location
  renderSettingsPageMap();
}

function resetToDefaults() {
  // Apply Time-Tested profile as default (Jerusalem, no location prompt)
  applyProfile('timeTested');
}

// ============================================================================
// SABBATH TESTER - Test biblical events against calendar theories
// ============================================================================

// Biblical test cases - extensible array
// These tests validate fixed-weekday sabbath theories (Saturday) against biblical events
const BIBLICAL_TESTS = [
  {
    id: 'manna-sabbath',
    name: 'First Sabbath of Manna',
    description: 'Israel arrived in the Wilderness of Sin on the 15th of the Second Month, 1446 BC (Exodus 16:1). Manna first fell on the 16th (the morning after arrival). They gathered manna for 6 days (16th-21st), and the 22nd was explicitly called the Sabbath when no manna fell (Exodus 16:22-26). Therefore, the 22nd of the 2nd month must be a Saturday.',
    scripture: 'Exodus 16:1-26',
    year: -1445,  // Astronomical year (1446 BC = -1445)
    month: 2,     // Second month (Iyar)
    day: 22,
    expectedWeekday: 6,  // Saturday (0=Sun, 6=Sat)
    expectedLabel: 'Saturday',
    location: { lat: 29.1500, lon: 33.4000, name: 'Wilderness of Sin' }
  },
  {
    id: 'first-fruits-1406',
    name: 'First Fruits After Jordan Crossing',
    description: 'The 16th of the First Month, 1406 BC was First Fruits when Israel ate the produce of Canaan for the first time (Joshua 5:10-12). According to Leviticus 23:11, First Fruits is offered "on the day after the Sabbath," which means the 16th should be the first day of the week (Sunday).',
    scripture: 'Joshua 5:10-12, Leviticus 23:11',
    year: -1405,  // Astronomical year (1406 BC = -1405)
    month: 1,     // First month (Nisan)
    day: 16,
    expectedWeekday: 0,  // Sunday (first day of week)
    expectedLabel: 'Sunday',
    location: { lat: 31.8500, lon: 35.4500, name: 'Jericho' }
  },
  {
    id: 'resurrection-32ad',
    name: 'Resurrection of Jesus (32 AD)',
    description: 'Jesus rose from the dead on the first day of the week (Matthew 28:1, Mark 16:2, Luke 24:1, John 20:1), which was also First Fruits (Leviticus 23:11). He was crucified on Passover (14th), rested in the tomb on the 15th, and rose on the 16th. For Saturday to be the weekly Sabbath, this calendar must place the 16th of Nisan 32 AD on Sunday (the day after Saturday).',
    scripture: 'Matthew 28:1, 1 Corinthians 15:20',
    year: 32,  // 32 AD
    month: 1,  // First month (Nisan)
    day: 16,   // First Fruits / Resurrection (must be first day of week)
    expectedWeekday: 0,  // Sunday (first day of week)
    expectedLabel: 'Sunday',
    location: { lat: 31.7683, lon: 35.2137, name: 'Jerusalem' }
  },
  {
    id: 'resurrection-30ad',
    name: 'Resurrection of Jesus (30 AD)',
    description: 'Alternative crucifixion year theory. For Saturday to be the weekly Sabbath, this calendar must place the 16th of Nisan 30 AD on Sunday.',
    scripture: 'Matthew 28:1, 1 Corinthians 15:20',
    year: 30,  // 30 AD
    month: 1,  // First month (Nisan)
    day: 16,   // First Fruits / Resurrection (must be first day of week)
    expectedWeekday: 0,  // Sunday (first day of week)
    expectedLabel: 'Sunday',
    location: { lat: 31.7683, lon: 35.2137, name: 'Jerusalem' },
    excludeFromScore: true  // Alternative theory - don't include in main score
  },
  {
    id: 'resurrection-33ad',
    name: 'Resurrection of Jesus (33 AD)',
    description: 'Alternative crucifixion year theory. For Saturday to be the weekly Sabbath, this calendar must place the 16th of Nisan 33 AD on Sunday.',
    scripture: 'Matthew 28:1, 1 Corinthians 15:20',
    year: 33,  // 33 AD
    month: 1,  // First month (Nisan)
    day: 16,   // First Fruits / Resurrection (must be first day of week)
    expectedWeekday: 0,  // Sunday (first day of week)
    expectedLabel: 'Sunday',
    location: { lat: 31.7683, lon: 35.2137, name: 'Jerusalem' },
    excludeFromScore: true  // Alternative theory - don't include in main score
  },
  {
    id: 'temple1-talmud',
    name: 'First Temple Destruction (Talmud)',
    description: 'The Talmud (Ta\'anit 29a) claims both Temples fell on the 9th of Av "at the conclusion of Shabbat" (post-Sabbath, i.e., Sunday). The Talmud reconciles biblical accounts (7th in 2 Kings, 10th in Jeremiah) by describing a multi-day process where the fire was set toward the end of the 9th. This tests whether the 9th of Av falls on Sunday according to Talmudic tradition.',
    scripture: 'Talmud Ta\'anit 29a, Arakhin 11b',
    year: -585,  // Astronomical year (586 BC = -585)
    month: 5,    // Fifth month (Av)
    day: 9,      // 9th of Av per Talmud
    expectedWeekday: 0,  // Sunday (first day of week, "post-Shabbat")
    expectedLabel: 'Sunday',
    location: { lat: 31.7683, lon: 35.2137, name: 'Jerusalem' },
    excludeFromScore: true  // Extra-biblical tradition test
  },
  {
    id: 'temple2-talmud',
    name: 'Second Temple Destruction (Talmud)',
    description: 'The Talmud claims the Second Temple also fell on the 9th of Av "at the conclusion of Shabbat" (Sunday), mirroring the First Temple. Josephus records the destruction on the 10th and notes the Romans built siege ramps on the 8th while Jews rested (implying the 8th was a Sabbath). This tests the Talmudic claim that 9th of Av was Sunday.',
    scripture: 'Talmud Ta\'anit 29a, Josephus Jewish War 6.4',
    year: 70,    // 70 AD
    month: 5,    // Fifth month (Av)
    day: 9,      // 9th of Av per Talmud
    expectedWeekday: 0,  // Sunday (first day of week, "post-Shabbat")
    expectedLabel: 'Sunday',
    location: { lat: 31.7683, lon: 35.2137, name: 'Jerusalem' },
    excludeFromScore: true  // Extra-biblical tradition test
  }
];

// Generate test profiles dynamically (Saturday sabbath with Jerusalem location)
// Check if a test profile configuration matches a preset profile
function getMatchingPresetName(profile) {
  for (const [presetId, preset] of Object.entries(PRESET_PROFILES)) {
    // Must match sabbath mode (only show presets that are Saturday sabbath for the tester)
    if (preset.sabbathMode !== 'saturday') continue;
    
    if (profile.moonPhase === preset.moonPhase &&
        profile.dayStartTime === preset.dayStartTime &&
        profile.yearStartRule === preset.yearStartRule &&
        (profile.moonPhase !== 'crescent' || profile.crescentThreshold === (preset.crescentThreshold || 18))) {
      return preset.name;
    }
  }
  return null;
}

function getSabbathTestProfiles() {
  const profiles = [];
  
  // Moon phases to test
  const moonPhases = [
    { id: 'full', name: 'Full Moon', icon: 'ðŸŒ•' },
    { id: 'dark', name: 'Dark Moon', icon: 'ðŸŒ‘' },
    { id: 'crescent', name: 'Crescent Moon', icon: 'ðŸŒ’' }
  ];
  
  // Day start times to test
  const dayStarts = [
    { id: 'morning', name: 'Daybreak', angle: 12 },
    { id: 'evening', name: 'Sunset', angle: 0 }
  ];
  
  // Year start rules to test
  const yearRules = [
    { id: 'equinox', name: 'Sun Scale', icon: 'âš–ï¸' },  // New Moon on or after Equinox
    { id: '13daysBefore', name: 'Lamb', icon: 'ðŸ‘' }   // Day 15 (Unleavened) on or after Equinox
  ];
  
  for (const moon of moonPhases) {
    for (const dayStart of dayStarts) {
      for (const yearRule of yearRules) {
        const profile = {
          id: `test-${moon.id}-${dayStart.id}-${yearRule.id}`,
          name: `${moon.icon} ${moon.name} ${dayStart.name} ${yearRule.icon}`,
          moonPhase: moon.id,
          dayStartTime: dayStart.id,
          dayStartAngle: dayStart.angle,
          yearStartRule: yearRule.id,
          crescentThreshold: 18,
          sabbathMode: 'saturday',
          lat: 31.7683,  // Jerusalem
          lon: 35.2137
        };
        
        // Check if this matches a preset
        const presetName = getMatchingPresetName(profile);
        if (presetName) {
          profile.presetName = presetName;
          profile.name += ` (${presetName})`;
        }
        
        profiles.push(profile);
      }
    }
  }
  
  // Sort profiles: presets first, then alphabetically
  profiles.sort((a, b) => {
    if (a.presetName && !b.presetName) return -1;
    if (!a.presetName && b.presetName) return 1;
    return a.name.localeCompare(b.name);
  });
  
  return profiles;
}

// Run a single biblical test against a profile
function runBiblicalTest(test, profile) {
  try {
    // Save current state
    const savedState = {
      moonPhase: state.moonPhase,
      dayStartTime: state.dayStartTime,
      dayStartAngle: state.dayStartAngle,
      yearStartRule: state.yearStartRule,
      crescentThreshold: state.crescentThreshold,
      sabbathMode: state.sabbathMode,
      lat: state.lat,
      lon: state.lon,
      year: state.year
    };
    
    // Apply profile settings temporarily
    state.moonPhase = profile.moonPhase;
    state.dayStartTime = profile.dayStartTime;
    state.dayStartAngle = profile.dayStartAngle;
    state.yearStartRule = profile.yearStartRule;
    state.crescentThreshold = profile.crescentThreshold;
    state.sabbathMode = profile.sabbathMode;
    state.lat = test.location.lat;
    state.lon = test.location.lon;
    state.year = test.year;
    
    const engine = getAstroEngine();
    
    // Find moon events for the test year
    const moonEvents = findMoonEvents(test.year, profile.moonPhase);
    if (!moonEvents || moonEvents.length === 0) {
      Object.assign(state, savedState);
      return { result: 'error', error: 'No moon events found' };
    }
    
    // Get the year start point based on yearStartRule
    // For 'equinox': first moon on or after spring equinox
    // For '13daysBefore': first moon such that Day 15 (Unleavened) is on or after equinox
    const springEquinox = engine.getSeasons(test.year).mar_equinox.date;
    let yearStartPoint;
    
    if (profile.yearStartRule === '13daysBefore') {
      // Day 15 (Unleavened Bread) must be on or after equinox (per Maimonides)
      // So the moon event must be at least 14 days before equinox
      yearStartPoint = new Date(springEquinox.getTime() - 14 * 24 * 60 * 60 * 1000);
    } else {
      // Default: moon on or after equinox
      yearStartPoint = springEquinox;
    }
    
    // Find the Nisan moon (first moon on or after year start point)
    // moonEvents is an array of Date objects directly
    let nissanMoonIdx = moonEvents.findIndex(e => e >= yearStartPoint);
    if (nissanMoonIdx === -1) {
      Object.assign(state, savedState);
      return { result: 'error', error: 'Could not find Nisan moon' };
    }
    
    // Calculate year-start uncertainty
    // If Nisan moon is close to year start point, Î”T could cause wrong moon selection
    const nissanMoon = moonEvents[nissanMoonIdx];
    const yearStartMarginMs = nissanMoon.getTime() - yearStartPoint.getTime();
    const yearStartMarginHours = yearStartMarginMs / (1000 * 60 * 60);
    const deltaTUncertaintyHours = AstroEngines.nasaEclipse.getDeltaTUncertainty(test.year);
    
    let yearUncertainty = null;
    if (deltaTUncertaintyHours > 0 && yearStartMarginHours <= deltaTUncertaintyHours) {
      // Nisan moon is close to boundary - year selection could be wrong
      const yearUncertaintyProb = Math.round(((deltaTUncertaintyHours - yearStartMarginHours) / (2 * deltaTUncertaintyHours)) * 100);
      if (yearUncertaintyProb > 0) {
        yearUncertainty = {
          direction: 'ahead',  // Our dates are potentially 1 month ahead
          probability: yearUncertaintyProb,
          marginHours: yearStartMarginHours
        };
      }
    }
    
    // Calculate which moon event corresponds to the test month
    const targetMoonIdx = nissanMoonIdx + (test.month - 1);
    if (targetMoonIdx >= moonEvents.length) {
      Object.assign(state, savedState);
      return { result: 'error', error: 'Month out of range' };
    }
    
    // findMoonEvents returns array of Date objects directly
    const moonEventDate = moonEvents[targetMoonIdx];
    
    // Calculate Day 1 of that month
    const dayStartTime = getDayStartTime(moonEventDate);
    const moonEventTs = moonEventDate.getTime();
    
    // Use the same logic as the calendar's buildLunarMonths function
    // Get local date of moon event adjusted for observer longitude
    const observerLon = test.location.lon;
    const moonEventLocalDate = getLocalDateFromUTC(moonEventDate, observerLon);
    
    let day1Date = new Date(moonEventLocalDate.getTime());
    
    // For all moon phases (dark, full, crescent), the moonEventDate already has any
    // necessary offset applied (crescent offset is added in findMoonEvents).
    // The calculation for Day 1 is the same regardless of phase.
    if (profile.dayStartTime === 'evening') {
      const sunsetOnMoonDate = getSunsetTimestamp(moonEventLocalDate);
      if (sunsetOnMoonDate != null) {
        const moonEventLocalTime = moonEventDate.getTime() + (observerLon / 15) * 60 * 60 * 1000;
        const sunsetLocalTime = sunsetOnMoonDate + (observerLon / 15) * 60 * 60 * 1000;
        if (moonEventLocalTime > sunsetLocalTime) {
          day1Date.setUTCDate(day1Date.getUTCDate() + 1);
        }
      }
    } else if (profile.dayStartTime === 'morning') {
      const sunriseOnMoonDate = getSunriseTimestamp(moonEventLocalDate);
      if (sunriseOnMoonDate != null) {
        const moonEventLocalTime = moonEventDate.getTime() + (observerLon / 15) * 60 * 60 * 1000;
        const sunriseLocalTime = sunriseOnMoonDate + (observerLon / 15) * 60 * 60 * 1000;
        if (moonEventLocalTime >= sunriseLocalTime) {
          day1Date.setUTCDate(day1Date.getUTCDate() + 1);
        }
      }
    } else {
      day1Date.setUTCDate(day1Date.getUTCDate() + 1);
    }
    
    // Calculate the target lunar day's Gregorian date
    const targetDayDate = new Date(day1Date);
    targetDayDate.setUTCDate(targetDayDate.getUTCDate() + (test.day - 1));
    
    // Get the weekday using correct Julian calendar calculation
    const calculatedWeekday = getCorrectWeekday(targetDayDate);
    const weekdayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    const calculatedWeekdayName = weekdayNames[calculatedWeekday];
    
    // Calculate actual margin between moon event and day boundary
    const uncertaintyHours = AstroEngines.nasaEclipse.getDeltaTUncertainty(test.year);
    let marginHours = Infinity;
    let dateUncertaintyProbability = 0;
    let dateUncertaintyDirection = null;
    
    if (uncertaintyHours > 0) {
      const moonEventLocalTime = moonEventDate.getTime() + (observerLon / 15) * 60 * 60 * 1000;
      
      // Get the day boundary time based on day start setting
      let boundaryTime;
      if (profile.dayStartTime === 'evening') {
        boundaryTime = getSunsetTimestamp(moonEventLocalDate);
      } else {
        boundaryTime = getSunriseTimestamp(moonEventLocalDate);
      }
      
      if (boundaryTime != null) {
        const boundaryLocalTime = boundaryTime + (observerLon / 15) * 60 * 60 * 1000;
        const marginMs = Math.abs(moonEventLocalTime - boundaryLocalTime);
        marginHours = marginMs / (1000 * 60 * 60);
        
        if (marginHours <= uncertaintyHours) {
          // Calculate probability that the date is wrong
          // If margin is M and uncertainty is Â±U, probability = (U - M) / (2U)
          dateUncertaintyProbability = Math.round(((uncertaintyHours - marginHours) / (2 * uncertaintyHours)) * 100);
          
          // Determine direction
          if (moonEventLocalTime >= boundaryLocalTime) {
            dateUncertaintyDirection = '-'; // Dates could be 1 day earlier
          } else {
            dateUncertaintyDirection = '+'; // Dates could be 1 day later
          }
        }
      }
    }
    
    // Determine result based on actual margin-based uncertainty
    // Check if there's significant uncertainty (margin within Î”T uncertainty)
    const hasUncertainty = marginHours <= uncertaintyHours && uncertaintyHours > 0;
    
    let result, probability = null;
    
    if (calculatedWeekday === test.expectedWeekday) {
      // Calculated matches expected
      if (hasUncertainty) {
        // Pass but with uncertainty - show as caution with % chance of passing
        result = 'uncertain';
        probability = 100 - dateUncertaintyProbability; // Probability we're correct (chance of passing)
      } else {
        result = 'pass';
        probability = null;
      }
    } else {
      // Calculated doesn't match expected
      // Check if the alternative date (shifted by uncertainty direction) would match
      let alternativeWeekday = null;
      if (dateUncertaintyDirection === '-') {
        // Dates could be 1 day earlier, so weekday would be previous day
        alternativeWeekday = (calculatedWeekday + 6) % 7;
      } else if (dateUncertaintyDirection === '+') {
        // Dates could be 1 day later, so weekday would be next day
        alternativeWeekday = (calculatedWeekday + 1) % 7;
      }
      
      if (hasUncertainty && alternativeWeekday === test.expectedWeekday) {
        // Alternative date would match - show as caution with % chance of passing
        result = 'uncertain';
        probability = dateUncertaintyProbability; // Probability the alternative is correct (chance of passing)
      } else {
        // Neither calculated nor alternative matches - definite fail
        result = 'fail';
      }
    }
    
    // Debug: log uncertainty details for ancient dates
    if (uncertaintyHours > 0 && profile === getSabbathTestProfiles()[0]) {
      console.log(`[Test Debug] ${test.name}: marginHours=${marginHours.toFixed(2)}, uncertaintyHours=${uncertaintyHours}, ` +
        `dateUncertaintyProb=${dateUncertaintyProbability}%, direction=${dateUncertaintyDirection}, ` +
        `calculated=${calculatedWeekdayName}, expected=${test.expectedLabel}, result=${result}`);
    }
    
    // Restore state
    Object.assign(state, savedState);
    
    return {
      result,
      calculatedWeekday,
      calculatedWeekdayName,
      gregorianDate: targetDayDate,
      uncertaintyHours,
      marginHours,
      probability,
      dateUncertaintyProbability,
      dateUncertaintyDirection,
      moonEventDate,
      yearUncertainty
    };
  } catch (e) {
    console.error('Error running biblical test:', e);
    return { result: 'error', error: e.message };
  }
}

// Store pending test navigation data
let pendingTestNavigation = null;

// Navigate to a specific date on a test profile
function navigateToTestResult(testId, profileId) {
  // Find the test and profile from stored data
  const test = BIBLICAL_TESTS.find(t => t.id === testId);
  const profiles = getSabbathTestProfiles();
  const profile = profiles.find(p => p.id === profileId);
  
  if (!test || !profile) {
    console.error('Test or profile not found:', testId, profileId);
    return;
  }
  
  // Create a temporary profile with the test settings
  const tempProfileId = 'sabbath-test-temp';
  PROFILES[tempProfileId] = {
    name: 'Sabbath Test',
    icon: profile.moonPhase === 'full' ? 'ðŸŒ•' : profile.moonPhase === 'dark' ? 'ðŸŒ‘' : 'ðŸŒ’',
    ...profile
  };
  
  // Apply the profile settings
  state.selectedProfile = tempProfileId;
  state.moonPhase = profile.moonPhase;
  state.dayStartTime = profile.dayStartTime;
  state.dayStartAngle = profile.dayStartAngle;
  state.yearStartRule = profile.yearStartRule;
  state.crescentThreshold = profile.crescentThreshold;
  state.sabbathMode = profile.sabbathMode;
  state.lat = test.location.lat;
  state.lon = test.location.lon;
  state.year = test.year;
  
  // Update UI inputs BEFORE generateCalendar (which reads from them)
  document.getElementById('year-input').value = test.year;
  document.getElementById('lat-input').value = test.location.lat;
  document.getElementById('lon-input').value = test.location.lon;
  document.getElementById('moon-phase-select').value = profile.moonPhase;
  
  // Generate calendar for this year
  generateCalendar({ preserveMonth: false });
  
  // Find the month and day in the generated calendar
  const targetMonth = state.lunarMonths.find(m => m.monthNumber === test.month);
  if (targetMonth) {
    state.currentMonthIndex = state.lunarMonths.indexOf(targetMonth);
    const targetDay = targetMonth.days.find(d => d.lunarDay === test.day);
    if (targetDay) {
      state.highlightedLunarDay = test.day;
    }
  }
  
  // Hide sabbath tester page
  document.getElementById('sabbath-tester-page').style.display = 'none';
  
  // Show calendar
  const calendarOutput = document.getElementById('calendar-output');
  const dayDetailPanel = document.getElementById('day-detail-panel');
  calendarOutput.style.display = 'block';
  
  // Render the month
  renderMonth(state.lunarMonths[state.currentMonthIndex]);
  updateMonthButtons();
  
  // Build URL using the new path format
  // Use pushState so back button returns to tester
  const newURL = buildPathURL({ includeMonth: true });
  window.history.pushState({ fromTester: true }, '', newURL);
  
  // Show day detail
  if (state.highlightedLunarDay) {
    const month = state.lunarMonths[state.currentMonthIndex];
    const dayObj = month.days.find(d => d.lunarDay === state.highlightedLunarDay);
    if (dayObj) {
      dayDetailPanel.classList.remove('hidden');
      dayDetailPanel.style.display = '';
      showDayDetail(dayObj, month);
    }
  }
  
  // Clean up temporary profile
  delete PROFILES[tempProfileId];
}

// Format a Gregorian date for ancient dates
function formatAncientDate(date, includeWeekday = true) {
  const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  const weekdays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
  
  const weekday = weekdays[getCorrectWeekday(date)];
  const monthName = months[date.getUTCMonth()];
  const day = date.getUTCDate();
  const year = date.getUTCFullYear();
  const yearStr = year < 0 ? `${Math.abs(year) + 1} BC` : `${year} AD`;
  
  if (includeWeekday) {
    return `${weekday}, ${monthName} ${day}, ${yearStr}`;
  }
  return `${monthName} ${day}, ${yearStr}`;
}

// Render the Sabbath Tester page
// Cache version for sabbath tester results - increment when test logic changes
const SABBATH_TESTER_CACHE_VERSION = 'v5';

function renderSabbathTester() {
  const loadingEl = document.getElementById('sabbath-tester-loading');
  const resultsEl = document.getElementById('sabbath-tester-results');
  
  // Check for cached results
  const cacheKey = 'sabbathTesterResults';
  const cacheVersionKey = 'sabbathTesterVersion';
  const cachedVersion = localStorage.getItem(cacheVersionKey);
  const cachedHtml = localStorage.getItem(cacheKey);
  
  if (cachedVersion === SABBATH_TESTER_CACHE_VERSION && cachedHtml) {
    // Use cached results
    loadingEl.style.display = 'none';
    resultsEl.innerHTML = cachedHtml;
    return;
  }
  
  loadingEl.style.display = 'block';
  resultsEl.innerHTML = '';
  
  // Use setTimeout to allow UI to update
  setTimeout(() => {
    const profiles = getSabbathTestProfiles();
    const allResults = [];
    
    // Run all tests against all profiles
    for (const test of BIBLICAL_TESTS) {
      const testResults = [];
      for (const profile of profiles) {
        const result = runBiblicalTest(test, profile);
        testResults.push({
          profile,
          ...result
        });
      }
      allResults.push({
        test,
        results: testResults
      });
    }
    
    // Calculate scoreboard
    const scoreboard = {};
    // Also calculate base scores excluding 32 AD for alternative year comparisons
    const baseScoreWithout32AD = {};
    // Track individual test results per profile for expandable details
    const testResultsByProfile = {};
    
    for (const profile of profiles) {
      scoreboard[profile.id] = {
        profile,
        passed: 0,
        failed: 0,
        uncertain: 0,
        totalScore: 0
      };
      baseScoreWithout32AD[profile.id] = {
        totalScore: 0,
        testResults: [] // Track individual test results for alt-score breakdown
      };
      testResultsByProfile[profile.id] = [];
    }
    
    for (const { test, results } of allResults) {
      for (const r of results) {
        const score = scoreboard[r.profile.id];
        const baseScore = baseScoreWithout32AD[r.profile.id];
        // Only count towards score if test is not excluded
        const countsForScore = !test.excludeFromScore;
        // For base score, exclude both excluded tests AND the 32 AD test
        const countsForBaseScore = !test.excludeFromScore && test.id !== 'resurrection-32ad';
        
        // Store test result for this profile (only scored tests)
        if (countsForScore) {
          testResultsByProfile[r.profile.id].push({
            testName: test.name,
            testId: test.id,
            result: r.result,
            probability: r.probability
          });
        }
        
        if (r.result === 'pass') {
          if (countsForScore) {
            score.passed++;
            score.totalScore += 1; // Pass = 1
          }
          if (countsForBaseScore) {
            baseScore.totalScore += 1;
            baseScore.testResults.push({ testName: test.name, testId: test.id, result: 'pass' });
          }
        } else if (r.result === 'uncertain') {
          if (countsForScore) {
            score.uncertain++;
            // Uncertain = probability / 100 (e.g., 55% = 0.55)
            score.totalScore += (r.probability || 50) / 100;
          }
          if (countsForBaseScore) {
            baseScore.totalScore += (r.probability || 50) / 100;
            baseScore.testResults.push({ testName: test.name, testId: test.id, result: 'uncertain', probability: r.probability });
          }
        } else if (r.result === 'fail') {
          if (countsForScore) {
            score.failed++;
            // Fail = 0
          }
          if (countsForBaseScore) {
            baseScore.testResults.push({ testName: test.name, testId: test.id, result: 'fail' });
          }
          // Fail adds 0 to base score too (nothing to add)
        }
      }
    }
    
    // Sort scoreboard: by passes (desc), then fails (asc), then score (desc)
    const sortedScores = Object.values(scoreboard).sort((a, b) => {
      // First: more passes is better
      if (b.passed !== a.passed) return b.passed - a.passed;
      // Second: fewer fails is better
      if (a.failed !== b.failed) return a.failed - b.failed;
      // Third: higher score is better (for uncertain probabilities)
      return b.totalScore - a.totalScore;
    });
    
    // Build HTML
    let html = '';
    
    // Summary Scoreboard
    html += `
      <div class="sabbath-scoreboard">
        <div class="sabbath-scoreboard-title">ðŸ“Š Summary Scoreboard</div>
        <div class="sabbath-scoreboard-intro">
          <p>This scoreboard tests each calendar configuration against biblical events where both the lunar date and weekday can be determined from Scripture. Tests include the first Sabbath of Manna (Exodus 16), the First Fruits offering after crossing the Jordan (Joshua 5), and the Resurrection on First Fruits (Matthew 28).</p>
          <div class="scoreboard-conclusion">
            <p><strong>Key Finding:</strong> The <span class="result-pass">Lunar Sabbath</span> is compatible with all scored tests. It is also compatible with Rabbinic tradition that both Temples fell "the day after the Sabbath" (Talmud Ta'anit 29a) and Josephus' record that Romans built siege ramps on the Sabbath when the 8th of Av fell on that day.</p>
            <p>For <span class="result-uncertain">Saturday Sabbath</span> to be compatible, only one specific configuration works: <strong>33 AD crucifixion, Full Moon month start, Sunset day start, and Lamb (early) year start</strong>. This requires assuming 33 AD despite the chronological cautions noted below, and abandons the crescent moon tradition while adopting the full moon start.</p>
          </div>
        </div>
        <table class="sabbath-scoreboard-table">
          <thead>
            <tr>
              <th>Calendar Profile</th>
              <th>Score</th>
            </tr>
          </thead>
          <tbody>
    `;
    
    const numTests = BIBLICAL_TESTS.filter(t => !t.excludeFromScore).length;
    for (const score of sortedScores) {
      // Score = sum / num tests, expressed as percentage
      const pct = Math.round((score.totalScore / numTests) * 100);
      let scoreClass = 'score-poor';
      if (pct >= 90) scoreClass = 'score-perfect';
      else if (pct >= 70) scoreClass = 'score-good';
      else if (pct >= 50) scoreClass = 'score-medium';
      
      // Build test breakdown for this profile
      const profileTests = testResultsByProfile[score.profile.id] || [];
      const passedTests = profileTests.filter(t => t.result === 'pass');
      const failedTests = profileTests.filter(t => t.result === 'fail');
      const uncertainTests = profileTests.filter(t => t.result === 'uncertain');
      
      // Helper to format test names, keeping year info for resurrection tests
      const formatName = (t) => {
        if (t.testId === 'resurrection-32ad') return 'Resurrection 32 AD';
        return t.testName.replace(/ \([^)]+\)$/, '');
      };
      
      let testBreakdown = '<div class="score-breakdown">';
      if (passedTests.length > 0) {
        testBreakdown += '<div class="breakdown-section"><span class="breakdown-label result-pass">âœ… Passed:</span> ';
        testBreakdown += passedTests.map(formatName).join(', ');
        testBreakdown += '</div>';
      }
      if (uncertainTests.length > 0) {
        testBreakdown += '<div class="breakdown-section"><span class="breakdown-label result-uncertain">âš ï¸ Uncertain:</span> ';
        testBreakdown += uncertainTests.map(t => `${formatName(t)} (${t.probability}%)`).join(', ');
        testBreakdown += '</div>';
      }
      if (failedTests.length > 0) {
        testBreakdown += '<div class="breakdown-section"><span class="breakdown-label result-fail">âŒ Failed:</span> ';
        testBreakdown += failedTests.map(formatName).join(', ');
        testBreakdown += '</div>';
      }
      testBreakdown += '</div>';
      
      const rowId = `scoreboard-row-${score.profile.id.replace(/[^a-zA-Z0-9]/g, '-')}`;
      
      html += `
        <tr class="scoreboard-expandable" onclick="toggleScoreboardRow('${rowId}')">
          <td><span class="expand-arrow">â–¶</span> ${score.profile.name}</td>
          <td class="${scoreClass}">${pct}%</td>
        </tr>
        <tr class="scoreboard-details" id="${rowId}" style="display: none;">
          <td colspan="2">${testBreakdown}</td>
        </tr>
      `;
    }
    
    html += `
          </tbody>
        </table>
      </div>
    `;
    
    // Individual Test Cards
    for (const { test, results } of allResults) {
      const yearDisplay = test.year < 0 ? `${Math.abs(test.year) + 1} BC` : `${test.year} AD`;
      const excludedNote = test.excludeFromScore ? ' <span style="font-size: 0.8em; color: #888;">(not scored)</span>' : '';
      
      html += `
        <div class="sabbath-test-card">
          <div class="sabbath-test-title">
            <span>ðŸ“œ ${test.name}${excludedNote}</span>
          </div>
          <div class="sabbath-test-date">
            ${test.day}${getDaySuffix(test.day)} of Month ${test.month}, ${yearDisplay}
          </div>
          <div class="sabbath-test-scripture">${test.scripture}</div>
          <div class="sabbath-test-description">${test.description}</div>
          ${test.id === 'resurrection-32ad' ? `
          <details class="test-evidence-accordion">
            <summary>ðŸ“– Why 32 AD? See the Evidence</summary>
            <div class="test-evidence-content">
              <p>Multiple independent chronological anchors converge on 32 AD:</p>
              <ul>
                <li><strong>Tiberius' 15th Year (Fall 28-29 AD)</strong> â€” John the Baptist began his ministry in the 15th year of Tiberius (Luke 3:1-2). Standard Roman historiography dates this to fall 28 â€“ fall 29 AD.</li>
                <li><strong>Year of Release (Fall 29 AD)</strong> â€” Jesus proclaimed "the year of the Lord's favor" in Nazareth (Luke 4:18-19). This sabbatical year proclamation aligns with Day of Atonement 29 AD, based on the 7-year cycle from the Jordan crossing in 1406 BC.</li>
                <li><strong>46 Years Building the Temple (30 AD)</strong> â€” At the first Passover in John's Gospel, the Jews said the temple had been under construction 46 years (John 2:20). Herod began rebuilding ~17-16 BC, placing this first Passover in spring 30 AD.</li>
                <li><strong>Three Passovers in John</strong> â€” John explicitly mentions three Passovers: 30 AD (John 2:13), 31 AD (John 6:4), and the final Passover 32 AD (John 11:55).</li>
                <li><strong>Daniel's 490-Year Prophecy (32 AD)</strong> â€” The decree to restore Jerusalem was issued in Artaxerxes' 7th year, spring 458 BC (Ezra 7:7-9). The 490th year lands on spring 32 AD (Daniel 9:24-25).</li>
                <li><strong>Passover Solar Eclipse (April 28, 32 AD)</strong> â€” NASA documents a partial solar eclipse visible in Jerusalem at midday on Passover 32 AD, matching the darkness recorded in Matthew 27:45.</li>
              </ul>
              <p>These independent lines of evidenceâ€”Tiberius' reign, the sabbatical cycle, temple construction, John's Passovers, Daniel's prophecy, and astronomical dataâ€”all align naturally on 32 AD without requiring ad hoc adjustments.</p>
              <p style="margin-top: 15px;"><a href="/chapters/12-32-ad-resurrection/" style="color: #7ec8e3;">ðŸ“– Read the full chapter: 32 AD Resurrection</a></p>
            </div>
          </details>
          ` : ''}
          ${test.id === 'resurrection-33ad' ? `
          <details class="test-evidence-accordion">
            <summary>âš ï¸ Cautions with 33 AD</summary>
            <div class="test-evidence-content">
              <p>While 33 AD is a popular alternative, it requires assumptions that conflict with other evidence:</p>
              <ul>
                <li><strong>Exceeds Daniel's 490 Years</strong> â€” The decree to restore Jerusalem was issued in Artaxerxes' 7th year, spring 458 BC (Ezra 7:7-9). The 490th year ends spring 32 AD (Daniel 9:24-25). A 33 AD crucifixion falls in the 491st year, requiring non-literal or non-inclusive counting of Daniel's prophecy.</li>
                <li><strong>Requires Undocumented 4th Passover</strong> â€” John explicitly mentions only three Passovers during Jesus' ministry (John 2:13, 6:4, 11:55). For 33 AD to work with John's ministry starting fall 28-29 AD (Tiberius' 15th year), a fourth unrecorded Passover must be assumed, extending to a 4-year ministry.</li>
                <li><strong>No Passover Solar Eclipse</strong> â€” NASA documents a partial solar eclipse visible in Jerusalem at midday on April 28, 32 AD, matching the darkness at the cross (Matthew 27:45). There is no similar eclipse alignment for Passover 33 AD. Phlegon's record placing it in the "4th year of the 202nd Olympiad" (July 32 â€“ July 33 AD) is approximate and written 105+ years after the event.</li>
              </ul>
              <p>These issues don't necessarily disprove 33 AD, but they require ad hoc adjustments that are unnecessary with a 32 AD crucifixion date.</p>
              <p style="margin-top: 15px;"><a href="/chapters/12-32-ad-resurrection/" style="color: #7ec8e3;">ðŸ“– Read the full chapter: 32 AD Resurrection</a></p>
            </div>
          </details>
          <div class="test-interpretation">
            <p><strong>Interpreting the Results Below:</strong></p>
            <ul>
              <li><strong>Traditional April 3rd Friday</strong> â€” The popular "April 3, 33 AD" Friday crucifixion date relies on the crescent moon calendar with the Lamb (Passover after equinox) year start rule. However, this assumes the crescent sighting was delayed by one day when astronomical calculations show it would have been clearly visible the evening before.</li>
              <li><strong>Other Passing Calendars Break Tradition</strong> â€” Any other calendar configuration that places the 16th on Sunday in 33 AD requires abandoning traditional assumptions: either using equinox-based year start instead of the Lamb rule, adopting full moon month starts instead of crescent, or starting the day at daybreak instead of sunset. Each of these deviates from the rabbinic traditions typically assumed by 33 AD proponents.</li>
              <li><strong>Most Fail Other Biblical Tests</strong> â€” Expand the "Alt Score" column to see how each configuration performs on the other biblical tests. All but one configuration that passes 33 AD will fail the Manna Sabbath, Jordan Crossing, or 32 AD Resurrection tests. The only Saturday Sabbath configuration achieving 100% is Full Moon + Sunset + Lambâ€”which still requires accepting the chronological cautions above.</li>
            </ul>
          </div>
          ` : ''}
          <div class="sabbath-test-expected">
            <strong>Expected:</strong> ${test.expectedLabel} (${test.expectedLabel === 'Saturday' ? 'Sabbath' : 'First Day of Week'})
          </div>
          <table class="sabbath-test-results-table">
            <thead>
              <tr>
                <th>Calendar Profile</th>
                <th>${test.year < 1582 ? 'Julian Date' : 'Gregorian Date'}</th>
                <th>Weekday</th>
                <th>Result</th>
                ${(test.id === 'resurrection-30ad' || test.id === 'resurrection-33ad') ? '<th title="Score if this year replaces 32 AD as the resurrection test">Alt Score</th>' : ''}
              </tr>
            </thead>
            <tbody>
      `;
      
      // Group results by base profile (moon phase + day start, without year rule)
      // to merge rows when both year rules produce same result
      const groupedResults = {};
      for (const r of results) {
        // Extract base key (without year rule)
        const baseKey = `${r.profile.moonPhase}-${r.profile.dayStartTime}`;
        if (!groupedResults[baseKey]) {
          groupedResults[baseKey] = { equinox: null, lamb: null };
        }
        if (r.profile.yearStartRule === 'equinox') {
          groupedResults[baseKey].equinox = r;
        } else {
          groupedResults[baseKey].lamb = r;
        }
      }
      
      // Build merged results array
      const mergedResults = [];
      for (const [baseKey, group] of Object.entries(groupedResults)) {
        const eq = group.equinox;
        const lamb = group.lamb;
        
        // Check if both produce same weekday (can be merged)
        if (eq && lamb && eq.calculatedWeekday === lamb.calculatedWeekday && eq.result === lamb.result) {
          // Merge: use equinox data but show both icons
          const moonIcon = eq.profile.moonPhase === 'full' ? 'ðŸŒ•' : eq.profile.moonPhase === 'dark' ? 'ðŸŒ‘' : 'ðŸŒ’';
          const moonName = eq.profile.moonPhase === 'full' ? 'Full Moon' : eq.profile.moonPhase === 'dark' ? 'Dark Moon' : 'Crescent Moon';
          const dayStartName = eq.profile.dayStartTime === 'morning' ? 'Daybreak' : 'Sunset';
          // Check if either profile matches a preset
          const presetName = eq.profile.presetName || lamb.profile.presetName;
          const presetSuffix = presetName ? ` (${presetName})` : '';
          mergedResults.push({
            ...eq,
            mergedName: `${moonIcon} ${moonName} ${dayStartName} âš–ï¸ðŸ‘${presetSuffix}`,
            isMerged: true,
            // Use equinox profile for navigation (either would work)
            profileIdForNav: eq.profile.id
          });
        } else {
          // Show separately - profile.name already includes preset suffix from getSabbathTestProfiles
          if (eq) mergedResults.push({ ...eq, mergedName: eq.profile.name, isMerged: false, profileIdForNav: eq.profile.id });
          if (lamb) mergedResults.push({ ...lamb, mergedName: lamb.profile.name, isMerged: false, profileIdForNav: lamb.profile.id });
        }
      }
      
      // Sort results: pass first, then uncertain, then fail
      const sortedResults = mergedResults.sort((a, b) => {
        const order = { pass: 0, uncertain: 1, fail: 2, error: 3 };
        return (order[a.result] || 3) - (order[b.result] || 3);
      });
      
      for (const r of sortedResults) {
        let resultText, resultClass;
        if (r.result === 'pass') {
          resultText = 'âœ… Pass';
          resultClass = 'result-pass';
        } else if (r.result === 'uncertain') {
          // Show caution with % chance of passing
          resultText = `âš ï¸ ${r.probability}%`;
          resultClass = 'result-uncertain';
        } else if (r.result === 'fail') {
          resultText = 'âŒ Fail';
          resultClass = 'result-fail';
        } else {
          resultText = 'âš ï¸ Error';
          resultClass = 'result-uncertain';
        }
        
        const dateStr = r.gregorianDate ? formatAncientDate(r.gregorianDate, false) : 'N/A';
        const weekdayStr = r.calculatedWeekdayName || 'N/A';
        
        // Create year uncertainty indicator if present
        let yearUncertaintyIcon = '';
        if (r.yearUncertainty && r.yearUncertainty.probability > 0) {
          const tooltipText = `Year uncertainty: ${r.yearUncertainty.probability}% chance all dates are 1 month ${r.yearUncertainty.direction} (Î”T uncertainty Â±${Math.round(r.uncertaintyHours)} hours, Nisan margin: ${r.yearUncertainty.marginHours.toFixed(1)} hours)`;
          yearUncertaintyIcon = ` <span class="year-uncertainty-icon" title="${tooltipText}">âš ï¸${r.yearUncertainty.probability}%</span>`;
        }
        
        // Create onclick handler for date link using test ID and profile ID
        const dateLink = r.gregorianDate ? 
          `<a class="sabbath-test-date-link" onclick="navigateToTestResult('${test.id}', '${r.profileIdForNav}')">${dateStr}</a>${yearUncertaintyIcon}` :
          dateStr;
        
        // Calculate alternative score for 30 AD and 33 AD tests
        let altScoreCell = '';
        if (test.id === 'resurrection-30ad' || test.id === 'resurrection-33ad') {
          // Get base score without 32 AD, then add this test's result
          const baseScoreData = baseScoreWithout32AD[r.profile.id];
          const baseScore = baseScoreData?.totalScore || 0;
          const baseTestResults = baseScoreData?.testResults || [];
          
          let thisTestScore = 0;
          if (r.result === 'pass') thisTestScore = 1;
          else if (r.result === 'uncertain') thisTestScore = (r.probability || 50) / 100;
          // else fail = 0
          
          const altTotalScore = baseScore + thisTestScore;
          const altPct = Math.round((altTotalScore / numTests) * 100);
          
          let altScoreClass = 'score-poor';
          if (altPct >= 90) altScoreClass = 'score-perfect';
          else if (altPct >= 70) altScoreClass = 'score-good';
          else if (altPct >= 50) altScoreClass = 'score-medium';
          
          // Build breakdown of tests (excluding current test - that's shown in Result column)
          const passedTests = baseTestResults.filter(t => t.result === 'pass');
          const failedTests = baseTestResults.filter(t => t.result === 'fail');
          const uncertainTests = baseTestResults.filter(t => t.result === 'uncertain');
          
          // Helper to format test names, keeping year info for resurrection tests
          const formatTestName = (t) => {
            if (t.testId === 'resurrection-32ad') return 'Resurrection 32 AD';
            return t.testName.replace(/ \([^)]+\)$/, '').replace('First Sabbath of ', '').replace('First Fruits After ', '');
          };
          
          let altBreakdown = '';
          if (passedTests.length > 0) {
            altBreakdown += '<div class="breakdown-section"><span class="breakdown-label result-pass">âœ…</span> ';
            altBreakdown += passedTests.map(formatTestName).join(', ');
            altBreakdown += '</div>';
          }
          if (uncertainTests.length > 0) {
            altBreakdown += '<div class="breakdown-section"><span class="breakdown-label result-uncertain">âš ï¸</span> ';
            altBreakdown += uncertainTests.map(t => `${formatTestName(t)} (${t.probability}%)`).join(', ');
            altBreakdown += '</div>';
          }
          if (failedTests.length > 0) {
            altBreakdown += '<div class="breakdown-section"><span class="breakdown-label result-fail">âŒ</span> ';
            altBreakdown += failedTests.map(formatTestName).join(', ');
            altBreakdown += '</div>';
          }
          
          altScoreCell = `<td class="${altScoreClass}">
            <details class="alt-score-details">
              <summary>${altPct}%</summary>
              <div class="alt-score-breakdown">${altBreakdown}</div>
            </details>
          </td>`;
        }
        
        html += `
          <tr>
            <td>${r.mergedName}</td>
            <td>${dateLink}</td>
            <td>${weekdayStr}</td>
            <td class="${resultClass}">${resultText}</td>
            ${altScoreCell}
          </tr>
        `;
      }
      
      html += `
            </tbody>
          </table>
        </div>
      `;
    }
    
    loadingEl.style.display = 'none';
    resultsEl.innerHTML = html;
    
    // Cache the results
    try {
      localStorage.setItem('sabbathTesterResults', html);
      localStorage.setItem('sabbathTesterVersion', SABBATH_TESTER_CACHE_VERSION);
    } catch (e) {
      // localStorage might be full or unavailable
      console.warn('Could not cache sabbath tester results:', e);
    }
    
    // Run engine comparison and log results to console
    setTimeout(() => {
      compareEngineResults();
    }, 100);
  }, 50);
}

// Toggle scoreboard row expansion
function toggleScoreboardRow(rowId) {
  const detailsRow = document.getElementById(rowId);
  const mainRow = detailsRow?.previousElementSibling;
  
  if (detailsRow && mainRow) {
    const isExpanded = detailsRow.style.display !== 'none';
    detailsRow.style.display = isExpanded ? 'none' : 'table-row';
    mainRow.classList.toggle('expanded', !isExpanded);
  }
}

// Helper to get day suffix (1st, 2nd, 3rd, etc.)
function getDaySuffix(day) {
  if (day >= 11 && day <= 13) return 'th';
  switch (day % 10) {
    case 1: return 'st';
    case 2: return 'nd';
    case 3: return 'rd';
    default: return 'th';
  }
}

// =============================================================================
// ENGINE COMPARISON - Verify new LunarCalendarEngine matches existing logic
// =============================================================================

function compareEngineResults() {
  console.log('%c=== LUNAR CALENDAR ENGINE COMPARISON ===', 'color: #4fc3f7; font-weight: bold; font-size: 14px;');
  
  // Use the existing abstracted engine (which handles Swiss Ephemeris, ancient dates, etc.)
  const existingEngine = getAstroEngine();
  
  // Create adapter for LunarCalendarEngine using the existing engine infrastructure
  const astroAdapter = {
    searchMoonPhase(phase, startDate, limitDays) {
      return existingEngine.searchMoonPhase(phase, startDate, limitDays);
    },
    getSeasons(year) {
      return existingEngine.getSeasons(year);
    },
    searchRiseSet(body, observer, direction, startDate, limitDays) {
      return existingEngine.searchRiseSet(body, observer, direction, startDate, limitDays);
    },
    searchAltitude(body, observer, direction, startDate, limitDays, altitude) {
      return existingEngine.searchAltitude(body, observer, direction, startDate, limitDays, altitude);
    },
    createObserver(lat, lon, elevation) {
      return existingEngine.createObserver(lat, lon, elevation);
    },
    getDeltaTUncertainty(year) {
      return existingEngine.getDeltaTUncertainty ? existingEngine.getDeltaTUncertainty(year) : 0;
    }
  };
  
  const engine = new LunarCalendarEngine(astroAdapter);
  const profiles = getSabbathTestProfiles();
  let totalTests = 0;
  let matchCount = 0;
  let mismatchCount = 0;
  const mismatches = [];
  
  for (const test of BIBLICAL_TESTS) {
    for (const profile of profiles) {
      totalTests++;
      
      // Run existing test
      const existingResult = runBiblicalTest(test, profile);
      
      // Debug: log existing result details for first profile of each test
      if (profile === profiles[0]) {
        console.log(`[Existing Debug] Test: ${test.name}, Year: ${test.year}`);
        console.log(`[Existing Debug] Result: ${existingResult.gregorianDate?.toISOString()} ${existingResult.calculatedWeekdayName}`);
        if (existingResult.moonEventDate) {
          console.log(`[Existing Debug] Moon event: ${existingResult.moonEventDate.toISOString()}`);
        }
      }
      
      // Run engine test
      engine.configure({
        moonPhase: profile.moonPhase,
        dayStartTime: profile.dayStartTime === 'morning' ? 'morning' : 'evening',
        dayStartAngle: 0,
        yearStartRule: profile.yearStartRule,
        crescentThreshold: 18
      });
      
      const location = test.location || { lat: 31.7683, lon: 35.2137 };
      
      try {
        // Enable debug for first profile of each test to diagnose
        const isFirstProfileForTest = profile === profiles[0];
        const calendar = engine.generateYear(test.year, location, { debug: isFirstProfileForTest });
        const dayInfo = engine.getDayInfo(calendar, test.month, test.day);
        
        if (!dayInfo) {
          mismatches.push({
            test: test.name,
            profile: profile.name,
            issue: 'Engine returned null for day info',
            existing: existingResult
          });
          mismatchCount++;
          continue;
        }
        
        // Compare weekday
        const existingWeekday = existingResult.calculatedWeekday;
        const engineWeekday = dayInfo.weekday;
        
        // Compare Gregorian date
        const existingDateStr = existingResult.gregorianDate ? 
          existingResult.gregorianDate.toISOString().split('T')[0] : null;
        const engineDateStr = dayInfo.gregorianDate ? 
          dayInfo.gregorianDate.toISOString().split('T')[0] : null;
        
        // Get uncertainty from engine
        const monthData = calendar.months.find(m => m.monthNumber === test.month);
        const engineUncertainty = monthData ? monthData.uncertainty : null;
        
        const weekdayMatch = existingWeekday === engineWeekday;
        const dateMatch = existingDateStr === engineDateStr;
        
        if (weekdayMatch && dateMatch) {
          matchCount++;
        } else {
          mismatchCount++;
          mismatches.push({
            test: test.name,
            profile: profile.name,
            existingWeekday: existingResult.calculatedWeekdayName,
            engineWeekday: dayInfo.weekdayName,
            existingDate: existingDateStr,
            engineDate: engineDateStr,
            weekdayMatch,
            dateMatch,
            existingUncertainty: existingResult.uncertaintyHours,
            engineUncertainty: engineUncertainty
          });
        }
      } catch (e) {
        mismatchCount++;
        console.error('Engine error for', test.name, profile.name, ':', e);
        mismatches.push({
          test: test.name,
          profile: profile.name,
          issue: 'Engine threw error: ' + e.message,
          existing: existingResult,
          stack: e.stack
        });
      }
    }
  }
  
  // Log summary
  console.log(`%cTotal tests: ${totalTests}`, 'color: #aaa;');
  console.log(`%cMatches: ${matchCount}`, 'color: #4caf50; font-weight: bold;');
  console.log(`%cMismatches: ${mismatchCount}`, mismatchCount > 0 ? 'color: #f44336; font-weight: bold;' : 'color: #4caf50;');
  
  if (mismatches.length > 0) {
    console.log('%c--- MISMATCHES ---', 'color: #ff9800; font-weight: bold;');
    for (const m of mismatches) {
      console.log('%c' + m.test + ' / ' + m.profile, 'color: #ff9800;');
      if (m.issue) {
        console.log('  Issue:', m.issue);
      } else {
        console.log('  Existing:', m.existingDate, m.existingWeekday);
        console.log('  Engine:  ', m.engineDate, m.engineWeekday);
        console.log('  Date match:', m.dateMatch, '| Weekday match:', m.weekdayMatch);
      }
    }
  } else {
    console.log('%câœ“ All results match!', 'color: #4caf50; font-weight: bold; font-size: 12px;');
  }
  
  return { totalTests, matchCount, mismatchCount, mismatches };
}

// Helper to regenerate calendar while preserving scroll position
function regenerateCalendarPreservingScroll() {
  const scrollTop = window.scrollY || document.documentElement.scrollTop;
  generateCalendar({ preserveMonth: true });
  updateURL();
  renderSettingsPageMap();
  
  // Check for pending navigation (from profile switching)
  if (state.pendingNavigationDate) {
    navigateToPendingDate();
  } else {
    refreshDayDetailIfVisible();
  }
  
  requestAnimationFrame(() => {
    window.scrollTo(0, scrollTop);
  });
}

function selectDayStartTime(time) {
  // Don't allow changes on preset profiles
  const profileId = editingProfileId || state.selectedProfile;
  if (PRESET_PROFILES[profileId]) return;
  
  // Update the editing profile
  if (PROFILES[profileId]) {
    PROFILES[profileId].dayStartTime = time;
    saveCustomProfiles();
  }
  
  updateDayStartButtons();
  
  // Only update state if editing the active profile
  if (profileId === state.selectedProfile) {
    state.dayStartTime = time;
    saveState();
    regenerateCalendarPreservingScroll();
  }
}

function selectDayStartAngle(angle) {
  // Don't allow changes on preset profiles
  const profileId = editingProfileId || state.selectedProfile;
  if (PRESET_PROFILES[profileId]) return;
  
  // Update the editing profile
  if (PROFILES[profileId]) {
    PROFILES[profileId].dayStartAngle = angle;
    saveCustomProfiles();
  }
  
  updateDayStartButtons();
  
  // Only update state if editing the active profile
  if (profileId === state.selectedProfile) {
    state.dayStartAngle = angle;
    saveState();
    regenerateCalendarPreservingScroll();
  }
}

function selectYearStartRule(rule) {
  // Don't allow changes on preset profiles
  const profileId = editingProfileId || state.selectedProfile;
  if (PRESET_PROFILES[profileId]) return;
  
  // Update the editing profile
  if (PROFILES[profileId]) {
    PROFILES[profileId].yearStartRule = rule;
    saveCustomProfiles();
  }
  
  updateYearStartButtons();
  
  // Only update state if editing the active profile
  if (profileId === state.selectedProfile) {
    state.yearStartRule = rule;
    saveState();
    regenerateCalendarPreservingScroll();
  }
}

function updateDayStartButtons() {
  // Use the editing profile for settings page
  const profileId = editingProfileId || state.selectedProfile;
  const profile = PROFILES[profileId];
  const dayStartTime = profile ? profile.dayStartTime : state.dayStartTime;
  const dayStartAngle = profile ? profile.dayStartAngle : state.dayStartAngle;
  
  // Update day start time buttons (evening/morning)
  document.querySelectorAll('.settings-option-btn[data-daystart]').forEach(btn => {
    btn.classList.toggle('selected', btn.dataset.daystart === dayStartTime);
  });
  // Update angle buttons
  document.querySelectorAll('.settings-option-btn[data-angle]').forEach(btn => {
    btn.classList.toggle('selected', parseInt(btn.dataset.angle) === dayStartAngle);
  });
}

function updateYearStartButtons() {
  // Use the editing profile for settings page
  const profileId = editingProfileId || state.selectedProfile;
  const profile = PROFILES[profileId];
  const yearStartRule = profile ? profile.yearStartRule : state.yearStartRule;
  
  document.querySelectorAll('.settings-option-btn[data-yearstart]').forEach(btn => {
    btn.classList.toggle('selected', btn.dataset.yearstart === yearStartRule);
  });
  
  // Update the "Renewed Moon after Equinox" icon to match current moon phase
  const iconEl = document.getElementById('yearstart-equinox-icon');
  if (iconEl) {
    iconEl.textContent = getMoonIcon();
  }
  
  // Show/hide the year start rule explanations - all populated dynamically
  const equinoxExplanation = document.getElementById('equinox-rule-explanation');
  if (equinoxExplanation) {
    if (yearStartRule === 'equinox') {
      equinoxExplanation.innerHTML = getEquinoxMethodologyHtml({ showCalculation: false });
      equinoxExplanation.style.display = 'block';
    } else {
      equinoxExplanation.style.display = 'none';
    }
  }
  
  const lambExplanation = document.getElementById('lamb-rule-explanation');
  if (lambExplanation) {
    if (yearStartRule === '13daysBefore') {
      lambExplanation.innerHTML = getPassoverMethodologyHtml({ showCalculation: false });
      lambExplanation.style.display = 'block';
    } else {
      lambExplanation.style.display = 'none';
    }
  }
  
  const virgoExplanation = document.getElementById('virgo-rule-explanation');
  if (virgoExplanation) {
    if (yearStartRule === 'virgoFeet') {
      // Populate with shared methodology content, including calculation if available
      const virgoCalc = getVirgoCalculation(state.year);
      virgoExplanation.innerHTML = getVirgoMethodologyHtml({ 
        showCalculation: !!virgoCalc, 
        virgoCalc: virgoCalc 
      });
      virgoExplanation.style.display = 'block';
    } else {
      virgoExplanation.style.display = 'none';
    }
  }
}

function selectCrescentThreshold(threshold) {
  // Don't allow changes on preset profiles
  const profileId = editingProfileId || state.selectedProfile;
  if (PRESET_PROFILES[profileId]) return;
  
  // Update the editing profile
  if (PROFILES[profileId]) {
    PROFILES[profileId].crescentThreshold = threshold;
    saveCustomProfiles();
  }
  
  updateCrescentThresholdButtons();
  
  // Only update state if editing the active profile
  if (profileId === state.selectedProfile) {
    state.crescentThreshold = threshold;
    saveState();
    regenerateCalendarPreservingScroll();
  }
}

function selectSabbathMode(mode) {
  // Don't allow changes on preset profiles
  const profileId = editingProfileId || state.selectedProfile;
  if (PRESET_PROFILES[profileId]) return;
  
  // Update the editing profile
  if (PROFILES[profileId]) {
    PROFILES[profileId].sabbathMode = mode;
    saveCustomProfiles();
  }
  
  // Clear dropdown when selecting a button option
  const dropdown = document.getElementById('sabbath-day-select');
  if (dropdown) dropdown.value = '';
  updateSabbathButtons();
  
  // Only update state if editing the active profile
  if (profileId === state.selectedProfile) {
    state.sabbathMode = mode;
    saveState();
    regenerateCalendarPreservingScroll();
  }
}

function updateSabbathButtons() {
  // Use the editing profile for settings page
  const profileId = editingProfileId || state.selectedProfile;
  const profile = PROFILES[profileId];
  const sabbathMode = profile ? profile.sabbathMode : state.sabbathMode;
  
  document.querySelectorAll('.settings-option-btn[data-sabbath]').forEach(btn => {
    btn.classList.toggle('selected', btn.dataset.sabbath === sabbathMode);
  });
  
  // Update the dropdown to reflect current selection
  const dropdown = document.getElementById('sabbath-day-select');
  if (dropdown) {
    const dropdownDays = ['none', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday'];
    if (dropdownDays.includes(sabbathMode)) {
      dropdown.value = sabbathMode;
    } else {
      dropdown.value = '';
    }
  }
}

function selectSabbathDayFromDropdown(day) {
  if (!day) return;
  
  // Don't allow changes on preset profiles
  const profileId = editingProfileId || state.selectedProfile;
  if (PRESET_PROFILES[profileId]) {
    // Reset dropdown to empty
    document.getElementById('sabbath-day-select').value = '';
    return;
  }
  
  state.sabbathMode = day;
  // Deselect the button options when selecting from dropdown
  document.querySelectorAll('.settings-option-btn[data-sabbath]').forEach(btn => {
    btn.classList.remove('selected');
  });
  updateSabbathButtons();
  updateProfileButtons();
  saveState();
  regenerateCalendarPreservingScroll();
}

// Determine if a day is a sabbath based on current sabbathMode
function isSabbath(day) {
  switch (state.sabbathMode) {
    case 'lunar':
      // Lunar sabbath: days 8, 15, 22, 29
      return [8, 15, 22, 29].includes(day.lunarDay);
    case 'sunday':
      return getCorrectWeekday(day.gregorianDate) === 0;
    case 'monday':
      return getCorrectWeekday(day.gregorianDate) === 1;
    case 'tuesday':
      return getCorrectWeekday(day.gregorianDate) === 2;
    case 'wednesday':
      return getCorrectWeekday(day.gregorianDate) === 3;
    case 'thursday':
      return getCorrectWeekday(day.gregorianDate) === 4;
    case 'friday':
      return getCorrectWeekday(day.gregorianDate) === 5;
    case 'saturday':
      return getCorrectWeekday(day.gregorianDate) === 6;
    case 'none':
      return false;
    default:
      return [8, 15, 22, 29].includes(day.lunarDay);
  }
}

function updateCrescentThresholdButtons() {
  // Use the editing profile for settings page
  const profileId = editingProfileId || state.selectedProfile;
  const profile = PROFILES[profileId];
  const crescentThreshold = profile ? (profile.crescentThreshold ?? 18) : state.crescentThreshold;
  
  document.querySelectorAll('.settings-option-btn[data-threshold]').forEach(btn => {
    btn.classList.toggle('selected', parseFloat(btn.dataset.threshold) === crescentThreshold);
  });
}

function updateCrescentThresholdVisibility() {
  // Use the editing profile for settings page
  const profileId = editingProfileId || state.selectedProfile;
  const profile = PROFILES[profileId];
  const moonPhase = profile ? profile.moonPhase : state.moonPhase;
  
  const section = document.getElementById('crescent-threshold-section');
  if (section) {
    section.style.display = moonPhase === 'crescent' ? 'block' : 'none';
  }
}

function renderSettingsMap() {
  const container = document.getElementById('settings-map-container');
  if (container && state.lunarMonths && state.lunarMonths[state.currentMonthIndex]) {
    const month = state.lunarMonths[state.currentMonthIndex];
    container.innerHTML = renderDatelineVisualization(month.moonEvent);
    // Update map editability after rendering
    updateMapEditability();
  }
}

// Month Picker Popup
function toggleMonthPicker() {
  const overlay = document.getElementById('month-picker-overlay');
  const picker = document.getElementById('month-picker');
  const isOpen = overlay.classList.contains('open');
  
  if (!isOpen) {
    // Opening - update the picker content
    updateMonthPicker();
  }
  
  overlay.classList.toggle('open');
  picker.style.display = isOpen ? 'none' : 'block';
}

function updateMonthPicker() {
  // Just show the year number (no BC/AD suffix - the dropdown handles that)
  const displayYear = state.year <= 0 ? Math.abs(state.year - 1) : state.year;
  document.getElementById('picker-year').textContent = displayYear;
  updateEraButtons();
  
  const grid = document.getElementById('month-grid');
  grid.innerHTML = '';
  
  const monthNames = ['1st', '2nd', '3rd', '4th', '5th', '6th', '7th', '8th', '9th', '10th', '11th', '12th', 'ðŸ“…13th'];
  
  for (let i = 0; i < 13; i++) {
    const btn = document.createElement('button');
    btn.textContent = monthNames[i];
    
    if (i >= state.lunarMonths.length) {
      btn.classList.add('disabled');
      btn.disabled = true;
    } else if (i === state.currentMonthIndex) {
      btn.classList.add('active');
    }
    
    // Add tooltip for 13th month
    if (i === 12) {
      btn.title = 'Intercalary 13th month';
    }
    
    btn.onclick = () => {
      if (i < state.lunarMonths.length) {
        selectMonth(i);
        toggleMonthPicker();
      }
    };
    
    grid.appendChild(btn);
  }
  
  // Add "Today" button - positioned in 4th column (under 12th month)
  // First add an empty spacer for the 3rd column position
  const spacer1 = document.createElement('div');
  spacer1.style.visibility = 'hidden';
  grid.appendChild(spacer1);
  
  const spacer2 = document.createElement('div');
  spacer2.style.visibility = 'hidden';
  grid.appendChild(spacer2);
  
  const todayBtn = document.createElement('button');
  todayBtn.textContent = 'Today';
  todayBtn.className = 'today-btn';
  todayBtn.title = 'Jump to today';
  todayBtn.onclick = () => {
    toggleMonthPicker();
    jumpToToday();
  };
  grid.appendChild(todayBtn);
}

function showYearInput() {
  const display = document.getElementById('picker-year');
  const input = document.getElementById('picker-year-input');
  
  display.style.visibility = 'hidden';
  input.classList.add('visible');
  
  // Convert internal year to display year (always positive)
  if (state.year <= 0) {
    input.value = Math.abs(state.year - 1);
  } else {
    input.value = state.year;
  }
  
  input.focus();
  input.select();
}

function hideYearInput() {
  const display = document.getElementById('picker-year');
  const input = document.getElementById('picker-year-input');
  
  display.style.visibility = '';
  input.classList.remove('visible');
}

function getPickerEra() {
  return state.year <= 0 ? 'BC' : 'AD';
}

function changeEra(era) {
  const input = document.getElementById('picker-year-input');
  const currentEra = getPickerEra();
  
  if (era === currentEra) return;
  
  // Get current display year
  let displayYear;
  if (input.classList.contains('visible')) {
    displayYear = parseInt(input.value) || 1;
  } else {
    displayYear = state.year <= 0 ? Math.abs(state.year - 1) : state.year;
  }
  
  // Convert to new era
  let newInternalYear;
  if (era === 'BC') {
    newInternalYear = -(displayYear - 1);
  } else {
    newInternalYear = displayYear;
  }
  
  // Validate range
  if (newInternalYear >= -3999 && newInternalYear <= 4000) {
    state.year = newInternalYear;
    document.getElementById('year-input').value = state.year;
    generateCalendar();
    updateMonthPicker();
  }
}

function updateEraButtons() {
  const eraSelect = document.getElementById('era-select');
  if (eraSelect) {
    eraSelect.value = state.year <= 0 ? 'BC' : 'AD';
  }
}

function applyYearInput() {
  const input = document.getElementById('picker-year-input');
  let displayYear = parseInt(input.value);
  
  if (isNaN(displayYear) || displayYear < 1 || displayYear > 4000) {
    hideYearInput();
    return;
  }
  
  // Convert display year to internal year based on current era
  const isBC = state.year <= 0;
  let internalYear;
  if (isBC) {
    internalYear = -(displayYear - 1);
  } else {
    internalYear = displayYear;
  }
  
  // Validate range: -3999 (4000 BC) to 4000 (4000 AD)
  if (internalYear >= -3999 && internalYear <= 4000) {
    state.year = internalYear;
    document.getElementById('year-input').value = state.year;
    generateCalendar();
    updateMonthPicker();
  }
  
  hideYearInput();
}

function changePickerYear(delta) {
  const newYear = state.year + delta;
  
  // Validate range: -3999 (4000 BC) to 4000 (4000 AD)
  if (newYear >= -3999 && newYear <= 4000) {
    state.year = newYear;
    document.getElementById('year-input').value = state.year;
    generateCalendar();
    updateMonthPicker();
    updateEraButtons();
  }
}

// Date Jump Popup
function toggleDateJump() {
  const overlay = document.getElementById('date-jump-overlay');
  const popup = document.getElementById('date-jump-popup');
  const isOpen = overlay.classList.contains('open');
  
  if (!isOpen) {
    // Opening - sync the datetime input
    const gotoDate = document.getElementById('goto-date').value;
    const datetimeInput = document.getElementById('jump-datetime');
    const ancientDisplay = document.getElementById('jump-ancient-display');
    const ancientDateText = document.getElementById('jump-ancient-date');
    
    if (gotoDate) {
      // Modern date - show datetime picker
      datetimeInput.value = gotoDate;
      datetimeInput.style.display = 'block';
      ancientDisplay.style.display = 'none';
    } else if (state.selectedTimestamp) {
      // Ancient date - show text display instead
      const date = new Date(state.selectedTimestamp);
      const dateStr = formatDisplayDate(date);
      ancientDateText.textContent = dateStr;
      datetimeInput.style.display = 'none';
      ancientDisplay.style.display = 'block';
    }
  }
  
  overlay.classList.toggle('open');
  popup.style.display = isOpen ? 'none' : 'block';
}

function executeJumpToDate() {
  const datetime = document.getElementById('jump-datetime').value;
  if (!datetime) {
    alert('Please enter a date');
    return;
  }
  document.getElementById('goto-date').value = datetime;
  jumpToDate();
  toggleDateJump();
}

function jumpToTodayFromPopup() {
  toggleDateJump();
  jumpToToday();
}

function addDaysFromPopup(direction) {
  const datetime = document.getElementById('jump-datetime').value;
  const days = parseInt(document.getElementById('jump-days').value) || 1;
  
  // For ancient dates, datetime input will be empty, use selectedTimestamp
  let utcTimestamp;
  if (datetime) {
    utcTimestamp = parseDatetimeLocal(datetime);
  } else if (state.selectedTimestamp) {
    utcTimestamp = state.selectedTimestamp;
  } else {
    alert('Please select a date first');
    return;
  }
  const newTimestamp = utcTimestamp + (direction * days * 24 * 60 * 60 * 1000);
  
  const formattedDate = formatLocalDatetime(newTimestamp);
  if (formattedDate) {
    // Modern date - update datetime input
    document.getElementById('jump-datetime').value = formattedDate;
    document.getElementById('jump-datetime').style.display = 'block';
    document.getElementById('jump-ancient-display').style.display = 'none';
  } else {
    // Ancient date - update text display
    const date = new Date(newTimestamp);
    document.getElementById('jump-ancient-date').textContent = formatDisplayDate(date);
    document.getElementById('jump-datetime').style.display = 'none';
    document.getElementById('jump-ancient-display').style.display = 'block';
  }
  
  document.getElementById('goto-date').value = formattedDate;
  state.selectedTimestamp = newTimestamp;
  jumpToDate();
}

function handleMapClick(event) {
  // Don't allow map clicks when on a preset profile
  const profileId = editingProfileId || state.selectedProfile;
  if (PRESET_PROFILES[profileId]) {
    return; // Preset profiles are read-only
  }
  
  const mapEl = event.currentTarget;
  const rect = mapEl.getBoundingClientRect();
  
  // Calculate click position as percentage
  const xPercent = (event.clientX - rect.left) / rect.width;
  const yPercent = (event.clientY - rect.top) / rect.height;
  
  // Convert to lat/lon (equirectangular projection)
  // X: 0% = -180Â°, 100% = 180Â°
  // Y: 0% = 90Â° (north), 100% = -90Â° (south)
  const lon = (xPercent * 360) - 180;
  const lat = 90 - (yPercent * 180);
  
  // Round to 2 decimal places
  const roundedLat = Math.round(lat * 100) / 100;
  const roundedLon = Math.round(lon * 100) / 100;
  
  // Check if we're in profile editor mode (settings page is visible with editingProfileId set)
  const settingsPage = document.getElementById('settings-page');
  const isInProfileEditor = settingsPage && settingsPage.classList.contains('visible') && editingProfileId;
  
  if (isInProfileEditor) {
    // Profile editor mode - only update the profile's location, not state
    if (PROFILES[profileId]) {
      PROFILES[profileId].lat = roundedLat;
      PROFILES[profileId].lon = roundedLon;
      PROFILES[profileId].city = '';
      saveCustomProfiles();
    }
    
    // Update settings page inputs only
    const settingsLatInput = document.getElementById('settings-lat-input');
    const settingsLonInput = document.getElementById('settings-lon-input');
    const settingsCitySelect = document.getElementById('settings-city-select');
    const settingsCustomCoords = document.getElementById('settings-custom-coords');
    
    if (settingsLatInput) settingsLatInput.value = roundedLat;
    if (settingsLonInput) settingsLonInput.value = roundedLon;
    if (settingsCitySelect) settingsCitySelect.value = 'custom';
    if (settingsCustomCoords) settingsCustomCoords.style.display = 'flex';
    
    renderSettingsPageMap();
  } else {
    // Calendar page mode - update state
    state.lat = roundedLat;
    state.lon = roundedLon;
    state.city = ''; // Clear city selection
    
    // Update main inputs
    document.getElementById('lat-input').value = state.lat;
    document.getElementById('lon-input').value = state.lon;
    document.getElementById('city-select').value = '';
    
    // Show custom coords on main page
    const customCoords = document.getElementById('custom-coords');
    if (customCoords) customCoords.style.display = 'block';
    
    // Save and regenerate (preserve current month for location changes)
    saveState();
    generateCalendar({ preserveMonth: true });
    updateURL();
    
    // Update the settings maps (both containers)
    renderSettingsMap();
    refreshDayDetailIfVisible();
  }
}

function useCurrentLocation() {
  const btn = document.querySelector('.location-btn');
  const originalText = btn.textContent;
  
  if (!navigator.geolocation) {
    alert('Geolocation is not supported by your browser');
    return;
  }
  
  btn.textContent = 'ðŸ“ Getting location...';
  btn.disabled = true;
  
  navigator.geolocation.getCurrentPosition(
    function(position) {
      // Success
      state.lat = Math.round(position.coords.latitude * 10000) / 10000;
      state.lon = Math.round(position.coords.longitude * 10000) / 10000;
      state.city = ''; // Clear city selection
      
      document.getElementById('lat-input').value = state.lat;
      document.getElementById('lon-input').value = state.lon;
      document.getElementById('city-select').value = '';
      document.getElementById('custom-coords').style.display = 'block';
      
      updateProfileButtons();  // Check if settings match a profile
      saveState();
      generateCalendar({ preserveMonth: true });
      updateURL();
      renderSettingsMap();
      refreshDayDetailIfVisible();
      
      btn.textContent = 'âœ“ Location set!';
      setTimeout(() => {
        btn.textContent = originalText;
        btn.disabled = false;
      }, 2000);
    },
    function(error) {
      // Error
      let message = 'Unable to get location';
      switch(error.code) {
        case error.PERMISSION_DENIED:
          message = 'Location access denied. Please enable location permissions.';
          break;
        case error.POSITION_UNAVAILABLE:
          message = 'Location information unavailable.';
          break;
        case error.TIMEOUT:
          message = 'Location request timed out.';
          break;
      }
      alert(message);
      btn.textContent = originalText;
      btn.disabled = false;
    },
    {
      enableHighAccuracy: false,
      timeout: 10000,
      maximumAge: 300000 // Cache for 5 minutes
    }
  );
}

document.getElementById('city-select').addEventListener('change', function() {
  const customCoords = document.getElementById('custom-coords');
  
  if (this.value === '') {
    // Custom selected - show coordinate inputs
    customCoords.style.display = 'block';
    state.city = '';
    return;
  }
  
  if (this.value) {
    customCoords.style.display = 'none';
    const [lat, lon] = this.value.split(',').map(Number);
    state.lat = lat;
    state.lon = lon;
    state.city = this.value;
    saveState();
    updateUI();
    generateCalendar({ preserveMonth: true });
    updateURL();
    renderSettingsMap();
    refreshDayDetailIfVisible();
  }
});

// Settings page city select handler
document.getElementById('settings-city-select').addEventListener('change', function() {
  // Don't allow changes on preset profiles
  const profileId = editingProfileId || state.selectedProfile;
  if (PRESET_PROFILES[profileId]) return;
  
  const customCoords = document.getElementById('settings-custom-coords');
  
  if (this.value === 'current') {
    // Use geolocation
    useCurrentLocationFromSettings();
    return;
  }
  
  if (this.value === 'custom') {
    customCoords.style.display = 'flex';
    state.city = '';
    return;
  }
  
  if (this.value) {
    customCoords.style.display = 'none';
    const [lat, lon] = this.value.split(',').map(Number);
    
    // Profile editor only updates the profile's location, not state
    if (!PRESET_PROFILES[profileId] && PROFILES[profileId]) {
      PROFILES[profileId].lat = lat;
      PROFILES[profileId].lon = lon;
      PROFILES[profileId].city = this.value;
      saveCustomProfiles();
    }
    
    renderSettingsPageMap();
  }
});

// Settings page custom coordinate inputs
document.getElementById('settings-lat-input').addEventListener('change', function() {
  // Don't allow changes on preset profiles
  const profileId = editingProfileId || state.selectedProfile;
  if (PRESET_PROFILES[profileId]) return;
  
  const lat = parseFloat(this.value);
  
  // Profile editor only updates the profile's location, not state
  if (PROFILES[profileId]) {
    PROFILES[profileId].lat = lat;
    PROFILES[profileId].city = '';
    saveCustomProfiles();
  }
  
  renderSettingsPageMap();
});

document.getElementById('settings-lon-input').addEventListener('change', function() {
  // Don't allow changes on preset profiles
  const profileId = editingProfileId || state.selectedProfile;
  if (PRESET_PROFILES[profileId]) return;
  
  const lon = parseFloat(this.value);
  
  // Profile editor only updates the profile's location, not state
  if (PROFILES[profileId]) {
    PROFILES[profileId].lon = lon;
    PROFILES[profileId].city = '';
    saveCustomProfiles();
  }
  
  renderSettingsPageMap();
});

function useCurrentLocationFromSettings() {
  const select = document.getElementById('settings-city-select');
  const profileId = editingProfileId || state.selectedProfile;
  
  // Don't allow changes on preset profiles
  if (PRESET_PROFILES[profileId]) return;
  
  if (!navigator.geolocation) {
    alert('Geolocation is not supported by your browser');
    // Reset to first city option
    select.value = '31.7683,35.2137';
    return;
  }
  
  navigator.geolocation.getCurrentPosition(
    function(position) {
      const lat = Math.round(position.coords.latitude * 10000) / 10000;
      const lon = Math.round(position.coords.longitude * 10000) / 10000;
      
      // Profile editor only updates the profile's location, not state
      if (PROFILES[profileId]) {
        PROFILES[profileId].lat = lat;
        PROFILES[profileId].lon = lon;
        PROFILES[profileId].city = '';
        saveCustomProfiles();
      }
      
      // Update settings inputs to show the detected location
      document.getElementById('settings-lat-input').value = lat;
      document.getElementById('settings-lon-input').value = lon;
      
      // Show custom coordinates with the detected location
      select.value = 'custom';
      document.getElementById('settings-custom-coords').style.display = 'flex';
      
      renderSettingsPageMap();
    },
    function(error) {
      alert('Unable to get your location. Please select a city or enter coordinates manually.');
      // Reset to first city option
      select.value = '31.7683,35.2137';
    },
    { timeout: 10000, enableHighAccuracy: true }
  );
}

// Auto-regenerate when inputs change
function regenerateAndUpdateURL() {
  generateCalendar();
  updateURL();
}
document.getElementById('year-input').addEventListener('change', regenerateAndUpdateURL);
document.getElementById('moon-phase-select').addEventListener('change', regenerateAndUpdateURL);
document.getElementById('lat-input').addEventListener('change', function() {
  state.city = ''; // Clear city selection when manually editing coordinates
  generateCalendar({ preserveMonth: true });
  updateURL();
  refreshDayDetailIfVisible();
});
document.getElementById('lon-input').addEventListener('change', function() {
  state.city = ''; // Clear city selection when manually editing coordinates
  generateCalendar({ preserveMonth: true });
  updateURL();
  refreshDayDetailIfVisible();
});

function changeYear(delta) {
  state.year += delta;
  state.highlightedLunarDay = 1;  // Default to day 1
  state.selectedTimestamp = null;
  updateUI();
  generateCalendar();
  updateURL();
}

function addDaysToDate(direction) {
  const dateInput = document.getElementById('goto-date').value;
  const daysValue = parseInt(document.getElementById('add-days').value);
  
  if (!dateInput) {
    alert('Please select a date first');
    return;
  }
  
  if (isNaN(daysValue) || daysValue <= 0) {
    alert('Please enter a positive number of days');
    return;
  }
  
  const daysToAdd = daysValue * direction; // direction: 1 = forward, -1 = backward
  
  // Parse current datetime as local time at location, get UTC timestamp
  const utcTimestamp = parseDatetimeLocal(dateInput);
  // Add days in milliseconds
  const newTimestamp = utcTimestamp + daysToAdd * 24 * 60 * 60 * 1000;
  
  // Update the datetime input with new local time
  document.getElementById('goto-date').value = formatLocalDatetime(newTimestamp);
  
  // Jump to the new date
  jumpToDate();
}

function jumpToDate() {
  const dateInput = document.getElementById('goto-date').value;
  
  // For ancient dates, dateInput will be empty - use selectedTimestamp
  let utcTimestamp;
  if (dateInput) {
    utcTimestamp = parseDatetimeLocal(dateInput);
  } else if (state.selectedTimestamp) {
    utcTimestamp = state.selectedTimestamp;
  } else {
    alert('Please enter a date');
    return;
  }
  
  const targetDate = new Date(utcTimestamp);
  const targetYear = targetDate.getUTCFullYear();
  
  // Helper function to search in current lunar months
  function searchInCurrentMonths() {
    for (let m = 0; m < state.lunarMonths.length; m++) {
      const month = state.lunarMonths[m];
      for (let d = 0; d < month.days.length; d++) {
        const day = month.days[d];
        if (day.gregorianDate.toDateString() === targetDate.toDateString()) {
          return { month: m, dayIndex: d };
        }
      }
    }
    return null;
  }
  
  // First try current lunar months
  let found = searchInCurrentMonths();
  
  // If not found, try different lunar years
  // Lunar years span ~March to ~March, so we need to try year-1, year, and year+1
  if (!found) {
    const yearsToTry = [targetYear, targetYear - 1, targetYear + 1];
    
    for (const lunarYear of yearsToTry) {
      if (lunarYear === state.year) continue; // Already tried
      
      state.year = lunarYear;
      updateUI();
      generateCalendar(); // This also updates dateline overview
      
      found = searchInCurrentMonths();
      if (found) break;
    }
  }
  
  if (found) {
    state.currentMonthIndex = found.month;
    const dayObj = state.lunarMonths[found.month].days[found.dayIndex];
    state.highlightedLunarDay = dayObj.lunarDay;
    // Store the actual timestamp from the input (preserves time)
    state.selectedTimestamp = targetDate.getTime();
    renderMonth(state.lunarMonths[state.currentMonthIndex]);
    updateMonthButtons();
    updateURL();
    showDayDetail(dayObj, state.lunarMonths[found.month]);
  } else {
    alert('Date not found in lunar calendar. The Astronomy library may not support this date range.');
  }
}

function selectMonth(index) {
  // Preserve the current day number when switching months
  const previousDay = state.highlightedLunarDay || 1;
  state.currentMonthIndex = index;
  
  // Carry day selection to new month, clamping to valid range
  const newMonth = state.lunarMonths[index];
  const maxDay = newMonth.days.length;
  state.highlightedLunarDay = Math.min(previousDay, maxDay);
  
  // Update selectedTimestamp for the new month's day
  const dayObj = newMonth.days.find(d => d.lunarDay === state.highlightedLunarDay);
  if (dayObj) {
    state.selectedTimestamp = getSunriseTimestamp(dayObj.gregorianDate);
    document.getElementById('goto-date').value = formatLocalDatetime(state.selectedTimestamp);
  }
  
  renderMonth(state.lunarMonths[state.currentMonthIndex]);
  updateMonthButtons();
  updateURL();
  
  // Show day detail for the carried-over day
  if (dayObj) {
    showDayDetail(dayObj, newMonth);
  }
}

function navigateMonth(direction) {
  const newIndex = state.currentMonthIndex + direction;
  const previousDay = state.highlightedLunarDay || 1;
  
  if (newIndex < 0) {
    // Go to previous year, last month
    state.year -= 1;
    updateUI();
    generateCalendar();
    // Jump to last month of previous year
    state.currentMonthIndex = state.lunarMonths.length - 1;
    
    // Preserve day selection, clamped to valid range
    const newMonth = state.lunarMonths[state.currentMonthIndex];
    const maxDay = newMonth.days.length;
    state.highlightedLunarDay = Math.min(previousDay, maxDay);
    const dayObj = newMonth.days.find(d => d.lunarDay === state.highlightedLunarDay);
    if (dayObj) {
      state.selectedTimestamp = getSunriseTimestamp(dayObj.gregorianDate);
      document.getElementById('goto-date').value = formatLocalDatetime(state.selectedTimestamp);
      showDayDetail(dayObj, newMonth);
    }
    
    renderMonth(state.lunarMonths[state.currentMonthIndex]);
    updateMonthButtons();
    updateURL();
  } else if (newIndex >= state.lunarMonths.length) {
    // Go to next year, first month
    state.year += 1;
    updateUI();
    generateCalendar();
    // Already at first month (generateCalendar sets to 0)
    
    // Preserve day selection, clamped to valid range
    const newMonth = state.lunarMonths[state.currentMonthIndex];
    const maxDay = newMonth.days.length;
    state.highlightedLunarDay = Math.min(previousDay, maxDay);
    const dayObj = newMonth.days.find(d => d.lunarDay === state.highlightedLunarDay);
    if (dayObj) {
      state.selectedTimestamp = getSunriseTimestamp(dayObj.gregorianDate);
      document.getElementById('goto-date').value = formatLocalDatetime(state.selectedTimestamp);
      showDayDetail(dayObj, newMonth);
    }
    
    renderMonth(state.lunarMonths[state.currentMonthIndex]);
    updateURL();
  } else {
    // Normal month navigation within same year
    selectMonth(newIndex);
  }
}

function updateMonthButtons() {
  const buttons = document.querySelectorAll('.month-btn');
  buttons.forEach((btn, i) => {
    btn.classList.toggle('active', i === state.currentMonthIndex);
  });
}

function renderMonthButtons() {
  const container = document.getElementById('month-buttons');
  container.innerHTML = '';
  
  const has13Months = state.lunarMonths.length >= 13;
  
  // Month buttons 1-12 (always show)
  for (let i = 0; i < 12; i++) {
    const btn = document.createElement('button');
    btn.className = 'month-btn' + (i === state.currentMonthIndex ? ' active' : '');
    if (i >= state.lunarMonths.length) {
      btn.classList.add('disabled');
      btn.disabled = true;
    }
    btn.textContent = i + 1;
    btn.onclick = () => selectMonth(i);
    container.appendChild(btn);
  }
  
  // Month 13 button (hidden on mobile unless year has 13 months) - with calendar icon
  if (state.lunarMonths.length >= 13) {
    const btn13 = document.createElement('button');
    btn13.className = 'month-btn month-13' + (has13Months ? ' has-13' : '') + (12 === state.currentMonthIndex ? ' active' : '');
    btn13.innerHTML = '<span class="month-13-icon">ðŸ“…</span><span class="month-13-num">13</span>';
    btn13.title = 'Intercalary 13th month';
    btn13.onclick = () => selectMonth(12);
    container.appendChild(btn13);
  }
}

function formatYear(year) {
  if (year <= 0) {
    // Astronomical year 0 = 1 BC, -1 = 2 BC, etc.
    return Math.abs(year - 1) + ' BC';
  }
  return String(year);  // No "AD" suffix for positive years
}

// Gregorian calendar reform date: October 15, 1582
// Before this date, use Julian calendar (following NASA/Stellarium convention)
const GREGORIAN_REFORM_DATE = new Date(1582, 9, 15); // Oct 15, 1582

// Convert a JavaScript Date (which is proleptic Gregorian) to Julian calendar date
// Returns { year, month, day } in Julian calendar
function gregorianToJulian(date) {
  // JavaScript dates are in proleptic Gregorian calendar
  // We need to convert to Julian for dates before 1582-10-15
  const year = date.getFullYear();
  const month = date.getMonth(); // 0-indexed
  const day = date.getDate();
  
  // Calculate Julian Day Number from Gregorian date
  const a = Math.floor((14 - (month + 1)) / 12);
  const y = year + 4800 - a;
  const m = (month + 1) + 12 * a - 3;
  
  // Julian Day Number for Gregorian calendar
  const jdn = day + Math.floor((153 * m + 2) / 5) + 365 * y + Math.floor(y / 4) - Math.floor(y / 100) + Math.floor(y / 400) - 32045;
  
  // Convert JDN back to Julian calendar date
  const c = jdn + 32082;
  const d = Math.floor((4 * c + 3) / 1461);
  const e = c - Math.floor(1461 * d / 4);
  const n = Math.floor((5 * e + 2) / 153);
  
  const julianDay = e - Math.floor((153 * n + 2) / 5) + 1;
  const julianMonth = n + 3 - 12 * Math.floor(n / 10); // 1-indexed
  const julianYear = d - 4800 + Math.floor(n / 10);
  
  return { year: julianYear, month: julianMonth - 1, day: julianDay }; // month 0-indexed to match JS
}

// Check if a date is before the Gregorian reform
function isBeforeGregorianReform(date) {
  return date < GREGORIAN_REFORM_DATE;
}

// Calculate Julian Day Number from Julian calendar date (year, month 0-indexed, day)
function julianCalendarToJDN(year, month, day) {
  // Convert 0-indexed month to 1-indexed
  const m = month + 1;
  const a = Math.floor((14 - m) / 12);
  const y = year + 4800 - a;
  const mm = m + 12 * a - 3;
  // Julian calendar formula
  return day + Math.floor((153 * mm + 2) / 5) + 365 * y + Math.floor(y / 4) - 32083;
}

// Calculate day of week from Julian Day Number (0 = Sunday, 6 = Saturday)
function jdnToWeekday(jdn) {
  return (jdn + 1) % 7;
}

// Get correct weekday for a date (handles Julian calendar for ancient dates)
function getCorrectWeekday(date) {
  if (isBeforeGregorianReform(date)) {
    const year = date.getUTCFullYear();
    const month = date.getUTCMonth();
    const day = date.getUTCDate();
    const jdn = julianCalendarToJDN(year, month, day);
    return jdnToWeekday(jdn);
  }
  return date.getUTCDay();
}

// Get formatted date components (handles Julian calendar for pre-1582 dates)
// Note: Dates from _jdToDate() already have Julian calendar components stored,
// so we just use getFullYear/getMonth/getDate directly - no conversion needed.
function getFormattedDateParts(date) {
  const weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
  const months = ['January', 'February', 'March', 'April', 'May', 'June', 
                  'July', 'August', 'September', 'October', 'November', 'December'];
  const shortMonths = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  
  // For ancient dates, use UTC methods to avoid timezone issues
  // The astronomy engine's _jdToDate already stores Julian calendar values
  const year = date.getUTCFullYear();
  const month = date.getUTCMonth();
  const day = date.getUTCDate();
  const isJulian = isBeforeGregorianReform(date);
  
  // Calculate weekday from Julian Day Number for correct result
  // (JavaScript's getUTCDay() uses proleptic Gregorian internally, which is wrong for Julian dates)
  let weekday;
  if (isJulian) {
    const jdn = julianCalendarToJDN(year, month, day);
    weekday = jdnToWeekday(jdn);
  } else {
    weekday = date.getUTCDay();
  }
  
  // Year string: only BC suffix, never AD
  const yearStr = year <= 0 ? `${Math.abs(year - 1)} BC` : `${year}`;
  
  return {
    year,
    yearStr,
    month,
    day,
    weekday,
    weekdayName: weekdays[weekday],
    monthName: months[month],
    shortMonthName: shortMonths[month],
    isJulian,
    calendarSuffix: isJulian ? ' (Julian)' : ''
  };
}

// Format a date for display in day detail panel: "Monday, January 1, 2025"
function formatDisplayDate(date) {
  const parts = getFormattedDateParts(date);
  return `${parts.weekdayName}, ${parts.monthName} ${parts.day}, ${parts.yearStr}${parts.calendarSuffix}`;
}

function getMoonIcon() {
  if (state.moonPhase === 'full') return 'ðŸŒ•';
  if (state.moonPhase === 'dark') return 'ðŸŒ‘';
  if (state.moonPhase === 'crescent') return 'ðŸŒ’';
  return 'ðŸŒ•';
}

// Get the moon phase icon for a specific date, but ONLY if a quarter phase
// (new moon 0Â°, first quarter 90Â°, full moon 180Â°, last quarter 270Â°) occurs during this lunar day
// Uses the calendar's day start/end definition (sunset, sunrise, etc.) rather than UTC midnight
function getMoonPhaseIconForDate(date) {
  try {
    // Get the lunar day start time for this date based on current calendar config
    const dayStartTs = getDayStartTime(date);
    
    // The lunar day runs from this day start to the next day's start
    // Calculate next day's start by getting the day start for tomorrow's Gregorian date
    const tomorrowGregorian = new Date(date.getTime());
    tomorrowGregorian.setUTCDate(tomorrowGregorian.getUTCDate() + 1);
    const dayEndTs = getDayStartTime(tomorrowGregorian);
    
    const startOfDay = new Date(dayStartTs);
    const endOfDay = new Date(dayEndTs);
    
    const elongStart = getElongationForDate(startOfDay);
    const elongEnd = getElongationForDate(endOfDay);
    
    if (elongStart === null || elongEnd === null) return '';
    
    // Check each of the 4 major quarters
    const quarters = [
      { angle: 0, icon: 'ðŸŒ‘' },    // New Moon
      { angle: 90, icon: 'ðŸŒ“' },   // First Quarter
      { angle: 180, icon: 'ðŸŒ•' },  // Full Moon
      { angle: 270, icon: 'ðŸŒ—' }   // Last Quarter
    ];
    
    for (const quarter of quarters) {
      if (phaseOccursDuringDay(elongStart, elongEnd, quarter.angle)) {
        return quarter.icon;
      }
    }
    
    return ''; // No quarter phase on this day
  } catch (err) {
    console.warn('Error calculating moon phase:', err);
    return '';
  }
}

// Check if a phase angle is crossed between two elongation values
function phaseOccursDuringDay(elongStart, elongEnd, targetAngle) {
  // Elongation increases over time (moon moves ~12Â° per day relative to sun)
  // Handle the 360Â°â†’0Â° wraparound for new moon
  
  if (targetAngle === 0) {
    // New moon: elongation wraps from ~350+ to ~10-
    // This happens when elongStart is high (>300) and elongEnd is lower OR 
    // when elongStart > 350 and elongEnd is small
    if (elongStart > 300 && elongEnd < elongStart) {
      // Could be wraparound or normal decrease (shouldn't normally decrease much)
      // If elongEnd is small (<60), it wrapped around
      if (elongEnd < 60) return true;
    }
    // Also check if we're very close to 0 on either end
    if (elongStart > 350 || elongEnd < 10) {
      if (elongStart > 350 && elongEnd < 60) return true;
    }
  } else {
    // For other phases (90, 180, 270): check if targetAngle is between start and end
    // Normal case: elongation increases
    if (elongStart <= targetAngle && elongEnd >= targetAngle) return true;
    
    // Edge case: day spans the 360â†’0 boundary but target is not 0
    // In this case, elongStart > elongEnd due to wraparound
    if (elongStart > elongEnd) {
      // Wrapped around - check both segments
      if (elongStart <= targetAngle || elongEnd >= targetAngle) return true;
    }
  }
  
  return false;
}

// Get moon-sun elongation for a date
function getElongationForDate(date) {
  // For Swiss Ephemeris, use the elongation function directly
  if (AstroEngines.swissEphemeris.isLoaded && AstroEngines.swissEphemeris._dateToJD) {
    const jd = AstroEngines.swissEphemeris._dateToJD(date);
    const elongation = AstroEngines.swissEphemeris._getMoonSunElongation(jd);
    if (elongation !== null) return elongation;
  }
  
  // Fallback: use astronomy-engine
  try {
    const engine = getAstroEngine();
    const observer = engine.createObserver(state.lat, state.lon, 0);
    const sunEq = engine.getEquator('sun', date, observer);
    const moonEq = engine.getEquator('moon', date, observer);
    
    if (sunEq && moonEq) {
      let sunRA = sunEq.ra * 15;
      let moonRA = moonEq.ra * 15;
      let elongation = moonRA - sunRA;
      while (elongation < 0) elongation += 360;
      while (elongation >= 360) elongation -= 360;
      return elongation;
    }
  } catch (err) {}
  
  return null;
}

// Calculate angular distance between two angles (0-360), handling wraparound
function angularDistance(a, b) {
  let diff = Math.abs(a - b);
  if (diff > 180) diff = 360 - diff;
  return diff;
}

function getMoonLabel() {
  if (state.moonPhase === 'full') return 'Full Moon';
  if (state.moonPhase === 'dark') return 'Dark Moon';
  if (state.moonPhase === 'crescent') return 'Crescent';
  return 'New Moon';
}

// Get dynamic description for Renewed Moon based on current moon phase setting
function getRenewedMoonDescription() {
  const dayStartLabel = getDayStartLabel();
  const isCrescentSunset = state.moonPhase === 'crescent' && 
                           state.dayStartTime === 'evening' && 
                           state.dayStartAngle === 0;
  
  if (state.moonPhase === 'full') {
    return `Month begins at ${dayStartLabel} after full moon`;
  } else if (state.moonPhase === 'dark') {
    return `Month begins at ${dayStartLabel} after dark moon (conjunction)`;
  } else if (state.moonPhase === 'crescent') {
    if (isCrescentSunset) {
      return 'Month begins at sunset when first crescent is sighted';
    }
    return `Month begins at ${dayStartLabel} after crescent sighting`;
  }
  return 'Beginning of the month';
}

function generateCalendar(options = {}) {
  const preserveSelection = options.preserveMonth || false;
  
  // Save the selected UTC timestamp before regenerating
  const savedTimestamp = state.selectedTimestamp;
  
  // Sync UI inputs with state (state is source of truth)
  // Only read year from input, everything else is set BY state
  const yearInput = document.getElementById('year-input');
  const latInput = document.getElementById('lat-input');
  const lonInput = document.getElementById('lon-input');
  const moonPhaseSelect = document.getElementById('moon-phase-select');
  
  if (yearInput && yearInput.value) {
    state.year = parseInt(yearInput.value);
  }
  // State is source of truth - update inputs to match state
  if (latInput && lonInput) {
    latInput.value = state.lat ?? 31.7683;
    lonInput.value = state.lon ?? 35.2137;
  }
  if (moonPhaseSelect) {
    moonPhaseSelect.value = state.moonPhase;
  }
  
  if (!preserveSelection) {
    state.currentMonthIndex = 0;
    state.highlightedLunarDay = 1;  // Default to day 1
    state.selectedTimestamp = null;
  }
  
  // Save settings to localStorage
  saveState();
  
  // Update all UI to match state
  updateUI();
  
  const engine = getAstroEngine();
  const springEquinox = engine.getSeasons(state.year).mar_equinox.date;
  const nextSpringEquinox = engine.getSeasons(state.year + 1).mar_equinox.date;
  const moonEvents = findMoonEvents(state.year, state.moonPhase);
  
  // Get year start point based on yearStartRule setting
  const yearStartPoint = getYearStartPoint(state.year);
  const nextYearStartPoint = getYearStartPoint(state.year + 1);
  
  // Find first moon event on or after the year start point
  // The resulting month's Day 1 must start after the year start point
  let nissanMoon = moonEvents.find(m => m >= yearStartPoint);
  if (!nissanMoon) nissanMoon = moonEvents[0];
  
  // Calculate year-start uncertainty
  // If the Nisan moon is close to the year start point, Î”T uncertainty could cause
  // a different moon to be selected, shifting all months by ~29-30 days
  const yearStartMarginMs = nissanMoon.getTime() - yearStartPoint.getTime();
  const yearStartMarginHours = yearStartMarginMs / (1000 * 60 * 60);
  const deltaTUncertaintyHours = AstroEngines.nasaEclipse.getDeltaTUncertainty(state.year);
  
  let yearStartUncertainty = null;
  if (deltaTUncertaintyHours > 0 && yearStartMarginHours <= deltaTUncertaintyHours) {
    // The Nisan moon is close enough to the year start that it could be uncertain
    // If the moon shifts earlier due to Î”T error, it could fall BEFORE the year start point
    // In that case, the NEXT moon would be Nisan instead, so our year is "1 month ahead"
    // Probability: (U - M) / (2U) where U = uncertainty, M = margin
    const probability = Math.round(((deltaTUncertaintyHours - yearStartMarginHours) / (2 * deltaTUncertaintyHours)) * 100);
    if (probability > 0) {
      yearStartUncertainty = {
        direction: 'ahead',  // Our dates are potentially 1 month ahead of reality
        probability: probability,
        marginHours: yearStartMarginHours
      };
    }
  }
  
  // Store equinoxes and year start points in state for use in day details
  state.springEquinox = springEquinox;
  state.nextSpringEquinox = nextSpringEquinox;
  state.yearStartPoint = yearStartPoint;
  state.nextYearStartPoint = nextYearStartPoint;
  state.yearStartUncertainty = yearStartUncertainty;
  
  state.lunarMonths = buildLunarMonths(nissanMoon, moonEvents, springEquinox, nextYearStartPoint);
  
  // Guard against empty months array
  if (state.lunarMonths.length === 0) {
    console.error('No lunar months generated - check moon event data');
    console.error('nissanMoon:', nissanMoon);
    console.error('moonEvents count:', moonEvents.length);
    console.error('yearStartPoint:', yearStartPoint);
    console.error('nextYearStartPoint:', nextYearStartPoint);
    return;
  }
  
  // If preserving selection, find which lunar day contains the saved UTC timestamp
  if (preserveSelection && savedTimestamp) {
    const savedMoment = new Date(savedTimestamp);
    let found = false;
    
    for (let m = 0; m < state.lunarMonths.length && !found; m++) {
      const month = state.lunarMonths[m];
      for (let d = 0; d < month.days.length; d++) {
        const day = month.days[d];
        const dayStart = day.gregorianDate.getTime();
        // Day ends at start of next day (24 hours later)
        const dayEnd = dayStart + 24 * 60 * 60 * 1000;
        
        if (savedTimestamp >= dayStart && savedTimestamp < dayEnd) {
          state.currentMonthIndex = m;
          state.highlightedLunarDay = day.lunarDay;
          // Update the goto-date input to show local time at new location
          document.getElementById('goto-date').value = formatLocalDatetime(savedTimestamp);
          found = true;
          break;
        }
      }
    }
    // If timestamp not found in lunar months, just stay on month 0
    if (!found) {
      state.currentMonthIndex = 0;
      state.highlightedLunarDay = 1;  // Default to day 1
    }
  }
  
  renderMonthButtons();
  renderMonth(state.lunarMonths[state.currentMonthIndex]);
  renderFeastTable(state.lunarMonths);
  
  // Show day detail panel if a day is highlighted
  if (state.highlightedLunarDay) {
    const month = state.lunarMonths[state.currentMonthIndex];
    const dayObj = month.days.find(d => d.lunarDay === state.highlightedLunarDay);
    if (dayObj) {
      showDayDetail(dayObj, month);
    }
  }
}

function findMoonEvents(year, phaseType) {
  const engine = getAstroEngine();
  const events = [];
  
  // Create dates with proper year handling for ancient dates
  // JavaScript Date constructor doesn't handle negative years correctly
  let searchDate = new Date(Date.UTC(2000, 11, 1));
  searchDate.setUTCFullYear(year - 1);
  
  let endDate = new Date(Date.UTC(2000, 5, 1));
  endDate.setUTCFullYear(year + 1); // Search through May of next year to cover full lunar year
  
  // Moon phase angles: 0 = new/dark, 90 = first quarter, 180 = full, 270 = last quarter
  let targetPhase;
  if (phaseType === 'full') {
    targetPhase = 180;
  } else if (phaseType === 'dark') {
    targetPhase = 0;
  } else if (phaseType === 'crescent') {
    targetPhase = 0; // We'll find conjunction then calculate first visibility
  }
  
  while (searchDate < endDate) {
    const result = engine.searchMoonPhase(targetPhase, searchDate, 40);
    if (result) {
      let eventDate = result.date;
      
      // For crescent, add offset to conjunction to create a "forged conjunction" time
      // This represents when the crescent becomes visible, treated as if it were the conjunction
      // The rest of the algorithm (before/after sunset check) works the same as dark moon
      // - 12h: Optimistic (perfect conditions + optical aids)
      // - 15.5h: Minimum viable (naked-eye record)
      // - 18h: Typical (standard naked-eye visibility)
      // - 24h: Conservative (easily visible to anyone)
      if (phaseType === 'crescent') {
        const conjunction = result.date;
        const crescentOffsetHours = state.crescentThreshold;
        eventDate = new Date(conjunction.getTime() + crescentOffsetHours * 60 * 60 * 1000);
      }
      
      events.push(eventDate);
      searchDate = new Date(result.date.getTime() + 20 * 24 * 60 * 60 * 1000);
    } else break;
  }
  return events;
}

// Convert UTC date to local date based on longitude (solar time)
function getLocalDateFromUTC(utcDate, longitude) {
  // Calculate timezone offset based on longitude
  // Each 15Â° of longitude = 1 hour offset
  const hourOffset = longitude / 15;
  
  // For ancient dates, _jdToDate stores Julian calendar components in the Date object.
  // We need to work with UTC components directly to avoid JavaScript's proleptic Gregorian timestamp issues.
  const utcHour = utcDate.getUTCHours() + utcDate.getUTCMinutes() / 60;
  const localHour = utcHour + hourOffset;
  
  // Get the base date components (these are already in the correct calendar from _jdToDate)
  let year = utcDate.getUTCFullYear();
  let month = utcDate.getUTCMonth();
  let day = utcDate.getUTCDate();
  
  // Adjust day if local time crosses midnight
  if (localHour >= 24) {
    day += 1;
    // Handle month/year rollover (simplified - assumes 30-day months for edge cases)
    const daysInMonth = new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    if (day > daysInMonth) {
      day = 1;
      month += 1;
      if (month > 11) {
        month = 0;
        year += 1;
      }
    }
  } else if (localHour < 0) {
    day -= 1;
    if (day < 1) {
      month -= 1;
      if (month < 0) {
        month = 11;
        year -= 1;
      }
      day = new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }
  }
  
  // Create date with correct components (use Date.UTC and setUTCFullYear for ancient dates)
  const result = new Date(Date.UTC(2000, month, day, 0, 0, 0));
  result.setUTCFullYear(year);
  return result;
}

// Calculate what lunar day a timestamp falls on for a given profile's settings
// Returns { day: number, month: number } or null if unable to calculate
function getLunarDayForTimestamp(timestamp, profile) {
  try {
    const date = new Date(timestamp);
    let year = date.getFullYear();
    
    // Temporarily store current state and apply profile settings
    const savedState = {
      moonPhase: state.moonPhase,
      dayStartTime: state.dayStartTime,
      dayStartAngle: state.dayStartAngle,
      yearStartRule: state.yearStartRule,
      crescentThreshold: state.crescentThreshold,
      lat: state.lat,
      lon: state.lon
    };
    
    // Apply profile settings temporarily (with defaults for undefined values)
    state.moonPhase = profile.moonPhase || 'full';
    state.dayStartTime = profile.dayStartTime || 'morning';
    state.dayStartAngle = profile.dayStartAngle ?? 12;
    state.yearStartRule = profile.yearStartRule || 'equinox';
    state.crescentThreshold = profile.crescentThreshold ?? 18;
    state.lat = profile.lat ?? 31.7683;
    state.lon = profile.lon ?? 35.2137;
    
    const engine = getAstroEngine();
    
    // Check if timestamp is before this year's spring equinox - if so, use previous year
    const thisYearEquinox = engine.getSeasons(year).mar_equinox.date;
    if (date < thisYearEquinox) {
      year = year - 1;
    }
    
    // Find moon events for the year (need events spanning into next year)
    const moonEvents = findMoonEvents(year, profile.moonPhase);
    if (!moonEvents || moonEvents.length === 0) {
      Object.assign(state, savedState);
      return null;
    }
    
    // Find the spring equinox for the lunar year
    const springEquinox = engine.getSeasons(year).mar_equinox.date;
    
    // Find the first moon event on or after the spring equinox for Nisan
    let nissanMoon = null;
    for (const event of moonEvents) {
      if (event >= springEquinox) {
        nissanMoon = event;
        break;
      }
    }
    
    // If no moon event after equinox, check the last one before
    if (!nissanMoon && moonEvents.length > 0) {
      for (let i = moonEvents.length - 1; i >= 0; i--) {
        if (moonEvents[i] < springEquinox) {
          nissanMoon = moonEvents[i];
          break;
        }
      }
    }
    
    if (!nissanMoon) {
      Object.assign(state, savedState);
      return null;
    }
    
    // Build simplified lunar months to find the day
    const observerLon = profile.lon;
    let currentMoonIdx = moonEvents.findIndex(m => Math.abs(m.getTime() - nissanMoon.getTime()) < 1000);
    if (currentMoonIdx === -1) currentMoonIdx = moonEvents.findIndex(m => m >= nissanMoon);
    
    // Iterate through months to find where the timestamp falls
    for (let m = 0; m < 13 && currentMoonIdx < moonEvents.length - 1; m++) {
      const moonEvent = moonEvents[currentMoonIdx];
      const nextMoonEvent = moonEvents[currentMoonIdx + 1];
      
      // Calculate month start date (similar to buildLunarMonths)
      const moonEventLocalDate = new Date(moonEvent.getTime());
      const monthStartDate = new Date(Date.UTC(
        moonEventLocalDate.getUTCFullYear(),
        moonEventLocalDate.getUTCMonth(),
        moonEventLocalDate.getUTCDate(),
        0, 0, 0
      ));
      
      // Apply day offset based on settings
      if ((profile.moonPhase === 'dark' || profile.moonPhase === 'full' || profile.moonPhase === 'crescent') && profile.dayStartTime === 'evening') {
        const sunsetOnMoonDate = getSunsetTimestamp(moonEventLocalDate);
        if (sunsetOnMoonDate != null) {
          const moonEventLocalTime = moonEvent.getTime() + (observerLon / 15) * 60 * 60 * 1000;
          const sunsetLocalTime = sunsetOnMoonDate + (observerLon / 15) * 60 * 60 * 1000;
          if (moonEventLocalTime > sunsetLocalTime) {
            monthStartDate.setUTCDate(monthStartDate.getUTCDate() + 1);
          }
        }
      }
      
      // Calculate next month start
      const nextMoonEventLocalDate = new Date(nextMoonEvent.getTime());
      const nextMonthStart = new Date(Date.UTC(
        nextMoonEventLocalDate.getUTCFullYear(),
        nextMoonEventLocalDate.getUTCMonth(),
        nextMoonEventLocalDate.getUTCDate(),
        0, 0, 0
      ));
      
      if ((profile.moonPhase === 'dark' || profile.moonPhase === 'full' || profile.moonPhase === 'crescent') && profile.dayStartTime === 'evening') {
        const sunsetOnNextMoonDate = getSunsetTimestamp(nextMoonEventLocalDate);
        if (sunsetOnNextMoonDate != null) {
          const nextMoonEventLocalTime = nextMoonEvent.getTime() + (observerLon / 15) * 60 * 60 * 1000;
          const nextSunsetLocalTime = sunsetOnNextMoonDate + (observerLon / 15) * 60 * 60 * 1000;
          if (nextMoonEventLocalTime > nextSunsetLocalTime) {
            nextMonthStart.setUTCDate(nextMonthStart.getUTCDate() + 1);
          }
        }
      }
      
      // Check if timestamp falls in this month
      const timestampDate = new Date(timestamp);
      const timestampDayStart = new Date(Date.UTC(
        timestampDate.getUTCFullYear(),
        timestampDate.getUTCMonth(),
        timestampDate.getUTCDate(),
        0, 0, 0
      ));
      
      if (timestampDayStart >= monthStartDate && timestampDayStart < nextMonthStart) {
        // Found the month - calculate the day
        const dayOffset = Math.floor((timestampDayStart - monthStartDate) / (24 * 60 * 60 * 1000));
        const lunarDay = dayOffset + 1;
        
        // Restore state
        Object.assign(state, savedState);
        return { day: lunarDay, month: m + 1 };
      }
      
      currentMoonIdx++;
    }
    
    // Restore state
    Object.assign(state, savedState);
    return null;
  } catch (e) {
    console.warn('Error calculating lunar day for profile:', e);
    return null;
  }
}

function buildLunarMonths(nissanMoon, allMoonEvents, springEquinox, nextYearStartPoint) {
  const months = [];
  
  // Use fuzzy timestamp comparison (within 1 second) to handle potential Date object differences
  let startIdx = allMoonEvents.findIndex(m => Math.abs(m.getTime() - nissanMoon.getTime()) < 1000);
  if (startIdx === -1) startIdx = allMoonEvents.findIndex(m => m >= nissanMoon);
  if (startIdx === -1) startIdx = 0; // Final fallback to first event
  
  // Get observer's longitude for local time calculation
  const observerLon = parseFloat(document.getElementById('lon-input')?.value) || 35.2137;
  
  
  for (let m = 0; m < 13 && (startIdx + m) < allMoonEvents.length - 1; m++) {
    const moonEvent = allMoonEvents[startIdx + m];
    
    // Stop if this moon event is after the next year's start point (belongs to next year)
    if (moonEvent >= nextYearStartPoint) break;
    
    const nextMoonEvent = allMoonEvents[startIdx + m + 1];
    
    // Calculate local date of moon event based on observer's longitude
    const moonEventLocalDate = getLocalDateFromUTC(moonEvent, observerLon);
    
    // Determine when Day 1 starts based on day start settings
    // General rule: Day 1 starts at the NEXT day start after the moon event
    let monthStartDate = new Date(moonEventLocalDate.getTime());
    
    // For dark/full/crescent moon with evening day start, check if moon event is before or after sunset
    if ((state.moonPhase === 'dark' || state.moonPhase === 'full' || state.moonPhase === 'crescent') && state.dayStartTime === 'evening') {
      // Get sunset time on the moon event's local date
      const sunsetOnMoonDate = getSunsetTimestamp(moonEventLocalDate);
      
      // Convert times to local for comparison
      const moonEventLocalTime = moonEvent.getTime() + (observerLon / 15) * 60 * 60 * 1000;
      const sunsetLocalTime = sunsetOnMoonDate + (observerLon / 15) * 60 * 60 * 1000;
      
      // Day 1 starts at the NEXT sunset after the moon event
      // - If moon event is AFTER sunset on its calendar date â†’ next sunset is tomorrow â†’ add 1 day
      // - Otherwise (before sunset, including early morning before sunrise) â†’ next sunset is today â†’ add 0 days
      if (moonEventLocalTime > sunsetLocalTime) {
        // Moon event is AFTER sunset - Day 1 starts at next day's sunset
        monthStartDate.setUTCDate(monthStartDate.getUTCDate() + 1);
      }
      // If moon event is before sunset (including early morning), Day 1 starts at same day's sunset (add 0 days)
    } else if ((state.moonPhase === 'dark' || state.moonPhase === 'full' || state.moonPhase === 'crescent') && state.dayStartTime === 'morning') {
      // For morning day start, check if moon event is before or after sunrise
      const sunriseOnMoonDate = getSunriseTimestamp(moonEventLocalDate);
      
      // Convert moon event to local time at observer's longitude for comparison
      const moonEventLocalTime = moonEvent.getTime() + (observerLon / 15) * 60 * 60 * 1000;
      const sunriseLocalTime = sunriseOnMoonDate + (observerLon / 15) * 60 * 60 * 1000;
      
      if (moonEventLocalTime >= sunriseLocalTime) {
        // Moon event is AT or AFTER sunrise - Day 1 starts at next sunrise (add 1 day)
        monthStartDate.setUTCDate(monthStartDate.getUTCDate() + 1);
      }
      // If moon event is BEFORE sunrise, Day 1 starts at same day's sunrise (add 0 days)
    } else {
      // For other modes, just add 1 day
      monthStartDate.setUTCDate(monthStartDate.getUTCDate() + 1);
    }
    
    // Same logic for next month start
    const nextMoonEventLocalDate = getLocalDateFromUTC(nextMoonEvent, observerLon);
    let nextMonthStart = new Date(nextMoonEventLocalDate.getTime());
    
    if ((state.moonPhase === 'dark' || state.moonPhase === 'full' || state.moonPhase === 'crescent') && state.dayStartTime === 'evening') {
      const sunsetOnNextMoonDate = getSunsetTimestamp(nextMoonEventLocalDate);
      const nextMoonEventLocalTime = nextMoonEvent.getTime() + (observerLon / 15) * 60 * 60 * 1000;
      const nextSunsetLocalTime = sunsetOnNextMoonDate + (observerLon / 15) * 60 * 60 * 1000;
      
      // Day 1 starts at the NEXT sunset after the moon event
      if (nextMoonEventLocalTime > nextSunsetLocalTime) {
        // Moon event is AFTER sunset - Day 1 starts at next day's sunset
        nextMonthStart.setUTCDate(nextMonthStart.getUTCDate() + 1);
      }
      // If moon event is before sunset, Day 1 starts at same day's sunset (add 0 days)
    } else if ((state.moonPhase === 'dark' || state.moonPhase === 'full' || state.moonPhase === 'crescent') && state.dayStartTime === 'morning') {
      // For morning day start, check if moon event is before or after sunrise
      const sunriseOnNextMoonDate = getSunriseTimestamp(nextMoonEventLocalDate);
      const nextMoonEventLocalTime = nextMoonEvent.getTime() + (observerLon / 15) * 60 * 60 * 1000;
      const nextSunriseLocalTime = sunriseOnNextMoonDate + (observerLon / 15) * 60 * 60 * 1000;
      
      if (nextMoonEventLocalTime >= nextSunriseLocalTime) {
        // Moon event is AT or AFTER sunrise - add 1 day
        nextMonthStart.setUTCDate(nextMonthStart.getUTCDate() + 1);
      }
      // If moon event is BEFORE sunrise, starts at same day's sunrise (add 0 days)
    } else {
      nextMonthStart.setUTCDate(nextMonthStart.getUTCDate() + 1);
    }
    
    const daysInMonth = Math.round((nextMonthStart - monthStartDate) / (24 * 60 * 60 * 1000));
    
    // Calculate date uncertainty for this month
    // Î”T uncertainty affects the calculated time of the moon event (conjunction, full, or forged crescent).
    // If the moon event is close to the day boundary (sunset for evening start, sunrise for morning start),
    // the uncertainty could shift whether Day 1 starts on this date or the next.
    // Direction: '+' means dates could be 1 day later, '-' means 1 day earlier
    let dateUncertainty = null; // null, '+', or '-'
    let dateUncertaintyProbability = 0; // Probability that dates are wrong (0-100%)
    
    const eventYear = moonEvent.getUTCFullYear();
    const uncertaintyHours = AstroEngines.nasaEclipse.getDeltaTUncertainty(eventYear);
    
    if (uncertaintyHours > 0) {
      const moonEventLocalTime = moonEvent.getTime() + (observerLon / 15) * 60 * 60 * 1000;
      
      // Get the day boundary time based on day start setting
      let boundaryTime, boundaryLocalTime;
      if (state.dayStartTime === 'evening') {
        boundaryTime = getSunsetTimestamp(moonEventLocalDate);
      } else {
        boundaryTime = getSunriseTimestamp(moonEventLocalDate);
      }
      
      if (boundaryTime != null) {
        boundaryLocalTime = boundaryTime + (observerLon / 15) * 60 * 60 * 1000;
        const marginMs = Math.abs(moonEventLocalTime - boundaryLocalTime);
        const marginHours = marginMs / (1000 * 60 * 60);
        
        if (marginHours <= uncertaintyHours) {
          // Calculate probability that the date is wrong
          // If margin is M and uncertainty is Â±U, probability = (U - M) / (2U)
          dateUncertaintyProbability = Math.round(((uncertaintyHours - marginHours) / (2 * uncertaintyHours)) * 100);
          
          // Moon event after boundary - prior month has 30 days
          // If moon event was actually earlier, prior month would have 29 days
          // So dates in THIS month could be 1 day earlier (-)
          if (moonEventLocalTime >= boundaryLocalTime) {
            dateUncertainty = '-';
          } else {
            // Moon event before boundary - prior month has 29 days  
            // If moon event was actually later, prior month would have 30 days
            // So dates in THIS month could be 1 day later (+)
            dateUncertainty = '+';
          }
        }
      }
    }
    
    const days = [];
    for (let d = 1; d <= daysInMonth; d++) {
      const dayDate = new Date(monthStartDate.getTime());
      dayDate.setUTCDate(dayDate.getUTCDate() + d - 1);
      
      const isSabbath = [8, 15, 22, 29].includes(d);
      const isNewMoon = d === 1;
      // Day 30 with '+' is impossible (can't add days), so only show uncertainty for days 1-29 with '+', or all days with '-'
      const isUncertain = dateUncertainty !== null && (dateUncertainty === '-' || d < 30);
      
      // Find all feasts for this day (some days have multiple)
      let feasts = [];
      for (const f of FEASTS) {
        if (f.month === (m + 1)) {
          if (f.endDay) {
            if (d >= f.day && d <= f.endDay) {
              const dayNum = f.startDayNum ? (f.startDayNum + d - f.day) : (d - f.day + 1);
              feasts.push({ feast: f, dayNum });
            }
          } else if (d === f.day) {
            feasts.push({ feast: f, dayNum: null });
          }
        }
      }
      // For backwards compatibility
      const feast = feasts.length > 0 ? feasts[0].feast : null;
      const feastDayNum = feasts.length > 0 ? feasts[0].dayNum : null;
      
      // Calculate moon phase for this day
      // For Day 1, force the icon based on mode (since Day 1 IS the phase by definition)
      // For other days, calculate from astronomical position
      let moonPhase = '';
      if (d === 1) {
        // Day 1 always shows the mode-defining phase
        if (state.moonPhase === 'full') moonPhase = 'ðŸŒ•';
        else if (state.moonPhase === 'dark') moonPhase = 'ðŸŒ‘';
        else if (state.moonPhase === 'crescent') moonPhase = 'ðŸŒ’';
      } else {
        moonPhase = getMoonPhaseIconForDate(dayDate);
      }
      
      // Check if spring equinox falls on this day
      const dayStart = dayDate.getTime();
      const dayEnd = dayStart + 24 * 60 * 60 * 1000;
      let equinox = null;
      if (springEquinox && springEquinox.getTime() >= dayStart && springEquinox.getTime() < dayEnd) {
        equinox = { type: 'spring', date: springEquinox };
      } else if (state.nextSpringEquinox && state.nextSpringEquinox.getTime() >= dayStart && state.nextSpringEquinox.getTime() < dayEnd) {
        equinox = { type: 'spring', date: state.nextSpringEquinox };
      }
      
      // Check if there's a lunar eclipse (blood moon) - only on days with a full moon icon
      // For Day 1 in full moon mode, check against the month's moon event date
      let isBloodMoon = false;
      if (moonPhase === 'ðŸŒ•') {
        const checkDate = (d === 1 && moonEvent) ? moonEvent : dayDate;
        isBloodMoon = AstroEngines.nasaEclipse.hasLunarEclipse(checkDate);
      }
      
      days.push({
        lunarDay: d,
        gregorianDate: dayDate,
        isSabbath,
        isNewMoon,
        isUncertain,  // True if this day (Day 30) might not exist due to Î”T uncertainty
        feast,
        feastDayNum,
        feasts,  // Array of all feasts for this day
        moonPhase,
        equinox,  // Spring equinox if it falls on this day
        isBloodMoon  // True if there's a lunar eclipse on this day
      });
    }
    
    months.push({
      monthNumber: m + 1,
      name: MONTH_NAMES[m] || `Month ${m + 1}`,
      startDate: monthStartDate,
      moonEvent: moonEvent,
      daysInMonth,
      dateUncertainty,  // '+', '-', or null - direction dates could be off
      dateUncertaintyProbability,  // 0-100% probability that dates are wrong
      days
    });
  }
  
  return months;
}

function formatShortDate(date) {
  const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  // Use UTC methods - dates from _jdToDate already have correct calendar components stored
  return `${months[date.getUTCMonth()]} ${date.getUTCDate()}`;
}

// Calculate sunrise timestamp for a given date at the selected location
function getSunriseTimestamp(date) {
  const engine = getAstroEngine();
  const observer = engine.createObserver(state.lat, state.lon, 0);
  // Search for sunrise starting from midnight of that day (use UTC for ancient dates)
  const midnightUTC = new Date(Date.UTC(2000, date.getUTCMonth(), date.getUTCDate(), 0, 0, 0));
  midnightUTC.setUTCFullYear(date.getUTCFullYear());
  const sunrise = engine.searchRiseSet('sun', observer, +1, midnightUTC, 1);
  if (sunrise) {
    return sunrise.date.getTime();
  }
  // Fallback to 6am if no sunrise found (polar regions)
  return midnightUTC.getTime() + 6 * 60 * 60 * 1000;
}

// Calculate sunset timestamp for a given date at the selected location
function getSunsetTimestamp(date) {
  const engine = getAstroEngine();
  const observer = engine.createObserver(state.lat, state.lon, 0);
  // Use noon UTC as search start to find THIS day's sunset (not previous day's)
  const noonUTC = new Date(Date.UTC(2000, date.getUTCMonth(), date.getUTCDate(), 12, 0, 0));
  noonUTC.setUTCFullYear(date.getUTCFullYear());
  const sunset = engine.searchRiseSet('sun', observer, -1, noonUTC, 1);
  if (sunset) {
    return sunset.date.getTime();
  }
  // Fallback to 6pm if no sunset found (polar regions)
  return midnightUTC.getTime() + 18 * 60 * 60 * 1000;
}

// Format a UTC time in the observer's local timezone based on longitude
// Returns an object with formatted time string and timezone abbreviation
function formatTimeInObserverTimezone(utcDate) {
  // Calculate timezone offset based on longitude (simple solar time approximation)
  // Each 15 degrees = 1 hour
  const offsetHours = state.lon / 15;
  const offsetMs = offsetHours * 60 * 60 * 1000;
  
  // Create local time by adding offset
  const localTime = new Date(utcDate.getTime() + offsetMs);
  
  // Format the time
  let hours = localTime.getUTCHours();
  const minutes = localTime.getUTCMinutes();
  const ampm = hours >= 12 ? 'PM' : 'AM';
  hours = hours % 12;
  if (hours === 0) hours = 12;
  const timeStr = `${hours}:${minutes.toString().padStart(2, '0')} ${ampm}`;
  
  // Format timezone offset (e.g., UTC+2, UTC-5)
  const offsetSign = offsetHours >= 0 ? '+' : '';
  const offsetStr = `UTC${offsetSign}${offsetHours.toFixed(0)}`;
  
  return {
    time: timeStr,
    timezone: offsetStr,
    full: `${timeStr} ${offsetStr}`
  };
}

// Get all astronomical times for a given date (first light, sunrise, sunset, nautical twilight)
function getAstronomicalTimes(date) {
  try {
    const engine = getAstroEngine();
    const observer = engine.createObserver(state.lat, state.lon, 0);
    
    // Use UTC for dates
    const midnightUTC = new Date(Date.UTC(2000, date.getUTCMonth(), date.getUTCDate(), 0, 0, 0));
    midnightUTC.setUTCFullYear(date.getUTCFullYear());
    
    // Sunrise (sun rises above horizon)
    const sunriseResult = engine.searchRiseSet('sun', observer, +1, midnightUTC, 1);
    const sunriseTs = sunriseResult ? sunriseResult.date.getTime() : null;
    
    // Sunset (sun sets below horizon)
    const sunsetResult = engine.searchRiseSet('sun', observer, -1, midnightUTC, 1);
    const sunsetTs = sunsetResult ? sunsetResult.date.getTime() : null;
    
    // First light (civil dawn) - sun is 6Â° below horizon in the morning
    // Search for sun reaching -6Â° altitude before sunrise
    let firstLightTs = null;
    if (sunriseTs) {
      const beforeSunrise = new Date(sunriseTs - 2 * 60 * 60 * 1000); // 2 hours before sunrise
      const civilDawn = engine.searchAltitude('sun', observer, +1, beforeSunrise, 1, -6);
      if (civilDawn) {
        firstLightTs = civilDawn.date.getTime();
      }
    }
    
    // Nautical twilight (end) - sun is 12Â° below horizon after sunset
    // Search for sun reaching -12Â° altitude after sunset
    let nauticalTwilightTs = null;
    if (sunsetTs) {
      const nauticalDusk = engine.searchAltitude('sun', observer, -1, new Date(sunsetTs), 1, -12);
      if (nauticalDusk) {
        nauticalTwilightTs = nauticalDusk.date.getTime();
      }
    }
    
    // Format times in observer's local time
    const formatTime = (ts) => {
      if (!ts) return '--:--';
      const localTime = utcToLocalTime(ts, state.lon);
      const hours = localTime.getUTCHours();
      const mins = String(localTime.getUTCMinutes()).padStart(2, '0');
      const ampm = hours >= 12 ? 'PM' : 'AM';
      const hour12 = hours % 12 || 12;
      return `${hour12}:${mins} ${ampm}`;
    };
    
    return {
      firstLight: formatTime(firstLightTs),
      sunrise: formatTime(sunriseTs),
      sunset: formatTime(sunsetTs),
      nauticalTwilight: formatTime(nauticalTwilightTs)
    };
  } catch (err) {
    console.warn('Error calculating astronomical times:', err);
    return null;
  }
}

// Calculate moon altitude at sunset for a given date
// Returns an object with sunset time, moon altitude, and elongation
function getMoonAltitudeAtSunset(date) {
  try {
    const engine = getAstroEngine();
    const observer = engine.createObserver(state.lat, state.lon, 0);
    
    // Create midnight date with proper handling for ancient years
    // Using setUTCFullYear to avoid JavaScript treating small years (0-99) as 1900+year
    const midnight = new Date(Date.UTC(2000, date.getUTCMonth(), date.getUTCDate(), 0, 0, 0));
    midnight.setUTCFullYear(date.getUTCFullYear());
    
    // Find sunset on this day
    const sunset = engine.searchRiseSet('sun', observer, -1, midnight, 1);
    
    if (!sunset) {
      return null;
    }
    
    // Ensure the sunset date has the correct year (engine may return 1900+year for small years)
    let sunsetDate = sunset.date;
    if (sunsetDate.getUTCFullYear() !== date.getUTCFullYear()) {
      // Create a corrected date with the proper year
      const correctedSunset = new Date(Date.UTC(
        2000,
        sunsetDate.getUTCMonth(),
        sunsetDate.getUTCDate(),
        sunsetDate.getUTCHours(),
        sunsetDate.getUTCMinutes(),
        sunsetDate.getUTCSeconds()
      ));
      correctedSunset.setUTCFullYear(date.getUTCFullYear());
      sunsetDate = correctedSunset;
    }
    
    // Calculate moon position at sunset (use original sunset.date for astronomy calculations)
    const moonEquator = engine.getEquator('moon', sunset.date, observer);
    const moonHorizon = engine.getHorizon(sunset.date, observer, moonEquator.ra, moonEquator.dec);
    
    // Calculate sun position at sunset
    const sunEquator = engine.getEquator('sun', sunset.date, observer);
    
    // Calculate elongation using spherical geometry (angular distance between RA/Dec positions)
    // Convert RA from hours to degrees
    const moonRaDeg = moonEquator.ra * 15;
    const sunRaDeg = sunEquator.ra * 15;
    const moonDecRad = moonEquator.dec * Math.PI / 180;
    const sunDecRad = sunEquator.dec * Math.PI / 180;
    const deltaRaRad = (moonRaDeg - sunRaDeg) * Math.PI / 180;
    
    // Spherical law of cosines for angular distance
    const cosAngle = Math.sin(sunDecRad) * Math.sin(moonDecRad) + 
                     Math.cos(sunDecRad) * Math.cos(moonDecRad) * Math.cos(deltaRaRad);
    const elongation = Math.acos(Math.max(-1, Math.min(1, cosAngle))) * 180 / Math.PI;
    
    return {
      sunsetTime: sunsetDate,  // Use corrected date with proper year
      moonAltitude: moonHorizon.altitude,
      moonAzimuth: moonHorizon.azimuth,
      elongation: elongation
    };
  } catch (e) {
    console.error('Error calculating moon altitude at sunset:', e);
    return null;
  }
}

// Get the day start time for a given date based on current settings
// Returns a UTC timestamp for when the day starts
function getDayStartTime(date) {
  const engine = getAstroEngine();
  const observer = engine.createObserver(state.lat, state.lon, 0);
  
  // Use UTC methods to avoid timezone issues with ancient dates
  const midnightUTC = new Date(Date.UTC(2000, date.getUTCMonth(), date.getUTCDate(), 0, 0, 0));
  midnightUTC.setUTCFullYear(date.getUTCFullYear());
  
  // Direction: -1 for evening (descending sun), +1 for morning (ascending sun)
  const direction = state.dayStartTime === 'evening' ? -1 : +1;
  
  // For evening, we need to search from noon of the previous day
  // For morning, we search from midnight of this day
  let searchStart = midnightUTC;
  if (state.dayStartTime === 'evening') {
    // Search starting from noon of the previous day to find evening twilight
    searchStart = new Date(midnightUTC.getTime() - 12 * 60 * 60 * 1000);
  }
  
  let result;
  if (state.dayStartAngle === 0) {
    // Use sunrise/sunset (sun at horizon)
    result = engine.searchRiseSet('sun', observer, direction, searchStart, 1);
  } else {
    // Use twilight angle (sun below horizon)
    // SearchAltitude finds when sun reaches the specified altitude
    result = engine.searchAltitude('sun', observer, direction, searchStart, 1, -state.dayStartAngle);
  }
  
  if (result) {
    return result.date.getTime();
  }
  
  // Fallback for polar regions
  if (state.dayStartTime === 'morning') {
    return midnightUTC.getTime() + 6 * 60 * 60 * 1000; // 6am
  } else {
    return midnightUTC.getTime() - 6 * 60 * 60 * 1000; // 6pm previous day
  }
}

// Get the year start point based on yearStartRule setting
function getYearStartPoint(year) {
  const engine = getAstroEngine();
  const springEquinox = engine.getSeasons(year).mar_equinox.date;
  
  if (state.yearStartRule === '13daysBefore') {
    // Return 14 days before the equinox (Day 15 must be on or after equinox per Maimonides)
    return new Date(springEquinox.getTime() - 14 * 24 * 60 * 60 * 1000);
  }
  
  if (state.yearStartRule === 'virgoFeet') {
    // Creator's Calendar: First full moon after equinox where moon is "under Virgo's feet"
    // Moon ecliptic longitude must be > Spica longitude (~204Â°)
    // This returns the date of that specific full moon, not just the equinox
    const virgoFullMoon = findVirgoFeetFullMoon(year);
    if (virgoFullMoon) {
      // Return a point just before the full moon so it gets selected
      return new Date(virgoFullMoon.getTime() - 1000);
    }
  }
  
  return springEquinox;
}

// Spica (Î± Virginis) ecliptic longitude at J2000.0 epoch
const SPICA_ECLIPTIC_LON_J2000 = 203.8;

// Precession rate: ~50.3 arcseconds per year = 0.01397 degrees per year
const PRECESSION_RATE_DEG_PER_YEAR = 50.3 / 3600;

// Get Spica's ecliptic longitude adjusted for precession at a given year
// Precession causes the vernal equinox to move westward, so ecliptic longitudes of fixed stars increase over time
function getSpicaLongitudeForYear(year) {
  const yearsFromJ2000 = year - 2000;
  // Ecliptic longitude increases as the vernal equinox precesses westward
  return SPICA_ECLIPTIC_LON_J2000 + (yearsFromJ2000 * PRECESSION_RATE_DEG_PER_YEAR);
}

// Virgo calculation cache is stored in AstroEngines.virgoCache

// Find the first full moon after spring equinox where Spica sets before the Moon
// This is the Creator's Calendar rule: at moonset (morning after full moon night),
// Spica must set before the Moon sets. When Spica sets first, the Moon is "under 
// Virgo's feet" - behind/below Spica in the sky.
// 
// The Creator's Calendar day starts at sunrise, so we check at sunrise on the full moon date.
// We compare Right Ascensions: if Moon RA > Spica RA, Spica sets before Moon.
// (Objects with lower RA cross the horizon earlier)
function findVirgoFeetFullMoon(year) {
  const engine = getAstroEngine();
  const springEquinox = engine.getSeasons(year).mar_equinox.date;
  
  // Spica's coordinates (J2000, with precession adjustment)
  // RA: 13h 25m 11.6s = 201.298Â° at J2000
  // The RA increases slightly due to precession (~0.0139Â°/year)
  const yearsFromJ2000 = year - 2000;
  const spicaRA_J2000 = 201.298;  // degrees
  const spicaRA = spicaRA_J2000 + (yearsFromJ2000 * PRECESSION_RATE_DEG_PER_YEAR);
  
  // Use observer's configured location for sunrise calculation
  const obsLat = state.lat ?? 31.7683;
  const obsLon = state.lon ?? 35.2137;
  const observer = engine.createObserver(obsLat, obsLon, 0);
  
  // Start search 29 days before equinox to catch the prior full moon
  // The Virgo rule is purely about Spica/Moon position, not the equinox
  const searchStart = new Date(springEquinox.getTime() - 29 * 24 * 60 * 60 * 1000);
  
  const locationName = getCurrentLocationName();
  console.log(`[Virgo Rule] Year ${year}: Spring equinox = ${springEquinox.toISOString()}`);
  console.log(`[Virgo Rule] Location: ${locationName} (${obsLat.toFixed(4)}, ${obsLon.toFixed(4)})`);
  console.log(`[Virgo Rule] Search starts: ${searchStart.toISOString()} (29 days before equinox)`);
  console.log(`[Virgo Rule] Spica RA (precession-adjusted) = ${spicaRA.toFixed(3)}Â°`);
  
  // Find full moons from 29 days before equinox
  let searchDate = new Date(searchStart.getTime());
  const attempts_log = [];
  
  for (let attempts = 0; attempts < 4; attempts++) {
    const result = engine.searchMoonPhase(180, searchDate, 40);  // 180 = full moon
    if (!result) break;
    
    const fullMoonDate = result.date;
    
    // Find sunrise on the full moon date (Creator's Calendar day start)
    const midnightUTC = new Date(Date.UTC(
      fullMoonDate.getUTCFullYear(),
      fullMoonDate.getUTCMonth(),
      fullMoonDate.getUTCDate(),
      0, 0, 0
    ));
    const sunriseResult = engine.searchRiseSet('sun', observer, +1, midnightUTC, 1);
    const sunriseTime = sunriseResult ? sunriseResult.date : midnightUTC;
    
    // Get Moon's Right Ascension at sunrise (when checking moonset)
    const moonRA = getMoonRightAscension(sunriseTime);
    
    const diff = moonRA - spicaRA;
    const spicaSetsFirst = diff > 0;  // Moon RA > Spica RA means Spica sets first
    const attemptInfo = {
      fullMoon: fullMoonDate.toISOString(),
      sunrise: sunriseTime.toISOString(),
      moonRA: moonRA.toFixed(3),
      spicaRA: spicaRA.toFixed(3),
      spicaSetsFirst: spicaSetsFirst,
      diff: diff.toFixed(3)
    };
    attempts_log.push(attemptInfo);
    
    console.log(`[Virgo Rule] Full Moon #${attempts + 1}: ${fullMoonDate.toISOString()}`);
    console.log(`[Virgo Rule]   Sunrise: ${sunriseTime.toISOString()}`);
    console.log(`[Virgo Rule]   Moon RA: ${moonRA.toFixed(3)}Â°, Spica RA: ${spicaRA.toFixed(3)}Â°`);
    console.log(`[Virgo Rule]   Difference: ${(moonRA - spicaRA).toFixed(3)}Â° (positive = Spica sets first)`);
    console.log(`[Virgo Rule]   Spica sets before Moon: ${moonRA > spicaRA}`);
    
    // Check if Spica sets before the Moon (Moon RA > Spica RA means Spica sets first)
    // For spring full moons, both Spica (~201Â°) and Moon (~180-220Â°) are in similar range
    // With correct location-based calculation, no tolerance should be needed
    if (moonRA > spicaRA) {
      // Spica sets before Moon - Moon is under Virgo's feet
      console.log(`[Virgo Rule] âœ“ SELECTED: Full Moon on ${fullMoonDate.toISOString()}`);
      const cacheKey = `${year}_${obsLat.toFixed(4)}_${obsLon.toFixed(4)}`;
      AstroEngines.virgoCache[cacheKey] = {
        year,
        springEquinox: springEquinox.toISOString(),
        spicaRA: spicaRA.toFixed(3),
        selectedFullMoon: fullMoonDate.toISOString(),
        sunriseCheck: sunriseTime.toISOString(),
        moonRA: moonRA.toFixed(3),
        difference: (moonRA - spicaRA).toFixed(3),
        attempts: attempts_log,
        locationName: locationName,
        locationLat: obsLat,
        locationLon: obsLon
      };
      return fullMoonDate;
    }
    
    // Move search to after this full moon
    searchDate = new Date(fullMoonDate.getTime() + 24 * 60 * 60 * 1000);
  }
  
  // Fallback: return first full moon after equinox
  console.log(`[Virgo Rule] No qualifying full moon found, using fallback`);
  const firstResult = engine.searchMoonPhase(180, springEquinox, 40);
  const fallbackCacheKey = `${year}_${obsLat.toFixed(4)}_${obsLon.toFixed(4)}`;
  AstroEngines.virgoCache[fallbackCacheKey] = {
    year,
    springEquinox: springEquinox.toISOString(),
    spicaRA: spicaRA.toFixed(3),
    fallback: true,
    selectedFullMoon: firstResult ? firstResult.date.toISOString() : springEquinox.toISOString(),
    attempts: attempts_log,
    locationName: locationName,
    locationLat: obsLat,
    locationLon: obsLon
  };
  return firstResult ? firstResult.date : springEquinox;
}

// Get Virgo calculation details for a specific year and current location
function getVirgoCalculation(year) {
  const cacheKey = `${year}_${(state.lat ?? 31.7683).toFixed(4)}_${(state.lon ?? 35.2137).toFixed(4)}`;
  return AstroEngines.virgoCache[cacheKey] || null;
}

// Get Moon's Right Ascension in degrees at a given date
function getMoonRightAscension(date) {
  try {
    const engine = getAstroEngine();
    // Use observer's configured location
    const obsLat = state.lat ?? 31.7683;
    const obsLon = state.lon ?? 35.2137;
    const observer = engine.createObserver(obsLat, obsLon, 0);
    const eq = engine.getEquator('moon', date, observer);
    // RA is returned in hours (0-24), convert to degrees (0-360)
    return eq.ra * 15;
  } catch (err) {
    console.error('Error getting Moon RA:', err);
    // Fallback: estimate from ecliptic longitude (rough approximation)
    return getMoonEclipticLongitude(date);
  }
}

// Get moon's ecliptic longitude at a given date
function getMoonEclipticLongitude(date) {
  try {
    // astronomy-engine has EclipticLongitude function
    if (typeof Astronomy !== 'undefined' && Astronomy.EclipticLongitude) {
      return Astronomy.EclipticLongitude(Astronomy.Body.Moon, date);
    }
    
    // Fallback: approximate from moon's position
    // This is less accurate but works if EclipticLongitude isn't available
    const engine = getAstroEngine();
    const observer = engine.createObserver(0, 0, 0);
    const eq = engine.getEquator('moon', date, observer);
    
    // Rough conversion from RA to ecliptic longitude (not accounting for obliquity properly)
    // RA is in hours (0-24), convert to degrees (0-360)
    const raDeg = eq.ra * 15;
    
    // This is a simplification - proper ecliptic conversion requires obliquity
    // For approximate purposes near the ecliptic, RA roughly correlates with ecliptic longitude
    return raDeg;
  } catch (err) {
    console.warn('Could not calculate moon ecliptic longitude:', err);
    return 0;
  }
}

// Get human-readable label for current year start setting
function getYearStartLabel() {
  switch (state.yearStartRule) {
    case '13daysBefore': return 'Passover after Equinox';
    case 'virgoFeet': return 'Moon Under Virgo\'s Feet';
    default: return 'Renewed Moon after Equinox';
  }
}

// Generate Equinox rule methodology HTML (used in settings and day detail)
function getEquinoxMethodologyHtml(options = {}) {
  const { showCalculation = false, equinoxDate = null, day1Date = null, timingStr = '', beforeAfter = '' } = options;
  
  let html = `
    <p><strong>âš–ï¸ Renewed Moon after Equinox</strong></p>
    <p>The first renewed moon <em>on or after</em> the spring equinox begins the year. This ensures:</p>
    <ul style="margin: 10px 0; padding-left: 20px; color: rgba(255,255,255,0.9);">
      <li><strong>Observation before the month</strong> â€” the sign precedes the decision</li>
      <li><strong>No calculation errors</strong> â€” watch the sun, not a formula</li>
      <li><strong>Practical globally</strong> â€” anyone can observe without technology</li>
      <li><strong>Barley ripe by First Fruits</strong> â€” harvest ready by Day 16</li>
    </ul>
    <p style="font-size: 0.9em; color: rgba(255,255,255,0.7);">Starting 2 weeks earlier risks unripe barley. Any later and the harvest would be over.</p>`;
  
  if (showCalculation && equinoxDate && day1Date) {
    html += `
    <div style="margin: 12px 0; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 6px;">
      <strong>This Year:</strong><br>
      â€¢ Spring Equinox: ${equinoxDate}<br>
      â€¢ Day 1 begins: ${day1Date}<br>
      â€¢ Timing: ${timingStr} ${beforeAfter} equinox
    </div>`;
  }
  
  html += `
    <details class="settings-accordion">
      <summary>View Biblical Justification</summary>
      <div class="accordion-content">
        <p><strong>Twelve Hours in the Day</strong></p>
        <blockquote>"Are there not twelve hours in the day?"<br>â€” John 11:9</blockquote>
        <p>Yeshua likely spoke these words around Renewed Moon day, shortly before Passover (see John 11:55, 12:1). The equinoxâ€”when day and night are equal (~12 hours each)â€”may be the precondition He was referencing for starting the year.</p>
        
        <p><strong>What is Aviv?</strong></p>
        <p>The first month is called <strong>Aviv</strong> (×Ö¸×‘Ö´×™×‘), describing barley at a specific stage of ripenessâ€”heads formed, soft dough stage, ready for harvest within 2-3 weeks:</p>
        <blockquote>"And the flax and the barley was smitten: for the barley was in the ear [aviv], and the flax was bolled."<br>â€” Exodus 9:31</blockquote>
        
        <p><strong>First Fruits Requirement</strong></p>
        <p><strong>First Fruits (Day 16)</strong> requires ripe barley for the wave-sheaf offering:</p>
        <blockquote>"From such time as thou begin to put the sickle to the standing grain shalt thou begin to number seven weeks."<br>â€” Deuteronomy 16:9</blockquote>
        
        <p><strong>The Tekufah (Turning Point)</strong></p>
        <p>The Feast of Ingathering (Tabernacles) is connected to the <em>tekufah</em> (turning point):</p>
        <blockquote>"You shall observe the Feast of Weeksâ€¦ and the Feast of Ingathering at the turning (tekufah) of the year."<br>â€” Exodus 34:22</blockquote>
        <p>If the fall feast is at one turning point (autumn equinox), Passover should be at the other (spring equinox).</p>
        
        <p style="margin-top: 15px;"><a href="/chapters/08-when-does-the-year-start/" style="color: #7ec8e3;">ðŸ“– See "Time Tested Tradition" chapter: When Does the Year Start?</a></p>
      </div>
    </details>`;
  
  return html;
}

// Generate Passover rule methodology HTML (used in settings and day detail)
function getPassoverMethodologyHtml(options = {}) {
  const { showCalculation = false, equinoxDate = null, day1Date = null, day15Date = null, timingStr = '', beforeAfter = '' } = options;
  
  let html = `
    <p><strong>ðŸ‘ Passover after Equinox</strong></p>
    <p>The first new moon is chosen such that <strong>Day 15</strong> (when Unleavened Bread begins) occurs <em>on or after</em> the spring equinox. This ensures:</p>
    <ul style="margin: 10px 0; padding-left: 20px; color: rgba(255,255,255,0.9);">
      <li>Passover is always a true "spring festival" (<em>á¸¥ag ha-aviv</em>)</li>
      <li>Matches the traditional Jewish calendar intercalation rule</li>
      <li>Allows the month to start up to 14 days before the equinox</li>
    </ul>`;
  
  if (showCalculation && equinoxDate && day1Date) {
    html += `
    <div style="margin: 12px 0; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 6px;">
      <strong>This Year:</strong><br>
      â€¢ Spring Equinox: ${equinoxDate}<br>
      â€¢ Day 1 begins: ${day1Date}<br>
      ${day15Date ? `â€¢ Day 15 (Unleavened): ${day15Date}<br>` : ''}
      â€¢ Timing: ${timingStr} ${beforeAfter} equinox
    </div>`;
  }
  
  html += `
    <details class="settings-accordion">
      <summary>View Traditional Source</summary>
      <div class="accordion-content">
        <p><strong>Maimonides' Codification</strong></p>
        <p>Maimonides codified the ancient rabbinic intercalation rule in <em>Hilchot Kiddush HaChodesh 4:2</em>:</p>
        <blockquote>"When the court calculates and determines that the vernal equinox will fall on the sixteenth of Nisan or later, the year is made full [a leap month is added]."</blockquote>
        <p>This means if the equinox would fall on Day 16 or later, a leap month (Adar II) is added, pushing Nisan forward so that the equinox falls on Day 15 or earlier.</p>
        
        <p><strong>Torah Command</strong></p>
        <blockquote>"Observe the month of Aviv, and keep the Passover unto the LORD thy God: for in the month of Aviv the LORD thy God brought thee forth out of Egypt by night."<br>â€” Deuteronomy 16:1</blockquote>
        <p>The month must be Aviv (spring) when Passover occurs, ensuring the festival aligns with the season of redemption and renewal.</p>
        
        <p style="margin-top: 15px;"><a href="/chapters/08-when-does-the-year-start/" style="color: #7ec8e3;">ðŸ“– See "Time Tested Tradition" chapter: When Does the Year Start?</a></p>
      </div>
    </details>`;
  
  return html;
}

// Generate Virgo rule methodology HTML (used in settings and day detail)
function getVirgoMethodologyHtml(options = {}) {
  const { showCalculation = false, virgoCalc = null } = options;
  
  let html = `
    <p><strong>â™ Moon Under Virgo's Feet</strong></p>
    <p>The year begins with the first spring full moon where <em>Spica sets before the Moon</em>, placing the Moon "under the feet of Virgo" (Bethulah), as described in Revelation 12:1.</p>
    <ul style="margin: 10px 0; padding-left: 20px; color: rgba(255,255,255,0.9);">
      <li><strong>Stellar witness</strong> â€” uses the stars as signs (Genesis 1:14)</li>
      <li><strong>Revelation 12:1 alignment</strong> â€” "moon under her feet"</li>
      <li><strong>Spica marks Wave Sheaf</strong> â€” the star aligns with Day 16 (First Fruits)</li>
      <li><strong>Passover in Aries</strong> â€” sun typically at 0Â°-15Â° Aries on Day 14</li>
    </ul>`;
  
  // Add calculation details if provided
  if (showCalculation && virgoCalc) {
    const virgoDate = new Date(virgoCalc.selectedFullMoon);
    const virgoParts = getFormattedDateParts(virgoDate);
    const virgoDateStr = `${virgoParts.weekdayName}, ${virgoParts.shortMonthName} ${virgoParts.day}${getOrdinalSuffix(virgoParts.day)}, ${virgoParts.yearStr}`;
    const equinoxDate = new Date(virgoCalc.springEquinox);
    const eqParts = getFormattedDateParts(equinoxDate);
    const equinoxDateStr = `${eqParts.weekdayName}, ${eqParts.shortMonthName} ${eqParts.day}${getOrdinalSuffix(eqParts.day)}, ${eqParts.yearStr}`;
    const diff = parseFloat(virgoCalc.difference);
    const statusIcon = diff >= 0 ? 'âœ“ Spica sets first' : 'âœ— Spica sets after';
    
    html += `
    <div style="margin: 12px 0; padding: 10px; background: rgba(138, 43, 226, 0.15); border: 1px solid rgba(138, 43, 226, 0.3); border-radius: 6px;">
      <strong>This Year's Calculation:</strong><br>
      â€¢ Location: ${virgoCalc.locationName || 'Jerusalem'}<br>
      â€¢ Spring Equinox: ${equinoxDateStr}<br>
      â€¢ Selected Full Moon: ${virgoDateStr}<br>
      â€¢ Check at Sunrise: ${new Date(virgoCalc.sunriseCheck).toLocaleTimeString()} (${virgoCalc.locationName || 'Jerusalem'})<br>
      â€¢ Moon RA: ${virgoCalc.moonRA}Â° | Spica RA: ${virgoCalc.spicaRA}Â°<br>
      â€¢ Difference: ${virgoCalc.difference}Â° ${statusIcon}`;
    
    if (virgoCalc.attempts && virgoCalc.attempts.length > 1) {
      html += `<br><br><strong>Previous Full Moon(s) Rejected:</strong>`;
      for (let i = 0; i < virgoCalc.attempts.length - 1; i++) {
        const attempt = virgoCalc.attempts[i];
        if (attempt && !attempt.spicaSetsFirst) {
          const attemptDate = new Date(attempt.fullMoon);
          const attParts = getFormattedDateParts(attemptDate);
          html += `<br>â€¢ ${attParts.shortMonthName} ${attParts.day}: Moon RA ${attempt.moonRA}Â°, Diff ${attempt.diff}Â° â€” Spica sets after Moon`;
        }
      }
    }
    
    // Add Stellarium link with the location used in the calculation
    const stellariumCheckDate = new Date(virgoCalc.sunriseCheck);
    const stellariumDateStr = stellariumCheckDate.toISOString().split('.')[0] + 'Z';
    const stellariumLat = virgoCalc.locationLat ?? 31.7683;
    const stellariumLon = virgoCalc.locationLon ?? 35.2137;
    const stellariumLocationName = virgoCalc.locationName || 'Jerusalem';
    html += `<br><br><a href="https://stellarium-web.org/?date=${stellariumDateStr}&lat=${stellariumLat}&lng=${stellariumLon}" target="_blank" rel="noopener" class="stellarium-link"><img src="https://stellarium-web.org/favicon.ico" alt="" onerror="this.style.display='none'">Verify in Stellarium (${stellariumLocationName} at sunrise)</a>`;
    
    html += `</div>`;
  }
  
  // Add methodology accordion
  html += `
    <details class="settings-accordion">
      <summary>View Methodology</summary>
      <div class="accordion-content">
        <p><strong>The Algorithm</strong></p>
        <p>Starting 29 days before the spring equinox, find each full moon and compare Right Ascensions at sunrise in your location. Select the first full moon where Spica's RA is less than the Moon's RA, meaning Spica sets before the Moon.</p>
        
        <p><strong>Biblical Basis</strong></p>
        <blockquote>"And there appeared a great wonder in heaven; a woman clothed with the sun, and the moon under her feet, and upon her head a crown of twelve stars."<br>â€” Revelation 12:1</blockquote>
        <p>This method interprets the sign as an annual astronomical configuration marking the new year.</p>
        
        <p><strong>Sources</strong></p>
        <p>This methodology is taught by <a href="https://thecreatorscalendar.com" target="_blank" style="color: #7ec8e3;">TheCreatorsCalendar.com</a> and the <a href="https://www.youtube.com/@MikalShabbat" target="_blank" style="color: #7ec8e3;">Mikal Shabbat Scriptural Studies</a> YouTube channel.</p>
      </div>
    </details>
    
    <div class="settings-warning" style="margin-top: 12px; padding: 10px; background: rgba(255, 180, 0, 0.15); border: 1px solid rgba(255, 180, 0, 0.3); border-radius: 6px;">
      <p style="margin: 0; color: #ffb400;"><strong>âš ï¸ Precession &amp; Barley Warning</strong></p>
      <p style="margin: 8px 0 0 0; color: rgba(255,255,255,0.85);">While this implementation adjusts Spica's position for precession (~1Â° per 72 years), the constellations drift relative to the seasons over millennia. Barley must be ripe for Wave Sheaf on Day 16 (Lev 23:10-11). Around 2000 BC, the Virgo alignment occurs ~1 month earlier in spring; around 4000 AD, ~1 month later. This could place Passover too early (before barley ripens) in ancient dates, or too late in future dates.</p>
    </div>`;
  
  return html;
}

// Get human-readable label for current day start setting
function getDayStartLabel() {
  const timeLabel = state.dayStartTime === 'evening' ? 'evening' : 'morning';
  
  let angleLabel;
  switch (state.dayStartAngle) {
    case 0: angleLabel = state.dayStartTime === 'evening' ? 'sunset' : 'sunrise'; break;
    case 6: angleLabel = 'civil twilight'; break;
    case 12: angleLabel = 'nautical twilight'; break;
    case 18: angleLabel = 'astronomical twilight'; break;
    default: angleLabel = `${state.dayStartAngle}Â° twilight`;
  }
  
  // Return "morning nautical twilight" instead of "nautical twilight (morning)"
  // For sunrise/sunset, just return that without time prefix
  if (state.dayStartAngle === 0) {
    return angleLabel;
  }
  return `${timeLabel} ${angleLabel}`;
}

// Convert UTC timestamp to local time at the selected longitude
function utcToLocalTime(utcTimestamp, longitude) {
  // Each 15Â° of longitude = 1 hour offset
  const hourOffset = longitude / 15;
  return new Date(utcTimestamp + hourOffset * 60 * 60 * 1000);
}

// Convert local time at selected longitude to UTC timestamp
function localTimeToUtc(localDate, longitude) {
  // Each 15Â° of longitude = 1 hour offset
  const hourOffset = longitude / 15;
  return localDate.getTime() - hourOffset * 60 * 60 * 1000;
}

// Format date for datetime-local input (YYYY-MM-DDTHH:MM)
// Uses UTC values since we pre-convert to local time
// Returns null for dates before year 1 (datetime-local doesn't support negative years)
function formatDatetimeLocal(date) {
  const year = date.getUTCFullYear();
  // datetime-local inputs don't support years before 1
  if (year < 1) return null;
  
  // Year must be 4 digits for datetime-local format
  return String(year).padStart(4, '0') + '-' + 
    String(date.getUTCMonth() + 1).padStart(2, '0') + '-' +
    String(date.getUTCDate()).padStart(2, '0') + 'T' +
    String(date.getUTCHours()).padStart(2, '0') + ':' +
    String(date.getUTCMinutes()).padStart(2, '0');
}

// Format UTC timestamp as local time string at selected location
// Returns empty string for ancient dates (datetime-local doesn't support them)
function formatLocalDatetime(utcTimestamp) {
  const localDate = utcToLocalTime(utcTimestamp, state.lon);
  return formatDatetimeLocal(localDate) || '';
}

// Parse datetime-local input as local time at selected location, return UTC timestamp
function parseDatetimeLocal(datetimeStr) {
  // Parse the datetime-local string as if it were UTC
  const [datePart, timePart] = datetimeStr.split('T');
  const [year, month, day] = datePart.split('-').map(Number);
  const [hours, minutes] = timePart.split(':').map(Number);
  
  // Create date as UTC
  const localAsUtc = Date.UTC(year, month - 1, day, hours, minutes);
  
  // Convert from local time at longitude to actual UTC
  return localTimeToUtc(new Date(localAsUtc), state.lon);
}

function formatFullDate(date) {
  const months = ['January', 'February', 'March', 'April', 'May', 'June', 
                  'July', 'August', 'September', 'October', 'November', 'December'];
  
  // Use UTC methods - dates from _jdToDate already have correct calendar components stored
  const year = date.getUTCFullYear();
  const month = date.getUTCMonth();
  const day = date.getUTCDate();
  const isJulian = isBeforeGregorianReform(date);
  const calendarSuffix = isJulian ? ' (Julian)' : '';
  
  // Format year: only show BC suffix, never AD
  const yearStr = year <= 0 ? `${Math.abs(year - 1)} BC` : `${year}`;
  
  return `${months[month]} ${day}, ${yearStr}${calendarSuffix}`;
}

// Calculate the "dateline" longitude - the first place to start the new day
// At any UTC time H, solar noon is at longitude = (12 - H) * 15 degrees
// Sunrise occurs 90Â° to the WEST of the subsolar point (6 hours earlier in local time)
// Sunset occurs 90Â° to the EAST of the subsolar point (6 hours later in local time)
// The dateline is where the day start event is occurring at the moment of the moon event
// This is the first place on Earth to begin a new day
function calculateDatelineLongitude(moonEventDate, moonPhase) {
  // Get UTC hours as decimal
  const utcHours = moonEventDate.getUTCHours() + moonEventDate.getUTCMinutes() / 60;
  
  // The subsolar point (where it's local noon) at this UTC time
  // At UTC 12:00, noon is at 0Â° (Greenwich)
  // At UTC 0:00, noon is at 180Â° (International Date Line)
  const subsolarLon = (12 - utcHours) * 15;
  
  let datelineLon;
  if (state.dayStartTime === 'evening') {
    // Sunset is 90Â° to the EAST of the subsolar point
    // (At any instant, places east of noon are in afternoon/evening)
    datelineLon = subsolarLon + 90;
    // Adjust for twilight angle - evening twilight occurs BEFORE sunset (further east)
    // Roughly 4Â° of longitude per 1Â° of sun angle (varies by latitude)
    datelineLon += state.dayStartAngle * 4;
  } else {
    // Sunrise is 90Â° to the WEST of the subsolar point
    // (At any instant, places west of noon are in morning)
    datelineLon = subsolarLon - 90;
    // Adjust for twilight angle - morning twilight occurs BEFORE sunrise (further east)
    // For morning, twilight starts earlier, so we add to move east
    datelineLon += state.dayStartAngle * 4;
  }
  
  // Normalize to -180 to 180
  while (datelineLon > 180) datelineLon -= 360;
  while (datelineLon < -180) datelineLon += 360;
  
  return datelineLon;
}

function getDatelineCity(lon) {
  // Find approximate region for the dateline longitude
  if (lon >= 140 || lon < -170) return 'Pacific Ocean (Date Line)';
  if (lon >= 120) return 'Japan / Philippines';
  if (lon >= 100) return 'China / Southeast Asia';
  if (lon >= 70) return 'India / Central Asia';
  if (lon >= 35) return 'Middle East';
  if (lon >= 10) return 'Europe / Africa';
  if (lon >= -30) return 'Atlantic Ocean';
  if (lon >= -50) return 'South America (East)';
  if (lon >= -70) return 'South America (West) / Caribbean';
  if (lon >= -85) return 'Americas (Eastern US / Central America)';
  if (lon >= -105) return 'Americas (Central US / Mexico)';
  if (lon >= -120) return 'Americas (West Coast)';
  if (lon >= -150) return 'Alaska / Hawaii';
  return 'Pacific Ocean';
}

// Get the day start event name for display
function getDayStartEventName() {
  if (state.dayStartAngle === 0) {
    return state.dayStartTime === 'evening' ? 'Sunset' : 'Sunrise';
  } else if (state.dayStartAngle === 6) {
    return state.dayStartTime === 'evening' ? 'Civil Dusk' : 'Civil Dawn';
  } else if (state.dayStartAngle === 12) {
    return state.dayStartTime === 'evening' ? 'Nautical Dusk' : 'Nautical Dawn';
  } else if (state.dayStartAngle === 18) {
    return state.dayStartTime === 'evening' ? 'Astronomical Dusk' : 'Astronomical Dawn';
  }
  return state.dayStartTime === 'evening' ? 'Evening Twilight' : 'Morning Twilight';
}

// Get the day start icon for the marker
function getDayStartIcon() {
  return state.dayStartTime === 'evening' ? 'ðŸŒ…' : 'â˜€';
}

function renderDatelineVisualization(moonEventDate, options = {}) {
  const utcHours = moonEventDate.getUTCHours() + moonEventDate.getUTCMinutes() / 60;
  const datelineLon = calculateDatelineLongitude(moonEventDate, state.moonPhase);
  
  // Convert longitude to percentage position (lon -180 = 0%, lon 180 = 100%)
  const position = ((datelineLon + 180) / 360) * 100;
  
  const region = getDatelineCity(datelineLon);
  const lonStr = datelineLon >= 0 
    ? `${Math.abs(datelineLon).toFixed(1)}Â°E` 
    : `${Math.abs(datelineLon).toFixed(1)}Â°W`;
  
  // Format moon event date for display
  const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  const moonDateStr = `${months[moonEventDate.getUTCMonth()]} ${moonEventDate.getUTCDate()}, ${moonEventDate.getUTCFullYear()}`;
  const utcTimeStr = `${Math.floor(utcHours).toString().padStart(2,'0')}:${Math.round((utcHours % 1) * 60).toString().padStart(2,'0')} UTC`;
  
  // Get day start event name and icon based on settings
  const dayStartEvent = getDayStartEventName();
  const dayStartIcon = getDayStartIcon();
  const markerLabel = dayStartEvent.toUpperCase();
  
  // Current location marker position - use provided options or fall back to state
  const currentLat = options.lat ?? state.lat ?? 31.7683;
  const currentLon = options.lon ?? state.lon ?? 35.2137;
  const locX = ((currentLon + 180) / 360) * 100;
  const locY = ((90 - currentLat) / 180) * 100;
  
  // Get location display name (city name or region) - use the provided coordinates
  const locationName = getCurrentLocationName(currentLat, currentLon);
  const coordStr = `${currentLat.toFixed(2)}Â°${currentLat >= 0 ? 'N' : 'S'}, ${Math.abs(currentLon).toFixed(2)}Â°${currentLon >= 0 ? 'E' : 'W'}`;
  // Show city name with coordinates, or just coordinates if it's a timezone region
  const locationDisplay = !locationName.includes('/') 
    ? `${locationName} (${coordStr})`
    : coordStr;
  
  return `
    <div class="dateline-container">
      <div class="dateline-label">${dayStartEvent} line at moment of ${getMoonLabel()} â€” ${moonDateStr} â€” ${utcTimeStr}</div>
      <div class="dateline-map" onclick="handleMapClick(event)">
        <div class="dateline-map-bg">
          <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/23/Blue_Marble_2002.png/1280px-Blue_Marble_2002.png" 
               alt="World Map"
               draggable="false"
               style="user-select: none; -webkit-user-drag: none; pointer-events: none;"
               onerror="this.style.display='none'">
        </div>
        <div class="dateline-marker" style="left: ${position}%">
          <span class="dateline-marker-icon">${dayStartIcon}</span>
          <span class="dateline-marker-label">${markerLabel}</span>
        </div>
        <div class="dateline-location-marker" style="left: ${locX}%; top: ${locY}%" title="${locationName}: ${coordStr}"><div class="dateline-location-pin"></div></div>
      </div>
      <div class="dateline-cities">
        <span>180Â°W</span>
        <span>90Â°W</span>
        <span>0Â°</span>
        <span>90Â°E</span>
        <span>180Â°E</span>
      </div>
      <div class="dateline-info">Day start line: ${lonStr} â€” ${region}</div>
      <div class="dateline-info" style="color: #7ec8e3;">Your location: ${locationDisplay}</div>
      <div class="dateline-click-hint">Click map to change location â€¢ First to reach ${dayStartEvent.toLowerCase()} after ${getMoonLabel()} starts month first</div>
    </div>
  `;
}

function formatMoonDateTime(date) {
  const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
  
  // UTC date and time - use correct weekday calculation for ancient dates
  const utcDay = days[getCorrectWeekday(date)];
  const utcMonth = months[date.getUTCMonth()];
  const utcDate = date.getUTCDate();
  const utcHours = date.getUTCHours().toString().padStart(2, '0');
  const utcMins = date.getUTCMinutes().toString().padStart(2, '0');
  
  // Local date and time
  const localDay = days[date.getDay()];
  const localMonth = months[date.getMonth()];
  const localDate = date.getDate();
  const localHours = date.getHours().toString().padStart(2, '0');
  const localMins = date.getMinutes().toString().padStart(2, '0');
  
  // Get timezone abbreviation
  const tzName = Intl.DateTimeFormat('en-US', { timeZoneName: 'short' }).formatToParts(date)
    .find(part => part.type === 'timeZoneName')?.value || 'Local';
  
  // Check if UTC and local are on different calendar days
  const sameDay = (date.getUTCDate() === date.getDate() && 
                   date.getUTCMonth() === date.getMonth() &&
                   date.getUTCFullYear() === date.getFullYear());
  
  if (sameDay) {
    return `${localDay}, ${localMonth} ${localDate}<br>` +
           `UTC: ${utcHours}:${utcMins}<br>` +
           `${tzName}: ${localHours}:${localMins}`;
  } else {
    // Show both dates when they differ
    return `UTC: ${utcDay}, ${utcMonth} ${utcDate} ${utcHours}:${utcMins}<br>` +
           `${tzName}: ${localDay}, ${localMonth} ${localDate} ${localHours}:${localMins}`;
  }
}

function renderMonth(month) {
  const scripture = SCRIPTURES[month.monthNumber % SCRIPTURES.length];
  
  const container = document.getElementById('calendar-output');
  
  // Get today's date string for comparison (YYYY-MM-DD format) at the state location
  // Convert current UTC time to local time at state location
  const nowUtc = new Date();
  const tzOffsetHours = Math.round(state.lon / 15);
  const localNowMs = nowUtc.getTime() + (tzOffsetHours * 60 * 60 * 1000);
  const localNow = new Date(localNowMs);
  const todayStr = `${localNow.getUTCFullYear()}-${String(localNow.getUTCMonth() + 1).padStart(2, '0')}-${String(localNow.getUTCDate()).padStart(2, '0')}`;
  
  // Day 1 is New Moon shown in header
  // Days 2-8 form the first week, 9-15 second week, etc.
  // Sabbath (days 8, 15, 22, 29) is always in the rightmost column
  
  // Find Day 2's Gregorian weekday to determine the weekday labels
  const day2 = month.days.find(d => d.lunarDay === 2);
  const day2Weekday = day2 ? getCorrectWeekday(day2.gregorianDate) : 0;
  
  // Generate weekday labels starting from Day 2's weekday
  const weekdayNames = ['Sun.', 'Mon.', 'Tue.', 'Wed.', 'Thu.', 'Fri.', 'Sat.'];
  const shiftedWeekdays = [];
  for (let i = 0; i < 7; i++) {
    shiftedWeekdays.push(weekdayNames[(day2Weekday + i) % 7]);
  }
  
  // Determine which column header should be highlighted as Sabbath
  // For lunar sabbath: always column 7 (days 8, 15, 22, 29)
  // For weekday sabbaths: find which column corresponds to that weekday
  let sabbathColumnIndex = -1;
  if (state.sabbathMode === 'lunar') {
    sabbathColumnIndex = 6; // Column 7 (0-indexed)
  } else if (['saturday', 'sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday'].includes(state.sabbathMode)) {
    // Find which column has the sabbath weekday
    const sabbathWeekdayMap = { sunday: 0, monday: 1, tuesday: 2, wednesday: 3, thursday: 4, friday: 5, saturday: 6 };
    const sabbathWeekday = sabbathWeekdayMap[state.sabbathMode];
    // Day 2's weekday is in column 0, so find which column has the sabbath weekday
    for (let col = 0; col < 7; col++) {
      if ((day2Weekday + col) % 7 === sabbathWeekday) {
        sabbathColumnIndex = col;
        break;
      }
    }
  }
  
  // Generate day labels (Day 1 through Day 7)
  // For fixed weekday sabbaths, the sabbath column is always "Day 7"
  // For lunar sabbath, column 6 is always "Day 7"
  const getDayLabel = (colIndex) => {
    if (sabbathColumnIndex === -1) return colIndex + 1; // No sabbath mode
    // Calculate day number so sabbath column is always Day 7
    return ((colIndex - sabbathColumnIndex - 1 + 7) % 7) + 1;
  };
  
  // Get Day 1 info for header
  const day1 = month.days.find(d => d.lunarDay === 1);
  const day1UncertaintySuffix = (day1 && day1.isUncertain) ? month.dateUncertainty : '';
  const day1Date = day1 ? formatShortDate(day1.gregorianDate) + day1UncertaintySuffix : '';
  const day1Year = day1 ? formatYear(day1.gregorianDate.getUTCFullYear()) : '';
  const day1Weekday = day1 ? weekdayNames[getCorrectWeekday(day1.gregorianDate)] : '';
  
  // Check for feasts and equinox on day 1
  let day1FeastIcons = '';
  if (day1) {
    const icons = [];
    if (day1.feasts && day1.feasts.length > 0) {
      icons.push(...new Set(day1.feasts.map(f => f.feast.icon)));
    }
    if (day1.equinox) {
      icons.push('â˜€ï¸âš–ï¸');
    }
    if (icons.length > 0) {
      day1FeastIcons = `<div class="feast-icons">${icons.join('')}</div>`;
    }
  }
  
  // Check for Î”T uncertainty warning on Day 1 (use the already-calculated flag)
  const day1UncertaintyIndicator = (day1 && day1.isUncertain) ? 'uncertain' : '';
  
  // Blood moon styling for Day 1
  const day1BloodMoonClass = (day1 && day1.isBloodMoon) ? ' blood-moon' : '';
  
  // Check if Day 1 is today
  const day1IsToday = day1 && day1.gregorianDate.toISOString().split('T')[0] === todayStr;
  
  // Calculate daylight percentage for day cycle bar based on Day 1's sunrise/sunset
  let daylightHours = 12; // default if we can't calculate
  let dayCycleGradient = '';
  if (day1 && day1.gregorianDate) {
    try {
      const sunriseTs = getSunriseTimestamp(day1.gregorianDate);
      const sunsetTs = getSunsetTimestamp(day1.gregorianDate);
      if (sunriseTs != null && sunsetTs != null && !isNaN(sunriseTs) && !isNaN(sunsetTs)) {
        const hours = (sunsetTs - sunriseTs) / (1000 * 60 * 60);
        if (hours > 0 && hours < 24) {
          daylightHours = hours;
        }
      }
    } catch (e) {
      console.warn('Could not calculate daylight hours:', e);
    }
  }
  
  // Clamp daylight hours to reasonable range (6-18 hours covers all latitudes/seasons)
  daylightHours = Math.max(6, Math.min(18, daylightHours));
  
  // Convert hours to percentages of 24-hour day
  const twilightHours = 1.5;
  const nightHours = 24 - daylightHours;
  
  const twi = (twilightHours / 24) * 100;  // ~6.25%
  const day = (daylightHours / 24) * 100;
  const night = (nightHours / 24) * 100;
  
  // Generate gradient based on day start time
  // Twilight transitions (~1.5hr) occur AT sunrise and sunset, not during day/night
  // Add small offset (1%) to make gradient start visible at edge
  const offset = 1;
  const twilight = twi * 2; // Full transition width (dawn or dusk)
  
  if (state.dayStartTime === 'evening') {
    // Evening start: 0% = sunset
    // Day just ended, dusk transition starts immediately
    const duskEnd = twilight - offset;
    const dawnStart = night - twilight + offset;
    const dawnEnd = night + twilight - offset;
    
    dayCycleGradient = `repeating-linear-gradient(90deg, 
      #7ab3d4 0%, 
      #0d1a2d ${duskEnd}%, 
      #0d1a2d ${dawnStart}%, 
      #7ab3d4 ${dawnEnd}%, 
      #7ab3d4 100%)`;
  } else {
    // Morning start: 0% = first light (dawn)
    // Night just ended, dawn transition starts immediately
    const dawnEnd = twilight - offset;
    const duskStart = day - twilight + offset;
    const duskEnd = day + twilight - offset;
    
    dayCycleGradient = `repeating-linear-gradient(90deg, 
      #0d1a2d 0%, 
      #7ab3d4 ${dawnEnd}%, 
      #7ab3d4 ${duskStart}%, 
      #0d1a2d ${duskEnd}%, 
      #0d1a2d 100%)`;
  }
  
  const daylightPercent = Math.round(day);
  
  // Get the year the lunar year started (from first month's day 1)
  const firstMonth = state.lunarMonths[0];
  const firstDay1 = firstMonth ? firstMonth.days.find(d => d.lunarDay === 1) : null;
  const lunarYearStart = firstDay1 ? firstDay1.gregorianDate.getUTCFullYear() : state.year;
  const displayYear = formatYear(lunarYearStart);
  
  let html = `
    <div class="month-calendar">
      <div class="calendar-header">
        <!-- Row 1: Moon + Profile name -->
        <div class="header-row-1">
          <div class="header-dropdown profile" onclick="toggleProfilePicker()" title="Change calendar profile">
            <span class="profile-moon">${getMoonIcon()}</span>
            <span>${getCurrentProfileName()}</span>
            <span class="dropdown-arrow">â–¼</span>
          </div>
        </div>
        
        <!-- Row 2: Year | Month | Time | Location -->
        <div class="header-row-2">
          <div class="header-dropdown year" onclick="toggleMonthPicker()" title="Change year">
            <span>${displayYear}</span>
            <span class="dropdown-arrow">â–¼</span>
          </div>
          <span class="header-separator">|</span>
          <div class="header-dropdown month" onclick="toggleMonthPicker()" title="Change month">
            <span>${month.name}</span>
            <span class="dropdown-arrow">â–¼</span>
          </div>
          <span class="header-separator">|</span>
          <div class="header-dropdown time" id="header-time-display" onclick="showTimePicker()" title="Set date time"></div>
          <span class="header-separator">|</span>
          <div class="header-dropdown location" onclick="openLocationPicker()" title="Change location">
            <span>${getCurrentLocationName()}</span>
            <span class="dropdown-arrow">â–¼</span>
          </div>
        </div>
        
        <div class="new-moon-box day-cell new-moon${state.highlightedLunarDay === 1 ? ' highlighted' : ''}${day1 && day1.feasts && day1.feasts.length > 0 ? ' feast' : ''}${day1 && isSabbath(day1) ? ' sabbath' : ''}${day1UncertaintyIndicator ? ' date-uncertain' : ''}${day1IsToday ? ' today' : ''}" data-date="${day1 ? day1.gregorianDate.toISOString().split('T')[0] : ''}" data-lunar-day="1" title="${day1 && day1.isBloodMoon ? 'ðŸ”´ Blood Moon (Lunar Eclipse)' : ''}">
          <div class="gregorian">${day1Date}<span class="day-year">${day1Year}</span></div>
          <div class="moon-phase${day1BloodMoonClass}">${day1 ? day1.moonPhase : ''}</div>
          <div class="lunar-day">1</div>
          ${day1FeastIcons}
        </div>
      </div>
      ${state.yearStartUncertainty ? `
      <div class="year-uncertainty-banner" title="The first moon of the year is close to the year start boundary. Î”T uncertainty of ${Math.round(AstroEngines.nasaEclipse.getDeltaTUncertainty(state.year))} hours means this could be the wrong year.">
        âš ï¸ ${state.yearStartUncertainty.probability}% chance 1 month ${state.yearStartUncertainty.direction}
      </div>
      ` : ''}
      <div class="week-header">
        <div class="day-label${sabbathColumnIndex === 0 ? ' sabbath-header' : ''}"><div class="day-name">Day ${getDayLabel(0)}</div><div class="weekday">${shiftedWeekdays[0]}</div></div>
        <div class="day-label${sabbathColumnIndex === 1 ? ' sabbath-header' : ''}"><div class="day-name">Day ${getDayLabel(1)}</div><div class="weekday">${shiftedWeekdays[1]}</div></div>
        <div class="day-label${sabbathColumnIndex === 2 ? ' sabbath-header' : ''}"><div class="day-name">Day ${getDayLabel(2)}</div><div class="weekday">${shiftedWeekdays[2]}</div></div>
        <div class="day-label${sabbathColumnIndex === 3 ? ' sabbath-header' : ''}"><div class="day-name">Day ${getDayLabel(3)}</div><div class="weekday">${shiftedWeekdays[3]}</div></div>
        <div class="day-label${sabbathColumnIndex === 4 ? ' sabbath-header' : ''}"><div class="day-name">Day ${getDayLabel(4)}</div><div class="weekday">${shiftedWeekdays[4]}</div></div>
        <div class="day-label${sabbathColumnIndex === 5 ? ' sabbath-header' : ''}"><div class="day-name">Day ${getDayLabel(5)}</div><div class="weekday">${shiftedWeekdays[5]}</div></div>
        <div class="day-label${sabbathColumnIndex === 6 ? ' sabbath-header' : ''}"><div class="day-name">Day ${getDayLabel(6)}</div><div class="weekday">${shiftedWeekdays[6]}</div></div>
      </div>
      
      <div class="day-cycle-bar" style="background: ${dayCycleGradient}; background-size: calc(100% / 7) 100%;" title="Day/night cycle (~${daylightPercent}% daylight): Each column shows ${state.dayStartTime === 'evening' ? 'sunset â†’ night â†’ day â†’ sunset' : 'dawn â†’ day â†’ night â†’ dawn'}"></div>
      
      <div class="calendar-grid">
  `;
  
  // Build rows by lunar week structure: 2-8, 9-15, 16-22, 23-29
  // The last row (day 30 + scripture) is handled separately
  const lunarWeeks = [
    [2, 3, 4, 5, 6, 7, 8],
    [9, 10, 11, 12, 13, 14, 15],
    [16, 17, 18, 19, 20, 21, 22],
    [23, 24, 25, 26, 27, 28, 29]
  ];
  
  for (const week of lunarWeeks) {
    for (const lunarDay of week) {
      const day = month.days.find(d => d.lunarDay === lunarDay);
      
      if (!day) {
        // Day doesn't exist in this month
        html += `<div class="day-cell empty"></div>`;
        continue;
      }
      
      let classes = ['day-cell'];
      // Determine if this day is a sabbath based on sabbathMode
      const isSabbathDay = isSabbath(day);
      if (isSabbathDay) classes.push('sabbath');
      if (day.isNewMoon) classes.push('new-moon');
      if (day.feasts && day.feasts.length > 0) classes.push('feast');
      if (day.lunarDay === state.highlightedLunarDay) classes.push('highlighted');
      if (day.isUncertain) classes.push('date-uncertain');
      
      // Check if this day is today
      const dayDateStr = day.gregorianDate.toISOString().split('T')[0];
      if (dayDateStr === todayStr) classes.push('today');
      
      let feastLabel = '';
      const icons = [];
      if (day.feasts && day.feasts.length > 0) {
        // Show icons for feasts (unique icons only)
        icons.push(...new Set(day.feasts.map(f => f.feast.icon)));
      }
      // Add equinox icon if applicable
      if (day.equinox) {
        icons.push('â˜€ï¸âš–ï¸');
      }
      if (icons.length > 0) {
        feastLabel = `<div class="feast-icons">${icons.join('')}</div>`;
      }
      
      // Format date for data attribute (YYYY-MM-DD)
      const dateStr = day.gregorianDate.toISOString().split('T')[0];
      let titleText = day.feasts && day.feasts.length > 0 
        ? day.feasts.map(f => f.feast.name + ': ' + f.feast.description).join(' | ')
        : '';
      
      // Add uncertainty suffix to date display
      const uncertaintySuffix = day.isUncertain ? month.dateUncertainty : '';
      if (day.isUncertain) {
        const prob = month.dateUncertaintyProbability || 0;
        titleText = (titleText ? titleText + ' | ' : '') + 
          `~${prob}% chance date is 1 day ${month.dateUncertainty === '+' ? 'later' : 'earlier'}`;
      }
      
      const isHighlighted = day.lunarDay === state.highlightedLunarDay;
      const bloodMoonClass = day.isBloodMoon ? ' blood-moon' : '';
      // Use red full moon emoji for blood moon, or add title
      const bloodMoonTitle = day.isBloodMoon ? ' | ðŸ”´ Blood Moon (Lunar Eclipse)' : '';
      html += `
        <div class="${classes.join(' ')}" data-date="${dateStr}" title="${titleText}${bloodMoonTitle}">
          <div class="gregorian">${formatShortDate(day.gregorianDate)}${uncertaintySuffix}</div>
          <div class="moon-phase${bloodMoonClass}">${day.moonPhase}</div>
          <div class="lunar-day">${day.lunarDay}</div>
          ${feastLabel}
        </div>
      `;
    }
  }
  
  // Last row: Day 30 (or spacer) + Prev + Scripture quote + Next
  // Layout: [Day30/spacer][Prev][Quote span-4][Next]
  const day30 = month.days.find(d => d.lunarDay === 30);
  const isFirstMonth = state.currentMonthIndex === 0;
  const isLastMonth = state.currentMonthIndex >= state.lunarMonths.length - 1;
  
  if (day30) {
    // Day 30 exists
    let classes = ['day-cell'];
    if (day30.feasts && day30.feasts.length > 0) classes.push('feast');
    if (day30.lunarDay === state.highlightedLunarDay) classes.push('highlighted');
    // Day 30 with '-' means it might not exist (only show uncertainty for '-' direction)
    const day30Uncertain = day30.isUncertain && month.dateUncertainty === '-';
    if (day30Uncertain) classes.push('date-uncertain');
    // Check if Day 30 is today
    if (day30.gregorianDate.toISOString().split('T')[0] === todayStr) classes.push('today');
    
    let feastLabel = '';
    const icons = [];
    if (day30.feasts && day30.feasts.length > 0) {
      icons.push(...new Set(day30.feasts.map(f => f.feast.icon)));
    }
    if (day30.equinox) {
      icons.push('â˜€ï¸âš–ï¸');
    }
    if (icons.length > 0) {
      feastLabel = `<div class="feast-icons">${icons.join('')}</div>`;
    }
    
    const dateStr = day30.gregorianDate.toISOString().split('T')[0];
    let titleText = day30.feasts && day30.feasts.length > 0 
      ? day30.feasts.map(f => f.feast.name + ': ' + f.feast.description).join(' | ')
      : '';
    if (day30Uncertain) {
      const prob = month.dateUncertaintyProbability || 0;
      titleText = (titleText ? titleText + ' | ' : '') + `~${prob}% chance this Day 30 does not exist`;
    }
    const isHighlighted30 = day30.lunarDay === state.highlightedLunarDay;
    
    // Day 30 with '-' shows the suffix, Day 30 with '+' doesn't exist scenario so no suffix
    const day30Suffix = day30Uncertain ? '-' : '';
    
    // Blood moon styling for Day 30
    const bloodMoonClass30 = day30.isBloodMoon ? ' blood-moon' : '';
    const bloodMoonTitle30 = day30.isBloodMoon ? ' | ðŸ”´ Blood Moon (Lunar Eclipse)' : '';
    
    html += `
      <div class="${classes.join(' ')}" data-date="${dateStr}" title="${titleText}${bloodMoonTitle30}">
        <div class="gregorian">${formatShortDate(day30.gregorianDate)}${day30Suffix}</div>
        <div class="moon-phase${bloodMoonClass30}">${day30.moonPhase}</div>
        <div class="lunar-day">${day30.lunarDay}</div>
        ${feastLabel}
      </div>
    `;
  } else {
    // No day 30 - use empty height-setter cell
    html += `<div class="day-cell empty quote-row-spacer"></div>`;
  }
  
  // Prev button - goes to previous year if at first month
  html += `
    <div class="month-nav-cell" onclick="navigateMonth(-1)" title="${isFirstMonth ? 'Previous Year' : 'Previous Month'}">
      <span class="nav-arrow">${isFirstMonth ? 'â®' : 'â—€'}</span>
    </div>
  `;
  
  // Scripture quote (span 4 columns)
  html += `
    <div class="scripture-quote span-4">
      "${scripture.text}" <span class="reference">${scripture.ref}</span>
    </div>
  `;
  
  // Next button - goes to next year if at last month
  html += `
    <div class="month-nav-cell" onclick="navigateMonth(1)" title="${isLastMonth ? 'Next Year' : 'Next Month'}">
      <span class="nav-arrow">${isLastMonth ? 'â­' : 'â–¶'}</span>
    </div>
  `;
  
  html += `
      </div>
    </div>
  `;
  
  container.innerHTML = html;
  
  // Update map editability based on current profile
  updateMapEditability();
  
  // Refresh time display since it was regenerated with the header
  updateTimeDisplay();
}

function jumpToFeast(monthIdx, lunarDay) {
  if (monthIdx >= 0 && monthIdx < state.lunarMonths.length) {
    state.currentMonthIndex = monthIdx;
    state.highlightedLunarDay = lunarDay;
    // Store timestamp for the feast day (sunrise)
    const month = state.lunarMonths[monthIdx];
    const dayObj = month.days.find(d => d.lunarDay === lunarDay);
    if (dayObj) {
      state.selectedTimestamp = getSunriseTimestamp(dayObj.gregorianDate);
      document.getElementById('goto-date').value = formatLocalDatetime(state.selectedTimestamp);
      showDayDetail(dayObj, month);
    }
    renderMonth(month);
    updateMonthButtons();
    updateURL();
    // Navigate to calendar view
    navigateTo('calendar');
    // Scroll to calendar after navigation
    setTimeout(() => {
      document.querySelector('.month-calendar')?.scrollIntoView({ behavior: 'smooth' });
    }, 50);
  }
}

function renderFeastTable(months) {
  const tbody = document.getElementById('feast-tbody');
  tbody.innerHTML = '';
  
  // Track which feasts we've already shown (for multi-month feasts like Hanukkah)
  const shownFeasts = new Set();
  
  // Collect all feast entries first
  const feastEntries = [];
  
  for (const feast of FEASTS) {
    // Skip if this is a continuation entry we've already handled
    if (feast.continuesNextMonth === undefined && shownFeasts.has(feast.name)) continue;
    
    const month = months.find(m => m.monthNumber === feast.month);
    if (!month) continue;
    
    const day = month.days.find(d => d.lunarDay === feast.day);
    if (!day) continue;
    
    let dateStr, gregDate;
    
    // Handle Hanukkah spanning two months
    if (feast.name === 'Hanukkah' && feast.continuesNextMonth) {
      shownFeasts.add('Hanukkah');
      const nextMonth = months.find(m => m.monthNumber === feast.month + 1);
      dateStr = `Month ${feast.month} day 25 - Month ${feast.month + 1} day 2`;
      
      const endDay = nextMonth ? nextMonth.days.find(d => d.lunarDay === 2) : null;
      gregDate = endDay 
        ? `${formatShortDate(day.gregorianDate)} - ${formatShortDate(endDay.gregorianDate)}`
        : formatFullDate(day.gregorianDate) + ' (8 days)';
    } else if (feast.name === 'Hanukkah' && !feast.continuesNextMonth) {
      // Skip the continuation entry in table
      continue;
    } else {
      dateStr = feast.endDay 
        ? `Month ${feast.month} days ${feast.day}-${feast.endDay}`
        : `Month ${feast.month} day ${feast.day}`;
      
      gregDate = formatFullDate(day.gregorianDate);
      if (feast.endDay) {
        const endDay = month.days.find(d => d.lunarDay === feast.endDay);
        if (endDay) gregDate = `${formatShortDate(day.gregorianDate)} - ${formatShortDate(endDay.gregorianDate)}`;
      }
    }
    
    const monthIdx = months.findIndex(m => m.monthNumber === feast.month);
    const dayIdx = feast.day;
    
    feastEntries.push({
      feast,
      day,
      dateStr,
      gregDate,
      monthIdx,
      dayIdx,
      sortDate: day.gregorianDate
    });
  }
  
  // Sort by Gregorian date
  feastEntries.sort((a, b) => a.sortDate.getTime() - b.sortDate.getTime());
  
  // Render sorted entries
  for (const entry of feastEntries) {
    // Use dynamic description for Renewed Moon based on current moon phase setting
    const description = entry.feast.name === 'Renewed Moon' 
      ? getRenewedMoonDescription() 
      : entry.feast.description;
    
    tbody.innerHTML += `
      <tr>
        <td><a href="#" class="feast-jump" data-month="${entry.monthIdx}" data-day="${entry.dayIdx}" style="color: inherit; text-decoration: none;"><strong>${entry.feast.name}</strong></a></td>
        <td><a href="#" class="feast-jump" data-month="${entry.monthIdx}" data-day="${entry.dayIdx}" style="color: inherit; text-decoration: none;">
          <div>${entry.dateStr}</div>
          <div style="color: #666; font-size: 0.9em;">${entry.gregDate}</div>
        </a></td>
        <td><a href="${entry.feast.chapter}" style="color: #2c5282;">${description} â†’</a></td>
      </tr>
    `;
  }
}

// Handle browser back/forward buttons
window.addEventListener('popstate', function(event) {
  // Parse the path-based URL
  const urlState = parsePathURL();
  
  if (urlState.view === 'sabbath-tester') {
    // Navigate back to sabbath tester
    const sabbathTesterPage = document.getElementById('sabbath-tester-page');
    const calendarOutput = document.getElementById('calendar-output');
    const dayDetailPanel = document.getElementById('day-detail-panel');
    const exportPage = document.getElementById('export-page');
    
    calendarOutput.style.display = 'none';
    dayDetailPanel.style.display = 'none';
    exportPage.style.display = 'none';
    sabbathTesterPage.style.display = 'block';
    renderSabbathTester();
  } else if (urlState.view === 'feasts') {
    navigateTo('feasts');
  } else {
    // Navigate to calendar with URL state
    const { needsRegenerate, month, day } = applyURLState(urlState);
    if (needsRegenerate) {
      updateUI();
      generateCalendar();
    }
    if (month !== null || day !== null) {
      if (month !== null) state.currentMonthIndex = month - 1;
      if (day !== null) state.highlightedLunarDay = day;
      renderMonth(state.lunarMonths[state.currentMonthIndex]);
      updateMonthButtons();
    }
    navigateTo('calendar');
  }
});

document.addEventListener('DOMContentLoaded', async function() {
  // Clear any lingering overflow classes from previous sessions
  document.body.classList.remove('sabbath-tester-open', 'feasts-open');
  document.documentElement.classList.remove('feasts-open');
  document.body.style.overflow = '';
  
  // Check for redirect path from 404 page (GitHub Pages SPA routing)
  const redirectPath = sessionStorage.getItem('redirectPath');
  if (redirectPath) {
    sessionStorage.removeItem('redirectPath');
    // Replace the current URL with the intended path
    window.history.replaceState({}, '', redirectPath);
  }
  
  // Rebuild profile dropdown with any saved custom profiles
  rebuildProfileDropdown();
  
  // Initialize settings editability (presets are read-only)
  updateSettingsEditability();
  
  // Initialize astronomy engine (loads Swiss Ephemeris WASM)
  await initializeAstroEngine();
  
  // Check if URL has path data or query params - if so, load from URL
  const path = window.location.pathname;
  const hasPathData = path !== '/' && path !== '/index.html';
  const hasQueryData = window.location.search.length > 0;
  
  if (hasPathData || hasQueryData) {
    // URL has state - restore from URL
    updateUI(); // Set UI from localStorage first
    generateCalendar();
    loadFromURL(); // Then override with URL params/path
  } else {
    // No URL data - always jump to today's date on fresh load
    jumpToToday();
    updateURL(); // Set initial URL
  }
  
  // Start live time updates for header display
  updateTimeDisplay();
  startLiveTimeUpdates();
  
  // Show about modal on first visit
  if (shouldShowAboutModal()) {
    // Small delay to let the page render first
    setTimeout(showAboutModal, 500);
  }
  
  // Initialize PWA install button
  initInstallButton();
  
  // Event delegation for feast table clicks
  document.getElementById('feast-tbody').addEventListener('click', function(e) {
    const link = e.target.closest('.feast-jump');
    if (link) {
      e.preventDefault();
      const monthIdx = parseInt(link.dataset.month);
      const lunarDay = parseInt(link.dataset.day);
      jumpToFeast(monthIdx, lunarDay);
    }
  });
  
  // Event delegation for calendar day cell clicks - update goto-date input and highlight
  document.getElementById('calendar-output').addEventListener('click', function(e) {
    // Check for day cell click
    const cell = e.target.closest('.day-cell[data-date]');
    if (cell) {
      // Find the lunar day for this cell and store the timestamp
      const lunarDayEl = cell.querySelector('.lunar-day');
      if (lunarDayEl) {
        const lunarDay = parseInt(lunarDayEl.textContent);
        const month = state.lunarMonths[state.currentMonthIndex];
        const dayObj = month.days.find(d => d.lunarDay === lunarDay);
        if (dayObj) {
          // Calculate sunrise time at selected location for this day
          state.selectedTimestamp = getSunriseTimestamp(dayObj.gregorianDate);
          document.getElementById('goto-date').value = formatLocalDatetime(state.selectedTimestamp);
          showDayDetail(dayObj, month);
        }
        state.highlightedLunarDay = lunarDay;
        renderMonth(state.lunarMonths[state.currentMonthIndex]);
        updateURL();
      }
      return;
    }
    
    // Check for new-moon-box (Day 1) click
    const newMoonBox = e.target.closest('.new-moon-box[data-date]');
    if (newMoonBox) {
      const month = state.lunarMonths[state.currentMonthIndex];
      const dayObj = month.days.find(d => d.lunarDay === 1);
      if (dayObj) {
        // Calculate sunrise time at selected location for this day
        state.selectedTimestamp = getSunriseTimestamp(dayObj.gregorianDate);
        document.getElementById('goto-date').value = formatLocalDatetime(state.selectedTimestamp);
        showDayDetail(dayObj, month);
      }
      state.highlightedLunarDay = 1;
      renderMonth(state.lunarMonths[state.currentMonthIndex]);
      updateURL();
    }
  });
});

// Helper function to refresh day detail panel if one is currently shown
function refreshDayDetailIfVisible() {
  if (state.highlightedLunarDay !== null && state.lunarMonths[state.currentMonthIndex]) {
    const month = state.lunarMonths[state.currentMonthIndex];
    const dayObj = month.days.find(d => d.lunarDay === state.highlightedLunarDay);
    if (dayObj) {
      showDayDetail(dayObj, month);
    }
  }
}

// Show the day detail panel with information about the selected day
function showDayDetail(dayObj, month) {
  const panel = document.getElementById('day-detail-panel');
  
  // Populate lunar date
  const ordinal = getOrdinalSuffix(month.monthNumber);
  const lunarDateStr = `Day ${dayObj.lunarDay} of the ${month.monthNumber}${ordinal} Month`;
  panel.querySelector('.day-detail-lunar').textContent = lunarDateStr;
  
  // Populate gregorian/julian date
  const gregDate = dayObj.gregorianDate;
  panel.querySelector('.day-detail-gregorian').textContent = formatDisplayDate(gregDate);
  
  // Populate feasts
  const feastsContainer = panel.querySelector('.day-detail-feasts');
  feastsContainer.innerHTML = '';
  
  if (dayObj.feasts && dayObj.feasts.length > 0) {
    for (const f of dayObj.feasts) {
      const feast = f.feast;
      const dayNum = f.dayNum;
      const nameText = dayNum ? `${feast.name} (Day ${dayNum})` : feast.name;
      
      // Check if this is a Renewed Moon feast and we have moon event data
      let basisHtml = '';
      let stellariumLink = ''; // Initialize for all feasts
      if (feast.name === 'Renewed Moon' && dayObj.lunarDay === 1 && month.moonEvent) {
        const moonEventTime = month.moonEvent;
        const signName = getMoonLabel();
        
        // Format moon event date in a friendly way
        const moonEventDate = new Date(moonEventTime);
        const moonParts = getFormattedDateParts(moonEventDate);
        const dayOfWeek = moonParts.weekdayName;
        const monthName = moonParts.shortMonthName;
        const dayNum = moonParts.day;
        const daySuffix = getOrdinalSuffix(dayNum);
        const year = moonParts.yearStr;
        
        // Format times in observer's local time (based on longitude), not browser timezone
        const moonLocalTime = utcToLocalTime(moonEventDate.getTime(), state.lon);
        const moonTimeStr = `${moonLocalTime.getUTCHours() % 12 || 12}:${String(moonLocalTime.getUTCMinutes()).padStart(2, '0')} ${moonLocalTime.getUTCHours() >= 12 ? 'PM' : 'AM'}`;
        
        const dayStartLabel = getDayStartLabel();
        
        // For dark/full moon mode with evening start, calculate margin to same-day sunset
        // This is the key margin that determines whether a 30th day was added to the prior month
        let sameDaySunset = null;
        let marginToSunsetMs = 0;
        let conjunctionAfterSunset = false;
        
        if ((state.moonPhase === 'dark' || state.moonPhase === 'full') && state.dayStartTime === 'evening') {
          sameDaySunset = getSunsetTimestamp(moonEventDate);
          const sameDaySunrise = getSunriseTimestamp(moonEventDate);
          marginToSunsetMs = sameDaySunset - moonEventTime.getTime();
          
          // Key insight: if the moon event is between midnight and sunrise (early morning),
          // it's actually part of the PREVIOUS evening's "day" in Hebrew calendar terms.
          const moonLocalTime = moonEventTime.getTime() + (state.lon / 15) * 60 * 60 * 1000;
          const sunriseLocalTime = sameDaySunrise + (state.lon / 15) * 60 * 60 * 1000;
          const sunsetLocalTime = sameDaySunset + (state.lon / 15) * 60 * 60 * 1000;
          
          const isBeforeSunrise = moonLocalTime < sunriseLocalTime;
          const isAfterSunset = moonLocalTime > sunsetLocalTime;
          
          // For early morning events (before sunrise), calculate margin from previous sunset
          if (isBeforeSunrise) {
            const prevDate = new Date(moonEventDate.getTime());
            prevDate.setUTCDate(prevDate.getUTCDate() - 1);
            const prevSunset = getSunsetTimestamp(prevDate);
            marginToSunsetMs = prevSunset - moonEventTime.getTime(); // Will be negative (after sunset)
            conjunctionAfterSunset = true;
          } else {
            conjunctionAfterSunset = isAfterSunset;
          }
        }
        
        // Get the day start time (sunset that starts Day 1)
        const dayStartTimestamp = getDayStartTime(dayObj.gregorianDate);
        const dayStartLocalTime = utcToLocalTime(dayStartTimestamp, state.lon);
        const dayStartStr = `${dayStartLocalTime.getUTCHours() % 12 || 12}:${String(dayStartLocalTime.getUTCMinutes()).padStart(2, '0')} ${dayStartLocalTime.getUTCHours() >= 12 ? 'PM' : 'AM'}`;
        
        // For the margin calculation (used for uncertainty warning), use the same-day sunset margin
        // This tells us how close the conjunction was to sunset on that day
        const marginMs = sameDaySunset !== null ? Math.abs(marginToSunsetMs) : Math.abs(dayStartTimestamp - moonEventTime.getTime());
        const marginMins = Math.round(marginMs / (1000 * 60));
        const marginHours = Math.floor(marginMins / 60);
        const marginMinsRemainder = marginMins % 60;
        
        let marginStr = '';
        if (marginHours > 0 && marginMinsRemainder > 0) {
          marginStr = `${marginHours} hour${marginHours > 1 ? 's' : ''} ${marginMinsRemainder} minute${marginMinsRemainder > 1 ? 's' : ''}`;
        } else if (marginHours > 0) {
          marginStr = `${marginHours} hour${marginHours > 1 ? 's' : ''}`;
        } else {
          marginStr = `${marginMinsRemainder} minute${marginMinsRemainder > 1 ? 's' : ''}`;
        }
        
        // Determine tense based on whether the date is past or future
        const now = new Date();
        const isPast = moonEventDate < now;
        const occurVerb = isPast ? 'occurred' : 'will occur';
        
        // Check if this is crescent + sunset mode (special case where crescent day IS Day 1)
        const isCrescentSunset = state.moonPhase === 'crescent' && 
                                 state.dayStartTime === 'evening' && 
                                 state.dayStartAngle === 0;
        
        // Get moon altitude at sunset for crescent mode
        let crescentAltitudeInfo = '';
        if (state.moonPhase === 'crescent') {
          // The moonEventTime is already the "forged" crescent event (conjunction + threshold hours)
          // Calculate the actual conjunction time
          const conjunctionDate = new Date(moonEventTime.getTime() - state.crescentThreshold * 60 * 60 * 1000);
          
          // For crescent visibility, we need to find the sunset when the crescent would be visible
          // This is the first sunset AFTER the conjunction
          let checkDate = new Date(conjunctionDate);
          let sightingData = getMoonAltitudeAtSunset(checkDate);
          
          // If the sunset on conjunction day is BEFORE the conjunction, check next day
          if (sightingData && sightingData.sunsetTime.getTime() < conjunctionDate.getTime()) {
            checkDate = new Date(conjunctionDate.getTime() + 24 * 60 * 60 * 1000);
            sightingData = getMoonAltitudeAtSunset(checkDate);
          }
          
          if (sightingData) {
            const altStr = sightingData.moonAltitude.toFixed(1);
            const elongStr = sightingData.elongation.toFixed(1);
            const sunsetFormatted = formatTimeInObserverTimezone(sightingData.sunsetTime);
            const sunsetDateStr = formatAncientDate(sightingData.sunsetTime);
            const conjTimeFormatted = formatTimeInObserverTimezone(conjunctionDate);
            const conjDateStr = formatAncientDate(conjunctionDate);
            
            // Determine visibility status
            let visibilityNote = '';
            if (sightingData.moonAltitude < 0) {
              visibilityNote = ' (below horizon - not visible)';
            } else if (sightingData.moonAltitude < 5) {
              visibilityNote = ' (very low - difficult to see)';
            } else if (sightingData.elongation < 7) {
              visibilityNote = ' (too close to sun - difficult to see)';
            } else if (sightingData.moonAltitude >= 5 && sightingData.elongation >= 7) {
              visibilityNote = ' (likely visible)';
            }
            
            crescentAltitudeInfo = ` Conjunction: ${conjDateStr} ${conjTimeFormatted.full}. Crescent check on ${sunsetDateStr} at sunset (${sunsetFormatted.time}): moon ${altStr}Â° altitude, ${elongStr}Â° from sun${visibilityNote}.`;
          }
        }
        
        // Generate Stellarium Web link for all moon phases
        // Use an appropriate viewing time based on moon phase and day start
        let stellariumDateTime;
        
        if (state.moonPhase === 'crescent') {
          // For crescent, use sunset time when you'd look for the crescent
          // Same logic as crescent altitude info: first sunset AFTER the conjunction
          const conjunctionForLink = new Date(moonEventTime.getTime() - state.crescentThreshold * 60 * 60 * 1000);
          let checkDateForLink = new Date(conjunctionForLink);
          let moonDataForLink = getMoonAltitudeAtSunset(checkDateForLink);
          
          // If sunset on conjunction day is before conjunction, check next day
          if (moonDataForLink && moonDataForLink.sunsetTime.getTime() < conjunctionForLink.getTime()) {
            checkDateForLink = new Date(conjunctionForLink.getTime() + 24 * 60 * 60 * 1000);
            moonDataForLink = getMoonAltitudeAtSunset(checkDateForLink);
          }
          
          if (moonDataForLink) {
            // Use the sunset time on the crescent sighting day
            stellariumDateTime = moonDataForLink.sunsetTime;
          } else {
            stellariumDateTime = moonEventDate;
          }
        } else if (state.moonPhase === 'full') {
          // For full moon, use early morning before sunrise when moon is visible in west
          // Get the day start time for Day 1
          const day1Date = dayObj.gregorianDate;
          const dayStartTs = getDayStartTime(day1Date);
          stellariumDateTime = new Date(dayStartTs);
        } else {
          // For dark moon (conjunction), use the moon event time
          // Note: dark moon isn't visible, but this shows the sky at that moment
          stellariumDateTime = moonEventDate;
        }
        
        const stellariumDate = stellariumDateTime.toISOString().split('.')[0] + 'Z';
        stellariumLink = `<a href="https://stellarium-web.org/?date=${stellariumDate}&lat=${state.lat}&lng=${state.lon}" target="_blank" rel="noopener" class="stellarium-link"><img src="https://stellarium-web.org/favicon.ico" alt="" onerror="this.style.display='none'">View in Stellarium</a>`;
        
        // Build explanation based on moon phase type and day start settings
        // Stellarium link is stored separately to put in header
        let explanationText = '';
        
        if ((state.moonPhase === 'dark' || state.moonPhase === 'full') && state.dayStartTime === 'evening') {
          // For dark/full moon with evening start, explain the margin to sunset
          const beforeAfterSunset = conjunctionAfterSunset ? 'after' : 'before';
          const moonLabel = state.moonPhase === 'dark' ? 'Dark Moon (conjunction)' : 'Full Moon';
          
          if (conjunctionAfterSunset) {
            // Conjunction was after sunset - a 30th day was added to the prior month
            explanationText = `The ${moonLabel} ${occurVerb} on ${dayOfWeek}, ${monthName} ${dayNum}${daySuffix}, ${year} at ${moonTimeStr}, ` +
              `which was ${marginStr} after sunset (${dayStartStr}). Since it occurred after sunset, ` +
              `the prior month had 30 days, and this month begins at the following evening's sunset.`;
          } else {
            // Conjunction was before sunset - month starts at this sunset
            explanationText = `The ${moonLabel} ${occurVerb} on ${dayOfWeek}, ${monthName} ${dayNum}${daySuffix}, ${year} at ${moonTimeStr}, ` +
              `which was ${marginStr} before sunset. The month begins at sunset (${dayStartStr}).`;
          }
        } else if (state.moonPhase === 'crescent') {
          if (isCrescentSunset) {
            explanationText = `The first visible Crescent Moon ${occurVerb} on ${dayOfWeek}, ${monthName} ${dayNum}${daySuffix}, ${year}. ` +
              `The month begins immediately at sunset following the sighting.${crescentAltitudeInfo}`;
          } else {
            explanationText = `The first visible Crescent Moon ${occurVerb} on ${dayOfWeek}, ${monthName} ${dayNum}${daySuffix}, ${year}. ` +
              `The month begins at the next ${dayStartLabel} (${dayStartStr}).${crescentAltitudeInfo}`;
          }
        } else {
          explanationText = `The ${signName} ${occurVerb} on ${dayOfWeek}, ${monthName} ${dayNum}${daySuffix}, ${year} at ${moonTimeStr}. ` +
            `The month begins at ${dayStartLabel} (${dayStartStr}).`;
        }
        
        // Check if the margin is within Î”T uncertainty for ancient dates
        let uncertaintyWarningHtml = '';
        const eventYear = moonEventDate.getUTCFullYear();
        const uncertaintyHours = AstroEngines.nasaEclipse.getDeltaTUncertainty(eventYear);
        const marginHoursValue = marginMins / 60;
        
        if (uncertaintyHours > 0 && marginHoursValue <= uncertaintyHours) {
          // Get the prior month's day count to determine which direction the error could go
          // Lunar months are always 29 or 30 days
          const currentMonthIdx = state.lunarMonths.findIndex(m => m.monthNumber === month.monthNumber);
          const priorMonth = currentMonthIdx > 0 ? state.lunarMonths[currentMonthIdx - 1] : null;
          const priorMonthDays = priorMonth ? priorMonth.daysInMonth : 29;
          
          let warningExplanation = '';
          if (state.moonPhase === 'dark' || state.moonPhase === 'full') {
            if (priorMonthDays === 29) {
              // Prior month has 29 days - only possible error is it should be 30
              warningExplanation = `If the actual ${getMoonLabel()} occurred later than calculated, ` +
                `it may have been after sunset, meaning the prior month would have had 30 days, ` +
                `and all dates in this month would be one day later than shown.`;
            } else {
              // Prior month has 30 days - only possible error is it should be 29
              warningExplanation = `If the actual ${getMoonLabel()} occurred earlier than calculated, ` +
                `it may have been before sunset, meaning the prior month would have had only 29 days, ` +
                `and all dates in this month would be one day earlier than shown.`;
            }
          } else if (state.moonPhase === 'crescent') {
            warningExplanation = `If the crescent was actually visible earlier or later than calculated, ` +
              `Day 1 could fall on the previous or next day, shifting all dates in this month.`;
          } else {
            warningExplanation = `The actual Day 1 could potentially fall on the previous or next day.`;
          }
          
          uncertaintyWarningHtml = `
            <div class="uncertainty-warning">
              <span class="warning-icon">âš ï¸</span>
              <strong>Date Uncertainty:</strong> The ${marginStr} margin between the ${getMoonLabel()} and sunset 
              is within the estimated Â±${uncertaintyHours} hour uncertainty for astronomical calculations at this date. 
              ${warningExplanation}
            </div>
          `;
        }
        
        basisHtml = `
          <div class="feast-basis">
            ${explanationText}
          </div>
          ${uncertaintyWarningHtml}
        `;
      }
      
      // Generate dynamic description for Renewed Moon based on current moon phase setting
      const feastDescription = feast.name === 'Renewed Moon' 
        ? getRenewedMoonDescription() 
        : feast.description;
      
      // For Renewed Moon on Day 1, include the Stellarium link in the header
      const showStellarium = feast.name === 'Renewed Moon' && dayObj.lunarDay === 1 && stellariumLink;
      
      const item = document.createElement('div');
      item.className = 'day-detail-feast-item';
      item.innerHTML = `
        <div class="day-detail-feast-icon">${feast.icon}</div>
        <div class="day-detail-feast-info">
          <div class="day-detail-feast-header">
            <div class="day-detail-feast-name">${nameText}</div>
            ${showStellarium ? stellariumLink : ''}
          </div>
          <div class="day-detail-feast-desc">${feastDescription}</div>
          ${basisHtml}
          ${feast.chapter ? `<a href="${feast.chapter}" class="day-detail-feast-link">Learn more &rarr;</a>` : ''}
        </div>
      `;
      feastsContainer.appendChild(item);
    }
  } else if (!dayObj.equinox) {
    feastsContainer.innerHTML = '<div class="day-detail-no-feast">No appointed times on this day</div>';
  }
  
  // Add equinox info if this day has the spring equinox
  if (dayObj.equinox) {
    const equinoxDate = dayObj.equinox.date;
    const eqParts = getFormattedDateParts(equinoxDate);
    const dayOfWeek = eqParts.weekdayName;
    const monthName = eqParts.monthName;
    const dayNum = eqParts.day;
    const daySuffix = getOrdinalSuffix(dayNum);
    const year = eqParts.yearStr;
    const timeStr = equinoxDate.toLocaleTimeString('en-US', { 
      hour: 'numeric', minute: '2-digit', hour12: true 
    });
    
    const now = new Date();
    const isPast = equinoxDate < now;
    const verb = isPast ? 'occurred' : 'will occur';
    
    const item = document.createElement('div');
    item.className = 'day-detail-feast-item';
    item.innerHTML = `
      <div class="day-detail-feast-icon">â˜€ï¸âš–ï¸</div>
      <div class="day-detail-feast-info">
        <div class="day-detail-feast-name">Spring Equinox</div>
        <div class="day-detail-feast-desc">The moment when day and night are equal in length, marking the astronomical beginning of spring.</div>
        <div class="feast-basis">
          The Spring Equinox ${verb} on ${dayOfWeek}, ${monthName} ${dayNum}${daySuffix}, ${year} at ${timeStr}.
        </div>
        <a href="/chapters/08-when-does-the-year-start/" class="day-detail-feast-link">Learn more &rarr;</a>
      </div>
    `;
    feastsContainer.appendChild(item);
  }
  
  // Add blood moon (lunar eclipse) info if this day has one
  if (dayObj.isBloodMoon) {
    const bloodMoonDate = dayObj.gregorianDate;
    const bmParts = getFormattedDateParts(bloodMoonDate);
    const dayOfWeek = bmParts.weekdayName;
    const monthName = bmParts.monthName;
    const dayNum = bmParts.day;
    const daySuffix = getOrdinalSuffix(dayNum);
    const year = bmParts.yearStr;
    
    const now = new Date();
    const isPast = bloodMoonDate < now;
    const verb = isPast ? 'occurred' : 'will occur';
    
    // Get the exact eclipse time for Stellarium link
    const eclipseTime = AstroEngines.nasaEclipse.getLunarEclipseTime(dayObj.gregorianDate);
    let eclipseTimeStr = '';
    let stellariumBloodMoonLink = '';
    if (eclipseTime) {
      const eclipseFormatted = formatTimeInObserverTimezone(eclipseTime);
      eclipseTimeStr = ` at ${eclipseFormatted.full}`;
      const stellariumDate = eclipseTime.toISOString().split('.')[0] + 'Z';
      stellariumBloodMoonLink = `<a href="https://stellarium-web.org/?date=${stellariumDate}&lat=${state.lat}&lng=${state.lon}" target="_blank" rel="noopener" class="stellarium-link"><img src="https://stellarium-web.org/favicon.ico" alt="" onerror="this.style.display='none'">View in Stellarium</a>`;
    }
    
    const item = document.createElement('div');
    item.className = 'day-detail-feast-item';
    item.innerHTML = `
      <div class="day-detail-feast-icon blood-moon-icon">ðŸŒ•</div>
      <div class="day-detail-feast-info">
        <div class="day-detail-feast-header">
          <div class="day-detail-feast-name" style="color: #ff6b6b;">Blood Moon (Total Lunar Eclipse)</div>
          ${stellariumBloodMoonLink}
        </div>
        <div class="day-detail-feast-desc">A total lunar eclipse occurs when the Earth passes between the Sun and Moon, 
          casting Earth's shadow on the lunar surface. The Moon appears deep red due to sunlight filtered through Earth's atmosphere.</div>
        <div class="feast-basis">
          A total lunar eclipse ${verb} on ${dayOfWeek}, ${monthName} ${dayNum}${daySuffix}, ${year}${eclipseTimeStr}. 
          In Scripture, blood moons are often associated with significant prophetic events (Joel 2:31, Acts 2:20, Revelation 6:12).
        </div>
      </div>
    `;
    feastsContainer.appendChild(item);
  }
  
  // Add uncertainty warning for any uncertain day
  if (dayObj.isUncertain && month.dateUncertainty) {
    const item = document.createElement('div');
    item.className = 'day-detail-feast-item';
    
    const prob = month.dateUncertaintyProbability || 0;
    let warningText = '';
    if (month.dateUncertainty === '-') {
      if (dayObj.lunarDay === 30) {
        warningText = `There is a ~${prob}% probability this Day 30 does not exist. The margin between this month's ${getMoonLabel()} and sunset 
          is within the estimated uncertainty for astronomical calculations at this ancient date. 
          If the ${getMoonLabel()} actually occurred before sunset, the prior month would have only 29 days, 
          and all dates in this month would be one day earlier than shown.`;
      } else {
        warningText = `There is a ~${prob}% probability this date is one day earlier than shown. The ${getMoonLabel()} occurred very close to sunset, 
          and if it was actually before sunset, the prior month would have only 29 days instead of 30.`;
      }
    } else if (month.dateUncertainty === '+') {
      warningText = `There is a ~${prob}% probability this date is one day later than shown. The ${getMoonLabel()} occurred very close to sunset, 
        and if it was actually after sunset, the prior month would have 30 days instead of 29.`;
    }
    
    item.innerHTML = `
      <div class="day-detail-feast-icon">âš ï¸</div>
      <div class="day-detail-feast-info">
        <div class="day-detail-feast-name">Date Uncertainty: ~${prob}% chance dates are ${month.dateUncertainty === '-' ? 'earlier' : 'later'}</div>
        <div class="uncertainty-warning" style="margin-top: 0.5rem;">
          ${warningText}
        </div>
      </div>
    `;
    feastsContainer.appendChild(item);
  }
  
  // Add year start explanation for 1st day of 1st month, or 13th month explanation
  if (dayObj.lunarDay === 1 && (month.monthNumber === 1 || month.monthNumber === 13)) {
    const item = document.createElement('div');
    item.className = 'day-detail-feast-item day-detail-year-info';
    
    const totalMonths = state.lunarMonths.length;
    const has13thMonth = totalMonths === 13;
    const moonLabel = getMoonLabel();
    
    // Get spring equinox for this lunar year
    const springEquinox = getAstroEngine().getSeasons(state.year).mar_equinox.date;
    const seqParts = getFormattedDateParts(springEquinox);
    const equinoxDateStr = `${seqParts.weekdayName}, ${seqParts.monthName} ${seqParts.day}${getOrdinalSuffix(seqParts.day)}, ${seqParts.yearStr}${seqParts.calendarSuffix}`;
    
    // Check if we're in crescent + sunset mode
    const isCrescentSunset = state.moonPhase === 'crescent' && 
                             state.dayStartTime === 'evening' && 
                             state.dayStartAngle === 0;
    
    // Calculate time from equinox to month start (day 1 day-start)
    // For crescent+sunset, use the moon event time (crescent sighting = sunset)
    let day1StartTs;
    if (isCrescentSunset && month.moonEvent) {
      day1StartTs = month.moonEvent.getTime();
    } else {
      day1StartTs = getDayStartTime(dayObj.gregorianDate);
    }
    const diffMs = day1StartTs - springEquinox.getTime();
    const diffTotalHours = diffMs / (1000 * 60 * 60);
    const diffDays = Math.floor(Math.abs(diffTotalHours) / 24);
    const diffHours = Math.round(Math.abs(diffTotalHours) % 24);
    
    let timingStr = '';
    if (diffDays > 0 && diffHours > 0) {
      timingStr = `${diffDays} day${diffDays !== 1 ? 's' : ''} and ${diffHours} hour${diffHours !== 1 ? 's' : ''}`;
    } else if (diffDays > 0) {
      timingStr = `${diffDays} day${diffDays !== 1 ? 's' : ''}`;
    } else {
      timingStr = `${diffHours} hour${diffHours !== 1 ? 's' : ''}`;
    }
    const beforeAfter = diffMs >= 0 ? 'after' : 'before';
    
    if (month.monthNumber === 1) {
      // Positive reason: explain why year CAN start here using current moon phase setting
      const dayStartLabel = getDayStartLabel();
      const day1StartDate = new Date(day1StartTs);
      const day1StartStr = day1StartDate.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
      const day1Parts = getFormattedDateParts(day1StartDate);
      const day1DateStr = `${day1Parts.weekdayName}, ${day1Parts.monthName} ${day1Parts.day}${getOrdinalSuffix(day1Parts.day)}`;
      
      let yearMonthInfo = '';
      let virgoExplanationHtml = '';
      
      // For Virgo rule, use shared methodology function
      if (state.yearStartRule === 'virgoFeet') {
        const virgoCalc = getVirgoCalculation(state.year);
        if (virgoCalc) {
          // Use the shared methodology function with calculation details
          virgoExplanationHtml = getVirgoMethodologyHtml({ 
            showCalculation: true, 
            virgoCalc: virgoCalc 
          });
          yearMonthInfo = ''; // Content is in virgoExplanationHtml
        } else {
          yearMonthInfo = `Day 1 begins at ${dayStartLabel} (${day1DateStr} at ${day1StartStr}). Using Moon Under Virgo's Feet rule.`;
        }
      } else if (state.yearStartRule === '13daysBefore') {
        // Passover rule - use shared function
        virgoExplanationHtml = getPassoverMethodologyHtml({
          showCalculation: true,
          equinoxDate: equinoxDateStr,
          day1Date: `${day1DateStr} at ${day1StartStr}`,
          timingStr: timingStr,
          beforeAfter: beforeAfter
        });
        yearMonthInfo = ''; // Content is in virgoExplanationHtml
      } else {
        // Equinox rule - use shared function
        virgoExplanationHtml = getEquinoxMethodologyHtml({
          showCalculation: true,
          equinoxDate: equinoxDateStr,
          day1Date: `${day1DateStr} at ${day1StartStr}`,
          timingStr: timingStr,
          beforeAfter: beforeAfter
        });
        yearMonthInfo = ''; // Content is in virgoExplanationHtml
      }
      
      // Determine icon based on rule
      let ruleIcon = 'ðŸ“…';
      if (state.yearStartRule === 'virgoFeet') ruleIcon = 'â™';
      else if (state.yearStartRule === '13daysBefore') ruleIcon = 'ðŸ‘';
      else ruleIcon = 'âš–ï¸';
      
      item.innerHTML = `
        <div class="day-detail-feast-icon">${ruleIcon}</div>
        <div class="day-detail-feast-info">
          <div class="day-detail-feast-name">Lunar Year ${state.year} Begins</div>
          <div class="day-detail-feast-desc">${yearMonthInfo}</div>
          ${virgoExplanationHtml}
        </div>
      `;
      feastsContainer.appendChild(item);
      
      // Add click handler for equinox link
      const equinoxLink = item.querySelector('.equinox-link');
      if (equinoxLink) {
        equinoxLink.addEventListener('click', (e) => {
          e.preventDefault();
          jumpToEquinoxDate(springEquinox);
        });
      }
    } else if (month.monthNumber === 13) {
      // Explain why 13th month exists: its day-start is BEFORE the next year's start point
      const nextEquinox = getAstroEngine().getSeasons(state.year + 1).mar_equinox.date;
      const neqParts = getFormattedDateParts(nextEquinox);
      const nextEquinoxDateStr = `${neqParts.weekdayName}, ${neqParts.monthName} ${neqParts.day}${getOrdinalSuffix(neqParts.day)}, ${neqParts.yearStr}${neqParts.calendarSuffix}`;
      
      // Get the 13th month's moon event (crescent/full/dark)
      const month13MoonEvent = month.moonEvent;
      let moonEventStr = '';
      let dayStartStr = '';
      let timingExplanation = '';
      
      if (month13MoonEvent) {
        const moonParts = getFormattedDateParts(month13MoonEvent);
        const moonTimeStr = month13MoonEvent.toLocaleTimeString('en-US', { 
          hour: 'numeric', minute: '2-digit', hour12: true 
        });
        moonEventStr = `${moonParts.weekdayName}, ${moonParts.monthName} ${moonParts.day}${getOrdinalSuffix(moonParts.day)}, ${moonParts.yearStr} at ${moonTimeStr}`;
        
        // Check if we're in crescent + sunset mode
        const isCrescentSunset = state.moonPhase === 'crescent' && 
                                 state.dayStartTime === 'evening' && 
                                 state.dayStartAngle === 0;
        
        // Calculate when Day 1 starts (day-start time)
        // For crescent+sunset, the month starts at the crescent sighting time (which IS sunset)
        let dayStartTimestamp;
        if (isCrescentSunset) {
          dayStartTimestamp = month13MoonEvent.getTime();
        } else {
          dayStartTimestamp = getDayStartTime(dayObj.gregorianDate);
        }
        const dayStartDate = new Date(dayStartTimestamp);
        const dayStartLabel = getDayStartLabel();
        const dsTimeStr = dayStartDate.toLocaleTimeString('en-US', { 
          hour: 'numeric', minute: '2-digit', hour12: true 
        });
        const dsParts = getFormattedDateParts(dayStartDate);
        dayStartStr = `${dsParts.weekdayName}, ${dsParts.monthName} ${dsParts.day}${getOrdinalSuffix(dsParts.day)} at ${dsTimeStr}`;
        
        // Calculate time from 13th month day-start to next equinox
        const diffToEquinoxMs = nextEquinox.getTime() - dayStartTimestamp;
        const diffToEquinoxHours = diffToEquinoxMs / (1000 * 60 * 60);
        const diffDays = Math.floor(diffToEquinoxHours / 24);
        const diffHours = Math.round(diffToEquinoxHours % 24);
        
        let diffStr = '';
        if (diffDays > 0 && diffHours > 0) {
          diffStr = `${diffDays} day${diffDays !== 1 ? 's' : ''} and ${diffHours} hour${diffHours !== 1 ? 's' : ''}`;
        } else if (diffDays > 0) {
          diffStr = `${diffDays} day${diffDays !== 1 ? 's' : ''}`;
        } else {
          diffStr = `${diffHours} hour${diffHours !== 1 ? 's' : ''}`;
        }
        
        timingExplanation = `The ${moonLabel} for this month was sighted on ${moonEventStr}. ` +
          `Day 1 begins at ${dayStartLabel} (${dayStartStr}), which is ${diffStr} before the ` +
          `<a href="#" class="equinox-link" data-equinox-date="${nextEquinox.toISOString()}">Spring Equinox (${nextEquinoxDateStr})</a>. ` +
          `Since this day-start falls before the equinox, this qualifies as the 13th month of the current year rather than the 1st month of the next year.`;
      }
      
      item.innerHTML = `
        <div class="day-detail-feast-icon">ðŸ“…</div>
        <div class="day-detail-feast-info">
          <div class="day-detail-feast-name">13th Month (Intercalary)</div>
          <div class="day-detail-feast-desc">${timingExplanation}</div>
        </div>
      `;
      feastsContainer.appendChild(item);
      
      // Add click handler for equinox link
      const equinoxLink = item.querySelector('.equinox-link');
      if (equinoxLink) {
        equinoxLink.addEventListener('click', (e) => {
          e.preventDefault();
          jumpToEquinoxDate(nextEquinox);
        });
      }
    }
  }
  
  // Populate astronomical times in header (to the right of date info)
  const astroTimesContainer = panel.querySelector('.day-detail-astro-times');
  const astroTimes = getAstronomicalTimes(dayObj.gregorianDate);
  if (astroTimes) {
    astroTimesContainer.innerHTML = `
      <div class="astro-times-title">â˜€ï¸ Astronomical Times</div>
      <div class="astro-times-row">
        <div class="astro-times-group">
          <div class="astro-time"><span class="astro-label">Daybreak:</span> <span class="astro-value">${astroTimes.firstLight}</span></div>
          <div class="astro-time"><span class="astro-label">Sunrise:</span> <span class="astro-value">${astroTimes.sunrise}</span></div>
        </div>
        <div class="astro-times-group">
          <div class="astro-time"><span class="astro-label">Sunset:</span> <span class="astro-value">${astroTimes.sunset}</span></div>
          <div class="astro-time"><span class="astro-label">Twilight:</span> <span class="astro-value">${astroTimes.nauticalTwilight}</span></div>
        </div>
      </div>
    `;
  } else {
    astroTimesContainer.innerHTML = '';
  }
  
  // Populate additional info
  const infoContainer = panel.querySelector('.day-detail-info');
  let infoHtml = '';
  
  if (isSabbath(dayObj)) {
    const sabbathLabel = state.sabbathMode === 'lunar' ? 'Lunar Sabbath' : 
                         state.sabbathMode === 'saturday' ? 'Shabbat' :
                         state.sabbathMode === 'sunday' ? 'Lord\'s Day' :
                         state.sabbathMode === 'friday' ? 'Jumu\'ah' : 
                         'Rest Day';
    infoHtml += `<div class="day-detail-sabbath">ðŸ•¯ï¸ ${sabbathLabel}</div>`;
  }
  
  if (dayObj.moonPhase && dayObj.lunarDay !== 1) {
    infoHtml += `<div>Moon phase: ${dayObj.moonPhase}</div>`;
  }
  
  infoContainer.innerHTML = infoHtml;
  
  // Populate dateline visualization for Day 1
  const datelineContainer = panel.querySelector('.day-detail-dateline');
  if (dayObj.lunarDay === 1 && month.moonEvent) {
    const datelineHtml = renderDatelineVisualization(month.moonEvent);
    datelineContainer.innerHTML = datelineHtml;
  } else {
    datelineContainer.innerHTML = '';
  }
  
  // Populate profile comparison section (World Clock style)
  const compareContainer = panel.querySelector('.day-detail-profile-compare');
  const viewTime = getViewTime();
  const checkTimestamp = viewTime.getTime();
  
  const entries = getWorldClockEntries();
  
  if (entries.length > 0) {
    let compareHtml = `
      <div class="profile-compare-header">
        <span class="profile-compare-title">ðŸ“… This Moment on Other Calendars</span>
        <button class="world-clock-add-btn" onclick="showAddWorldClockModal()" title="Add Calendar">+</button>
      </div>`;
    compareHtml += `<div class="profile-compare-grid">`;
    
    let hasResults = false;
    entries.forEach((entry, index) => {
      const profile = PROFILES[entry.profileId] || PRESET_PROFILES[entry.profileId];
      if (!profile) return;
      
      // Create a temp profile with the entry's location
      const coords = CITY_SLUGS[entry.locationSlug];
      if (!coords) return;
      
      const tempProfile = {
        ...profile,
        lat: coords.lat,
        lon: coords.lon
      };
      
      const lunarDayInfo = getLunarDayForTimestamp(checkTimestamp, tempProfile);
      if (!lunarDayInfo) return;
      
      hasResults = true;
      
      // Check if this is the current view
      const currentLocSlug = getLocationSlug();
      const isCurrent = entry.profileId === (state.selectedProfile || 'timeTested') && 
                        entry.locationSlug === currentLocSlug;
      
      // Get feast icons for this lunar day/month
      const feastIcons = getFeastIconsForLunarDay(lunarDayInfo.month, lunarDayInfo.day);
      const feastHtml = feastIcons.length > 0 ? `<div class="profile-compare-feasts">${feastIcons.join('')}</div>` : '';
      
      // Get local time for this location
      const localTime = getLocalTimeForLocation(coords.lat, coords.lon);
      
      compareHtml += `
        <div class="profile-compare-item${isCurrent ? ' current' : ''}" onclick="navigateToWorldClockEntry('${entry.profileId}', '${entry.locationSlug}')">
          <button class="world-clock-remove-btn" onclick="event.stopPropagation(); removeWorldClockEntryAndRefresh(${index})" title="Remove">Ã—</button>
          <span class="profile-compare-name">${renderProfileIcon(profile)} ${profile.name}</span>
          <span class="profile-compare-day">Day ${lunarDayInfo.day} of Month ${lunarDayInfo.month}</span>
          <span class="profile-compare-location">${entry.locationName || formatCitySlug(entry.locationSlug)} Â· ${localTime}</span>
          ${feastHtml}
        </div>
      `;
    });
    
    compareHtml += `</div>`;
    
    if (hasResults) {
      compareContainer.innerHTML = compareHtml;
    } else {
      compareContainer.innerHTML = '';
    }
  } else {
    compareContainer.innerHTML = '';
  }
  
  // Show the panel (reset both inline style and class)
  panel.style.display = '';  // Reset any inline display:none from settings page
  panel.classList.remove('hidden');
}

function closeDayDetail() {
  document.getElementById('day-detail-panel').classList.add('hidden');
}

function getOrdinalSuffix(n) {
  const s = ['th', 'st', 'nd', 'rd'];
  const v = n % 100;
  return s[(v - 20) % 10] || s[v] || s[0];
}

// Jump to a specific equinox date and highlight that day
function jumpToEquinoxDate(equinoxDate) {
  const targetDate = new Date(equinoxDate);
  
  // Find this date in the current lunar months
  for (let m = 0; m < state.lunarMonths.length; m++) {
    const month = state.lunarMonths[m];
    for (let d = 0; d < month.days.length; d++) {
      const day = month.days[d];
      // Check if equinox falls on this day
      if (day.equinox && day.equinox.date.toDateString() === targetDate.toDateString()) {
        state.currentMonthIndex = m;
        state.highlightedLunarDay = day.lunarDay;
        state.selectedTimestamp = getSunriseTimestamp(day.gregorianDate);
        document.getElementById('goto-date').value = formatLocalDatetime(state.selectedTimestamp);
        renderMonth(state.lunarMonths[state.currentMonthIndex]);
        updateMonthButtons();
        updateURL();
        showDayDetail(day, month);
        return;
      }
    }
  }
  
  // If not found in current year's months, the equinox might be in a different year
  // Navigate to that year first
  const equinoxYear = targetDate.getFullYear();
  if (equinoxYear !== state.year) {
    state.year = equinoxYear;
    updateUI();
    generateCalendar();
    // Try again after regenerating
    jumpToEquinoxDate(equinoxDate);
  }
}

function jumpToToday() {
  const now = new Date();
  const utcTimestamp = now.getTime();
  
  // Get the current date at the selected location (based on longitude)
  // utcToLocalTime returns a Date where UTC methods give local time at location
  const localDateAtLocation = utcToLocalTime(utcTimestamp, state.lon);
  const targetYear = localDateAtLocation.getUTCFullYear();
  const targetMonth = localDateAtLocation.getUTCMonth();
  const targetDay = localDateAtLocation.getUTCDate();
  
  // Update goto-date input with local time at selected location
  document.getElementById('goto-date').value = formatLocalDatetime(utcTimestamp);
  
  // Determine which lunar year today belongs to
  // Use UTC comparison - the calendar builds months based on UTC moon events
  const springEquinox = getAstroEngine().getSeasons(targetYear).mar_equinox.date;
  const lunarYear = utcTimestamp < springEquinox.getTime() ? targetYear - 1 : targetYear;
  
  // Update state year (keep other settings from localStorage)
  state.year = lunarYear;
  
  // Update UI with all state (including saved location/moon phase settings)
  updateUI();
  
  // Generate calendar for today's lunar year
  generateCalendar();
  
  // Find today in the generated months
  // Calendar dates are stored as browser-local Date objects but represent the date at the location
  for (let m = 0; m < state.lunarMonths.length; m++) {
    const month = state.lunarMonths[m];
    for (let d = 0; d < month.days.length; d++) {
      const day = month.days[d];
      const gd = day.gregorianDate;
      // Compare year/month/day - both represent the date at the observer's location
      if (gd.getFullYear() === targetYear && 
          gd.getMonth() === targetMonth && 
          gd.getDate() === targetDay) {
        state.currentMonthIndex = m;
        state.highlightedLunarDay = day.lunarDay;
        state.selectedTimestamp = utcTimestamp;
        renderMonth(state.lunarMonths[m]);
        updateMonthButtons();
        showDayDetail(day, month);
        return;
      }
    }
  }
  
  // Fallback: if today not found, just show first month
  state.currentMonthIndex = 0;
  renderMonth(state.lunarMonths[0]);
  updateMonthButtons();
}

// Open ICS directly in calendar app
async function openInCalendar() {
  const icsContent = generateICSContent();
  if (!icsContent) return;
  
  const filename = `lunar-sabbath-calendar-${state.year}.ics`;
  const blob = new Blob([icsContent], { type: 'text/calendar' });
  const file = new File([blob], filename, { type: 'text/calendar' });
  
  // Try Web Share API first (works great on mobile and some desktop)
  if (navigator.share && navigator.canShare && navigator.canShare({ files: [file] })) {
    try {
      await navigator.share({
        files: [file],
        title: 'Lunar Sabbath Calendar',
        text: `Sabbaths and Feasts for ${formatYear(state.year)}`
      });
      return;
    } catch (err) {
      if (err.name !== 'AbortError') {
        console.log('Share failed, falling back to download');
      } else {
        return; // User cancelled
      }
    }
  }
  
  // Fallback: Download the file
  exportToICS();
  
  // Close the export modal after successful download
  const exportPage = document.getElementById('export-page');
  if (exportPage && exportPage.style.display !== 'none') {
    toggleExportModal();
  }
}

// Generate ICS content for calendar export
function generateICSContent() {
  if (!state.lunarMonths || state.lunarMonths.length === 0) {
    alert('Please generate a calendar first');
    return null;
  }
  
  const events = [];
  const yearLabel = formatYear(state.year);
  
  // Collect all Sabbaths and Feasts
  for (const month of state.lunarMonths) {
    for (const day of month.days) {
      // Add Sabbaths
      if (isSabbath(day)) {
        const sabbathLabel = state.sabbathMode === 'lunar' ? 'Lunar Sabbath' : 
                             state.sabbathMode === 'saturday' ? 'Shabbat' :
                             state.sabbathMode === 'sunday' ? 'Lord\'s Day' :
                             state.sabbathMode === 'friday' ? 'Jumu\'ah' : 
                             'Rest Day';
        events.push({
          date: day.gregorianDate,
          title: `${sabbathLabel} (${MONTH_NAMES[month.monthNumber - 1]} ${day.lunarDay})`,
          description: `${sabbathLabel} - Day ${day.lunarDay} of ${MONTH_NAMES[month.monthNumber - 1]}`,
          allDay: true
        });
      }
      
      // Add Feasts
      if (day.feast) {
        let title = day.feast.name;
        if (day.feastDayNum) {
          title += ` Day ${day.feastDayNum}`;
        }
        events.push({
          date: day.gregorianDate,
          title: title,
          description: day.feast.description + ` (${MONTH_NAMES[month.monthNumber - 1]} ${day.lunarDay})`,
          allDay: true
        });
      }
      
      // Add New Moon days
      if (day.isNewMoon) {
        events.push({
          date: day.gregorianDate,
          title: `New Moon - ${MONTH_NAMES[month.monthNumber - 1]}`,
          description: `Start of ${MONTH_NAMES[month.monthNumber - 1]} (Lunar Month ${month.monthNumber})`,
          allDay: true
        });
      }
    }
  }
  
  // Sort events by date
  events.sort((a, b) => a.date.getTime() - b.date.getTime());
  
  // Generate ICS content
  let ics = [
    'BEGIN:VCALENDAR',
    'VERSION:2.0',
    'PRODID:-//LunarSabbath.net//Lunar Sabbath Calendar//EN',
    'CALSCALE:GREGORIAN',
    'METHOD:PUBLISH',
    `X-WR-CALNAME:Lunar Sabbath Calendar ${yearLabel}`
  ];
  
  for (const event of events) {
    const dateStr = formatICSDate(event.date);
    const uid = `${dateStr}-${event.title.replace(/\s+/g, '-')}@lunarsabbath.net`;
    
    ics.push('BEGIN:VEVENT');
    ics.push(`UID:${uid}`);
    ics.push(`DTSTART;VALUE=DATE:${dateStr}`);
    ics.push(`DTEND;VALUE=DATE:${dateStr}`);
    ics.push(`SUMMARY:${escapeICS(event.title)}`);
    ics.push(`DESCRIPTION:${escapeICS(event.description)}`);
    ics.push('END:VEVENT');
  }
  
  ics.push('END:VCALENDAR');
  
  return ics.join('\r\n');
}

// Export Sabbaths and Feasts to ICS file for calendar import
function exportToICS() {
  const icsContent = generateICSContent();
  if (!icsContent) return;
  
  // Download the file
  const blob = new Blob([icsContent], { type: 'text/calendar;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = `lunar-sabbath-calendar-${state.year}.ics`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

function formatICSDate(date) {
  const year = date.getFullYear();
  const month = (date.getMonth() + 1).toString().padStart(2, '0');
  const day = date.getDate().toString().padStart(2, '0');
  return `${year}${month}${day}`;
}

function escapeICS(text) {
  // Escape special characters for ICS format
  return text
    .replace(/\\/g, '\\\\')
    .replace(/;/g, '\\;')
    .replace(/,/g, '\\,')
    .replace(/\n/g, '\\n');
}

// Register Service Worker for PWA functionality
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js')
      .then((registration) => {
        console.log('ServiceWorker registered:', registration.scope);
      })
      .catch((error) => {
        console.log('ServiceWorker registration failed:', error);
      });
  });
}

// Track book PDF download with GoatCounter
function trackBookDownload() {
  if (typeof goatcounter !== 'undefined' && goatcounter.count) {
    goatcounter.count({
      path: '/download/book-pdf',
      title: 'Book PDF Download',
      event: true
    });
  }
}
</script>

<!-- GoatCounter Analytics -->
<script data-goatcounter="https://lunarsabbath.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
</body>
</html>

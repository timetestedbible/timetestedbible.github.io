---
layout: null
title: "Lunar Sabbath Calendar"
---
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#1a3a5c">
  <meta name="description" content="A time-tested lunar calendar for tracking Sabbaths and appointed times">
  <title>{{ page.title }}</title>
  <link rel="icon" type="image/svg+xml" href="/icons/icon.svg">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/icon-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/icon-16.png">
  <link rel="manifest" href="/manifest.json">
  <link rel="apple-touch-icon" href="/icons/icon-192.png">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #1a3a5c;
      min-height: 100vh;
    }

* {
  box-sizing: border-box;
}

.calendar-app {
  max-width: 900px;
  margin: 0 auto;
  padding: 8px;
  font-family: 'Georgia', serif;
  min-height: 100vh;
}

.calendar-controls {
  display: flex;
  flex-wrap: wrap;
  gap: 15px;
  margin-bottom: 20px;
  padding: 15px;
  background: #1a3a5c;
  border-radius: 8px;
  color: white;
}

.control-group {
  display: flex;
  flex-direction: column;
  gap: 5px;
}

.control-group label {
  font-size: 0.85em;
  opacity: 0.9;
}

.control-group input, .control-group select {
  padding: 8px 12px;
  border: none;
  border-radius: 4px;
  font-size: 1em;
}

.btn {
  padding: 10px 20px;
  background: #d4a017;
  color: #1a3a5c;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-weight: bold;
  align-self: flex-end;
}

.btn:hover {
  background: #e8b830;
}

/* Month Calendar Container */
.month-calendar {
  background: linear-gradient(180deg, #1a3a5c 0%, #2a5a8c 100%);
  overflow: hidden;
  margin-bottom: 0;
  border-radius: 12px;
}

/* Header Section */
.calendar-header {
  display: grid;
  grid-template-columns: 1fr auto;
  padding: 0;
  background: linear-gradient(180deg, #0d2840 0%, #1a3a5c 100%);
  color: white;
  align-items: stretch;
  gap: 0;
  width: 100%;
  overflow: hidden;
}

.header-left {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 10px 15px;
  min-width: 0;
  overflow: hidden;
}

.calendar-title {
  text-align: left;
  padding: 5px 10px;
  flex: 1;
}

.calendar-title .site-title {
  font-size: 1.6em;
  color: #7ec8e3;
  font-weight: bold;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
  margin-bottom: 2px;
}

.calendar-title .site-tagline .book-link {
  text-decoration: none;
  font-size: 1.1em;
  margin-left: 6px;
  opacity: 0.8;
  transition: opacity 0.2s;
}

.calendar-title .site-tagline .book-link:hover {
  opacity: 1;
}

.calendar-title .site-tagline {
  font-size: 0.85em;
  color: #d4a017;
  font-style: italic;
  margin-bottom: 4px;
}

.calendar-title .month-year-row {
  display: flex;
  align-items: baseline;
  gap: 10px;
  cursor: pointer;
  padding: 4px 8px;
  margin: -4px -8px;
  border-radius: 6px;
  transition: background 0.2s;
}

.calendar-title .month-year-row:hover {
  background: rgba(255,255,255,0.1);
}

.calendar-title .month-name {
  font-size: 1.1em;
  color: #d4a017;
  display: flex;
  align-items: center;
  gap: 6px;
}

.calendar-title .dropdown-arrow {
  font-size: 0.6em;
  opacity: 0.7;
}

.calendar-title .year {
  font-size: 1.4em;
  color: #7ec8e3;
  font-weight: bold;
}

/* Month Picker Popup */
.month-picker-overlay {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0,0,0,0.5);
  z-index: 1000;
}

.month-picker-overlay.open {
  display: block;
}

.month-picker {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: #1a3a5c;
  border-radius: 20px;
  padding: 28px;
  z-index: 1001;
  width: 70%;
  max-width: 630px;
  box-shadow: 0 10px 40px rgba(0,0,0,0.5);
}

.month-picker-header {
  display: flex;
  justify-content: center;
  align-items: center;
  margin-bottom: 24px;
  padding-bottom: 16px;
  border-bottom: 1px solid rgba(255,255,255,0.2);
  position: relative;
}

.month-picker-header h3 {
  margin: 0;
  color: #7ec8e3;
  font-size: 1.5em;
}

.month-picker .close-btn {
  position: absolute;
  top: -8px;
  right: -8px;
  background: rgba(255,255,255,0.1);
  border: none;
  color: #fff;
  font-size: 1.3em;
  cursor: pointer;
  padding: 12px 16px;
  line-height: 1;
  border-radius: 10px;
  min-width: 48px;
  min-height: 48px;
}

.month-picker .close-btn:hover {
  background: rgba(255,255,255,0.2);
}

.year-nav {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 20px;
  margin-bottom: 20px;
}

.year-nav button {
  background: #0d2840;
  border: none;
  color: #d4a017;
  padding: 16px 24px;
  border-radius: 12px;
  cursor: pointer;
  font-size: 1.5em;
  min-width: 58px;
  min-height: 58px;
}

.year-nav button:hover {
  background: #2a5a8c;
}

.year-nav .year-display {
  color: #fff;
  font-size: 1.5em;
  font-weight: bold;
  min-width: 130px;
  text-align: center;
}

.month-grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 12px;
}

.month-grid button {
  background: #0d2840;
  border: none;
  color: #fff;
  padding: 18px 10px;
  border-radius: 12px;
  cursor: pointer;
  font-size: 1.1em;
  transition: all 0.2s;
  min-height: 58px;
}

.month-grid button:hover {
  background: #2a5a8c;
}

.month-grid button.active {
  background: #d4a017;
  color: #1a3a5c;
  font-weight: bold;
}

.month-grid button.disabled {
  opacity: 0.3;
  cursor: not-allowed;
}

/* Date Jump Popup */
.date-jump-overlay {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0,0,0,0.5);
  z-index: 1000;
}

.date-jump-overlay.open {
  display: block;
}

.date-jump-popup {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: #1a3a5c;
  border-radius: 20px;
  padding: 28px;
  z-index: 1001;
  width: 70%;
  max-width: 630px;
  box-shadow: 0 10px 40px rgba(0,0,0,0.5);
}

.date-jump-popup h3 {
  margin: 0 0 24px 0;
  color: #7ec8e3;
  font-size: 1.5em;
  text-align: center;
}

.date-jump-popup .close-btn {
  position: absolute;
  top: 16px;
  right: 16px;
  background: rgba(255,255,255,0.1);
  border: none;
  color: #fff;
  font-size: 1.3em;
  cursor: pointer;
  padding: 12px 16px;
  line-height: 1;
  border-radius: 10px;
  min-width: 48px;
  min-height: 48px;
}

.date-jump-popup .close-btn:hover {
  background: rgba(255,255,255,0.2);
}

.date-jump-popup input {
  width: 100%;
  padding: 18px;
  border: none;
  border-radius: 12px;
  background: #0d2840;
  color: #fff;
  font-size: 1.2em;
  margin-bottom: 20px;
  box-sizing: border-box;
  min-height: 60px;
}

.date-jump-popup .btn-row {
  display: flex;
  gap: 14px;
  margin-bottom: 24px;
}

.date-jump-popup .btn {
  flex: 1;
  padding: 18px;
  background: #d4a017;
  color: #1a3a5c;
  border: none;
  border-radius: 12px;
  cursor: pointer;
  font-weight: bold;
  font-size: 1.2em;
  min-height: 60px;
}

.date-jump-popup .btn:hover {
  background: #e5b328;
}

.date-jump-popup .btn.secondary {
  background: #2a5a8c;
  color: #fff;
}

.date-jump-popup .btn.secondary:hover {
  background: #3a6a9c;
}

.days-jump {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 12px;
  padding-top: 20px;
  margin-top: 8px;
  border-top: 1px solid rgba(255,255,255,0.2);
}

.days-jump input {
  width: 100px;
  text-align: center;
  margin-bottom: 0;
  min-height: 58px;
  font-size: 1.3em;
  border-radius: 12px;
}

.days-jump button {
  background: #0d2840;
  border: none;
  color: #d4a017;
  padding: 16px 24px;
  border-radius: 12px;
  cursor: pointer;
  font-size: 1.5em;
  min-height: 58px;
  min-width: 58px;
}

.days-jump button:hover {
  background: #2a5a8c;
}

.days-jump span {
  color: #ccc;
  font-size: 1.2em;
  margin-left: 4px;
}

/* Old jump button styles removed - button is now in day detail header */

.full-moon-info {
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  border-radius: 10px;
  padding: 6px;
  transition: background 0.2s;
}

.full-moon-info:hover {
  background: rgba(255,255,255,0.1);
}

.full-moon-info .moon-icon {
  font-size: 68px;
  line-height: 1;
}

.moon-icon-wrapper {
  position: relative;
  display: inline-block;
}

.moon-gear-badge {
  position: absolute;
  bottom: -4px;
  right: -2px;
  font-size: 22px;
  color: #7ec8e3;
  opacity: 0.7;
  text-shadow: 0 1px 2px rgba(0,0,0,0.5);
}

.full-moon-info:hover .moon-gear-badge {
  opacity: 1;
}

/* Export button in header - prominent desktop icon style */
.export-header-btn {
  background: none;
  border: none;
  cursor: pointer;
  padding: 10px 14px;
  border-radius: 12px;
  transition: all 0.2s;
  margin-left: 10px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.export-header-btn .icon {
  font-size: 48px;
  line-height: 1;
}

.export-header-btn .label {
  font-size: 13px;
  color: #d4a017;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.export-header-btn:hover {
  background: rgba(255,255,255,0.1);
  transform: scale(1.05);
}

.export-header-btn:hover .label {
  color: #f0c040;
}

.export-header-btn:active {
  transform: scale(0.98);
}

/* Export/Feasts page specific styles */
#export-page {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  min-height: 100vh;
  z-index: 100;
}

#export-page .settings-page-header {
  position: sticky;
  top: 0;
  z-index: 10;
}

#export-page .export-header {
  flex-wrap: wrap;
  gap: 10px;
}

.export-branding {
  flex: 1;
  text-align: center;
  min-width: 200px;
}

.export-site-title {
  font-size: 1.4em;
  color: #7ec8e3;
  font-weight: bold;
}

.export-page-title {
  font-size: 1em;
  color: #d4a017;
  margin-top: 2px;
}

#export-page .export-download-btn {
  padding: 8px 16px;
  font-size: 0.95em;
  white-space: nowrap;
}

.export-settings-context {
  background: rgba(0,0,0,0.3);
  padding: 12px 20px;
  font-size: 0.9em;
  color: #ccc;
  border-bottom: 1px solid rgba(255,255,255,0.1);
}

.export-settings-context span {
  display: flex;
  flex-wrap: wrap;
  gap: 8px 20px;
  justify-content: center;
}

.export-context-item {
  display: inline-flex;
  align-items: center;
  gap: 5px;
}

.export-context-label {
  color: #888;
}

.export-context-value {
  color: #d4a017;
  font-weight: 500;
}

/* Dateline Visualization */
.dateline-container {
  margin-top: 20px;
  padding: 15px;
  background: rgba(0,0,0,0.2);
  border-radius: 8px;
  width: 100%;
}

.dateline-label {
  font-size: 0.7em;
  color: #7ec8e3;
  margin-bottom: 5px;
}

.dateline-map {
  position: relative;
  aspect-ratio: 2 / 1;
  background: #1a3a5c;
  border-radius: 8px;
  overflow: hidden;
  cursor: crosshair;
}

.dateline-map-bg {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  /* Fallback gradient if image fails */
  background: linear-gradient(to bottom, 
    #1a4a6e 0%, 
    #2d6a4f 20%, 
    #2d6a4f 40%,
    #1a4a6e 50%,
    #2d6a4f 60%,
    #1a4a6e 100%);
}

.dateline-map-bg img {
  width: 100%;
  height: 100%;
  object-fit: fill;
  opacity: 0.85;
}

.dateline-location-marker {
  position: absolute;
  width: 12px;
  height: 12px;
  background: #00ff00;
  border: 2px solid #fff;
  border-radius: 50%;
  transform: translate(-50%, -50%);
  box-shadow: 0 0 10px rgba(0,255,0,0.8);
  z-index: 5;
  pointer-events: none;
}

.dateline-click-hint {
  font-size: 0.6em;
  color: #7ec8e3;
  text-align: center;
  margin-top: 3px;
  font-style: italic;
}

.dateline-marker {
  position: absolute;
  top: 0;
  bottom: 0;
  width: 3px;
  background: linear-gradient(to bottom, #ffcc00, #ff6b6b);
  box-shadow: 0 0 15px rgba(255,107,107,0.8), 0 0 30px rgba(255,204,0,0.5);
  z-index: 10;
  pointer-events: none;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: space-between;
}

.dateline-marker-icon {
  position: absolute;
  top: 5px;
  left: 50%;
  transform: translateX(-50%);
  color: #ffcc00;
  font-size: 18px;
  text-shadow: 0 0 10px rgba(255,204,0,0.8);
}

.dateline-marker-label {
  position: absolute;
  bottom: 5px;
  left: 50%;
  transform: translateX(-50%);
  color: #ffcc00;
  font-size: 8px;
  font-weight: bold;
  text-shadow: 0 0 5px rgba(0,0,0,0.8);
  white-space: nowrap;
}

.dateline-cities {
  display: flex;
  justify-content: space-between;
  font-size: 0.65em;
  color: #7ec8e3;
  margin-top: 5px;
  padding: 0 5px;
}

.dateline-info {
  font-size: 0.65em;
  color: #d4a017;
  margin-top: 5px;
}


/* Day 1 in header - inherits from .day-cell */
.new-moon-box {
  aspect-ratio: unset;
  min-height: 80px;
  width: calc((min(100vw, 900px) - 16px) / 7);
  box-sizing: border-box;
  overflow: hidden;
  flex-shrink: 0;
}

.new-moon-box .gregorian {
  flex-direction: row;
  gap: 4px;
  white-space: nowrap;
}

.new-moon-box .gregorian .day-year {
  font-size: 0.85em;
}

/* Week Header */
.week-header {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  background: #1a3a5c;
  border-top: 2px solid #2a5a8c;
  border-bottom: 2px solid #2a5a8c;
}

.week-header .day-label {
  padding: 10px 5px;
  text-align: center;
  color: white;
  font-size: 0.85em;
  border-right: 1px solid #2a5a8c;
}

.week-header .day-label:last-child {
  border-right: none;
  background: #d4a017;
  color: #1a3a5c;
  font-weight: bold;
}

.week-header .day-label .day-name {
  font-weight: bold;
}

.week-header .day-label .weekday {
  font-size: 0.9em;
  opacity: 0.8;
}

/* Calendar Grid */
.calendar-grid {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  grid-template-rows: repeat(5, 1fr);
  background: #2a5a8c;
  aspect-ratio: 7 / 5;
}

.day-cell {
  aspect-ratio: 1;
  min-height: 70px;
  padding: 5px;
  background: #3a6a9c;
  border: 1px solid #2a5a8c;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  position: relative;
  color: white;
  cursor: pointer;
}

.day-cell:not(.empty):hover {
  background: #4a7aac;
}

.day-cell.empty {
  background: #2a5a8c;
}

.day-cell.quote-row-spacer {
  background: #0d2840;
}

.day-cell .gregorian {
  font-size: 1em;
  color: #fff;
  position: absolute;
  top: 5px;
  left: 5px;
  font-weight: 600;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
  display: flex;
  flex-direction: column;
  line-height: 1.2;
}

.day-cell .gregorian .day-year {
  font-size: 0.75em;
  color: #7ec8e3;
  font-weight: normal;
}

.day-cell .lunar-day {
  font-size: 2em;
  font-weight: bold;
  color: #e8e8e8;
}

.day-cell .moon-phase {
  font-size: 1.2em;
  position: absolute;
  top: 5px;
  right: 5px;
}

/* Sabbath Days */
.day-cell.sabbath {
  background: linear-gradient(135deg, #3a6a9c 0%, #2a5a8c 100%);
}

.day-cell.sabbath .lunar-day {
  color: #d4a017;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
}

/* New Moon Day */
.day-cell.new-moon {
  background: linear-gradient(135deg, #1a4a7c 0%, #2a5a8c 100%);
}

.day-cell.new-moon .lunar-day {
  color: #7ec8e3;
}

/* Highlighted/Selected Day */
.day-cell.highlighted {
  box-shadow: inset 0 0 0 3px #ff6b6b, 0 0 10px #ff6b6b;
  animation: pulse 1.5s ease-in-out 3;
}

@keyframes pulse {
  0%, 100% { box-shadow: inset 0 0 0 3px #ff6b6b, 0 0 10px #ff6b6b; }
  50% { box-shadow: inset 0 0 0 3px #ff6b6b, 0 0 20px #ff6b6b; }
}

.day-cell .feast-icons {
  font-size: 1em;
  position: absolute;
  bottom: 2px;
  right: 3px;
  text-align: right;
  line-height: 1;
  letter-spacing: 0.15em;
  line-height: 1.2;
  font-weight: bold;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
}

/* Scripture Quote - integrated into last row */
.scripture-quote {
  padding: 10px 15px;
  text-align: center;
  color: #d4a017;
  font-style: italic;
  background: #0d2840;
  font-size: 0.85em;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
}

.scripture-quote.span-4 {
  grid-column: span 4;
}

/* Month navigation cells in last row */
.month-nav-cell {
  background: #0d2840;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: background 0.2s;
}

.month-nav-cell:hover:not(.disabled) {
  background: #1a3a5c;
}

.month-nav-cell.disabled {
  cursor: default;
  opacity: 0.3;
}

.month-nav-cell .nav-arrow {
  color: #d4a017;
  font-size: 1.5em;
}

.scripture-quote .reference {
  color: #7ec8e3;
  font-style: normal;
  margin-left: 10px;
}

/* Settings Dialog */
/* Old settings overlay - now hidden, replaced by settings page */
.settings-overlay {
  display: none !important;
}

.settings-overlay.open {
  display: none !important;
}

/* Old settings dialog - now hidden, replaced by settings page */
.settings-dialog {
  display: none !important;
}

.settings-dialog.open {
  display: none !important;
}

.settings-header {
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 20px 24px 16px;
  color: white;
  border-bottom: 1px solid rgba(255,255,255,0.2);
  position: relative;
}

.settings-header h3 {
  margin: 0;
  font-size: 1.4em;
  color: #7ec8e3;
}

.settings-dialog .close-btn {
  position: absolute;
  top: 12px;
  right: 12px;
  background: rgba(255,255,255,0.1);
  border: none;
  color: white;
  font-size: 1.2em;
  cursor: pointer;
  padding: 12px 16px;
  line-height: 1;
  border-radius: 10px;
  min-width: 48px;
  min-height: 48px;
}

.settings-dialog .close-btn:hover {
  background: rgba(255,255,255,0.2);
}

.settings-content {
  padding: 24px;
}

.setting-group {
  margin-bottom: 24px;
}

.setting-group label {
  display: block;
  font-weight: bold;
  margin-bottom: 12px;
  color: #7ec8e3;
  font-size: 1.1em;
}

.setting-group select,
.setting-group input {
  width: 100%;
  padding: 16px;
  border: none;
  border-radius: 12px;
  font-size: 1.1em;
  box-sizing: border-box;
  background: #0d2840;
  color: #fff;
  min-height: 54px;
}

.city-select-styled {
  margin-top: 12px;
}

.setting-info {
  font-size: 0.95em;
  color: #aaa;
  padding-top: 16px;
  border-top: 1px solid rgba(255,255,255,0.2);
  text-align: center;
}

/* Moon Phase Buttons */
.moon-phase-buttons {
  display: flex;
  gap: 12px;
}

.moon-phase-btn {
  flex: 1;
  background: #0d2840;
  border: 3px solid transparent;
  border-radius: 14px;
  padding: 16px 10px;
  cursor: pointer;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  transition: all 0.2s;
  min-height: 90px;
}

.moon-phase-btn:hover {
  background: #2a5a8c;
}

.moon-phase-btn.active {
  border-color: #d4a017;
  background: #2a5a8c;
}

.moon-phase-btn .phase-icon {
  font-size: 2em;
}

.moon-phase-btn .phase-name {
  color: #fff;
  font-size: 0.85em;
  font-weight: bold;
}

/* Settings Map */
#settings-map-container {
  margin-bottom: 12px;
}

#settings-map-container .dateline-container {
  margin-top: 0;
  padding: 12px;
}


.location-btn {
  width: 100%;
  padding: 16px;
  background: #2a5a8c;
  color: #fff;
  border: none;
  border-radius: 12px;
  font-size: 1.1em;
  cursor: pointer;
  margin-top: 12px;
  min-height: 54px;
}

.location-btn:hover {
  background: #3a6a9c;
}

.location-btn {
  width: 100%;
  padding: 12px;
  background: #2a5a8c;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 1em;
  margin-bottom: 15px;
}

.location-btn:hover {
  background: #1a3a5c;
}

.location-btn:disabled {
  background: #ccc;
  cursor: not-allowed;
}


/* Month Navigation */
.month-nav {
  display: flex;
  justify-content: center;
  align-items: center;
  margin-bottom: 20px;
}

.month-buttons {
  display: flex;
  flex-wrap: nowrap;
  gap: 4px;
  justify-content: center;
  align-items: center;
  width: 100%;
}

.month-btn {
  flex: 1;
  min-width: 0;
  height: 40px;
  padding: 0;
  background: #1a3a5c;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 1em;
  font-weight: bold;
  transition: all 0.2s;
}

/* 13th month button with calendar icon overlay */
.month-btn.month-13 {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
}

.month-13-icon {
  font-size: 1.2em;
  position: relative;
}

.month-13-num {
  position: absolute;
  font-size: 0.6em;
  font-weight: bold;
  color: #1a3a5c;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -35%);
  text-shadow: 0 0 2px white, 0 0 2px white;
}

.month-btn:hover {
  background: #2a5a8c;
  transform: scale(1.05);
}

.month-btn.active {
  background: #d4a017;
  color: #1a3a5c;
}

.month-btn.disabled {
  opacity: 0.3;
  cursor: not-allowed;
}

/* Settings Page - Full Width */
.settings-page {
  background: linear-gradient(180deg, #1a3a5c 0%, #2a5a8c 100%);
  border-radius: 12px;
  overflow: hidden;
  margin-bottom: 20px;
}

.settings-page-header {
  display: flex;
  align-items: center;
  gap: 15px;
  padding: 15px 20px;
  background: linear-gradient(180deg, #0d2840 0%, #1a3a5c 100%);
  border-bottom: 2px solid #d4a017;
}

.settings-page-header h2 {
  margin: 0;
  color: #d4a017;
  font-size: 1.4em;
  flex: 1;
}

.settings-page-header .back-btn {
  background: rgba(255,255,255,0.1);
  border: none;
  color: #7ec8e3;
  font-size: 1em;
  padding: 10px 16px;
  border-radius: 8px;
  cursor: pointer;
}

.settings-page-header .back-btn:hover {
  background: rgba(255,255,255,0.2);
}

.settings-page-header .defaults-btn {
  background: rgba(255,255,255,0.1);
  border: none;
  color: #ccc;
  font-size: 0.9em;
  padding: 8px 14px;
  border-radius: 8px;
  cursor: pointer;
}

.settings-page-header .defaults-btn:hover {
  background: rgba(255,255,255,0.2);
  color: white;
}

.settings-section {
  padding: 20px;
  border-bottom: 1px solid rgba(255,255,255,0.1);
}

.settings-section:last-child {
  border-bottom: none;
}

.settings-section h3 {
  margin: 0 0 8px 0;
  color: #7ec8e3;
  font-size: 1.2em;
}

.settings-description {
  margin: 0 0 15px 0;
  color: rgba(255,255,255,0.7);
  font-size: 0.9em;
}

.settings-options {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
}

.settings-option-btn {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  padding: 15px 20px;
  background: rgba(255,255,255,0.1);
  border: 2px solid transparent;
  border-radius: 12px;
  color: white;
  cursor: pointer;
  flex: 1;
  min-width: 90px;
  transition: all 0.2s;
}

.settings-option-btn:hover {
  background: rgba(255,255,255,0.15);
}

.settings-option-btn.selected {
  border-color: #d4a017;
  background: rgba(212, 160, 23, 0.2);
}

.settings-option-btn .option-icon {
  font-size: 2.5em;
}

/* Moon phase icons in Month Starts section - extra large */
.settings-option-btn[data-phase] .option-icon {
  font-size: 3.5em;
}

.settings-option-btn .option-label {
  font-size: 0.85em;
  font-weight: 500;
}

.settings-option-btn .option-hint {
  font-size: 0.75em;
  opacity: 0.7;
  font-weight: normal;
}

#settings-page-map {
  margin-bottom: 15px;
}

#settings-page-map .dateline-container {
  margin-top: 0;
  padding: 12px;
  background: rgba(0,0,0,0.2);
  border-radius: 10px;
}

.settings-select {
  width: 100%;
  padding: 14px 16px;
  font-size: 1.1em;
  border: none;
  border-radius: 10px;
  background: rgba(255,255,255,0.1);
  color: white;
  cursor: pointer;
  margin-bottom: 12px;
}

.settings-select option,
.settings-select optgroup {
  background: #1a3a5c;
  color: white;
}

.settings-custom-coords {
  display: flex;
  gap: 10px;
  margin-bottom: 12px;
}

.settings-custom-coords input {
  flex: 1;
  padding: 12px 14px;
  font-size: 1em;
  border: none;
  border-radius: 8px;
  background: rgba(255,255,255,0.1);
  color: white;
}

.settings-custom-coords input::placeholder {
  color: rgba(255,255,255,0.5);
}

/* Day Detail Panel */
.day-detail-panel {
  background: linear-gradient(180deg, #0d2840 0%, #1a3a5c 100%);
  border-top: 3px solid #d4a017;
  padding: 15px 20px;
  margin-top: 0;
}

.day-detail-panel.hidden {
  display: none;
}

.day-detail-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
}

.day-detail-date {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.day-detail-lunar {
  font-size: 1.4em;
  font-weight: bold;
  color: #d4a017;
}

.day-detail-gregorian {
  font-size: 1em;
  color: #7ec8e3;
}

.day-detail-gregorian-row {
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.day-detail-jump-btn {
  background: #d4a017;
  border: none;
  color: #1a3a5c;
  font-size: 1em;
  font-weight: bold;
  cursor: pointer;
  padding: 4px 10px;
  border-radius: 4px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  line-height: 1;
  transition: all 0.2s;
  white-space: nowrap;
  flex-shrink: 0;
}

.day-detail-jump-btn:hover {
  background: #e5b328;
  transform: scale(1.1);
}

.day-detail-content {
  color: #fff;
}

.day-detail-feasts {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.day-detail-feast-item {
  display: flex;
  align-items: flex-start;
  gap: 12px;
  padding: 10px 12px;
  background: rgba(42, 90, 140, 0.5);
  border-radius: 8px;
  border-left: 3px solid #28a745;
}

.day-detail-feast-icon {
  font-size: 1.5em;
  line-height: 1;
}

.day-detail-feast-info {
  flex: 1;
}

.day-detail-feast-name {
  font-weight: bold;
  color: #90ee90;
  font-size: 1.1em;
  margin-bottom: 4px;
}

.day-detail-feast-desc {
  color: #ccc;
  font-size: 0.95em;
  line-height: 1.4;
}

.day-detail-feast-link {
  display: inline-block;
  margin-top: 6px;
  color: #7ec8e3;
  text-decoration: none;
  font-size: 0.9em;
}

.day-detail-feast-link:hover {
  text-decoration: underline;
}

.equinox-link {
  color: #d4a017;
  text-decoration: none;
  font-weight: bold;
  cursor: pointer;
}

.equinox-link:hover {
  text-decoration: underline;
  color: #f0c040;
}

.day-detail-info {
  margin-top: 12px;
  padding-top: 12px;
  border-top: 1px solid rgba(126, 200, 227, 0.3);
  color: #aaa;
  font-size: 0.9em;
}

.feast-basis {
  margin-top: 8px;
  padding: 8px 10px;
  background: rgba(0, 0, 0, 0.2);
  border-radius: 4px;
  font-size: 0.9em;
  color: #aaa;
  line-height: 1.5;
}

.feast-basis strong {
  color: #d4a017;
}

.day-detail-sabbath {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  color: #d4a017;
  font-weight: bold;
  margin-bottom: 8px;
}

.day-detail-no-feast {
  color: #888;
  font-style: italic;
  padding: 10px 0;
}

/* Feast Table */
.feast-list {
  margin-top: 30px;
  padding: 0 10px;
}

.feast-list h3 {
  color: #1a3a5c;
  margin-bottom: 15px;
}

.feast-table {
  width: 100%;
  border-collapse: collapse;
  background: white;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  border-radius: 8px;
  overflow: hidden;
}

.feast-table th {
  background: #1a3a5c;
  color: white;
  padding: 12px;
  text-align: left;
}

.feast-table td {
  padding: 12px;
  border-bottom: 1px solid #eee;
}

.feast-table tr:hover {
  background: #f8f9fa;
}

.feast-table .feast-jump {
  cursor: pointer;
}

.feast-table .feast-jump:hover {
  text-decoration: underline !important;
}

.feast-table td a {
  display: block;
}

.info-box {
  background: #e7f3ff;
  border-left: 4px solid #1a3a5c;
  padding: 15px;
  margin: 20px 0;
  font-size: 0.95em;
  border-radius: 0 8px 8px 0;
}

@media (max-width: 768px) {
  .calendar-app {
    max-width: 100%;
    padding: 0;
  }
  
  .month-calendar,
  .settings-page {
    border-radius: 0;
  }
  
  .settings-dialog,
  .month-picker,
  .date-jump-popup {
    width: calc(100% - 16px);
    max-width: none;
  }
  
  .settings-page-header {
    padding: 12px 15px;
  }
  
  .settings-section {
    padding: 15px;
  }
  
  .settings-option-btn {
    padding: 12px 15px;
  }
  
  .settings-option-btn .option-icon {
    font-size: 2em;
  }
  
  .settings-option-btn[data-phase] .option-icon {
    font-size: 2.8em;
  }
  
  .calendar-controls {
    flex-direction: column;
    gap: 10px;
    padding: 10px;
  }
  
  .control-group {
    width: 100%;
  }
  
  .control-group input,
  .control-group select {
    width: 100%;
    min-height: 44px; /* Touch-friendly */
  }
  
  .btn {
    min-height: 44px;
    font-size: 1em;
    flex: 1;
  }
  
  .control-group div[style*="display: flex"] {
    width: 100%;
  }
  
  
  .month-buttons {
    gap: 3px;
  }
  
  .month-btn {
    min-height: 36px;
    padding: 6px 2px;
    font-size: 0.85em;
  }
  
  .month-btn.month-13:not(.has-13) {
    display: none; /* Hide 13th month button on mobile unless year has 13 months */
  }
  
  .calendar-header {
    grid-template-columns: 1fr minmax(55px, calc(100vw / 7));
    gap: 0;
    padding: 0;
  }
  
  .header-left {
    gap: 6px;
    padding: 8px 10px;
    flex-shrink: 1;
    overflow: hidden;
    align-items: flex-end;
  }
  
  .new-moon-box {
    min-height: 60px;
    padding: 3px;
    width: calc(100vw / 7);
    min-width: 55px;
    flex-shrink: 0;
    align-self: end;
  }
  
  .new-moon-box .gregorian {
    font-size: 0.75em;
  }
  
  .new-moon-box .lunar-day {
    font-size: 1.1em;
  }
  
  .new-moon-box .feast-icons {
    font-size: 0.7em;
  }
  
  .full-moon-info .moon-icon {
    font-size: 52px;
  }
  
  .moon-gear-badge {
    font-size: 18px;
    bottom: -3px;
    right: -1px;
  }
  
  .calendar-title .site-title {
    font-size: 1em;
  }
  
  .calendar-title .site-tagline {
    font-size: 0.7em;
  }
  
  .calendar-title .month-name {
    font-size: 0.9em;
  }
  
  .calendar-title .year {
    font-size: 1.1em;
  }
  
  .calendar-title .month-year-row {
    gap: 8px;
  }
  
  .export-header-btn {
    padding: 4px 6px;
    margin-left: 4px;
    gap: 6px;
    align-self: end;
    margin-bottom: 3px;
  }
  
  .export-header-btn .icon {
    font-size: 28px;
  }
  
  .export-header-btn .label {
    font-size: 9px;
    letter-spacing: 0.3px;
  }
  
  .full-moon-info {
    font-size: 0.85em;
  }
  
  .week-header {
    font-size: 0.65em;
    gap: 2px;
  }
  
  .week-header > div {
    padding: 5px 2px;
  }
  
  .calendar-grid {
    gap: 2px;
  }
  
  .day-cell {
    min-height: 55px;
    padding: 3px;
  }
  
  .day-cell .lunar-day {
    font-size: 1.2em;
  }
  
  .day-cell .gregorian {
    font-size: 0.85em;
    color: #fff;
  }
  
  .day-cell .gregorian .day-year {
    font-size: 0.9em;
    color: #ffd700;
    font-weight: bold;
  }
  
  .day-cell .moon-phase {
    font-size: 0.65em;
  }
  
  .feast-icons {
    font-size: 0.85em !important;
  }
  
  .scripture-quote {
    font-size: 0.75em;
    padding: 8px;
  }
  
  .month-nav-cell .nav-arrow {
    font-size: 1.2em;
  }
  
  /* Feast table responsive */
  .feast-table-container {
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
  }
  
  .feast-table {
    font-size: 0.85em;
    min-width: 400px;
  }
  
  .feast-table th,
  .feast-table td {
    padding: 8px 6px;
  }
  
  /* Day detail panel mobile */
  .day-detail-panel {
    padding: 12px 15px;
  }
  
  .day-detail-lunar {
    font-size: 1.2em;
  }
  
  .day-detail-gregorian {
    font-size: 0.9em;
  }
}

@media (max-width: 480px) {
  .day-cell {
    min-height: 48px;
    padding: 2px;
  }
  
  .day-cell .lunar-day {
    font-size: 1em;
  }
  
  .day-cell .gregorian {
    font-size: 0.8em;
    color: #fff;
  }
  
  .day-cell .gregorian .day-year {
    font-size: 0.85em;
    color: #ffd700;
    font-weight: bold;
  }
  
  .day-cell .moon-phase {
    font-size: 0.5em;
  }
  
  .new-moon-box {
    min-height: 50px;
    padding: 2px;
    width: calc(100vw / 7);
  }
  
  .new-moon-box .gregorian {
    font-size: 0.7em;
  }
  
  .new-moon-box .gregorian .day-year {
    display: none;
  }
  
  .new-moon-box .lunar-day {
    font-size: 1em;
  }
  
  .new-moon-box .feast-icons {
    font-size: 0.6em;
  }
  
  .feast-icons {
    font-size: 0.75em !important;
  }
  
  .week-header {
    font-size: 0.55em;
  }
  
  .month-btn {
    min-height: 32px;
    padding: 4px 1px;
    font-size: 0.75em;
  }

  .scripture-quote {
    font-size: 0.6em;
    padding: 3px;
  }
  
  .month-nav-cell .nav-arrow {
    font-size: 1em;
  }
}

@media print {
  .calendar-controls, .month-nav button, .info-box {
    display: none;
  }
  
  .month-calendar {
    break-inside: avoid;
  }
}
  </style>
</head>
<body>

<div class="calendar-app">
  <!-- Settings Dialog (hidden by default) -->
  <div id="settings-overlay" class="settings-overlay" onclick="if(event.target === this) toggleSettings()"></div>
  <div id="settings-dialog" class="settings-dialog">
    <div class="settings-header">
      <h3>Month Sign & Location</h3>
      <button onclick="toggleSettings()" class="close-btn">‚úï</button>
    </div>
    <div class="settings-content">
      <div class="setting-group">
        <label>Month Starts At</label>
        <div class="moon-phase-buttons">
          <button class="moon-phase-btn" data-phase="full" onclick="selectMoonPhase('full')">
            <span class="phase-icon">üåï</span>
            <span class="phase-name">Full Moon</span>
          </button>
          <button class="moon-phase-btn" data-phase="dark" onclick="selectMoonPhase('dark')">
            <span class="phase-icon">üåë</span>
            <span class="phase-name">Dark Moon</span>
          </button>
          <button class="moon-phase-btn" data-phase="crescent" onclick="selectMoonPhase('crescent')">
            <span class="phase-icon">üåô</span>
            <span class="phase-name">Crescent</span>
          </button>
        </div>
        <select id="moon-phase-select" style="display: none;">
          <option value="full">Full Moon</option>
          <option value="dark">Dark Moon (Conjunction)</option>
          <option value="crescent">Crescent Moon (First Visible)</option>
        </select>
      </div>
      
      <div class="setting-group">
        <label>Your Location</label>
        <div id="settings-map-container"></div>
        <select id="city-select" class="city-select-styled">
          <optgroup label="Biblical">
            <option value="31.7683,35.2137">Jerusalem</option>
          </optgroup>
          <optgroup label="United States">
            <option value="40.7128,-74.0060">New York (Eastern)</option>
            <option value="41.8781,-87.6298">Chicago (Central)</option>
            <option value="39.7392,-104.9903">Denver (Mountain)</option>
            <option value="34.0522,-118.2437">Los Angeles (Pacific)</option>
            <option value="61.2181,-149.9003">Anchorage (Alaska)</option>
            <option value="21.3069,-157.8583">Honolulu (Hawaii)</option>
          </optgroup>
          <optgroup label="International">
            <option value="51.5074,-0.1278">London</option>
            <option value="48.8566,2.3522">Paris</option>
            <option value="35.6762,139.6503">Tokyo</option>
            <option value="-33.8688,151.2093">Sydney</option>
          </optgroup>
          <option value="">Custom Coordinates...</option>
        </select>
        <div class="setting-group" id="custom-coords" style="display: none;">
          <div style="display: flex; gap: 10px; margin-top: 10px;">
            <input type="number" id="lat-input" value="31.7683" step="0.0001" placeholder="Latitude">
            <input type="number" id="lon-input" value="35.2137" step="0.0001" placeholder="Longitude">
          </div>
        </div>
        <button type="button" class="location-btn" onclick="useCurrentLocation()">üìç Use My Current Location</button>
      </div>
      
      <div class="setting-info">
        The location determines when the lunar day begins for you.
      </div>
    </div>
  </div>

  <!-- Hidden inputs for state -->
  <input type="number" id="year-input" value="2026" min="-4000" max="4000" style="display: none;">
  <span id="year-display" style="display: none;"></span>
  <input type="datetime-local" id="goto-date" step="60" style="display: none;">
  <input type="number" id="add-days" value="1" min="1" style="display: none;">
  
  <!-- Month Picker Popup -->
  <div id="month-picker-overlay" class="month-picker-overlay" onclick="if(event.target === this) toggleMonthPicker()"></div>
  <div id="month-picker" class="month-picker" style="display: none;">
    <div class="month-picker-header">
      <h3>Select Month</h3>
      <button class="close-btn" onclick="toggleMonthPicker()">‚úï</button>
    </div>
    <div class="year-nav">
      <button onclick="changePickerYear(-1)">‚óÄ</button>
      <span id="picker-year" class="year-display"></span>
      <button onclick="changePickerYear(1)">‚ñ∂</button>
    </div>
    <div id="month-grid" class="month-grid"></div>
  </div>
  
  <!-- Date Jump Popup -->
  <div id="date-jump-overlay" class="date-jump-overlay" onclick="if(event.target === this) toggleDateJump()"></div>
  <div id="date-jump-popup" class="date-jump-popup" style="display: none;">
    <button class="close-btn" onclick="toggleDateJump()">‚úï</button>
    <h3>Jump to Date</h3>
    <input type="datetime-local" id="jump-datetime" step="60">
    <div class="btn-row">
      <button class="btn" onclick="executeJumpToDate()">Go</button>
      <button class="btn secondary" onclick="jumpToTodayFromPopup()">Today</button>
    </div>
    <div class="days-jump">
      <button onclick="addDaysFromPopup(-1)">‚óÄ</button>
      <input type="number" id="jump-days" value="1" min="1">
      <button onclick="addDaysFromPopup(1)">‚ñ∂</button>
      <span>days</span>
    </div>
  </div>
  
  <!-- Hidden month buttons container (for compatibility) -->
  <div id="month-buttons" style="display: none;"></div>

  <div id="calendar-output"></div>

  <!-- Settings Page - replaces calendar when active -->
  <div id="settings-page" class="settings-page" style="display: none;">
    <div class="settings-page-header">
      <button class="back-btn" onclick="toggleSettings()">‚Üê Back</button>
      <h2>Settings</h2>
      <button class="defaults-btn" onclick="resetToDefaults()">Defaults</button>
    </div>
    
    <div class="settings-section">
      <h3>Month Starts At</h3>
      <p class="settings-description">Choose which lunar phase marks the beginning of each month.</p>
      <div class="settings-options">
        <button class="settings-option-btn" data-phase="full" onclick="selectMoonPhase('full')">
          <span class="option-icon">üåï</span>
          <span class="option-label">Full Moon</span>
        </button>
        <button class="settings-option-btn" data-phase="dark" onclick="selectMoonPhase('dark')">
          <span class="option-icon">üåë</span>
          <span class="option-label">Dark Moon</span>
        </button>
        <button class="settings-option-btn" data-phase="crescent" onclick="selectMoonPhase('crescent')">
          <span class="option-icon">üåô</span>
          <span class="option-label">Crescent</span>
        </button>
      </div>
    </div>
    
    <div id="crescent-threshold-section" class="settings-section" style="display: none;">
      <h3>Crescent Visibility Threshold</h3>
      <p class="settings-description">Minimum moon altitude above horizon at sunset for crescent to be considered visible.</p>
      <div class="settings-options">
        <button class="settings-option-btn" data-threshold="5" onclick="selectCrescentThreshold(5)">
          <span class="option-label">5¬∞ Optimistic</span>
          <span class="option-hint">Earliest possible, ideal conditions</span>
        </button>
        <button class="settings-option-btn" data-threshold="8" onclick="selectCrescentThreshold(8)">
          <span class="option-label">8¬∞ Standard</span>
          <span class="option-hint">Typical naked-eye visibility</span>
        </button>
        <button class="settings-option-btn" data-threshold="10" onclick="selectCrescentThreshold(10)">
          <span class="option-label">10¬∞ Conservative</span>
          <span class="option-hint">Ensures easy visibility</span>
        </button>
        <button class="settings-option-btn" data-threshold="12" onclick="selectCrescentThreshold(12)">
          <span class="option-label">12¬∞ Very Conservative</span>
          <span class="option-hint">Clearly visible to anyone</span>
        </button>
      </div>
    </div>
    
    <div class="settings-section">
      <h3>Day Starts At</h3>
      <p class="settings-description">Choose when each day begins.</p>
      <div class="settings-options" style="margin-bottom: 15px;">
        <button class="settings-option-btn" data-daystart="evening" onclick="selectDayStartTime('evening')">
          <span class="option-icon">üåÖ</span>
          <span class="option-label">Evening</span>
        </button>
        <button class="settings-option-btn" data-daystart="morning" onclick="selectDayStartTime('morning')">
          <span class="option-icon">üåÑ</span>
          <span class="option-label">Morning</span>
        </button>
      </div>
      <p class="settings-description">Sun position below horizon:</p>
      <div class="settings-options">
        <button class="settings-option-btn" data-angle="0" onclick="selectDayStartAngle(0)">
          <span class="option-label">0¬∞ Horizon</span>
          <span class="option-hint">Sun at horizon</span>
        </button>
        <button class="settings-option-btn" data-angle="6" onclick="selectDayStartAngle(6)">
          <span class="option-label">6¬∞ Civil</span>
          <span class="option-hint">Bright stars visible</span>
        </button>
        <button class="settings-option-btn" data-angle="12" onclick="selectDayStartAngle(12)">
          <span class="option-label">12¬∞ Nautical</span>
          <span class="option-hint">Most stars visible</span>
        </button>
        <button class="settings-option-btn" data-angle="18" onclick="selectDayStartAngle(18)">
          <span class="option-label">18¬∞ Astronomical</span>
          <span class="option-hint">Fully dark</span>
        </button>
      </div>
    </div>
    
    <div class="settings-section">
      <h3>Year Starts At</h3>
      <p class="settings-description">Choose the rule for determining the first month of the year.</p>
      <div class="settings-options">
        <button class="settings-option-btn" data-yearstart="equinox" onclick="selectYearStartRule('equinox')">
          <span class="option-icon" id="yearstart-equinox-icon">üåï</span>
          <span class="option-label">Renewed Moon after Equinox</span>
          <span class="option-hint" id="yearstart-equinox-hint">Month 1 starts after spring equinox</span>
        </button>
        <button class="settings-option-btn" data-yearstart="13daysBefore" onclick="selectYearStartRule('13daysBefore')">
          <span class="option-icon">üêë</span>
          <span class="option-label">Passover after Equinox</span>
          <span class="option-hint" id="yearstart-passover-hint">Day 14 of Month 1 after equinox</span>
        </button>
      </div>
    </div>
    
    <div class="settings-section">
      <h3>Your Location</h3>
      <p class="settings-description">Your location determines the timing of sunrise, sunset, and twilight.</p>
      <div id="settings-page-map"></div>
      <select id="settings-city-select" class="settings-select">
        <option value="current">üìç Use Current Location</option>
        <optgroup label="Biblical">
          <option value="31.7683,35.2137">Jerusalem</option>
        </optgroup>
        <optgroup label="United States">
          <option value="40.7128,-74.0060">New York (Eastern)</option>
          <option value="41.8781,-87.6298">Chicago (Central)</option>
          <option value="39.7392,-104.9903">Denver (Mountain)</option>
          <option value="34.0522,-118.2437">Los Angeles (Pacific)</option>
          <option value="61.2181,-149.9003">Anchorage (Alaska)</option>
          <option value="21.3069,-157.8583">Honolulu (Hawaii)</option>
        </optgroup>
        <optgroup label="International">
          <option value="51.5074,-0.1278">London</option>
          <option value="48.8566,2.3522">Paris</option>
          <option value="35.6762,139.6503">Tokyo</option>
          <option value="-33.8688,151.2093">Sydney</option>
        </optgroup>
        <option value="custom">Custom Coordinates...</option>
      </select>
      <div id="settings-custom-coords" class="settings-custom-coords" style="display: none;">
        <input type="number" id="settings-lat-input" step="0.0001" placeholder="Latitude">
        <input type="number" id="settings-lon-input" step="0.0001" placeholder="Longitude">
      </div>
    </div>
  </div>

  <!-- Day Detail Panel - slides up when a day is selected -->
  <div id="day-detail-panel" class="day-detail-panel hidden">
    <div class="day-detail-header">
      <div class="day-detail-date">
        <span class="day-detail-lunar"></span>
        <span class="day-detail-gregorian-row">
          <span class="day-detail-gregorian"></span>
          <button class="day-detail-jump-btn" onclick="toggleDateJump()" title="Jump to another date">‚á•</button>
        </span>
      </div>
    </div>
    <div class="day-detail-content">
      <div class="day-detail-feasts"></div>
      <div class="day-detail-info"></div>
    </div>
  </div>

  <!-- Feast table hidden from main page - shown in export modal -->
  <div class="feast-list" style="display: none;">
    <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px; margin-bottom: 15px;">
      <h3 style="margin: 0;">Appointed Times for <span id="feast-year">2026</span></h3>
      <button class="btn" onclick="openInCalendar()" title="Download all Sabbaths and Feasts for this year">üìÖ Export Year to Calendar App</button>
    </div>
    <div class="feast-table-container">
    <table class="feast-table">
      <thead>
        <tr>
          <th>Feast</th>
          <th>Date</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody id="feast-tbody"></tbody>
    </table>
    </div>
  </div>
</div>

<!-- Export/Feasts Page -->
<div id="export-page" class="settings-page" style="display: none;">
  <div class="settings-page-header export-header">
    <button class="back-btn" onclick="toggleExportModal()">‚Üê Calendar</button>
    <div class="export-branding">
      <div class="export-site-title">Lunar Sabbath Calendar</div>
      <div class="export-page-title">Appointed Times for <span id="export-year">2026</span></div>
    </div>
    <button class="btn export-download-btn" onclick="openInCalendar()">üìÖ Export</button>
  </div>
  <div class="export-settings-context">
    <span id="export-context-text">Loading settings...</span>
  </div>
  <div class="settings-content" style="padding-top: 0;">
    <div class="feast-table-container">
      <table class="feast-table">
        <thead>
          <tr>
            <th>Feast</th>
            <th>Date</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody id="export-feast-tbody"></tbody>
      </table>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/astronomy-engine@2.1.19/astronomy.browser.min.js"></script>
<script>
const MONTH_NAMES = [
  '1st Month', '2nd Month', '3rd Month', '4th Month', '5th Month', '6th Month',
  '7th Month', '8th Month', '9th Month', '10th Month', '11th Month', '12th Month', '13th Month'
];

// Shofar SVG icon for Renewed Moon - larger and more distinct
const SHOFAR_ICON = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 20" width="1.4em" height="1.2em" style="vertical-align:middle"><path fill="#A67C00" stroke="#5C4300" stroke-width="1" d="M21 3c-1 0-2 .5-3 1.2c-1.5 1-3 2.5-4 4.3c-1 1.8-2 3.5-3.5 5c-1.5 1.5-3.5 2.5-6 2.5c-1.5 0-2.5 1-2.5 2s1 2 2.5 2c2 0 4-.5 5.5-1.5c1.5-1 3-2.5 4-4c1-1.5 2-3 3-4.5c1-1.5 2-2.5 3-3c.8-.4 1.5-1 1.5-2S22 3 21 3z"/><circle fill="#5C4300" cx="4" cy="17" r="1.2"/></svg>';

// Order matters: single-day feasts should come AFTER multi-day feasts so they take priority
// Order matters for overlapping feasts: specific single-day feasts listed AFTER multi-day feasts take priority
const FEASTS = [
  // Renewed Moon Day - first day of every month (first light after full moon when waning moon is 12¬∞+ above western horizon)
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 1, day: 1, description: 'First light after full moon ‚Äî waning moon 12¬∞+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 2, day: 1, description: 'First light after full moon ‚Äî waning moon 12¬∞+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 3, day: 1, description: 'First light after full moon ‚Äî waning moon 12¬∞+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 4, day: 1, description: 'First light after full moon ‚Äî waning moon 12¬∞+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 5, day: 1, description: 'First light after full moon ‚Äî waning moon 12¬∞+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 6, day: 1, description: 'First light after full moon ‚Äî waning moon 12¬∞+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 7, day: 1, description: 'First light after full moon ‚Äî waning moon 12¬∞+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 8, day: 1, description: 'First light after full moon ‚Äî waning moon 12¬∞+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 9, day: 1, description: 'First light after full moon ‚Äî waning moon 12¬∞+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 10, day: 1, description: 'First light after full moon ‚Äî waning moon 12¬∞+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 11, day: 1, description: 'First light after full moon ‚Äî waning moon 12¬∞+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 12, day: 1, description: 'First light after full moon ‚Äî waning moon 12¬∞+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 13, day: 1, description: 'First light after full moon ‚Äî waning moon 12¬∞+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  // Specific feasts
  { name: 'Last Supper', shortName: 'Last Supper', icon: 'üçûüç∑', month: 1, day: 13, description: 'The Last Supper - bread and wine', chapter: '/chapters/18-appointed-times/#passover' },
  { name: 'Passover', shortName: 'Passover', icon: 'üêë‚Ä†', month: 1, day: 14, description: 'Lamb slain at twilight', chapter: '/chapters/18-appointed-times/#passover' },
  { name: 'Unleavened Bread', shortName: 'Unleavened', icon: 'ü´ì', month: 1, day: 15, endDay: 21, description: 'High Sabbath, no leaven for 7 days', chapter: '/chapters/18-appointed-times/#unleavened-bread' },
  { name: 'First Fruits', shortName: 'First Fruits', icon: 'üåæ', month: 1, day: 16, description: 'Wave sheaf offering (also Unleavened 2)', chapter: '/chapters/18-appointed-times/#first-fruits-of-barley' },
  { name: 'Atzeret of Unleavened', shortName: 'Atzeret', icon: 'üïç', month: 1, day: 21, description: 'Solemn assembly - 7th day of Unleavened Bread', chapter: '/chapters/18-appointed-times/#unleavened-bread' },
  { name: 'Shavuot', shortName: 'Shavuot', icon: 'üåæ', month: 3, day: 16, description: '7 complete weeks after First Fruits', chapter: '/chapters/18-appointed-times/#shavuot---first-fruits-of-wheat' },
  { name: 'Trumpets', shortName: 'Trumpets', icon: 'üé∫', month: 7, day: 1, description: 'Day of shouting/blowing', chapter: '/chapters/18-appointed-times/#trumpets---first-fruits-of-oil' },
  { name: 'Atonement', shortName: 'Atonement', icon: 'ü©∏', month: 7, day: 10, description: 'Yom Kippur - day of fasting', chapter: '/chapters/18-appointed-times/#day-of-atonement' },
  { name: 'Tabernacles', shortName: 'Tabernacles', icon: '‚õ∫', month: 7, day: 15, endDay: 21, description: 'Feast of Booths', chapter: '/chapters/18-appointed-times/#tabernacles' },
  { name: 'Atzeret', shortName: 'Atzeret', icon: 'üïç', month: 7, day: 22, description: 'Shemini Atzeret - Last Great Day', chapter: '/chapters/18-appointed-times/#atzeret---last-great-day' },
  { name: 'Hanukkah', shortName: 'Hanukkah', icon: 'üïé', month: 9, day: 25, endDay: 30, description: 'Festival of Dedication (8 days)', chapter: '/chapters/18-appointed-times/#hanukkah', continuesNextMonth: true },
  { name: 'Hanukkah', shortName: 'Hanukkah', icon: 'üïé', month: 10, day: 1, endDay: 2, description: 'Festival of Dedication (continued)', chapter: '/chapters/18-appointed-times/#hanukkah', startDayNum: 7 },
  { name: 'Atzeret of Hanukkah', shortName: 'Atzeret', icon: 'üïç', month: 10, day: 2, description: 'Atzeret - 8th day of Hanukkah', chapter: '/chapters/18-appointed-times/#hanukkah' },
  { name: 'Purim', shortName: 'Purim', icon: 'üìú', month: 12, day: 14, endDay: 15, description: 'Feast of Lots - deliverance from Haman', chapter: '/chapters/18-appointed-times/#purim' }
];

const SCRIPTURES = [
  { text: "It shall be established forever like the moon, even like the trustworthy witness in the sky.", ref: "Psalms 89:37" },
  { text: "He appointed the moon for seasons; the sun knows its going down.", ref: "Psalms 104:19" },
  { text: "And God said, Let there be lights in the firmament... for signs, and for seasons, and for days, and years.", ref: "Genesis 1:14" },
  { text: "Blow the trumpet at the new moon, at the full moon, on our feast day.", ref: "Psalms 81:3" }
];

// Central state object with defaults
const defaultState = {
  year: new Date().getFullYear(),
  lat: 31.7683,
  lon: 35.2137,
  city: '31.7683,35.2137', // Store the city select value directly
  moonPhase: 'full',
  dayStartTime: 'morning',  // 'evening' or 'morning'
  dayStartAngle: 12,        // 0, 6, 12, or 18 degrees below horizon
  yearStartRule: 'equinox', // 'equinox' or '13daysBefore'
  crescentThreshold: 8,     // Minimum moon altitude (degrees) at sunset for crescent visibility
  lunarMonths: [],
  currentMonthIndex: 0,
  highlightedLunarDay: null,
  selectedTimestamp: null  // UTC timestamp of selected moment
};

// Load saved state from localStorage or use defaults
function loadState() {
  const saved = localStorage.getItem('lunarCalendarState');
  if (saved) {
    try {
      const parsed = JSON.parse(saved);
      return {
        ...defaultState,
        year: parsed.year || defaultState.year,
        lat: parsed.lat || defaultState.lat,
        lon: parsed.lon || defaultState.lon,
        city: parsed.city || '',
        moonPhase: parsed.moonPhase || defaultState.moonPhase,
        dayStartTime: parsed.dayStartTime || defaultState.dayStartTime,
        dayStartAngle: parsed.dayStartAngle !== undefined ? parsed.dayStartAngle : defaultState.dayStartAngle,
        yearStartRule: parsed.yearStartRule || defaultState.yearStartRule,
        crescentThreshold: parsed.crescentThreshold !== undefined ? parsed.crescentThreshold : defaultState.crescentThreshold
      };
    } catch (e) {
      return { ...defaultState };
    }
  }
  return { ...defaultState };
}

// Save settings to localStorage
function saveState() {
  const toSave = {
    year: state.year,
    lat: state.lat,
    lon: state.lon,
    city: state.city,
    moonPhase: state.moonPhase,
    dayStartTime: state.dayStartTime,
    dayStartAngle: state.dayStartAngle,
    yearStartRule: state.yearStartRule,
    crescentThreshold: state.crescentThreshold
  };
  localStorage.setItem('lunarCalendarState', JSON.stringify(toSave));
}

// Update URL with current calendar state for sharing
function updateURL() {
  const params = new URLSearchParams();
  params.set('year', state.year);
  params.set('month', state.currentMonthIndex + 1); // 1-indexed for readability
  if (state.highlightedLunarDay) {
    params.set('day', state.highlightedLunarDay);
  }
  params.set('lat', state.lat);
  params.set('lon', state.lon);
  params.set('phase', state.moonPhase);
  
  const newURL = window.location.pathname + '?' + params.toString();
  window.history.replaceState({}, '', newURL);
}

// Load state from URL parameters (called after initial calendar generation)
function loadFromURL() {
  const params = new URLSearchParams(window.location.search);
  
  if (!params.has('year')) return; // No URL params, use defaults
  
  let needsRegenerate = false;
  
  // Year
  if (params.has('year')) {
    const urlYear = parseInt(params.get('year'));
    if (!isNaN(urlYear) && urlYear !== state.year) {
      state.year = urlYear;
      needsRegenerate = true;
    }
  }
  
  // Location
  if (params.has('lat') && params.has('lon')) {
    const urlLat = parseFloat(params.get('lat'));
    const urlLon = parseFloat(params.get('lon'));
    if (!isNaN(urlLat) && !isNaN(urlLon)) {
      if (urlLat !== state.lat || urlLon !== state.lon) {
        state.lat = urlLat;
        state.lon = urlLon;
        state.city = ''; // Clear city selection
        needsRegenerate = true;
      }
    }
  }
  
  // Moon phase
  if (params.has('phase')) {
    const urlPhase = params.get('phase');
    if (['full', 'dark', 'crescent'].includes(urlPhase) && urlPhase !== state.moonPhase) {
      state.moonPhase = urlPhase;
      needsRegenerate = true;
    }
  }
  
  // Regenerate if settings changed
  if (needsRegenerate) {
    updateUI();
    generateCalendar();
  }
  
  // Month and day (after calendar is generated)
  if (params.has('month')) {
    const urlMonth = parseInt(params.get('month')) - 1; // Convert to 0-indexed
    if (!isNaN(urlMonth) && urlMonth >= 0 && urlMonth < state.lunarMonths.length) {
      state.currentMonthIndex = urlMonth;
    }
  }
  
  if (params.has('day')) {
    const urlDay = parseInt(params.get('day'));
    if (!isNaN(urlDay) && urlDay >= 1 && urlDay <= 30) {
      state.highlightedLunarDay = urlDay;
      // Update the goto-date input and timestamp to match the highlighted day
      const month = state.lunarMonths[state.currentMonthIndex];
      const dayObj = month?.days.find(d => d.lunarDay === urlDay);
      if (dayObj) {
        // Set to sunrise time of that day
        state.selectedTimestamp = getSunriseTimestamp(dayObj.gregorianDate);
        document.getElementById('goto-date').value = formatLocalDatetime(state.selectedTimestamp);
        // Show the day detail panel
        showDayDetail(dayObj, month);
      }
    }
  }
  
  // Re-render with the URL state
  if (params.has('month') || params.has('day')) {
    renderMonth(state.lunarMonths[state.currentMonthIndex]);
    updateMonthButtons();
  }
  
  // Check for view=feasts parameter to open the feasts page
  if (params.has('view') && params.get('view') === 'feasts') {
    toggleExportModal(true); // Skip URL update since we're loading from URL
  }
}

const state = loadState();

// Update UI to reflect current state
function updateUI() {
  document.getElementById('year-input').value = state.year;
  // Show BC label only when needed (no AD suffix)
  const yearVal = state.year;
  if (yearVal <= 0) {
    document.getElementById('year-display').textContent = `(${Math.abs(yearVal - 1)} BC)`;
  } else {
    document.getElementById('year-display').textContent = '';  // No AD suffix for positive years
  }
  document.getElementById('feast-year').textContent = formatYear(state.year);
  document.getElementById('lat-input').value = state.lat;
  document.getElementById('lon-input').value = state.lon;
  document.getElementById('moon-phase-select').value = state.moonPhase;
  document.getElementById('city-select').value = state.city || '';
  
  // Update button states
  updateMoonPhaseButtons();
  
  // Show/hide custom coordinates
  const customCoords = document.getElementById('custom-coords');
  if (customCoords) {
    customCoords.style.display = state.city === '' ? 'block' : 'none';
  }
}

function toggleSettings() {
  const calendarOutput = document.getElementById('calendar-output');
  const dayDetailPanel = document.getElementById('day-detail-panel');
  const settingsPage = document.getElementById('settings-page');
  
  const isOpening = settingsPage.style.display === 'none';
  
  if (isOpening) {
    // Hide calendar, show settings
    calendarOutput.style.display = 'none';
    dayDetailPanel.style.display = 'none';
    settingsPage.style.display = 'block';
    
    // Update settings page state
    updateSettingsPageState();
  } else {
    // Show calendar, hide settings
    calendarOutput.style.display = 'block';
    settingsPage.style.display = 'none';
    
    // Reset day detail panel display and refresh if a day was selected
    dayDetailPanel.style.display = '';  // Reset inline style
    if (state.highlightedLunarDay !== null) {
      dayDetailPanel.classList.remove('hidden');
      refreshDayDetailIfVisible();
    }
  }
}

function toggleExportModal(skipUrlUpdate = false) {
  const calendarOutput = document.getElementById('calendar-output');
  const dayDetailPanel = document.getElementById('day-detail-panel');
  const exportPage = document.getElementById('export-page');
  const settingsPage = document.getElementById('settings-page');
  
  const isOpening = exportPage.style.display === 'none';
  
  if (isOpening) {
    // Hide calendar and settings, show export
    calendarOutput.style.display = 'none';
    dayDetailPanel.style.display = 'none';
    settingsPage.style.display = 'none';
    exportPage.style.display = 'block';
    
    // Scroll to top of page (with timeout to ensure DOM update)
    window.scrollTo(0, 0);
    document.documentElement.scrollTop = 0;
    document.body.scrollTop = 0;
    setTimeout(() => {
      window.scrollTo(0, 0);
      exportPage.scrollTop = 0;
    }, 0);
    
    // Update export table with current feast data
    updateExportTable();
    
    // Update URL with view=feasts
    if (!skipUrlUpdate) {
      updateURLWithView('feasts');
    }
  } else {
    // Show calendar, hide export
    calendarOutput.style.display = 'block';
    exportPage.style.display = 'none';
    
    // Reset day detail panel display and refresh if a day was selected
    dayDetailPanel.style.display = '';  // Reset inline style
    if (state.highlightedLunarDay !== null) {
      dayDetailPanel.classList.remove('hidden');
      refreshDayDetailIfVisible();
    }
    
    // Remove view parameter from URL
    if (!skipUrlUpdate) {
      updateURL();
    }
  }
}

function updateURLWithView(view) {
  const params = new URLSearchParams();
  params.set('year', state.year);
  params.set('lat', state.lat);
  params.set('lon', state.lon);
  params.set('phase', state.moonPhase);
  params.set('view', view);
  
  const newURL = window.location.pathname + '?' + params.toString();
  window.history.replaceState({}, '', newURL);
}

function updateExportTable() {
  // Update the year display
  document.getElementById('export-year').textContent = formatYear(state.year);
  
  // Update settings context
  const contextEl = document.getElementById('export-context-text');
  if (contextEl) {
    const moonLabel = getMoonLabel();
    const dayStartLabel = getDayStartLabel();
    const yearStartLabel = state.yearStartRule === '13daysBefore' ? 'Passover after Equinox' : 'Renewed Moon after Equinox';
    const locationLabel = state.city || `${state.lat.toFixed(2)}¬∞, ${state.lon.toFixed(2)}¬∞`;
    
    contextEl.innerHTML = `
      <span class="export-context-item">
        <span class="export-context-label">Month Start:</span>
        <span class="export-context-value">${moonLabel}</span>
      </span>
      <span class="export-context-item">
        <span class="export-context-label">Day Start:</span>
        <span class="export-context-value">${dayStartLabel}</span>
      </span>
      <span class="export-context-item">
        <span class="export-context-label">Year Start:</span>
        <span class="export-context-value">${yearStartLabel}</span>
      </span>
      <span class="export-context-item">
        <span class="export-context-label">Location:</span>
        <span class="export-context-value">${locationLabel}</span>
      </span>
    `;
  }
  
  // Copy the feast table content to the export modal
  const sourceTbody = document.getElementById('feast-tbody');
  const targetTbody = document.getElementById('export-feast-tbody');
  
  if (sourceTbody && targetTbody) {
    targetTbody.innerHTML = sourceTbody.innerHTML;
  }
}

function updateSettingsPageState() {
  // Update moon phase buttons
  document.querySelectorAll('.settings-option-btn[data-phase]').forEach(btn => {
    btn.classList.toggle('selected', btn.dataset.phase === state.moonPhase);
  });
  
  // Update crescent threshold visibility and buttons
  updateCrescentThresholdVisibility();
  updateCrescentThresholdButtons();
  
  // Update day start buttons
  updateDayStartButtons();
  
  // Update year start buttons
  updateYearStartButtons();
  
  // Update city select
  const citySelect = document.getElementById('settings-city-select');
  const coordValue = `${state.lat},${state.lon}`;
  let found = false;
  
  for (let option of citySelect.options) {
    if (option.value === coordValue) {
      citySelect.value = coordValue;
      found = true;
      break;
    }
  }
  
  if (!found) {
    citySelect.value = 'custom';
    document.getElementById('settings-custom-coords').style.display = 'flex';
    document.getElementById('settings-lat-input').value = state.lat;
    document.getElementById('settings-lon-input').value = state.lon;
  } else {
    document.getElementById('settings-custom-coords').style.display = 'none';
  }
  
  // Render the map
  renderSettingsPageMap();
}

function renderSettingsPageMap() {
  const container = document.getElementById('settings-page-map');
  if (container && state.lunarMonths && state.lunarMonths[state.currentMonthIndex]) {
    const month = state.lunarMonths[state.currentMonthIndex];
    container.innerHTML = renderDatelineVisualization(month.moonEvent);
  }
}

function updateMoonPhaseButtons() {
  document.querySelectorAll('.moon-phase-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.phase === state.moonPhase);
  });
  // Also update settings page buttons
  document.querySelectorAll('.settings-option-btn[data-phase]').forEach(btn => {
    btn.classList.toggle('selected', btn.dataset.phase === state.moonPhase);
  });
}

function selectMoonPhase(phase) {
  state.moonPhase = phase;
  document.getElementById('moon-phase-select').value = phase;
  updateMoonPhaseButtons();
  updateCrescentThresholdVisibility();
  updateYearStartButtons();  // Update year start icon to match moon phase
  saveState();
  generateCalendar({ preserveMonth: true });
  updateURL();
  renderSettingsPageMap();
  refreshDayDetailIfVisible();
}

function resetToDefaults() {
  // Reset to default settings: Full Moon, Morning Nautical Twilight, Renewed Moon after Equinox
  state.moonPhase = 'full';
  state.dayStartTime = 'morning';
  state.dayStartAngle = 12;
  state.yearStartRule = 'equinox';
  state.crescentThreshold = 8;
  
  // Update UI
  document.getElementById('moon-phase-select').value = 'full';
  updateMoonPhaseButtons();
  updateDayStartButtons();
  updateYearStartButtons();
  updateCrescentThresholdVisibility();
  updateCrescentThresholdButtons();
  
  // Save and regenerate
  saveState();
  generateCalendar({ preserveMonth: true });
  updateURL();
  renderSettingsPageMap();
  refreshDayDetailIfVisible();
}

function selectDayStartTime(time) {
  state.dayStartTime = time;
  updateDayStartButtons();
  saveState();
  generateCalendar({ preserveMonth: true });
  updateURL();
  renderSettingsPageMap();
  refreshDayDetailIfVisible();
}

function selectDayStartAngle(angle) {
  state.dayStartAngle = angle;
  updateDayStartButtons();
  saveState();
  generateCalendar({ preserveMonth: true });
  updateURL();
  renderSettingsPageMap();
  refreshDayDetailIfVisible();
}

function selectYearStartRule(rule) {
  state.yearStartRule = rule;
  updateYearStartButtons();
  saveState();
  generateCalendar({ preserveMonth: true });
  updateURL();
  renderSettingsPageMap();
  refreshDayDetailIfVisible();
}

function updateDayStartButtons() {
  // Update day start time buttons (evening/morning)
  document.querySelectorAll('.settings-option-btn[data-daystart]').forEach(btn => {
    btn.classList.toggle('selected', btn.dataset.daystart === state.dayStartTime);
  });
  // Update angle buttons
  document.querySelectorAll('.settings-option-btn[data-angle]').forEach(btn => {
    btn.classList.toggle('selected', parseInt(btn.dataset.angle) === state.dayStartAngle);
  });
}

function updateYearStartButtons() {
  document.querySelectorAll('.settings-option-btn[data-yearstart]').forEach(btn => {
    btn.classList.toggle('selected', btn.dataset.yearstart === state.yearStartRule);
  });
  
  // Update the "Renewed Moon after Equinox" icon to match current moon phase
  const iconEl = document.getElementById('yearstart-equinox-icon');
  if (iconEl) {
    iconEl.textContent = getMoonIcon();
  }
}

function selectCrescentThreshold(threshold) {
  state.crescentThreshold = threshold;
  updateCrescentThresholdButtons();
  saveState();
  generateCalendar({ preserveMonth: true });
  updateURL();
  renderSettingsPageMap();
  refreshDayDetailIfVisible();
}

function updateCrescentThresholdButtons() {
  document.querySelectorAll('.settings-option-btn[data-threshold]').forEach(btn => {
    btn.classList.toggle('selected', parseInt(btn.dataset.threshold) === state.crescentThreshold);
  });
}

function updateCrescentThresholdVisibility() {
  const section = document.getElementById('crescent-threshold-section');
  if (section) {
    section.style.display = state.moonPhase === 'crescent' ? 'block' : 'none';
  }
}

function renderSettingsMap() {
  const container = document.getElementById('settings-map-container');
  if (container && state.lunarMonths && state.lunarMonths[state.currentMonthIndex]) {
    const month = state.lunarMonths[state.currentMonthIndex];
    container.innerHTML = renderDatelineVisualization(month.moonEvent);
  }
}

// Month Picker Popup
function toggleMonthPicker() {
  const overlay = document.getElementById('month-picker-overlay');
  const picker = document.getElementById('month-picker');
  const isOpen = overlay.classList.contains('open');
  
  if (!isOpen) {
    // Opening - update the picker content
    updateMonthPicker();
  }
  
  overlay.classList.toggle('open');
  picker.style.display = isOpen ? 'none' : 'block';
}

function updateMonthPicker() {
  document.getElementById('picker-year').textContent = formatYear(state.year);
  
  const grid = document.getElementById('month-grid');
  grid.innerHTML = '';
  
  const monthNames = ['1st', '2nd', '3rd', '4th', '5th', '6th', '7th', '8th', '9th', '10th', '11th', '12th', 'üìÖ13th'];
  
  for (let i = 0; i < 13; i++) {
    const btn = document.createElement('button');
    btn.textContent = monthNames[i];
    
    if (i >= state.lunarMonths.length) {
      btn.classList.add('disabled');
      btn.disabled = true;
    } else if (i === state.currentMonthIndex) {
      btn.classList.add('active');
    }
    
    // Add tooltip for 13th month
    if (i === 12) {
      btn.title = 'Intercalary 13th month';
    }
    
    btn.onclick = () => {
      if (i < state.lunarMonths.length) {
        selectMonth(i);
        toggleMonthPicker();
      }
    };
    
    grid.appendChild(btn);
  }
}

function changePickerYear(delta) {
  state.year += delta;
  document.getElementById('year-input').value = state.year;
  generateCalendar();
  updateMonthPicker();
}

// Date Jump Popup
function toggleDateJump() {
  const overlay = document.getElementById('date-jump-overlay');
  const popup = document.getElementById('date-jump-popup');
  const isOpen = overlay.classList.contains('open');
  
  if (!isOpen) {
    // Opening - sync the datetime input
    const gotoDate = document.getElementById('goto-date').value;
    document.getElementById('jump-datetime').value = gotoDate;
  }
  
  overlay.classList.toggle('open');
  popup.style.display = isOpen ? 'none' : 'block';
}

function executeJumpToDate() {
  const datetime = document.getElementById('jump-datetime').value;
  if (!datetime) {
    alert('Please enter a date');
    return;
  }
  document.getElementById('goto-date').value = datetime;
  jumpToDate();
  toggleDateJump();
}

function jumpToTodayFromPopup() {
  toggleDateJump();
  jumpToToday();
}

function addDaysFromPopup(direction) {
  const datetime = document.getElementById('jump-datetime').value;
  const days = parseInt(document.getElementById('jump-days').value) || 1;
  
  if (!datetime) {
    alert('Please select a date first');
    return;
  }
  
  // Parse as local time at location, add days, convert back
  const utcTimestamp = parseDatetimeLocal(datetime);
  const newTimestamp = utcTimestamp + (direction * days * 24 * 60 * 60 * 1000);
  
  document.getElementById('jump-datetime').value = formatLocalDatetime(newTimestamp);
  document.getElementById('goto-date').value = formatLocalDatetime(newTimestamp);
  jumpToDate();
}

function handleMapClick(event) {
  const mapEl = event.currentTarget;
  const rect = mapEl.getBoundingClientRect();
  
  // Calculate click position as percentage
  const xPercent = (event.clientX - rect.left) / rect.width;
  const yPercent = (event.clientY - rect.top) / rect.height;
  
  // Convert to lat/lon (equirectangular projection)
  // X: 0% = -180¬∞, 100% = 180¬∞
  // Y: 0% = 90¬∞ (north), 100% = -90¬∞ (south)
  const lon = (xPercent * 360) - 180;
  const lat = 90 - (yPercent * 180);
  
  // Round to 2 decimal places
  state.lat = Math.round(lat * 100) / 100;
  state.lon = Math.round(lon * 100) / 100;
  state.city = ''; // Clear city selection
  
  // Update main inputs
  document.getElementById('lat-input').value = state.lat;
  document.getElementById('lon-input').value = state.lon;
  document.getElementById('city-select').value = '';
  
  // Update settings page inputs
  const settingsLatInput = document.getElementById('settings-lat-input');
  const settingsLonInput = document.getElementById('settings-lon-input');
  const settingsCitySelect = document.getElementById('settings-city-select');
  const settingsCustomCoords = document.getElementById('settings-custom-coords');
  
  if (settingsLatInput) settingsLatInput.value = state.lat;
  if (settingsLonInput) settingsLonInput.value = state.lon;
  if (settingsCitySelect) settingsCitySelect.value = 'custom';
  if (settingsCustomCoords) settingsCustomCoords.style.display = 'flex';
  
  // Show custom coords on main page
  const customCoords = document.getElementById('custom-coords');
  if (customCoords) customCoords.style.display = 'block';
  
  // Save and regenerate (preserve current month for location changes)
  saveState();
  generateCalendar({ preserveMonth: true });
  updateURL();
  
  // Update the settings maps (both containers)
  renderSettingsMap();
  renderSettingsPageMap();
  refreshDayDetailIfVisible();
}

function useCurrentLocation() {
  const btn = document.querySelector('.location-btn');
  const originalText = btn.textContent;
  
  if (!navigator.geolocation) {
    alert('Geolocation is not supported by your browser');
    return;
  }
  
  btn.textContent = 'üìç Getting location...';
  btn.disabled = true;
  
  navigator.geolocation.getCurrentPosition(
    function(position) {
      // Success
      state.lat = Math.round(position.coords.latitude * 10000) / 10000;
      state.lon = Math.round(position.coords.longitude * 10000) / 10000;
      state.city = ''; // Clear city selection
      
      document.getElementById('lat-input').value = state.lat;
      document.getElementById('lon-input').value = state.lon;
      document.getElementById('city-select').value = '';
      document.getElementById('custom-coords').style.display = 'block';
      
      saveState();
      generateCalendar({ preserveMonth: true });
      updateURL();
      renderSettingsMap();
      refreshDayDetailIfVisible();
      
      btn.textContent = '‚úì Location set!';
      setTimeout(() => {
        btn.textContent = originalText;
        btn.disabled = false;
      }, 2000);
    },
    function(error) {
      // Error
      let message = 'Unable to get location';
      switch(error.code) {
        case error.PERMISSION_DENIED:
          message = 'Location access denied. Please enable location permissions.';
          break;
        case error.POSITION_UNAVAILABLE:
          message = 'Location information unavailable.';
          break;
        case error.TIMEOUT:
          message = 'Location request timed out.';
          break;
      }
      alert(message);
      btn.textContent = originalText;
      btn.disabled = false;
    },
    {
      enableHighAccuracy: false,
      timeout: 10000,
      maximumAge: 300000 // Cache for 5 minutes
    }
  );
}

document.getElementById('city-select').addEventListener('change', function() {
  const customCoords = document.getElementById('custom-coords');
  
  if (this.value === '') {
    // Custom selected - show coordinate inputs
    customCoords.style.display = 'block';
    state.city = '';
    return;
  }
  
  if (this.value) {
    customCoords.style.display = 'none';
    const [lat, lon] = this.value.split(',').map(Number);
    state.lat = lat;
    state.lon = lon;
    state.city = this.value;
    saveState();
    updateUI();
    generateCalendar({ preserveMonth: true });
    updateURL();
    renderSettingsMap();
    refreshDayDetailIfVisible();
  }
});

// Settings page city select handler
document.getElementById('settings-city-select').addEventListener('change', function() {
  const customCoords = document.getElementById('settings-custom-coords');
  
  if (this.value === 'current') {
    // Use geolocation
    useCurrentLocationFromSettings();
    return;
  }
  
  if (this.value === 'custom') {
    customCoords.style.display = 'flex';
    state.city = '';
    return;
  }
  
  if (this.value) {
    customCoords.style.display = 'none';
    const [lat, lon] = this.value.split(',').map(Number);
    state.lat = lat;
    state.lon = lon;
    state.city = this.value;
    
    // Sync with old inputs
    document.getElementById('lat-input').value = state.lat;
    document.getElementById('lon-input').value = state.lon;
    document.getElementById('city-select').value = this.value;
    
    saveState();
    generateCalendar({ preserveMonth: true });
    updateURL();
    renderSettingsPageMap();
    refreshDayDetailIfVisible();
  }
});

// Settings page custom coordinate inputs
document.getElementById('settings-lat-input').addEventListener('change', function() {
  state.lat = parseFloat(this.value);
  state.city = '';
  document.getElementById('lat-input').value = state.lat;
  saveState();
  generateCalendar({ preserveMonth: true });
  updateURL();
  renderSettingsPageMap();
  refreshDayDetailIfVisible();
});

document.getElementById('settings-lon-input').addEventListener('change', function() {
  state.lon = parseFloat(this.value);
  state.city = '';
  document.getElementById('lon-input').value = state.lon;
  saveState();
  generateCalendar({ preserveMonth: true });
  updateURL();
  renderSettingsPageMap();
  refreshDayDetailIfVisible();
});

function useCurrentLocationFromSettings() {
  const select = document.getElementById('settings-city-select');
  
  if (!navigator.geolocation) {
    alert('Geolocation is not supported by your browser');
    // Reset to first city option
    select.value = '31.7683,35.2137';
    return;
  }
  
  navigator.geolocation.getCurrentPosition(
    function(position) {
      state.lat = Math.round(position.coords.latitude * 10000) / 10000;
      state.lon = Math.round(position.coords.longitude * 10000) / 10000;
      state.city = '';
      
      // Update both old and new inputs
      document.getElementById('lat-input').value = state.lat;
      document.getElementById('lon-input').value = state.lon;
      document.getElementById('settings-lat-input').value = state.lat;
      document.getElementById('settings-lon-input').value = state.lon;
      
      // Show custom coordinates with the detected location
      select.value = 'custom';
      document.getElementById('settings-custom-coords').style.display = 'flex';
      
      saveState();
      generateCalendar({ preserveMonth: true });
      updateURL();
      renderSettingsPageMap();
      refreshDayDetailIfVisible();
    },
    function(error) {
      alert('Unable to get your location. Please select a city or enter coordinates manually.');
      // Reset to first city option
      select.value = '31.7683,35.2137';
    },
    { timeout: 10000, enableHighAccuracy: true }
  );
}

// Auto-regenerate when inputs change
function regenerateAndUpdateURL() {
  generateCalendar();
  updateURL();
}
document.getElementById('year-input').addEventListener('change', regenerateAndUpdateURL);
document.getElementById('moon-phase-select').addEventListener('change', regenerateAndUpdateURL);
document.getElementById('lat-input').addEventListener('change', function() {
  state.city = ''; // Clear city selection when manually editing coordinates
  generateCalendar({ preserveMonth: true });
  updateURL();
  refreshDayDetailIfVisible();
});
document.getElementById('lon-input').addEventListener('change', function() {
  state.city = ''; // Clear city selection when manually editing coordinates
  generateCalendar({ preserveMonth: true });
  updateURL();
  refreshDayDetailIfVisible();
});

function changeYear(delta) {
  state.year += delta;
  state.highlightedLunarDay = null;
  state.selectedTimestamp = null;
  updateUI();
  generateCalendar();
  updateURL();
}

function addDaysToDate(direction) {
  const dateInput = document.getElementById('goto-date').value;
  const daysValue = parseInt(document.getElementById('add-days').value);
  
  if (!dateInput) {
    alert('Please select a date first');
    return;
  }
  
  if (isNaN(daysValue) || daysValue <= 0) {
    alert('Please enter a positive number of days');
    return;
  }
  
  const daysToAdd = daysValue * direction; // direction: 1 = forward, -1 = backward
  
  // Parse current datetime as local time at location, get UTC timestamp
  const utcTimestamp = parseDatetimeLocal(dateInput);
  // Add days in milliseconds
  const newTimestamp = utcTimestamp + daysToAdd * 24 * 60 * 60 * 1000;
  
  // Update the datetime input with new local time
  document.getElementById('goto-date').value = formatLocalDatetime(newTimestamp);
  
  // Jump to the new date
  jumpToDate();
}

function jumpToDate() {
  const dateInput = document.getElementById('goto-date').value;
  if (!dateInput) {
    alert('Please enter a date');
    return;
  }
  
  // Parse as local time at selected location, convert to UTC
  const utcTimestamp = parseDatetimeLocal(dateInput);
  const targetDate = new Date(utcTimestamp);
  const targetYear = targetDate.getUTCFullYear();
  
  // Helper function to search in current lunar months
  function searchInCurrentMonths() {
    for (let m = 0; m < state.lunarMonths.length; m++) {
      const month = state.lunarMonths[m];
      for (let d = 0; d < month.days.length; d++) {
        const day = month.days[d];
        if (day.gregorianDate.toDateString() === targetDate.toDateString()) {
          return { month: m, dayIndex: d };
        }
      }
    }
    return null;
  }
  
  // First try current lunar months
  let found = searchInCurrentMonths();
  
  // If not found, try different lunar years
  // Lunar years span ~March to ~March, so we need to try year-1, year, and year+1
  if (!found) {
    const yearsToTry = [targetYear, targetYear - 1, targetYear + 1];
    
    for (const lunarYear of yearsToTry) {
      if (lunarYear === state.year) continue; // Already tried
      
      state.year = lunarYear;
      updateUI();
      generateCalendar(); // This also updates dateline overview
      
      found = searchInCurrentMonths();
      if (found) break;
    }
  }
  
  if (found) {
    state.currentMonthIndex = found.month;
    const dayObj = state.lunarMonths[found.month].days[found.dayIndex];
    state.highlightedLunarDay = dayObj.lunarDay;
    // Store the actual timestamp from the input (preserves time)
    state.selectedTimestamp = targetDate.getTime();
    renderMonth(state.lunarMonths[state.currentMonthIndex]);
    updateMonthButtons();
    updateURL();
    showDayDetail(dayObj, state.lunarMonths[found.month]);
  } else {
    alert('Date not found in lunar calendar. The Astronomy library may not support this date range.');
  }
}

function selectMonth(index) {
  // Preserve the current day number when switching months
  const previousDay = state.highlightedLunarDay || 1;
  state.currentMonthIndex = index;
  
  // Carry day selection to new month, clamping to valid range
  const newMonth = state.lunarMonths[index];
  const maxDay = newMonth.days.length;
  state.highlightedLunarDay = Math.min(previousDay, maxDay);
  
  // Update selectedTimestamp for the new month's day
  const dayObj = newMonth.days.find(d => d.lunarDay === state.highlightedLunarDay);
  if (dayObj) {
    state.selectedTimestamp = getSunriseTimestamp(dayObj.gregorianDate);
    document.getElementById('goto-date').value = formatLocalDatetime(state.selectedTimestamp);
  }
  
  renderMonth(state.lunarMonths[state.currentMonthIndex]);
  updateMonthButtons();
  updateURL();
  
  // Show day detail for the carried-over day
  if (dayObj) {
    showDayDetail(dayObj, newMonth);
  }
}

function navigateMonth(direction) {
  const newIndex = state.currentMonthIndex + direction;
  const previousDay = state.highlightedLunarDay || 1;
  
  if (newIndex < 0) {
    // Go to previous year, last month
    state.year -= 1;
    updateUI();
    generateCalendar();
    // Jump to last month of previous year
    state.currentMonthIndex = state.lunarMonths.length - 1;
    
    // Preserve day selection, clamped to valid range
    const newMonth = state.lunarMonths[state.currentMonthIndex];
    const maxDay = newMonth.days.length;
    state.highlightedLunarDay = Math.min(previousDay, maxDay);
    const dayObj = newMonth.days.find(d => d.lunarDay === state.highlightedLunarDay);
    if (dayObj) {
      state.selectedTimestamp = getSunriseTimestamp(dayObj.gregorianDate);
      document.getElementById('goto-date').value = formatLocalDatetime(state.selectedTimestamp);
      showDayDetail(dayObj, newMonth);
    }
    
    renderMonth(state.lunarMonths[state.currentMonthIndex]);
    updateMonthButtons();
    updateURL();
  } else if (newIndex >= state.lunarMonths.length) {
    // Go to next year, first month
    state.year += 1;
    updateUI();
    generateCalendar();
    // Already at first month (generateCalendar sets to 0)
    
    // Preserve day selection, clamped to valid range
    const newMonth = state.lunarMonths[state.currentMonthIndex];
    const maxDay = newMonth.days.length;
    state.highlightedLunarDay = Math.min(previousDay, maxDay);
    const dayObj = newMonth.days.find(d => d.lunarDay === state.highlightedLunarDay);
    if (dayObj) {
      state.selectedTimestamp = getSunriseTimestamp(dayObj.gregorianDate);
      document.getElementById('goto-date').value = formatLocalDatetime(state.selectedTimestamp);
      showDayDetail(dayObj, newMonth);
    }
    
    renderMonth(state.lunarMonths[state.currentMonthIndex]);
    updateURL();
  } else {
    // Normal month navigation within same year
    selectMonth(newIndex);
  }
}

function updateMonthButtons() {
  const buttons = document.querySelectorAll('.month-btn');
  buttons.forEach((btn, i) => {
    btn.classList.toggle('active', i === state.currentMonthIndex);
  });
}

function renderMonthButtons() {
  const container = document.getElementById('month-buttons');
  container.innerHTML = '';
  
  const has13Months = state.lunarMonths.length >= 13;
  
  // Month buttons 1-12 (always show)
  for (let i = 0; i < 12; i++) {
    const btn = document.createElement('button');
    btn.className = 'month-btn' + (i === state.currentMonthIndex ? ' active' : '');
    if (i >= state.lunarMonths.length) {
      btn.classList.add('disabled');
      btn.disabled = true;
    }
    btn.textContent = i + 1;
    btn.onclick = () => selectMonth(i);
    container.appendChild(btn);
  }
  
  // Month 13 button (hidden on mobile unless year has 13 months) - with calendar icon
  if (state.lunarMonths.length >= 13) {
    const btn13 = document.createElement('button');
    btn13.className = 'month-btn month-13' + (has13Months ? ' has-13' : '') + (12 === state.currentMonthIndex ? ' active' : '');
    btn13.innerHTML = '<span class="month-13-icon">üìÖ</span><span class="month-13-num">13</span>';
    btn13.title = 'Intercalary 13th month';
    btn13.onclick = () => selectMonth(12);
    container.appendChild(btn13);
  }
}

function formatYear(year) {
  if (year <= 0) {
    // Astronomical year 0 = 1 BC, -1 = 2 BC, etc.
    return Math.abs(year - 1) + ' BC';
  }
  return String(year);  // No "AD" suffix for positive years
}

// Gregorian calendar reform date: October 15, 1582
// Before this date, use Julian calendar (following NASA/Stellarium convention)
const GREGORIAN_REFORM_DATE = new Date(1582, 9, 15); // Oct 15, 1582

// Convert a JavaScript Date (which is proleptic Gregorian) to Julian calendar date
// Returns { year, month, day } in Julian calendar
function gregorianToJulian(date) {
  // JavaScript dates are in proleptic Gregorian calendar
  // We need to convert to Julian for dates before 1582-10-15
  const year = date.getFullYear();
  const month = date.getMonth(); // 0-indexed
  const day = date.getDate();
  
  // Calculate Julian Day Number from Gregorian date
  const a = Math.floor((14 - (month + 1)) / 12);
  const y = year + 4800 - a;
  const m = (month + 1) + 12 * a - 3;
  
  // Julian Day Number for Gregorian calendar
  const jdn = day + Math.floor((153 * m + 2) / 5) + 365 * y + Math.floor(y / 4) - Math.floor(y / 100) + Math.floor(y / 400) - 32045;
  
  // Convert JDN back to Julian calendar date
  const c = jdn + 32082;
  const d = Math.floor((4 * c + 3) / 1461);
  const e = c - Math.floor(1461 * d / 4);
  const n = Math.floor((5 * e + 2) / 153);
  
  const julianDay = e - Math.floor((153 * n + 2) / 5) + 1;
  const julianMonth = n + 3 - 12 * Math.floor(n / 10); // 1-indexed
  const julianYear = d - 4800 + Math.floor(n / 10);
  
  return { year: julianYear, month: julianMonth - 1, day: julianDay }; // month 0-indexed to match JS
}

// Check if a date is before the Gregorian reform
function isBeforeGregorianReform(date) {
  return date < GREGORIAN_REFORM_DATE;
}

// Get formatted date components (handles Julian calendar for pre-1582 dates)
function getFormattedDateParts(date) {
  const weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
  const months = ['January', 'February', 'March', 'April', 'May', 'June', 
                  'July', 'August', 'September', 'October', 'November', 'December'];
  const shortMonths = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  
  let year, month, day, weekday;
  let isJulian = false;
  
  if (isBeforeGregorianReform(date)) {
    const julian = gregorianToJulian(date);
    year = julian.year;
    month = julian.month;
    day = julian.day;
    // Calculate day of week from the JS date (this is correct since it's based on actual time)
    weekday = date.getDay();
    isJulian = true;
  } else {
    year = date.getFullYear();
    month = date.getMonth();
    day = date.getDate();
    weekday = date.getDay();
  }
  
  // Year string: only BC suffix, never AD
  const yearStr = year <= 0 ? `${Math.abs(year - 1)} BC` : `${year}`;
  
  return {
    year,
    yearStr,
    month,
    day,
    weekday,
    weekdayName: weekdays[weekday],
    monthName: months[month],
    shortMonthName: shortMonths[month],
    isJulian,
    calendarSuffix: isJulian ? ' (Julian)' : ''
  };
}

// Format a date for display in day detail panel: "Monday, January 1, 2025"
function formatDisplayDate(date) {
  const parts = getFormattedDateParts(date);
  return `${parts.weekdayName}, ${parts.monthName} ${parts.day}, ${parts.yearStr}${parts.calendarSuffix}`;
}

function getMoonIcon() {
  if (state.moonPhase === 'full') return 'üåï';
  if (state.moonPhase === 'dark') return 'üåë';
  if (state.moonPhase === 'crescent') return 'üåí';
  return 'üåï';
}

function getMoonLabel() {
  if (state.moonPhase === 'full') return 'Full Moon';
  if (state.moonPhase === 'dark') return 'Dark Moon';
  if (state.moonPhase === 'crescent') return 'Crescent';
  return 'New Moon';
}

// Get dynamic description for Renewed Moon based on current moon phase setting
function getRenewedMoonDescription() {
  const dayStartLabel = getDayStartLabel();
  const isCrescentSunset = state.moonPhase === 'crescent' && 
                           state.dayStartTime === 'evening' && 
                           state.dayStartAngle === 0;
  
  if (state.moonPhase === 'full') {
    return `Month begins at ${dayStartLabel} after full moon`;
  } else if (state.moonPhase === 'dark') {
    return `Month begins at ${dayStartLabel} after dark moon (conjunction)`;
  } else if (state.moonPhase === 'crescent') {
    if (isCrescentSunset) {
      return 'Month begins at sunset when first crescent is sighted';
    }
    return `Month begins at ${dayStartLabel} after crescent sighting`;
  }
  return 'Beginning of the month';
}

function generateCalendar(options = {}) {
  const preserveSelection = options.preserveMonth || false;
  
  // Save the selected UTC timestamp before regenerating
  const savedTimestamp = state.selectedTimestamp;
  
  // Read from UI inputs into state
  state.year = parseInt(document.getElementById('year-input').value);
  state.lat = parseFloat(document.getElementById('lat-input').value);
  state.lon = parseFloat(document.getElementById('lon-input').value);
  state.moonPhase = document.getElementById('moon-phase-select').value;
  
  if (!preserveSelection) {
    state.currentMonthIndex = 0;
    state.highlightedLunarDay = null;
    state.selectedTimestamp = null;
  }
  
  // Save settings to localStorage
  saveState();
  
  // Update all UI to match state
  updateUI();
  
  const springEquinox = Astronomy.Seasons(state.year).mar_equinox.date;
  const nextSpringEquinox = Astronomy.Seasons(state.year + 1).mar_equinox.date;
  const moonEvents = findMoonEvents(state.year, state.moonPhase);
  
  // Get year start point based on yearStartRule setting
  const yearStartPoint = getYearStartPoint(state.year);
  const nextYearStartPoint = getYearStartPoint(state.year + 1);
  
  // Find first moon event on or after the year start point
  // The resulting month's Day 1 must start after the year start point
  let nissanMoon = moonEvents.find(m => m >= yearStartPoint);
  if (!nissanMoon) nissanMoon = moonEvents[0];
  
  // Store equinoxes and year start points in state for use in day details
  state.springEquinox = springEquinox;
  state.nextSpringEquinox = nextSpringEquinox;
  state.yearStartPoint = yearStartPoint;
  state.nextYearStartPoint = nextYearStartPoint;
  
  state.lunarMonths = buildLunarMonths(nissanMoon, moonEvents, springEquinox, nextYearStartPoint);
  
  // Guard against empty months array
  if (state.lunarMonths.length === 0) {
    console.error('No lunar months generated - check moon event data');
    console.error('nissanMoon:', nissanMoon);
    console.error('moonEvents count:', moonEvents.length);
    console.error('yearStartPoint:', yearStartPoint);
    console.error('nextYearStartPoint:', nextYearStartPoint);
    return;
  }
  
  // If preserving selection, find which lunar day contains the saved UTC timestamp
  if (preserveSelection && savedTimestamp) {
    const savedMoment = new Date(savedTimestamp);
    let found = false;
    
    for (let m = 0; m < state.lunarMonths.length && !found; m++) {
      const month = state.lunarMonths[m];
      for (let d = 0; d < month.days.length; d++) {
        const day = month.days[d];
        const dayStart = day.gregorianDate.getTime();
        // Day ends at start of next day (24 hours later)
        const dayEnd = dayStart + 24 * 60 * 60 * 1000;
        
        if (savedTimestamp >= dayStart && savedTimestamp < dayEnd) {
          state.currentMonthIndex = m;
          state.highlightedLunarDay = day.lunarDay;
          // Update the goto-date input to show local time at new location
          document.getElementById('goto-date').value = formatLocalDatetime(savedTimestamp);
          found = true;
          break;
        }
      }
    }
    // If timestamp not found in lunar months, just stay on month 0
    if (!found) {
      state.currentMonthIndex = 0;
      state.highlightedLunarDay = null;
    }
  }
  
  renderMonthButtons();
  renderMonth(state.lunarMonths[state.currentMonthIndex]);
  renderFeastTable(state.lunarMonths);
  
  // Show day detail panel if a day is highlighted
  if (state.highlightedLunarDay) {
    const month = state.lunarMonths[state.currentMonthIndex];
    const dayObj = month.days.find(d => d.lunarDay === state.highlightedLunarDay);
    if (dayObj) {
      showDayDetail(dayObj, month);
    }
  }
}

function findMoonEvents(year, phaseType) {
  const events = [];
  let searchDate = new Date(year - 1, 11, 1);
  const endDate = new Date(year + 1, 5, 1); // Search through May of next year to cover full lunar year
  
  // Moon phase angles: 0 = new/dark, 90 = first quarter, 180 = full, 270 = last quarter
  let targetPhase;
  if (phaseType === 'full') {
    targetPhase = 180;
  } else if (phaseType === 'dark') {
    targetPhase = 0;
  } else if (phaseType === 'crescent') {
    targetPhase = 0; // We'll find conjunction then calculate first visibility
  }
  
  // Create observer for crescent visibility calculations
  const observer = new Astronomy.Observer(state.lat, state.lon, 0);
  
  while (searchDate < endDate) {
    const result = Astronomy.SearchMoonPhase(targetPhase, searchDate, 40);
    if (result) {
      let eventDate = result.date;
      
      // For crescent, find the first evening where moon altitude at sunset exceeds threshold
      if (phaseType === 'crescent') {
        const conjunction = result.date;
        let visibilityDate = null;
        
        // Check each evening for up to 5 days after conjunction
        for (let dayOffset = 0; dayOffset < 5; dayOffset++) {
          // Create a date at midnight UTC of the target day to ensure we find THAT day's sunset
          const conjunctionDay = new Date(Date.UTC(
            conjunction.getUTCFullYear(),
            conjunction.getUTCMonth(),
            conjunction.getUTCDate() + dayOffset,
            0, 0, 0
          ));
          
          // Find sunset on this day (searching from midnight will find this evening's sunset)
          const sunset = Astronomy.SearchRiseSet(Astronomy.Body.Sun, observer, -1, conjunctionDay, 1);
          
          if (sunset) {
            // Calculate moon position at sunset
            const moonEquator = Astronomy.Equator(Astronomy.Body.Moon, sunset.date, observer, true, true);
            const moonHorizon = Astronomy.Horizon(sunset.date, observer, moonEquator.ra, moonEquator.dec, 'normal');
            
            // Check if moon altitude exceeds threshold
            if (moonHorizon.altitude >= state.crescentThreshold) {
              visibilityDate = sunset.date;
              break;
            }
          }
        }
        
        // Use visibility date if found, otherwise fallback to conjunction + 1.5 days
        eventDate = visibilityDate || new Date(conjunction.getTime() + 1.5 * 24 * 60 * 60 * 1000);
      }
      
      events.push(eventDate);
      searchDate = new Date(result.date.getTime() + 20 * 24 * 60 * 60 * 1000);
    } else break;
  }
  return events;
}

// Convert UTC date to local date based on longitude (solar time)
function getLocalDateFromUTC(utcDate, longitude) {
  // Calculate timezone offset based on longitude
  // Each 15¬∞ of longitude = 1 hour offset
  const hourOffset = longitude / 15;
  
  // Create a new date adjusted by the longitude offset
  const localTime = new Date(utcDate.getTime() + hourOffset * 60 * 60 * 1000);
  
  // Return just the date part (midnight local time)
  return new Date(localTime.getFullYear(), localTime.getMonth(), localTime.getDate());
}

function buildLunarMonths(nissanMoon, allMoonEvents, springEquinox, nextYearStartPoint) {
  const months = [];
  
  // Use fuzzy timestamp comparison (within 1 second) to handle potential Date object differences
  let startIdx = allMoonEvents.findIndex(m => Math.abs(m.getTime() - nissanMoon.getTime()) < 1000);
  if (startIdx === -1) startIdx = allMoonEvents.findIndex(m => m >= nissanMoon);
  if (startIdx === -1) startIdx = 0; // Final fallback to first event
  
  // Debug logging for troubleshooting empty months
  console.log('buildLunarMonths debug:', {
    nissanMoon: nissanMoon?.toISOString(),
    startIdx,
    totalEvents: allMoonEvents.length,
    nextYearStartPoint: nextYearStartPoint?.toISOString(),
    firstMoonEvent: allMoonEvents[startIdx]?.toISOString(),
    moonPhase: state.moonPhase
  });
  
  // Get observer's longitude for local time calculation
  const observerLon = parseFloat(document.getElementById('lon-input')?.value) || 35.2137;
  
  // Check if we're in crescent + evening + 0¬∞ mode (special case)
  const isCrescentSunset = state.moonPhase === 'crescent' && 
                           state.dayStartTime === 'evening' && 
                           state.dayStartAngle === 0;
  
  for (let m = 0; m < 13 && (startIdx + m) < allMoonEvents.length - 1; m++) {
    const moonEvent = allMoonEvents[startIdx + m];
    
    // Stop if this moon event is after the next year's start point (belongs to next year)
    if (moonEvent >= nextYearStartPoint) break;
    
    const nextMoonEvent = allMoonEvents[startIdx + m + 1];
    
    // Calculate local date of moon event based on observer's longitude
    const moonEventLocalDate = getLocalDateFromUTC(moonEvent, observerLon);
    
    // Determine when Day 1 starts based on day start settings
    let monthStartDate;
    
    if (isCrescentSunset) {
      // Exception: Crescent + Evening + 0¬∞ (Sunset)
      // The day containing the crescent sighting IS Day 1
      // Day 1 starts at sunset of that day
      monthStartDate = new Date(moonEventLocalDate);
    } else {
      // General rule: Day 1 starts at the NEXT day start after the moon event
      // The day containing the moon event is the last day of the prior month
      monthStartDate = new Date(moonEventLocalDate);
      monthStartDate.setDate(monthStartDate.getDate() + 1);
    }
    
    // Same logic for next month start
    const nextMoonEventLocalDate = getLocalDateFromUTC(nextMoonEvent, observerLon);
    let nextMonthStart;
    
    if (isCrescentSunset) {
      nextMonthStart = new Date(nextMoonEventLocalDate);
    } else {
      nextMonthStart = new Date(nextMoonEventLocalDate);
      nextMonthStart.setDate(nextMonthStart.getDate() + 1);
    }
    
    const daysInMonth = Math.round((nextMonthStart - monthStartDate) / (24 * 60 * 60 * 1000));
    
    const days = [];
    for (let d = 1; d <= daysInMonth; d++) {
      const dayDate = new Date(monthStartDate);
      dayDate.setDate(dayDate.getDate() + d - 1);
      
      const isSabbath = [8, 15, 22, 29].includes(d);
      const isNewMoon = d === 1;
      
      // Find all feasts for this day (some days have multiple)
      let feasts = [];
      for (const f of FEASTS) {
        if (f.month === (m + 1)) {
          if (f.endDay) {
            if (d >= f.day && d <= f.endDay) {
              const dayNum = f.startDayNum ? (f.startDayNum + d - f.day) : (d - f.day + 1);
              feasts.push({ feast: f, dayNum });
            }
          } else if (d === f.day) {
            feasts.push({ feast: f, dayNum: null });
          }
        }
      }
      // For backwards compatibility
      const feast = feasts.length > 0 ? feasts[0].feast : null;
      const feastDayNum = feasts.length > 0 ? feasts[0].dayNum : null;
      
      // Moon phase icons depend on which phase starts the month
      let moonPhase = '';
      if (state.moonPhase === 'full') {
        // Full moon start: full ‚Üí last quarter ‚Üí new ‚Üí first quarter ‚Üí full
        if (d === 1) moonPhase = 'üåï';
        else if (d === 8) moonPhase = 'üåó';
        else if (d === 15) moonPhase = 'üåë';
        else if (d === 22) moonPhase = 'üåì';
        else if (d === 29) moonPhase = 'üåï';
      } else if (state.moonPhase === 'dark') {
        // Dark/new moon start: new ‚Üí first quarter ‚Üí full ‚Üí last quarter ‚Üí new
        if (d === 1) moonPhase = 'üåë';
        else if (d === 8) moonPhase = 'üåì';
        else if (d === 15) moonPhase = 'üåï';
        else if (d === 22) moonPhase = 'üåó';
        else if (d === 29) moonPhase = 'üåë';
      } else if (state.moonPhase === 'crescent') {
        // Crescent start (~2 days after new): crescent ‚Üí first quarter ‚Üí full ‚Üí last quarter ‚Üí crescent
        if (d === 1) moonPhase = 'üåí';
        else if (d === 7) moonPhase = 'üåì';
        else if (d === 14) moonPhase = 'üåï';
        else if (d === 21) moonPhase = 'üåó';
        else if (d === 28) moonPhase = 'üåí';
      }
      
      // Check if spring equinox falls on this day
      const dayStart = dayDate.getTime();
      const dayEnd = dayStart + 24 * 60 * 60 * 1000;
      let equinox = null;
      if (springEquinox && springEquinox.getTime() >= dayStart && springEquinox.getTime() < dayEnd) {
        equinox = { type: 'spring', date: springEquinox };
      } else if (state.nextSpringEquinox && state.nextSpringEquinox.getTime() >= dayStart && state.nextSpringEquinox.getTime() < dayEnd) {
        equinox = { type: 'spring', date: state.nextSpringEquinox };
      }
      
      days.push({
        lunarDay: d,
        gregorianDate: dayDate,
        isSabbath,
        isNewMoon,
        feast,
        feastDayNum,
        feasts,  // Array of all feasts for this day
        moonPhase,
        equinox  // Spring equinox if it falls on this day
      });
    }
    
    months.push({
      monthNumber: m + 1,
      name: MONTH_NAMES[m] || `Month ${m + 1}`,
      startDate: monthStartDate,
      moonEvent: moonEvent,
      daysInMonth,
      days
    });
  }
  
  return months;
}

function formatShortDate(date) {
  const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  
  if (isBeforeGregorianReform(date)) {
    // Use Julian calendar for dates before Oct 15, 1582
    const julian = gregorianToJulian(date);
    return `${months[julian.month]} ${julian.day}`;
  }
  
  return `${months[date.getMonth()]} ${date.getDate()}`;
}

// Calculate sunrise timestamp for a given date at the selected location
function getSunriseTimestamp(date) {
  const observer = new Astronomy.Observer(state.lat, state.lon, 0);
  // Search for sunrise starting from midnight of that day
  const midnight = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0);
  const sunrise = Astronomy.SearchRiseSet(Astronomy.Body.Sun, observer, +1, midnight, 1);
  if (sunrise) {
    return sunrise.date.getTime();
  }
  // Fallback to 6am local solar time if no sunrise found (polar regions)
  return date.getTime() + 6 * 60 * 60 * 1000;
}

// Calculate moon altitude at sunset for a given date
// Returns an object with sunset time, moon altitude, and elongation
function getMoonAltitudeAtSunset(date) {
  try {
    const observer = new Astronomy.Observer(state.lat, state.lon, 0);
    const midnight = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0);
    
    // Find sunset on this day
    const sunset = Astronomy.SearchRiseSet(Astronomy.Body.Sun, observer, -1, midnight, 1);
    
    if (!sunset) {
      return null;
    }
    
    // Calculate moon position at sunset
    const moonEquator = Astronomy.Equator(Astronomy.Body.Moon, sunset.date, observer, true, true);
    const moonHorizon = Astronomy.Horizon(sunset.date, observer, moonEquator.ra, moonEquator.dec, 'normal');
    
    // Calculate sun position at sunset
    const sunEquator = Astronomy.Equator(Astronomy.Body.Sun, sunset.date, observer, true, true);
    
    // Calculate elongation using spherical geometry (angular distance between RA/Dec positions)
    // Convert RA from hours to degrees
    const moonRaDeg = moonEquator.ra * 15;
    const sunRaDeg = sunEquator.ra * 15;
    const moonDecRad = moonEquator.dec * Math.PI / 180;
    const sunDecRad = sunEquator.dec * Math.PI / 180;
    const deltaRaRad = (moonRaDeg - sunRaDeg) * Math.PI / 180;
    
    // Spherical law of cosines for angular distance
    const cosAngle = Math.sin(sunDecRad) * Math.sin(moonDecRad) + 
                     Math.cos(sunDecRad) * Math.cos(moonDecRad) * Math.cos(deltaRaRad);
    const elongation = Math.acos(Math.max(-1, Math.min(1, cosAngle))) * 180 / Math.PI;
    
    return {
      sunsetTime: sunset.date,
      moonAltitude: moonHorizon.altitude,
      moonAzimuth: moonHorizon.azimuth,
      elongation: elongation
    };
  } catch (e) {
    console.error('Error calculating moon altitude at sunset:', e);
    return null;
  }
}

// Get the day start time for a given date based on current settings
// Returns a UTC timestamp for when the day starts
function getDayStartTime(date) {
  const observer = new Astronomy.Observer(state.lat, state.lon, 0);
  const midnight = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0);
  
  // Direction: -1 for evening (descending sun), +1 for morning (ascending sun)
  const direction = state.dayStartTime === 'evening' ? -1 : +1;
  
  // For evening, we need to search from noon of the previous day
  // For morning, we search from midnight of this day
  let searchStart = midnight;
  if (state.dayStartTime === 'evening') {
    // Search starting from noon of the previous day to find evening twilight
    searchStart = new Date(midnight.getTime() - 12 * 60 * 60 * 1000);
  }
  
  let result;
  if (state.dayStartAngle === 0) {
    // Use sunrise/sunset (sun at horizon)
    result = Astronomy.SearchRiseSet(Astronomy.Body.Sun, observer, direction, searchStart, 1);
  } else {
    // Use twilight angle (sun below horizon)
    // SearchAltitude finds when sun reaches the specified altitude
    result = Astronomy.SearchAltitude(Astronomy.Body.Sun, observer, direction, searchStart, 1, -state.dayStartAngle);
  }
  
  if (result) {
    return result.date.getTime();
  }
  
  // Fallback for polar regions
  if (state.dayStartTime === 'morning') {
    return midnight.getTime() + 6 * 60 * 60 * 1000; // 6am
  } else {
    return midnight.getTime() - 6 * 60 * 60 * 1000; // 6pm previous day
  }
}

// Get the year start point based on yearStartRule setting
function getYearStartPoint(year) {
  const springEquinox = Astronomy.Seasons(year).mar_equinox.date;
  
  if (state.yearStartRule === '13daysBefore') {
    // Return 13 days before the equinox
    return new Date(springEquinox.getTime() - 13 * 24 * 60 * 60 * 1000);
  }
  
  return springEquinox;
}

// Get human-readable label for current day start setting
function getDayStartLabel() {
  const timeLabel = state.dayStartTime === 'evening' ? 'evening' : 'morning';
  
  let angleLabel;
  switch (state.dayStartAngle) {
    case 0: angleLabel = state.dayStartTime === 'evening' ? 'sunset' : 'sunrise'; break;
    case 6: angleLabel = 'civil twilight'; break;
    case 12: angleLabel = 'nautical twilight'; break;
    case 18: angleLabel = 'astronomical twilight'; break;
    default: angleLabel = `${state.dayStartAngle}¬∞ twilight`;
  }
  
  // Return "morning nautical twilight" instead of "nautical twilight (morning)"
  // For sunrise/sunset, just return that without time prefix
  if (state.dayStartAngle === 0) {
    return angleLabel;
  }
  return `${timeLabel} ${angleLabel}`;
}

// Convert UTC timestamp to local time at the selected longitude
function utcToLocalTime(utcTimestamp, longitude) {
  // Each 15¬∞ of longitude = 1 hour offset
  const hourOffset = longitude / 15;
  return new Date(utcTimestamp + hourOffset * 60 * 60 * 1000);
}

// Convert local time at selected longitude to UTC timestamp
function localTimeToUtc(localDate, longitude) {
  // Each 15¬∞ of longitude = 1 hour offset
  const hourOffset = longitude / 15;
  return localDate.getTime() - hourOffset * 60 * 60 * 1000;
}

// Format date for datetime-local input (YYYY-MM-DDTHH:MM)
// Uses UTC values since we pre-convert to local time
function formatDatetimeLocal(date) {
  return date.getUTCFullYear() + '-' + 
    String(date.getUTCMonth() + 1).padStart(2, '0') + '-' +
    String(date.getUTCDate()).padStart(2, '0') + 'T' +
    String(date.getUTCHours()).padStart(2, '0') + ':' +
    String(date.getUTCMinutes()).padStart(2, '0');
}

// Format UTC timestamp as local time string at selected location
function formatLocalDatetime(utcTimestamp) {
  const localDate = utcToLocalTime(utcTimestamp, state.lon);
  return formatDatetimeLocal(localDate);
}

// Parse datetime-local input as local time at selected location, return UTC timestamp
function parseDatetimeLocal(datetimeStr) {
  // Parse the datetime-local string as if it were UTC
  const [datePart, timePart] = datetimeStr.split('T');
  const [year, month, day] = datePart.split('-').map(Number);
  const [hours, minutes] = timePart.split(':').map(Number);
  
  // Create date as UTC
  const localAsUtc = Date.UTC(year, month - 1, day, hours, minutes);
  
  // Convert from local time at longitude to actual UTC
  return localTimeToUtc(new Date(localAsUtc), state.lon);
}

function formatFullDate(date) {
  const months = ['January', 'February', 'March', 'April', 'May', 'June', 
                  'July', 'August', 'September', 'October', 'November', 'December'];
  
  let year, month, day, calendarSuffix;
  
  if (isBeforeGregorianReform(date)) {
    // Use Julian calendar for dates before Oct 15, 1582
    const julian = gregorianToJulian(date);
    year = julian.year;
    month = julian.month;
    day = julian.day;
    calendarSuffix = ' (Julian)';
  } else {
    // Use Gregorian calendar
    year = date.getFullYear();
    month = date.getMonth();
    day = date.getDate();
    calendarSuffix = '';
  }
  
  // Format year: only show BC suffix, never AD
  const yearStr = year <= 0 ? `${Math.abs(year - 1)} BC` : `${year}`;
  
  return `${months[month]} ${day}, ${yearStr}${calendarSuffix}`;
}

// Calculate the "dateline" longitude - the first place to start the new day
// At any UTC time H, solar noon is at longitude = (12 - H) * 15 degrees
// Sunrise occurs 90¬∞ to the WEST of the subsolar point (6 hours earlier in local time)
// Sunset occurs 90¬∞ to the EAST of the subsolar point (6 hours later in local time)
// The dateline is where the day start event is occurring at the moment of the moon event
// This is the first place on Earth to begin a new day
function calculateDatelineLongitude(moonEventDate, moonPhase) {
  // Get UTC hours as decimal
  const utcHours = moonEventDate.getUTCHours() + moonEventDate.getUTCMinutes() / 60;
  
  // The subsolar point (where it's local noon) at this UTC time
  // At UTC 12:00, noon is at 0¬∞ (Greenwich)
  // At UTC 0:00, noon is at 180¬∞ (International Date Line)
  const subsolarLon = (12 - utcHours) * 15;
  
  let datelineLon;
  if (state.dayStartTime === 'evening') {
    // Sunset is 90¬∞ to the EAST of the subsolar point
    // (At any instant, places east of noon are in afternoon/evening)
    datelineLon = subsolarLon + 90;
    // Adjust for twilight angle - evening twilight occurs BEFORE sunset (further east)
    // Roughly 4¬∞ of longitude per 1¬∞ of sun angle (varies by latitude)
    datelineLon += state.dayStartAngle * 4;
  } else {
    // Sunrise is 90¬∞ to the WEST of the subsolar point
    // (At any instant, places west of noon are in morning)
    datelineLon = subsolarLon - 90;
    // Adjust for twilight angle - morning twilight occurs BEFORE sunrise (further east)
    // For morning, twilight starts earlier, so we add to move east
    datelineLon += state.dayStartAngle * 4;
  }
  
  // Normalize to -180 to 180
  while (datelineLon > 180) datelineLon -= 360;
  while (datelineLon < -180) datelineLon += 360;
  
  return datelineLon;
}

function getDatelineCity(lon) {
  // Find approximate region for the dateline longitude
  if (lon >= 140 || lon < -170) return 'Pacific Ocean (Date Line)';
  if (lon >= 120) return 'Japan / Philippines';
  if (lon >= 100) return 'China / Southeast Asia';
  if (lon >= 70) return 'India / Central Asia';
  if (lon >= 35) return 'Middle East';
  if (lon >= 10) return 'Europe / Africa';
  if (lon >= -30) return 'Atlantic Ocean';
  if (lon >= -50) return 'South America (East)';
  if (lon >= -70) return 'South America (West) / Caribbean';
  if (lon >= -85) return 'Americas (Eastern US / Central America)';
  if (lon >= -105) return 'Americas (Central US / Mexico)';
  if (lon >= -120) return 'Americas (West Coast)';
  if (lon >= -150) return 'Alaska / Hawaii';
  return 'Pacific Ocean';
}

// Get the day start event name for display
function getDayStartEventName() {
  if (state.dayStartAngle === 0) {
    return state.dayStartTime === 'evening' ? 'Sunset' : 'Sunrise';
  } else if (state.dayStartAngle === 6) {
    return state.dayStartTime === 'evening' ? 'Civil Dusk' : 'Civil Dawn';
  } else if (state.dayStartAngle === 12) {
    return state.dayStartTime === 'evening' ? 'Nautical Dusk' : 'Nautical Dawn';
  } else if (state.dayStartAngle === 18) {
    return state.dayStartTime === 'evening' ? 'Astronomical Dusk' : 'Astronomical Dawn';
  }
  return state.dayStartTime === 'evening' ? 'Evening Twilight' : 'Morning Twilight';
}

// Get the day start icon for the marker
function getDayStartIcon() {
  return state.dayStartTime === 'evening' ? 'üåÖ' : '‚òÄ';
}

function renderDatelineVisualization(moonEventDate) {
  const utcHours = moonEventDate.getUTCHours() + moonEventDate.getUTCMinutes() / 60;
  const datelineLon = calculateDatelineLongitude(moonEventDate, state.moonPhase);
  
  // Convert longitude to percentage position (lon -180 = 0%, lon 180 = 100%)
  const position = ((datelineLon + 180) / 360) * 100;
  
  const region = getDatelineCity(datelineLon);
  const lonStr = datelineLon >= 0 
    ? `${Math.abs(datelineLon).toFixed(1)}¬∞E` 
    : `${Math.abs(datelineLon).toFixed(1)}¬∞W`;
  
  // Format moon event date for display
  const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  const moonDateStr = `${months[moonEventDate.getUTCMonth()]} ${moonEventDate.getUTCDate()}, ${moonEventDate.getUTCFullYear()}`;
  const utcTimeStr = `${Math.floor(utcHours).toString().padStart(2,'0')}:${Math.round((utcHours % 1) * 60).toString().padStart(2,'0')} UTC`;
  
  // Get day start event name and icon based on settings
  const dayStartEvent = getDayStartEventName();
  const dayStartIcon = getDayStartIcon();
  const markerLabel = dayStartEvent.toUpperCase();
  
  // Current location marker position
  const currentLat = parseFloat(document.getElementById('lat-input')?.value) || 31.7683;
  const currentLon = parseFloat(document.getElementById('lon-input')?.value) || 35.2137;
  const locX = ((currentLon + 180) / 360) * 100;
  const locY = ((90 - currentLat) / 180) * 100;
  
  
  return `
    <div class="dateline-container">
      <div class="dateline-label">${dayStartEvent} line at moment of ${getMoonLabel()} ‚Äî ${moonDateStr} ‚Äî ${utcTimeStr}</div>
      <div class="dateline-map" onclick="handleMapClick(event)">
        <div class="dateline-map-bg">
          <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/23/Blue_Marble_2002.png/1280px-Blue_Marble_2002.png" 
               alt="World Map"
               onerror="this.style.display='none'">
        </div>
        <div class="dateline-marker" style="left: ${position}%">
          <span class="dateline-marker-icon">${dayStartIcon}</span>
          <span class="dateline-marker-label">${markerLabel}</span>
        </div>
        <div class="dateline-location-marker" style="left: ${locX}%; top: ${locY}%" title="Your Location: ${currentLat.toFixed(2)}¬∞, ${currentLon.toFixed(2)}¬∞"></div>
      </div>
      <div class="dateline-cities">
        <span>180¬∞W</span>
        <span>90¬∞W</span>
        <span>0¬∞</span>
        <span>90¬∞E</span>
        <span>180¬∞E</span>
      </div>
      <div class="dateline-info">Day start line: ${lonStr} ‚Äî ${region}</div>
      <div class="dateline-info" style="color: #7ec8e3;">Your location: ${currentLat.toFixed(2)}¬∞${currentLat >= 0 ? 'N' : 'S'}, ${Math.abs(currentLon).toFixed(2)}¬∞${currentLon >= 0 ? 'E' : 'W'}</div>
      <div class="dateline-click-hint">Click map to change location ‚Ä¢ First to reach ${dayStartEvent.toLowerCase()} after ${getMoonLabel()} starts month first</div>
    </div>
  `;
}

function formatMoonDateTime(date) {
  const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
  
  // UTC date and time
  const utcDay = days[date.getUTCDay()];
  const utcMonth = months[date.getUTCMonth()];
  const utcDate = date.getUTCDate();
  const utcHours = date.getUTCHours().toString().padStart(2, '0');
  const utcMins = date.getUTCMinutes().toString().padStart(2, '0');
  
  // Local date and time
  const localDay = days[date.getDay()];
  const localMonth = months[date.getMonth()];
  const localDate = date.getDate();
  const localHours = date.getHours().toString().padStart(2, '0');
  const localMins = date.getMinutes().toString().padStart(2, '0');
  
  // Get timezone abbreviation
  const tzName = Intl.DateTimeFormat('en-US', { timeZoneName: 'short' }).formatToParts(date)
    .find(part => part.type === 'timeZoneName')?.value || 'Local';
  
  // Check if UTC and local are on different calendar days
  const sameDay = (date.getUTCDate() === date.getDate() && 
                   date.getUTCMonth() === date.getMonth() &&
                   date.getUTCFullYear() === date.getFullYear());
  
  if (sameDay) {
    return `${localDay}, ${localMonth} ${localDate}<br>` +
           `UTC: ${utcHours}:${utcMins}<br>` +
           `${tzName}: ${localHours}:${localMins}`;
  } else {
    // Show both dates when they differ
    return `UTC: ${utcDay}, ${utcMonth} ${utcDate} ${utcHours}:${utcMins}<br>` +
           `${tzName}: ${localDay}, ${localMonth} ${localDate} ${localHours}:${localMins}`;
  }
}

function renderMonth(month) {
  const scripture = SCRIPTURES[month.monthNumber % SCRIPTURES.length];
  
  const container = document.getElementById('calendar-output');
  
  // Day 1 is New Moon shown in header
  // Days 2-8 form the first week, 9-15 second week, etc.
  // Sabbath (days 8, 15, 22, 29) is always in the rightmost column
  
  // Find Day 2's Gregorian weekday to determine the weekday labels
  const day2 = month.days.find(d => d.lunarDay === 2);
  const day2Weekday = day2 ? day2.gregorianDate.getDay() : 0;
  
  // Generate weekday labels starting from Day 2's weekday
  const weekdayNames = ['Sun.', 'Mon.', 'Tue.', 'Wed.', 'Thu.', 'Fri.', 'Sat.'];
  const shiftedWeekdays = [];
  for (let i = 0; i < 7; i++) {
    shiftedWeekdays.push(weekdayNames[(day2Weekday + i) % 7]);
  }
  
  // Get Day 1 info for header
  const day1 = month.days.find(d => d.lunarDay === 1);
  const day1Date = day1 ? formatShortDate(day1.gregorianDate) : '';
  const day1Year = day1 ? day1.gregorianDate.getFullYear() : '';
  const day1Weekday = day1 ? weekdayNames[day1.gregorianDate.getDay()] : '';
  
  // Check for feasts on day 1
  let day1FeastIcons = '';
  if (day1 && day1.feasts && day1.feasts.length > 0) {
    const icons = [...new Set(day1.feasts.map(f => f.feast.icon))];
    day1FeastIcons = `<div class="feast-icons">${icons.join('')}</div>`;
  }
  
  // Get the year the lunar year started (from first month's day 1)
  const firstMonth = state.lunarMonths[0];
  const firstDay1 = firstMonth ? firstMonth.days.find(d => d.lunarDay === 1) : null;
  const lunarYearStart = firstDay1 ? firstDay1.gregorianDate.getFullYear() : state.year;
  const displayYear = `from ${formatYear(lunarYearStart)}`;
  
  let html = `
    <div class="month-calendar">
      <div class="calendar-header">
        <div class="header-left">
          <div class="full-moon-info" onclick="toggleSettings()" title="Change moon phase or location">
            <div class="moon-icon-wrapper">
              <div class="moon-icon">${getMoonIcon()}</div>
              <div class="moon-gear-badge">‚öô</div>
            </div>
          </div>
          <div class="calendar-title">
            <div class="site-title">Lunar Sabbath Calendar</div>
            <div class="site-tagline">a time tested tradition <a href="/book/" class="book-link">üìñ</a></div>
            <div class="month-year-row" onclick="toggleMonthPicker()">
              <div class="month-name">${month.name} <span class="dropdown-arrow">‚ñº</span></div>
              <div class="year">${displayYear}</div>
            </div>
          </div>
          <button class="export-header-btn" onclick="event.stopPropagation(); toggleExportModal();" title="View Feasts & Export to Calendar">
            <span class="icon">üìÖ</span>
            <span class="label">Feasts</span>
          </button>
        </div>
        <div class="new-moon-box day-cell new-moon${state.highlightedLunarDay === 1 ? ' highlighted' : ''}${day1 && day1.feasts && day1.feasts.length > 0 ? ' feast' : ''}" data-date="${day1 ? day1.gregorianDate.toISOString().split('T')[0] : ''}" data-lunar-day="1">
          <div class="gregorian">${day1Date}<span class="day-year">${day1Year}</span></div>
          <div class="moon-phase">${day1 ? day1.moonPhase : ''}</div>
          <div class="lunar-day">1</div>
          ${day1FeastIcons}
        </div>
      </div>
      
      <div class="week-header">
        <div class="day-label"><div class="day-name">Day 1</div><div class="weekday">${shiftedWeekdays[0]}</div></div>
        <div class="day-label"><div class="day-name">Day 2</div><div class="weekday">${shiftedWeekdays[1]}</div></div>
        <div class="day-label"><div class="day-name">Day 3</div><div class="weekday">${shiftedWeekdays[2]}</div></div>
        <div class="day-label"><div class="day-name">Day 4</div><div class="weekday">${shiftedWeekdays[3]}</div></div>
        <div class="day-label"><div class="day-name">Day 5</div><div class="weekday">${shiftedWeekdays[4]}</div></div>
        <div class="day-label"><div class="day-name">Day 6</div><div class="weekday">${shiftedWeekdays[5]}</div></div>
        <div class="day-label"><div class="day-name">SABBATH</div><div class="weekday">${shiftedWeekdays[6]}</div></div>
      </div>
      
      <div class="calendar-grid">
  `;
  
  // Build rows by lunar week structure: 2-8, 9-15, 16-22, 23-29
  // The last row (day 30 + scripture) is handled separately
  const lunarWeeks = [
    [2, 3, 4, 5, 6, 7, 8],
    [9, 10, 11, 12, 13, 14, 15],
    [16, 17, 18, 19, 20, 21, 22],
    [23, 24, 25, 26, 27, 28, 29]
  ];
  
  for (const week of lunarWeeks) {
    for (const lunarDay of week) {
      const day = month.days.find(d => d.lunarDay === lunarDay);
      
      if (!day) {
        // Day doesn't exist in this month
        html += `<div class="day-cell empty"></div>`;
        continue;
      }
      
      let classes = ['day-cell'];
      if (day.isSabbath) classes.push('sabbath');
      if (day.isNewMoon) classes.push('new-moon');
      if (day.feasts && day.feasts.length > 0) classes.push('feast');
      if (day.lunarDay === state.highlightedLunarDay) classes.push('highlighted');
      
      let feastLabel = '';
      const icons = [];
      if (day.feasts && day.feasts.length > 0) {
        // Show icons for feasts (unique icons only)
        icons.push(...new Set(day.feasts.map(f => f.feast.icon)));
      }
      // Add equinox icon if applicable
      if (day.equinox) {
        icons.push('‚òÄÔ∏è‚öñÔ∏è');
      }
      if (icons.length > 0) {
        feastLabel = `<div class="feast-icons">${icons.join('')}</div>`;
      }
      
      // Format date for data attribute (YYYY-MM-DD)
      const dateStr = day.gregorianDate.toISOString().split('T')[0];
      const titleText = day.feasts && day.feasts.length > 0 
        ? day.feasts.map(f => f.feast.name + ': ' + f.feast.description).join(' | ')
        : '';
      
      const isHighlighted = day.lunarDay === state.highlightedLunarDay;
      html += `
        <div class="${classes.join(' ')}" data-date="${dateStr}" title="${titleText}">
          <div class="gregorian">${formatShortDate(day.gregorianDate)}</div>
          <div class="moon-phase">${day.moonPhase}</div>
          <div class="lunar-day">${day.lunarDay}</div>
          ${feastLabel}
        </div>
      `;
    }
  }
  
  // Last row: Day 30 (or spacer) + Prev + Scripture quote + Next
  // Layout: [Day30/spacer][Prev][Quote span-4][Next]
  const day30 = month.days.find(d => d.lunarDay === 30);
  const isFirstMonth = state.currentMonthIndex === 0;
  const isLastMonth = state.currentMonthIndex >= state.lunarMonths.length - 1;
  
  if (day30) {
    // Day 30 exists
    let classes = ['day-cell'];
    if (day30.feasts && day30.feasts.length > 0) classes.push('feast');
    if (day30.lunarDay === state.highlightedLunarDay) classes.push('highlighted');
    
    let feastLabel = '';
    const icons = [];
    if (day30.feasts && day30.feasts.length > 0) {
      icons.push(...new Set(day30.feasts.map(f => f.feast.icon)));
    }
    if (day30.equinox) {
      icons.push('‚òÄÔ∏è‚öñÔ∏è');
    }
    if (icons.length > 0) {
      feastLabel = `<div class="feast-icons">${icons.join('')}</div>`;
    }
    
    const dateStr = day30.gregorianDate.toISOString().split('T')[0];
    const titleText = day30.feasts && day30.feasts.length > 0 
      ? day30.feasts.map(f => f.feast.name + ': ' + f.feast.description).join(' | ')
      : '';
    const isHighlighted30 = day30.lunarDay === state.highlightedLunarDay;
    
    html += `
      <div class="${classes.join(' ')}" data-date="${dateStr}" title="${titleText}">
        <div class="gregorian">${formatShortDate(day30.gregorianDate)}</div>
        <div class="moon-phase">${day30.moonPhase}</div>
        <div class="lunar-day">${day30.lunarDay}</div>
        ${feastLabel}
      </div>
    `;
  } else {
    // No day 30 - use empty height-setter cell
    html += `<div class="day-cell empty quote-row-spacer"></div>`;
  }
  
  // Prev button - goes to previous year if at first month
  html += `
    <div class="month-nav-cell" onclick="navigateMonth(-1)" title="${isFirstMonth ? 'Previous Year' : 'Previous Month'}">
      <span class="nav-arrow">${isFirstMonth ? '‚èÆ' : '‚óÄ'}</span>
    </div>
  `;
  
  // Scripture quote (span 4 columns)
  html += `
    <div class="scripture-quote span-4">
      "${scripture.text}" <span class="reference">${scripture.ref}</span>
    </div>
  `;
  
  // Next button - goes to next year if at last month
  html += `
    <div class="month-nav-cell" onclick="navigateMonth(1)" title="${isLastMonth ? 'Next Year' : 'Next Month'}">
      <span class="nav-arrow">${isLastMonth ? '‚è≠' : '‚ñ∂'}</span>
    </div>
  `;
  
  html += `
      </div>
    </div>
  `;
  
  container.innerHTML = html;
}

function jumpToFeast(monthIdx, lunarDay) {
  if (monthIdx >= 0 && monthIdx < state.lunarMonths.length) {
    state.currentMonthIndex = monthIdx;
    state.highlightedLunarDay = lunarDay;
    // Store timestamp for the feast day (sunrise)
    const month = state.lunarMonths[monthIdx];
    const dayObj = month.days.find(d => d.lunarDay === lunarDay);
    if (dayObj) {
      state.selectedTimestamp = getSunriseTimestamp(dayObj.gregorianDate);
      document.getElementById('goto-date').value = formatLocalDatetime(state.selectedTimestamp);
      showDayDetail(dayObj, month);
    }
    renderMonth(month);
    updateMonthButtons();
    updateURL();
    // Scroll to calendar
    document.querySelector('.month-calendar').scrollIntoView({ behavior: 'smooth' });
  }
}

function renderFeastTable(months) {
  const tbody = document.getElementById('feast-tbody');
  tbody.innerHTML = '';
  
  // Track which feasts we've already shown (for multi-month feasts like Hanukkah)
  const shownFeasts = new Set();
  
  // Collect all feast entries first
  const feastEntries = [];
  
  for (const feast of FEASTS) {
    // Skip if this is a continuation entry we've already handled
    if (feast.continuesNextMonth === undefined && shownFeasts.has(feast.name)) continue;
    
    const month = months.find(m => m.monthNumber === feast.month);
    if (!month) continue;
    
    const day = month.days.find(d => d.lunarDay === feast.day);
    if (!day) continue;
    
    let dateStr, gregDate;
    
    // Handle Hanukkah spanning two months
    if (feast.name === 'Hanukkah' && feast.continuesNextMonth) {
      shownFeasts.add('Hanukkah');
      const nextMonth = months.find(m => m.monthNumber === feast.month + 1);
      dateStr = `Month ${feast.month} day 25 - Month ${feast.month + 1} day 2`;
      
      const endDay = nextMonth ? nextMonth.days.find(d => d.lunarDay === 2) : null;
      gregDate = endDay 
        ? `${formatShortDate(day.gregorianDate)} - ${formatShortDate(endDay.gregorianDate)}`
        : formatFullDate(day.gregorianDate) + ' (8 days)';
    } else if (feast.name === 'Hanukkah' && !feast.continuesNextMonth) {
      // Skip the continuation entry in table
      continue;
    } else {
      dateStr = feast.endDay 
        ? `Month ${feast.month} days ${feast.day}-${feast.endDay}`
        : `Month ${feast.month} day ${feast.day}`;
      
      gregDate = formatFullDate(day.gregorianDate);
      if (feast.endDay) {
        const endDay = month.days.find(d => d.lunarDay === feast.endDay);
        if (endDay) gregDate = `${formatShortDate(day.gregorianDate)} - ${formatShortDate(endDay.gregorianDate)}`;
      }
    }
    
    const monthIdx = months.findIndex(m => m.monthNumber === feast.month);
    const dayIdx = feast.day;
    
    feastEntries.push({
      feast,
      day,
      dateStr,
      gregDate,
      monthIdx,
      dayIdx,
      sortDate: day.gregorianDate
    });
  }
  
  // Sort by Gregorian date
  feastEntries.sort((a, b) => a.sortDate.getTime() - b.sortDate.getTime());
  
  // Render sorted entries
  for (const entry of feastEntries) {
    // Use dynamic description for Renewed Moon based on current moon phase setting
    const description = entry.feast.name === 'Renewed Moon' 
      ? getRenewedMoonDescription() 
      : entry.feast.description;
    
    tbody.innerHTML += `
      <tr>
        <td><a href="#" class="feast-jump" data-month="${entry.monthIdx}" data-day="${entry.dayIdx}" style="color: inherit; text-decoration: none;"><strong>${entry.feast.name}</strong></a></td>
        <td><a href="#" class="feast-jump" data-month="${entry.monthIdx}" data-day="${entry.dayIdx}" style="color: inherit; text-decoration: none;">
          <div>${entry.dateStr}</div>
          <div style="color: #666; font-size: 0.9em;">${entry.gregDate}</div>
        </a></td>
        <td><a href="${entry.feast.chapter}" style="color: #2c5282;">${description} ‚Üí</a></td>
      </tr>
    `;
  }
}

document.addEventListener('DOMContentLoaded', function() {
  // Check if URL has parameters - if so, load from URL, otherwise jump to today
  const params = new URLSearchParams(window.location.search);
  if (params.has('year') || params.has('view')) {
    // URL has state - restore from URL
    updateUI(); // Set UI from localStorage first
    generateCalendar();
    loadFromURL(); // Then override with URL params
  } else {
    // No URL params - always jump to today's date on fresh load
    jumpToToday();
    updateURL(); // Set initial URL
  }
  
  // Event delegation for feast table clicks
  document.getElementById('feast-tbody').addEventListener('click', function(e) {
    const link = e.target.closest('.feast-jump');
    if (link) {
      e.preventDefault();
      const monthIdx = parseInt(link.dataset.month);
      const lunarDay = parseInt(link.dataset.day);
      jumpToFeast(monthIdx, lunarDay);
    }
  });
  
  // Event delegation for calendar day cell clicks - update goto-date input and highlight
  document.getElementById('calendar-output').addEventListener('click', function(e) {
    // Check for day cell click
    const cell = e.target.closest('.day-cell[data-date]');
    if (cell) {
      // Find the lunar day for this cell and store the timestamp
      const lunarDayEl = cell.querySelector('.lunar-day');
      if (lunarDayEl) {
        const lunarDay = parseInt(lunarDayEl.textContent);
        const month = state.lunarMonths[state.currentMonthIndex];
        const dayObj = month.days.find(d => d.lunarDay === lunarDay);
        if (dayObj) {
          // Calculate sunrise time at selected location for this day
          state.selectedTimestamp = getSunriseTimestamp(dayObj.gregorianDate);
          document.getElementById('goto-date').value = formatLocalDatetime(state.selectedTimestamp);
          showDayDetail(dayObj, month);
        }
        state.highlightedLunarDay = lunarDay;
        renderMonth(state.lunarMonths[state.currentMonthIndex]);
        updateURL();
      }
      return;
    }
    
    // Check for new-moon-box (Day 1) click
    const newMoonBox = e.target.closest('.new-moon-box[data-date]');
    if (newMoonBox) {
      const month = state.lunarMonths[state.currentMonthIndex];
      const dayObj = month.days.find(d => d.lunarDay === 1);
      if (dayObj) {
        // Calculate sunrise time at selected location for this day
        state.selectedTimestamp = getSunriseTimestamp(dayObj.gregorianDate);
        document.getElementById('goto-date').value = formatLocalDatetime(state.selectedTimestamp);
        showDayDetail(dayObj, month);
      }
      state.highlightedLunarDay = 1;
      renderMonth(state.lunarMonths[state.currentMonthIndex]);
      updateURL();
    }
  });
});

// Helper function to refresh day detail panel if one is currently shown
function refreshDayDetailIfVisible() {
  if (state.highlightedLunarDay !== null && state.lunarMonths[state.currentMonthIndex]) {
    const month = state.lunarMonths[state.currentMonthIndex];
    const dayObj = month.days.find(d => d.lunarDay === state.highlightedLunarDay);
    if (dayObj) {
      showDayDetail(dayObj, month);
    }
  }
}

// Show the day detail panel with information about the selected day
function showDayDetail(dayObj, month) {
  const panel = document.getElementById('day-detail-panel');
  
  // Populate lunar date
  const ordinal = getOrdinalSuffix(month.monthNumber);
  const lunarDateStr = `Day ${dayObj.lunarDay} of the ${month.monthNumber}${ordinal} Month`;
  panel.querySelector('.day-detail-lunar').textContent = lunarDateStr;
  
  // Populate gregorian/julian date
  const gregDate = dayObj.gregorianDate;
  panel.querySelector('.day-detail-gregorian').textContent = formatDisplayDate(gregDate);
  
  // Populate feasts
  const feastsContainer = panel.querySelector('.day-detail-feasts');
  feastsContainer.innerHTML = '';
  
  if (dayObj.feasts && dayObj.feasts.length > 0) {
    for (const f of dayObj.feasts) {
      const feast = f.feast;
      const dayNum = f.dayNum;
      const nameText = dayNum ? `${feast.name} (Day ${dayNum})` : feast.name;
      
      // Check if this is a Renewed Moon feast and we have moon event data
      let basisHtml = '';
      if (feast.name === 'Renewed Moon' && dayObj.lunarDay === 1 && month.moonEvent) {
        const moonEventTime = month.moonEvent;
        const signName = getMoonLabel();
        
        // Format moon event date in a friendly way
        const moonEventDate = new Date(moonEventTime);
        const moonParts = getFormattedDateParts(moonEventDate);
        const dayOfWeek = moonParts.weekdayName;
        const monthName = moonParts.shortMonthName;
        const dayNum = moonParts.day;
        const daySuffix = getOrdinalSuffix(dayNum);
        const year = moonParts.yearStr;
        const moonTimeStr = moonEventDate.toLocaleTimeString('en-US', { 
          hour: 'numeric', minute: '2-digit', hour12: true 
        });
        
        // Get day start time based on current settings
        const dayStartTimestamp = getDayStartTime(dayObj.gregorianDate);
        const dayStartDate = new Date(dayStartTimestamp);
        const dayStartStr = dayStartDate.toLocaleTimeString('en-US', { 
          hour: 'numeric', minute: '2-digit', hour12: true 
        });
        const dayStartLabel = getDayStartLabel();
        
        // Calculate time difference between moon event and day start
        const diffMs = dayStartTimestamp - moonEventTime.getTime();
        const diffMins = Math.round(Math.abs(diffMs) / (1000 * 60));
        const hours = Math.floor(diffMins / 60);
        const mins = diffMins % 60;
        
        let timeDiffStr = '';
        if (hours > 0 && mins > 0) {
          timeDiffStr = `${hours} hour${hours > 1 ? 's' : ''} ${mins} minute${mins > 1 ? 's' : ''}`;
        } else if (hours > 0) {
          timeDiffStr = `${hours} hour${hours > 1 ? 's' : ''}`;
        } else {
          timeDiffStr = `${mins} minute${mins > 1 ? 's' : ''}`;
        }
        
        const beforeAfter = diffMs > 0 ? 'before' : 'after';
        
        // Determine tense based on whether the date is past or future
        const now = new Date();
        const isPast = moonEventDate < now;
        const occurVerb = isPast ? 'occurred' : 'will occur';
        
        // Check if this is crescent + sunset mode (special case where crescent day IS Day 1)
        const isCrescentSunset = state.moonPhase === 'crescent' && 
                                 state.dayStartTime === 'evening' && 
                                 state.dayStartAngle === 0;
        
        // Get moon altitude at sunset for crescent mode
        let crescentAltitudeInfo = '';
        if (state.moonPhase === 'crescent') {
          const moonData = getMoonAltitudeAtSunset(moonEventDate);
          if (moonData) {
            const altStr = moonData.moonAltitude.toFixed(1);
            const elongStr = moonData.elongation.toFixed(1);
            const sunsetStr = moonData.sunsetTime.toLocaleTimeString('en-US', { 
              hour: 'numeric', minute: '2-digit', hour12: true 
            });
            crescentAltitudeInfo = ` At sunset (${sunsetStr}), the moon was ${altStr}¬∞ above the horizon (threshold: ${state.crescentThreshold}¬∞, elongation: ${elongStr}¬∞).`;
          }
        }
        
        // Build explanation based on moon phase type and day start settings
        // beforeAfter: 'before' means day start is AFTER moon event (positive diffMs)
        // beforeAfter: 'after' means day start is BEFORE moon event (negative diffMs)
        const laterEarlier = beforeAfter === 'before' ? 'later' : 'earlier';
        
        let explanationText = '';
        if (state.moonPhase === 'full') {
          explanationText = `The Full Moon ${occurVerb} on ${dayOfWeek}, ${monthName} ${dayNum}${daySuffix}, ${year} at ${moonTimeStr}. ` +
            `The month begins ${timeDiffStr} ${laterEarlier} at ${dayStartLabel} (${dayStartStr}).`;
        } else if (state.moonPhase === 'dark') {
          explanationText = `The Dark Moon (conjunction) ${occurVerb} on ${dayOfWeek}, ${monthName} ${dayNum}${daySuffix}, ${year} at ${moonTimeStr}. ` +
            `The month begins ${timeDiffStr} ${laterEarlier} at ${dayStartLabel} (${dayStartStr}).`;
        } else if (state.moonPhase === 'crescent') {
          if (isCrescentSunset) {
            explanationText = `The first visible Crescent Moon ${occurVerb} on ${dayOfWeek}, ${monthName} ${dayNum}${daySuffix}, ${year}. ` +
              `The month begins immediately at sunset following the sighting.${crescentAltitudeInfo}`;
          } else {
            explanationText = `The first visible Crescent Moon ${occurVerb} on ${dayOfWeek}, ${monthName} ${dayNum}${daySuffix}, ${year}. ` +
              `The month begins ${timeDiffStr} ${laterEarlier} at ${dayStartLabel} (${dayStartStr}).${crescentAltitudeInfo}`;
          }
        } else {
          explanationText = `The ${signName} ${occurVerb} on ${dayOfWeek}, ${monthName} ${dayNum}${daySuffix}, ${year} at ${moonTimeStr}. ` +
            `The month begins ${timeDiffStr} ${laterEarlier} at ${dayStartLabel} (${dayStartStr}).`;
        }
        
        basisHtml = `
          <div class="feast-basis">
            ${explanationText}
          </div>
        `;
      }
      
      // Generate dynamic description for Renewed Moon based on current moon phase setting
      const feastDescription = feast.name === 'Renewed Moon' 
        ? getRenewedMoonDescription() 
        : feast.description;
      
      const item = document.createElement('div');
      item.className = 'day-detail-feast-item';
      item.innerHTML = `
        <div class="day-detail-feast-icon">${feast.icon}</div>
        <div class="day-detail-feast-info">
          <div class="day-detail-feast-name">${nameText}</div>
          <div class="day-detail-feast-desc">${feastDescription}</div>
          ${basisHtml}
          ${feast.chapter ? `<a href="${feast.chapter}" class="day-detail-feast-link">Learn more &rarr;</a>` : ''}
        </div>
      `;
      feastsContainer.appendChild(item);
    }
  } else if (!dayObj.equinox) {
    feastsContainer.innerHTML = '<div class="day-detail-no-feast">No appointed times on this day</div>';
  }
  
  // Add equinox info if this day has the spring equinox
  if (dayObj.equinox) {
    const equinoxDate = dayObj.equinox.date;
    const eqParts = getFormattedDateParts(equinoxDate);
    const dayOfWeek = eqParts.weekdayName;
    const monthName = eqParts.monthName;
    const dayNum = eqParts.day;
    const daySuffix = getOrdinalSuffix(dayNum);
    const year = eqParts.yearStr;
    const timeStr = equinoxDate.toLocaleTimeString('en-US', { 
      hour: 'numeric', minute: '2-digit', hour12: true 
    });
    
    const now = new Date();
    const isPast = equinoxDate < now;
    const verb = isPast ? 'occurred' : 'will occur';
    
    const item = document.createElement('div');
    item.className = 'day-detail-feast-item';
    item.innerHTML = `
      <div class="day-detail-feast-icon">‚òÄÔ∏è‚öñÔ∏è</div>
      <div class="day-detail-feast-info">
        <div class="day-detail-feast-name">Spring Equinox</div>
        <div class="day-detail-feast-desc">The moment when day and night are equal in length, marking the astronomical beginning of spring.</div>
        <div class="feast-basis">
          The Spring Equinox ${verb} on ${dayOfWeek}, ${monthName} ${dayNum}${daySuffix}, ${year} at ${timeStr}.
        </div>
        <a href="/chapters/08-when-does-the-year-start/" class="day-detail-feast-link">Learn more &rarr;</a>
      </div>
    `;
    feastsContainer.appendChild(item);
  }
  
  // Add year start explanation for 1st day of 1st month, or 13th month explanation
  if (dayObj.lunarDay === 1 && (month.monthNumber === 1 || month.monthNumber === 13)) {
    const item = document.createElement('div');
    item.className = 'day-detail-feast-item day-detail-year-info';
    
    const totalMonths = state.lunarMonths.length;
    const has13thMonth = totalMonths === 13;
    const moonLabel = getMoonLabel();
    
    // Get spring equinox for this lunar year
    const springEquinox = Astronomy.Seasons(state.year).mar_equinox.date;
    const seqParts = getFormattedDateParts(springEquinox);
    const equinoxDateStr = `${seqParts.weekdayName}, ${seqParts.monthName} ${seqParts.day}${getOrdinalSuffix(seqParts.day)}, ${seqParts.yearStr}${seqParts.calendarSuffix}`;
    
    // Check if we're in crescent + sunset mode
    const isCrescentSunset = state.moonPhase === 'crescent' && 
                             state.dayStartTime === 'evening' && 
                             state.dayStartAngle === 0;
    
    // Calculate time from equinox to month start (day 1 day-start)
    // For crescent+sunset, use the moon event time (crescent sighting = sunset)
    let day1StartTs;
    if (isCrescentSunset && month.moonEvent) {
      day1StartTs = month.moonEvent.getTime();
    } else {
      day1StartTs = getDayStartTime(dayObj.gregorianDate);
    }
    const diffMs = day1StartTs - springEquinox.getTime();
    const diffTotalHours = diffMs / (1000 * 60 * 60);
    const diffDays = Math.floor(Math.abs(diffTotalHours) / 24);
    const diffHours = Math.round(Math.abs(diffTotalHours) % 24);
    
    let timingStr = '';
    if (diffDays > 0 && diffHours > 0) {
      timingStr = `${diffDays} day${diffDays !== 1 ? 's' : ''} and ${diffHours} hour${diffHours !== 1 ? 's' : ''}`;
    } else if (diffDays > 0) {
      timingStr = `${diffDays} day${diffDays !== 1 ? 's' : ''}`;
    } else {
      timingStr = `${diffHours} hour${diffHours !== 1 ? 's' : ''}`;
    }
    const beforeAfter = diffMs >= 0 ? 'after' : 'before';
    
    if (month.monthNumber === 1) {
      // Positive reason: explain why year CAN start here using current moon phase setting
      const dayStartLabel = getDayStartLabel();
      const day1StartDate = new Date(day1StartTs);
      const day1StartStr = day1StartDate.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
      const day1Parts = getFormattedDateParts(day1StartDate);
      const day1DateStr = `${day1Parts.weekdayName}, ${day1Parts.monthName} ${day1Parts.day}${getOrdinalSuffix(day1Parts.day)}`;
      
      const yearMonthInfo = `Day 1 begins at ${dayStartLabel} (${day1DateStr} at ${day1StartStr}), which is ${timingStr} ${beforeAfter} the <a href="#" class="equinox-link" data-equinox-date="${springEquinox.toISOString()}">Spring Equinox (${equinoxDateStr})</a>. This qualifies as the 1st month of Lunar Year ${state.year}.`;
      
      item.innerHTML = `
        <div class="day-detail-feast-icon">üìÖ</div>
        <div class="day-detail-feast-info">
          <div class="day-detail-feast-name">Lunar Year ${state.year} Begins</div>
          <div class="day-detail-feast-desc">${yearMonthInfo}</div>
        </div>
      `;
      feastsContainer.appendChild(item);
      
      // Add click handler for equinox link
      const equinoxLink = item.querySelector('.equinox-link');
      if (equinoxLink) {
        equinoxLink.addEventListener('click', (e) => {
          e.preventDefault();
          jumpToEquinoxDate(springEquinox);
        });
      }
    } else if (month.monthNumber === 13) {
      // Explain why 13th month exists: its day-start is BEFORE the next year's start point
      const nextEquinox = Astronomy.Seasons(state.year + 1).mar_equinox.date;
      const neqParts = getFormattedDateParts(nextEquinox);
      const nextEquinoxDateStr = `${neqParts.weekdayName}, ${neqParts.monthName} ${neqParts.day}${getOrdinalSuffix(neqParts.day)}, ${neqParts.yearStr}${neqParts.calendarSuffix}`;
      
      // Get the 13th month's moon event (crescent/full/dark)
      const month13MoonEvent = month.moonEvent;
      let moonEventStr = '';
      let dayStartStr = '';
      let timingExplanation = '';
      
      if (month13MoonEvent) {
        const moonParts = getFormattedDateParts(month13MoonEvent);
        const moonTimeStr = month13MoonEvent.toLocaleTimeString('en-US', { 
          hour: 'numeric', minute: '2-digit', hour12: true 
        });
        moonEventStr = `${moonParts.weekdayName}, ${moonParts.monthName} ${moonParts.day}${getOrdinalSuffix(moonParts.day)}, ${moonParts.yearStr} at ${moonTimeStr}`;
        
        // Check if we're in crescent + sunset mode
        const isCrescentSunset = state.moonPhase === 'crescent' && 
                                 state.dayStartTime === 'evening' && 
                                 state.dayStartAngle === 0;
        
        // Calculate when Day 1 starts (day-start time)
        // For crescent+sunset, the month starts at the crescent sighting time (which IS sunset)
        let dayStartTimestamp;
        if (isCrescentSunset) {
          dayStartTimestamp = month13MoonEvent.getTime();
        } else {
          dayStartTimestamp = getDayStartTime(dayObj.gregorianDate);
        }
        const dayStartDate = new Date(dayStartTimestamp);
        const dayStartLabel = getDayStartLabel();
        const dsTimeStr = dayStartDate.toLocaleTimeString('en-US', { 
          hour: 'numeric', minute: '2-digit', hour12: true 
        });
        const dsParts = getFormattedDateParts(dayStartDate);
        dayStartStr = `${dsParts.weekdayName}, ${dsParts.monthName} ${dsParts.day}${getOrdinalSuffix(dsParts.day)} at ${dsTimeStr}`;
        
        // Calculate time from 13th month day-start to next equinox
        const diffToEquinoxMs = nextEquinox.getTime() - dayStartTimestamp;
        const diffToEquinoxHours = diffToEquinoxMs / (1000 * 60 * 60);
        const diffDays = Math.floor(diffToEquinoxHours / 24);
        const diffHours = Math.round(diffToEquinoxHours % 24);
        
        let diffStr = '';
        if (diffDays > 0 && diffHours > 0) {
          diffStr = `${diffDays} day${diffDays !== 1 ? 's' : ''} and ${diffHours} hour${diffHours !== 1 ? 's' : ''}`;
        } else if (diffDays > 0) {
          diffStr = `${diffDays} day${diffDays !== 1 ? 's' : ''}`;
        } else {
          diffStr = `${diffHours} hour${diffHours !== 1 ? 's' : ''}`;
        }
        
        timingExplanation = `The ${moonLabel} for this month was sighted on ${moonEventStr}. ` +
          `Day 1 begins at ${dayStartLabel} (${dayStartStr}), which is ${diffStr} before the ` +
          `<a href="#" class="equinox-link" data-equinox-date="${nextEquinox.toISOString()}">Spring Equinox (${nextEquinoxDateStr})</a>. ` +
          `Since this day-start falls before the equinox, this qualifies as the 13th month of the current year rather than the 1st month of the next year.`;
      }
      
      item.innerHTML = `
        <div class="day-detail-feast-icon">üìÖ</div>
        <div class="day-detail-feast-info">
          <div class="day-detail-feast-name">13th Month (Intercalary)</div>
          <div class="day-detail-feast-desc">${timingExplanation}</div>
        </div>
      `;
      feastsContainer.appendChild(item);
      
      // Add click handler for equinox link
      const equinoxLink = item.querySelector('.equinox-link');
      if (equinoxLink) {
        equinoxLink.addEventListener('click', (e) => {
          e.preventDefault();
          jumpToEquinoxDate(nextEquinox);
        });
      }
    }
  }
  
  // Populate additional info
  const infoContainer = panel.querySelector('.day-detail-info');
  let infoHtml = '';
  
  if (dayObj.isSabbath) {
    infoHtml += '<div class="day-detail-sabbath">üïØÔ∏è Weekly Sabbath</div>';
  }
  
  if (dayObj.moonPhase && dayObj.lunarDay !== 1) {
    infoHtml += `<div>Moon phase: ${dayObj.moonPhase}</div>`;
  }
  
  infoContainer.innerHTML = infoHtml;
  
  // Show the panel (reset both inline style and class)
  panel.style.display = '';  // Reset any inline display:none from settings page
  panel.classList.remove('hidden');
  
  // Scroll panel into view on mobile
  if (window.innerWidth <= 768) {
    panel.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
  }
}

function closeDayDetail() {
  document.getElementById('day-detail-panel').classList.add('hidden');
}

function getOrdinalSuffix(n) {
  const s = ['th', 'st', 'nd', 'rd'];
  const v = n % 100;
  return s[(v - 20) % 10] || s[v] || s[0];
}

// Jump to a specific equinox date and highlight that day
function jumpToEquinoxDate(equinoxDate) {
  const targetDate = new Date(equinoxDate);
  
  // Find this date in the current lunar months
  for (let m = 0; m < state.lunarMonths.length; m++) {
    const month = state.lunarMonths[m];
    for (let d = 0; d < month.days.length; d++) {
      const day = month.days[d];
      // Check if equinox falls on this day
      if (day.equinox && day.equinox.date.toDateString() === targetDate.toDateString()) {
        state.currentMonthIndex = m;
        state.highlightedLunarDay = day.lunarDay;
        state.selectedTimestamp = getSunriseTimestamp(day.gregorianDate);
        document.getElementById('goto-date').value = formatLocalDatetime(state.selectedTimestamp);
        renderMonth(state.lunarMonths[state.currentMonthIndex]);
        updateMonthButtons();
        updateURL();
        showDayDetail(day, month);
        return;
      }
    }
  }
  
  // If not found in current year's months, the equinox might be in a different year
  // Navigate to that year first
  const equinoxYear = targetDate.getFullYear();
  if (equinoxYear !== state.year) {
    state.year = equinoxYear;
    updateUI();
    generateCalendar();
    // Try again after regenerating
    jumpToEquinoxDate(equinoxDate);
  }
}

function jumpToToday() {
  const now = new Date();
  const utcTimestamp = now.getTime();
  
  // Get the current date at the selected location (based on longitude)
  // utcToLocalTime returns a Date where UTC methods give local time at location
  const localDateAtLocation = utcToLocalTime(utcTimestamp, state.lon);
  const targetYear = localDateAtLocation.getUTCFullYear();
  const targetMonth = localDateAtLocation.getUTCMonth();
  const targetDay = localDateAtLocation.getUTCDate();
  
  // Update goto-date input with local time at selected location
  document.getElementById('goto-date').value = formatLocalDatetime(utcTimestamp);
  
  // Determine which lunar year today belongs to
  // Use UTC comparison - the calendar builds months based on UTC moon events
  const springEquinox = Astronomy.Seasons(targetYear).mar_equinox.date;
  const lunarYear = utcTimestamp < springEquinox.getTime() ? targetYear - 1 : targetYear;
  
  // Update state year (keep other settings from localStorage)
  state.year = lunarYear;
  
  // Update UI with all state (including saved location/moon phase settings)
  updateUI();
  
  // Generate calendar for today's lunar year
  generateCalendar();
  
  // Find today in the generated months
  // Calendar dates are stored as browser-local Date objects but represent the date at the location
  for (let m = 0; m < state.lunarMonths.length; m++) {
    const month = state.lunarMonths[m];
    for (let d = 0; d < month.days.length; d++) {
      const day = month.days[d];
      const gd = day.gregorianDate;
      // Compare year/month/day - both represent the date at the observer's location
      if (gd.getFullYear() === targetYear && 
          gd.getMonth() === targetMonth && 
          gd.getDate() === targetDay) {
        state.currentMonthIndex = m;
        state.highlightedLunarDay = day.lunarDay;
        state.selectedTimestamp = utcTimestamp;
        renderMonth(state.lunarMonths[m]);
        updateMonthButtons();
        showDayDetail(day, month);
        return;
      }
    }
  }
  
  // Fallback: if today not found, just show first month
  state.currentMonthIndex = 0;
  renderMonth(state.lunarMonths[0]);
  updateMonthButtons();
}

// Open ICS directly in calendar app
async function openInCalendar() {
  const icsContent = generateICSContent();
  if (!icsContent) return;
  
  const filename = `lunar-sabbath-calendar-${state.year}.ics`;
  const blob = new Blob([icsContent], { type: 'text/calendar' });
  const file = new File([blob], filename, { type: 'text/calendar' });
  
  // Try Web Share API first (works great on mobile and some desktop)
  if (navigator.share && navigator.canShare && navigator.canShare({ files: [file] })) {
    try {
      await navigator.share({
        files: [file],
        title: 'Lunar Sabbath Calendar',
        text: `Sabbaths and Feasts for ${formatYear(state.year)}`
      });
      return;
    } catch (err) {
      if (err.name !== 'AbortError') {
        console.log('Share failed, falling back to download');
      } else {
        return; // User cancelled
      }
    }
  }
  
  // Fallback: Download the file
  exportToICS();
  
  // Close the export modal after successful download
  const exportPage = document.getElementById('export-page');
  if (exportPage && exportPage.style.display !== 'none') {
    toggleExportModal();
  }
}

// Generate ICS content for calendar export
function generateICSContent() {
  if (!state.lunarMonths || state.lunarMonths.length === 0) {
    alert('Please generate a calendar first');
    return null;
  }
  
  const events = [];
  const yearLabel = formatYear(state.year);
  
  // Collect all Sabbaths and Feasts
  for (const month of state.lunarMonths) {
    for (const day of month.days) {
      // Add Sabbaths
      if (day.isSabbath) {
        events.push({
          date: day.gregorianDate,
          title: `Lunar Sabbath (${MONTH_NAMES[month.monthNumber - 1]} ${day.lunarDay})`,
          description: `Weekly Sabbath - Day ${day.lunarDay} of ${MONTH_NAMES[month.monthNumber - 1]}`,
          allDay: true
        });
      }
      
      // Add Feasts
      if (day.feast) {
        let title = day.feast.name;
        if (day.feastDayNum) {
          title += ` Day ${day.feastDayNum}`;
        }
        events.push({
          date: day.gregorianDate,
          title: title,
          description: day.feast.description + ` (${MONTH_NAMES[month.monthNumber - 1]} ${day.lunarDay})`,
          allDay: true
        });
      }
      
      // Add New Moon days
      if (day.isNewMoon) {
        events.push({
          date: day.gregorianDate,
          title: `New Moon - ${MONTH_NAMES[month.monthNumber - 1]}`,
          description: `Start of ${MONTH_NAMES[month.monthNumber - 1]} (Lunar Month ${month.monthNumber})`,
          allDay: true
        });
      }
    }
  }
  
  // Sort events by date
  events.sort((a, b) => a.date.getTime() - b.date.getTime());
  
  // Generate ICS content
  let ics = [
    'BEGIN:VCALENDAR',
    'VERSION:2.0',
    'PRODID:-//LunarSabbath.net//Lunar Sabbath Calendar//EN',
    'CALSCALE:GREGORIAN',
    'METHOD:PUBLISH',
    `X-WR-CALNAME:Lunar Sabbath Calendar ${yearLabel}`
  ];
  
  for (const event of events) {
    const dateStr = formatICSDate(event.date);
    const uid = `${dateStr}-${event.title.replace(/\s+/g, '-')}@lunarsabbath.net`;
    
    ics.push('BEGIN:VEVENT');
    ics.push(`UID:${uid}`);
    ics.push(`DTSTART;VALUE=DATE:${dateStr}`);
    ics.push(`DTEND;VALUE=DATE:${dateStr}`);
    ics.push(`SUMMARY:${escapeICS(event.title)}`);
    ics.push(`DESCRIPTION:${escapeICS(event.description)}`);
    ics.push('END:VEVENT');
  }
  
  ics.push('END:VCALENDAR');
  
  return ics.join('\r\n');
}

// Export Sabbaths and Feasts to ICS file for calendar import
function exportToICS() {
  const icsContent = generateICSContent();
  if (!icsContent) return;
  
  // Download the file
  const blob = new Blob([icsContent], { type: 'text/calendar;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = `lunar-sabbath-calendar-${state.year}.ics`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

function formatICSDate(date) {
  const year = date.getFullYear();
  const month = (date.getMonth() + 1).toString().padStart(2, '0');
  const day = date.getDate().toString().padStart(2, '0');
  return `${year}${month}${day}`;
}

function escapeICS(text) {
  // Escape special characters for ICS format
  return text
    .replace(/\\/g, '\\\\')
    .replace(/;/g, '\\;')
    .replace(/,/g, '\\,')
    .replace(/\n/g, '\\n');
}

// Register Service Worker for PWA functionality
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js')
      .then((registration) => {
        console.log('ServiceWorker registered:', registration.scope);
      })
      .catch((error) => {
        console.log('ServiceWorker registration failed:', error);
      });
  });
}
</script>
</body>
</html>

---
layout: null
title: "Lunar Sabbath Calendar"
---
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#1a3a5c">
  <meta name="description" content="A time-tested lunar calendar for tracking Sabbaths and appointed times">
  <title>{{ page.title }}</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@600;700;900&display=swap" rel="stylesheet">
  <link rel="icon" type="image/svg+xml" href="/icons/icon.svg">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/icon-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/icon-16.png">
  <link rel="manifest" href="/manifest.json">
  <link rel="apple-touch-icon" href="/icons/icon-192.png">
  <link rel="stylesheet" href="/styles.css">
</head>
<body>

<!-- About Modal -->
<div id="about-modal-overlay" class="about-modal-overlay" onclick="closeAboutModal(event)">
  <div class="about-modal" onclick="event.stopPropagation()">
    <div class="about-modal-header">
      <div class="about-modal-logo">
        <span class="moon-phase">ğŸŒ’</span>
        <span class="moon-phase primary">ğŸŒ•</span>
        <span class="moon-phase">ğŸŒ‘</span>
      </div>
      <h2 class="about-modal-title">LunarSabbath.net</h2>
      <p class="about-modal-subtitle">A Time Tested Tradition</p>
    </div>
    
    <div class="about-modal-content">
      <ul class="about-features">
        <li>
          <span class="feature-icon">ğŸŒ•</span>
          <span class="feature-text"><strong>Any Month Start</strong> â€” Full Moon, Dark Moon, or Crescent Moon</span>
        </li>
        <li>
          <span class="feature-icon">ğŸª</span>
          <span class="feature-text"><strong>Any Sabbath</strong> â€” Lunar, Saturday, or Custom cycles</span>
        </li>
        <li>
          <span class="feature-icon">ğŸŒ</span>
          <span class="feature-text"><strong>Any Location</strong> â€” Moon phases calculated for your coordinates</span>
        </li>
        <li>
          <span class="feature-icon">â˜€ï¸</span>
          <span class="feature-text"><strong>Any Day Start</strong> â€” Morning twilight or evening sunset</span>
        </li>
        <li>
          <span class="feature-icon">ğŸ“†</span>
          <span class="feature-text"><strong>Any Year</strong> â€” From Exodus to Christ's Return</span>
        </li>
        <li>
          <span class="feature-icon"><img src="/icons/menorah.png" alt="Menorah" class="feature-img"></span>
          <span class="feature-text"><strong>Export Feasts</strong> â€” Add feasts to your calendar app</span>
        </li>
        <li>
          <span class="feature-icon">ğŸ“²</span>
          <span class="feature-text"><strong>Installable App</strong> â€” Works offline on any device</span>
        </li>
      </ul>
      
      <button class="about-start-btn" onclick="closeAboutModal()">Test Everything</button>
      
      <div class="about-cta">
        <p>Discover which historical events align with different calendar interpretations and why communities chose their traditions.</p>
      </div>
    </div>
  </div>
</div>

<!-- Top Navigation Bar -->
<nav class="top-nav">
  <div class="top-nav-inner">
    <div class="top-nav-brand" onclick="navigateTo('calendar')" style="cursor: pointer;">
      <span class="top-nav-icon">ğŸŒ•</span>
      <div class="top-nav-text">
        <div class="top-nav-title">Lunar Sabbath</div>
        <div class="top-nav-tagline">a time tested tradition</div>
      </div>
    </div>
    <button class="hamburger-btn" onclick="toggleNavMenu()" aria-label="Menu">â˜°</button>
  </div>
</nav>

<!-- Navigation Menu Overlay -->
<div id="nav-menu-overlay" class="nav-menu-overlay" onclick="toggleNavMenu()"></div>

<!-- Navigation Menu -->
<div id="nav-menu" class="nav-menu">
  <div class="nav-menu-header">
    <h3>Menu</h3>
    <button class="nav-menu-close" onclick="toggleNavMenu()">âœ•</button>
  </div>
  <div class="nav-menu-items">
    <button class="nav-menu-item" onclick="navigateTo('calendar')">
      <span class="icon">ğŸ“…</span>
      <span>Calendar</span>
    </button>
    <button class="nav-menu-item" onclick="navigateTo('feasts')">
      <span class="icon">ğŸº</span>
      <span>Feasts</span>
    </button>
    <button class="nav-menu-item" onclick="navigateTo('settings')">
      <span class="icon">âš™ï¸</span>
      <span>Profiles</span>
    </button>
    <button class="nav-menu-item" onclick="navigateTo('sabbath-tester')">
      <span class="icon">ğŸ”¬</span>
      <span>Sabbath Tester</span>
    </button>
    <div class="nav-menu-divider"></div>
    <button class="nav-menu-item" id="install-app-btn" style="display: none;" onclick="handleInstallClick()">
      <span class="icon">ğŸ“²</span>
      <span>Install App</span>
    </button>
    <div class="book-ad">
      <div class="book-ad-top">
        <div class="book-ad-title">TIME</div>
        <div class="book-ad-subtitle">Tested Tradition</div>
        <div class="book-ad-tagline">The Renewed Biblical Calendar</div>
      </div>
      <div class="book-ad-bottom">
        <div class="book-ad-author">By Daniel Larimer</div>
        <a class="book-ad-download" href="/media/time-tested-tradition.pdf" download onclick="trackBookDownload()">
          <span class="icon">ğŸ“¥</span>
          <span>Download PDF</span>
        </a>
      </div>
    </div>
    <a class="nav-menu-item" href="/book/">
      <span class="icon">ğŸ“–</span>
      <span>Browse Book</span>
    </a>
    <button class="nav-menu-item" onclick="navigateTo('about')">
      <span class="icon">â„¹ï¸</span>
      <span>About</span>
    </button>
  </div>
</div>

<!-- iOS Install Instructions Modal -->
<div id="ios-install-overlay" class="ios-install-overlay" onclick="closeIOSInstallModal(event)">
  <div class="ios-install-modal" onclick="event.stopPropagation()">
    <button class="ios-install-close" onclick="closeIOSInstallModal()">âœ•</button>
    <div class="ios-install-header">
      <span class="ios-install-icon">ğŸ“²</span>
      <h3>Install LunarSabbath</h3>
    </div>
    <p class="ios-install-intro">Add this app to your home screen for quick access and an app-like experience.</p>
    <div class="ios-install-steps">
      <div class="ios-install-step">
        <div class="step-number">1</div>
        <div class="step-content">
          <p>Tap the <strong>Share</strong> button <span class="ios-share-icon">â¬†ï¸</span> in Safari's toolbar</p>
        </div>
      </div>
      <div class="ios-install-step">
        <div class="step-number">2</div>
        <div class="step-content">
          <p>Scroll down and tap <strong>"Add to Home Screen"</strong></p>
        </div>
      </div>
      <div class="ios-install-step">
        <div class="step-number">3</div>
        <div class="step-content">
          <p>Tap <strong>"Add"</strong> in the top right corner</p>
        </div>
      </div>
    </div>
    <button class="ios-install-done-btn" onclick="closeIOSInstallModal()">Got it!</button>
  </div>
</div>

<div class="calendar-app">
  <!-- Settings Dialog (hidden by default) -->
  <div id="settings-overlay" class="settings-overlay" onclick="if(event.target === this) toggleSettings()"></div>
  <div id="settings-dialog" class="settings-dialog">
    <div class="settings-header">
      <h3>Month Sign & Location</h3>
      <button onclick="toggleSettings()" class="close-btn">âœ•</button>
    </div>
    <div class="settings-content">
      <div class="setting-group">
        <label>Month Starts At</label>
        <div class="moon-phase-buttons">
          <button class="moon-phase-btn" data-phase="full" onclick="selectMoonPhase('full')">
            <span class="phase-icon">ğŸŒ•</span>
            <span class="phase-name">Full Moon</span>
          </button>
          <button class="moon-phase-btn" data-phase="dark" onclick="selectMoonPhase('dark')">
            <span class="phase-icon">ğŸŒ‘</span>
            <span class="phase-name">Dark Moon</span>
          </button>
          <button class="moon-phase-btn" data-phase="crescent" onclick="selectMoonPhase('crescent')">
            <span class="phase-icon">ğŸŒ’</span>
            <span class="phase-name">Crescent</span>
          </button>
        </div>
        <select id="moon-phase-select" style="display: none;">
          <option value="full">Full Moon</option>
          <option value="dark">Dark Moon (Conjunction)</option>
          <option value="crescent">Crescent Moon (First Visible)</option>
        </select>
      </div>
      
      <div class="setting-group">
        <label>Default Location</label>
        <div id="settings-map-container"></div>
        <select id="city-select" class="city-select-styled">
          <optgroup label="Biblical">
            <option value="31.7683,35.2137">Jerusalem</option>
          </optgroup>
          <optgroup label="United States">
            <option value="40.7128,-74.0060">New York (Eastern)</option>
            <option value="41.8781,-87.6298">Chicago (Central)</option>
            <option value="39.7392,-104.9903">Denver (Mountain)</option>
            <option value="34.0522,-118.2437">Los Angeles (Pacific)</option>
            <option value="61.2181,-149.9003">Anchorage (Alaska)</option>
            <option value="21.3069,-157.8583">Honolulu (Hawaii)</option>
          </optgroup>
          <optgroup label="International">
            <option value="51.5074,-0.1278">London</option>
            <option value="48.8566,2.3522">Paris</option>
            <option value="35.6762,139.6503">Tokyo</option>
            <option value="-33.8688,151.2093">Sydney</option>
          </optgroup>
          <option value="">Custom Coordinates...</option>
        </select>
        <div class="setting-group" id="custom-coords" style="display: none;">
          <div style="display: flex; gap: 10px; margin-top: 10px;">
            <input type="number" id="lat-input" value="31.7683" step="0.0001" placeholder="Latitude">
            <input type="number" id="lon-input" value="35.2137" step="0.0001" placeholder="Longitude">
          </div>
        </div>
        <button type="button" class="location-btn" onclick="useCurrentLocation()">ğŸ“ Use My Current Location</button>
      </div>
      
      <div class="setting-info">
        The location determines when the lunar day begins for you.
      </div>
    </div>
  </div>

  <!-- Hidden inputs for state -->
  <input type="number" id="year-input" value="2026" min="-4000" max="4000" style="display: none;">
  <span id="year-display" style="display: none;"></span>
  <input type="datetime-local" id="goto-date" step="60" style="display: none;">
  <input type="number" id="add-days" value="1" min="1" style="display: none;">
  
  <!-- Month Picker Popup -->
  <div id="month-picker-overlay" class="month-picker-overlay" onclick="if(event.target === this) toggleMonthPicker()"></div>
  <div id="month-picker" class="month-picker" style="display: none;">
    <div class="month-picker-header">
      <h3>Select Month</h3>
      <button class="close-btn" onclick="toggleMonthPicker()">âœ•</button>
    </div>
    <div class="year-nav">
      <button onclick="changePickerYear(-1)">â—€</button>
      <div class="year-display-container">
        <span id="picker-year" class="year-display" onclick="showYearInput()" title="Click to enter year"></span>
        <input type="number" id="picker-year-input" class="year-input" min="1" max="4000"
               onkeydown="if(event.key==='Enter') applyYearInput(); if(event.key==='Escape') hideYearInput();"
               onblur="applyYearInput()">
      </div>
      <button onclick="changePickerYear(1)">â–¶</button>
      <select id="era-select" class="era-select" onchange="changeEra(this.value)">
        <option value="AD">AD</option>
        <option value="BC">BC</option>
      </select>
    </div>
    <div id="month-grid" class="month-grid"></div>
  </div>
  
  <!-- City Picker Modal -->
  <div id="city-picker-overlay" class="city-picker-overlay" onclick="if(event.target === this) toggleCityPicker()"></div>
  <div id="city-picker" class="city-picker" style="display: none;">
    <div class="city-picker-header">
      <h3>Select Location</h3>
      <button class="close-btn" onclick="toggleCityPicker()">âœ•</button>
    </div>
    <div class="city-picker-controls">
      <button class="city-action-btn" onclick="useMyLocationFromPicker()">ğŸ“ Use My Location</button>
      <select id="city-picker-select" class="city-picker-select" onchange="selectCityFromDropdown(this.value)">
        <option value="">-- Select a city --</option>
      </select>
    </div>
    <div id="city-picker-map"></div>
  </div>
  
  <!-- Profile Picker Modal -->
  <div id="profile-picker-overlay" class="profile-picker-overlay" onclick="if(event.target === this) toggleProfilePicker()"></div>
  <div id="profile-picker" class="profile-picker" style="display: none;">
    <div class="profile-picker-header">
      <h3>Select Calendar Profile</h3>
      <button class="profile-add-btn" onclick="toggleProfilePicker(); navigateTo('settings');" title="Customize Settings">+</button>
    </div>
    <div id="profile-picker-list" class="profile-picker-list">
      <!-- Populated by JavaScript -->
    </div>
  </div>
  
  <!-- Date Jump Popup -->
  <div id="date-jump-overlay" class="date-jump-overlay" onclick="if(event.target === this) toggleDateJump()"></div>
  <div id="date-jump-popup" class="date-jump-popup" style="display: none;">
    <button class="close-btn" onclick="toggleDateJump()">âœ•</button>
    <h3>Jump to Date</h3>
    <div id="jump-ancient-display" style="display: none; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 4px; margin-bottom: 10px; text-align: center;">
      <div style="color: #d4a017; font-size: 1.1em;" id="jump-ancient-date"></div>
      <div style="color: #888; font-size: 0.85em; margin-top: 4px;">Date picker unavailable for BC dates</div>
    </div>
    <input type="datetime-local" id="jump-datetime" step="60">
    <div class="btn-row">
      <button class="btn secondary" onclick="jumpToTodayFromPopup()">Jump to Today</button>
    </div>
    <div class="days-jump">
      <button onclick="addDaysFromPopup(-1)">â—€</button>
      <input type="number" id="jump-days" value="1" min="1">
      <button onclick="addDaysFromPopup(1)">â–¶</button>
      <span>days</span>
    </div>
  </div>
  
  <!-- Hidden month buttons container (for compatibility) -->
  <div id="month-buttons" style="display: none;"></div>

  <div id="calendar-output"></div>

  <!-- Settings Page Overlay -->
  <div id="settings-page-overlay" class="settings-page-overlay" onclick="toggleSettings()"></div>
  
  <!-- Settings Page - slides in from right -->
  <div id="settings-page" class="settings-page">
    <div class="settings-page-header">
      <h2>Profiles</h2>
      <button class="close-btn" onclick="navigateTo('calendar')" aria-label="Close">âœ•</button>
    </div>
    
    <div class="settings-section">
      <h3>Profile</h3>
      <p class="settings-description">Select a preset or customize settings below.</p>
      <div class="profile-row">
        <select id="profile-select" class="profile-select" onchange="onProfileSelectChange(this.value)">
          <option value="timeTested">ğŸŒ• Time-Tested â€” Full Moon, Morning Twilight, Lunar Sabbath</option>
          <option value="ancientTraditional">ğŸŒ’ Ancient Traditional â€” Crescent, Evening, Saturday</option>
          <option value="ministries119">ğŸŒ‘ 119 Ministries â€” Dark Moon, Evening, Saturday</option>
        </select>
        <button id="profile-clone-btn" class="profile-icon-btn" onclick="cloneProfile()" title="Clone as new profile">+</button>
        <button id="profile-edit-btn" class="profile-icon-btn" onclick="editProfileName()" title="Rename profile" disabled>âœï¸</button>
        <button id="profile-delete-btn" class="profile-icon-btn" onclick="deleteCustomProfile()" title="Delete profile" disabled>ğŸ—‘ï¸</button>
      </div>
    </div>
    
    <div class="settings-section">
      <h3>Month Starts At</h3>
      <p class="settings-description">Choose which lunar phase marks the beginning of each month.</p>
      <div class="settings-options">
        <button class="settings-option-btn" data-phase="full" onclick="selectMoonPhase('full')">
          <span class="option-icon">ğŸŒ•</span>
          <span class="option-label">Full Moon</span>
        </button>
        <button class="settings-option-btn" data-phase="dark" onclick="selectMoonPhase('dark')">
          <span class="option-icon">ğŸŒ‘</span>
          <span class="option-label">Dark Moon</span>
        </button>
        <button class="settings-option-btn" data-phase="crescent" onclick="selectMoonPhase('crescent')">
          <span class="option-icon">ğŸŒ’</span>
          <span class="option-label">Crescent</span>
        </button>
      </div>
    </div>
    
    <div id="crescent-threshold-section" class="settings-section" style="display: none;">
      <h3>Crescent Visibility Timing</h3>
      <p class="settings-description">Hours after conjunction when crescent moon is considered visible.</p>
      <div class="settings-options">
        <button class="settings-option-btn" data-threshold="12" onclick="selectCrescentThreshold(12)">
          <span class="option-label">12h Optimistic</span>
          <span class="option-hint">Perfect conditions + optical aids</span>
        </button>
        <button class="settings-option-btn" data-threshold="15.5" onclick="selectCrescentThreshold(15.5)">
          <span class="option-label">15.5h Minimum</span>
          <span class="option-hint">Naked-eye record, ideal conditions</span>
        </button>
        <button class="settings-option-btn" data-threshold="18" onclick="selectCrescentThreshold(18)">
          <span class="option-label">18h Typical</span>
          <span class="option-hint">Standard naked-eye visibility</span>
        </button>
        <button class="settings-option-btn" data-threshold="24" onclick="selectCrescentThreshold(24)">
          <span class="option-label">24h Conservative</span>
          <span class="option-hint">Easily visible to anyone</span>
        </button>
      </div>
    </div>
    
    <div class="settings-section">
      <h3>Day Starts At</h3>
      <p class="settings-description">Choose when each day begins.</p>
      <div class="settings-options" style="margin-bottom: 15px;">
        <button class="settings-option-btn" data-daystart="evening" onclick="selectDayStartTime('evening')">
          <span class="option-icon">ğŸŒ…</span>
          <span class="option-label">Evening</span>
        </button>
        <button class="settings-option-btn" data-daystart="morning" onclick="selectDayStartTime('morning')">
          <span class="option-icon">ğŸŒ„</span>
          <span class="option-label">Morning</span>
        </button>
      </div>
      <p class="settings-description">Sun position below horizon:</p>
      <div class="settings-options">
        <button class="settings-option-btn" data-angle="0" onclick="selectDayStartAngle(0)">
          <span class="option-label">0Â° Horizon</span>
          <span class="option-hint">Sun at horizon</span>
        </button>
        <button class="settings-option-btn" data-angle="6" onclick="selectDayStartAngle(6)">
          <span class="option-label">6Â° Civil</span>
          <span class="option-hint">Bright stars visible</span>
        </button>
        <button class="settings-option-btn" data-angle="12" onclick="selectDayStartAngle(12)">
          <span class="option-label">12Â° Nautical</span>
          <span class="option-hint">Most stars visible</span>
        </button>
        <button class="settings-option-btn" data-angle="18" onclick="selectDayStartAngle(18)">
          <span class="option-label">18Â° Astronomical</span>
          <span class="option-hint">Fully dark</span>
        </button>
      </div>
    </div>
    
    <div class="settings-section">
      <h3>Year Starts At</h3>
      <p class="settings-description">Choose the rule for determining the first month of the year.</p>
      <div class="settings-options">
        <button class="settings-option-btn" data-yearstart="equinox" onclick="selectYearStartRule('equinox')">
          <span class="option-icon" id="yearstart-equinox-icon">ğŸŒ•</span>
          <span class="option-label">Renewed Moon after Equinox</span>
          <span class="option-hint" id="yearstart-equinox-hint">Month 1 starts after spring equinox</span>
        </button>
        <button class="settings-option-btn" data-yearstart="13daysBefore" onclick="selectYearStartRule('13daysBefore')">
          <span class="option-icon">ğŸ‘</span>
          <span class="option-label">Passover after Equinox</span>
          <span class="option-hint" id="yearstart-passover-hint">Day 15 (Unleavened) on or after equinox</span>
        </button>
        <button class="settings-option-btn" data-yearstart="virgoFeet" onclick="selectYearStartRule('virgoFeet')">
          <span class="option-icon">â™</span>
          <span class="option-label">Moon Under Virgo's Feet</span>
          <span class="option-hint" id="yearstart-virgo-hint">Full moon below Spica (Rev 12:1)</span>
        </button>
      </div>
      <div class="settings-info-box" id="equinox-rule-explanation" style="display: none;">
        <!-- Content populated dynamically by updateYearStartButtons() using getEquinoxMethodologyHtml() -->
      </div>
      <div class="settings-info-box" id="lamb-rule-explanation" style="display: none;">
        <!-- Content populated dynamically by updateYearStartButtons() using getPassoverMethodologyHtml() -->
      </div>
      <div class="settings-info-box" id="virgo-rule-explanation" style="display: none;">
        <!-- Content populated dynamically by updateYearStartButtons() using getVirgoMethodologyHtml() -->
      </div>
    </div>
    
    <div class="settings-section">
      <h3>Sabbath Day</h3>
      <p class="settings-description">Choose how the Sabbath day is determined and highlighted.</p>
      <div class="settings-options">
        <button class="settings-option-btn" data-sabbath="lunar" onclick="selectSabbathMode('lunar')">
          <span class="option-icon">ğŸŒ•</span>
          <span class="option-label">Lunar Sabbath</span>
          <span class="option-hint">Days 8, 15, 22, 29 of each month</span>
        </button>
        <button class="settings-option-btn" data-sabbath="saturday" onclick="selectSabbathMode('saturday')">
          <span class="option-icon">ğŸª</span>
          <span class="option-label">Saturday</span>
          <span class="option-hint">Fixed weekly Sabbath</span>
        </button>
        <button class="settings-option-btn" data-sabbath="sunday" onclick="selectSabbathMode('sunday')">
          <span class="option-icon">â˜€ï¸</span>
          <span class="option-label">Sunday</span>
          <span class="option-hint">Christian day of rest</span>
        </button>
      </div>
      <div class="settings-row" style="margin-top: 15px;">
        <label class="settings-row-label">Other fixed day:</label>
        <select id="sabbath-day-select" class="settings-select" onchange="selectSabbathDayFromDropdown(this.value)">
          <option value="">â€” Choose â€”</option>
          <option value="none">None</option>
          <option value="monday">Monday</option>
          <option value="tuesday">Tuesday</option>
          <option value="wednesday">Wednesday</option>
          <option value="thursday">Thursday</option>
          <option value="friday">Friday</option>
        </select>
      </div>
    </div>
    
    <div class="settings-section">
      <h3>Default Location</h3>
      <p class="settings-description">The default location determines the timing of sunrise, sunset, and twilight for this profile.</p>
      <div id="settings-page-map"></div>
      <div class="settings-location-buttons">
        <button type="button" class="exact-location-btn settings-location-btn" onclick="getExactLocation()">ğŸ“ Use My Location</button>
        <span class="settings-location-hint">Saves as your default location</span>
      </div>
      <select id="settings-city-select" class="settings-select">
        <option value="current">ğŸ“ Auto-detect via IP (approximate)</option>
        <optgroup label="Biblical">
          <option value="31.7683,35.2137">Jerusalem</option>
        </optgroup>
        <optgroup label="United States">
          <option value="40.7128,-74.0060">New York (Eastern)</option>
          <option value="41.8781,-87.6298">Chicago (Central)</option>
          <option value="39.7392,-104.9903">Denver (Mountain)</option>
          <option value="34.0522,-118.2437">Los Angeles (Pacific)</option>
          <option value="61.2181,-149.9003">Anchorage (Alaska)</option>
          <option value="21.3069,-157.8583">Honolulu (Hawaii)</option>
        </optgroup>
        <optgroup label="International">
          <option value="51.5074,-0.1278">London</option>
          <option value="48.8566,2.3522">Paris</option>
          <option value="35.6762,139.6503">Tokyo</option>
          <option value="-33.8688,151.2093">Sydney</option>
        </optgroup>
        <option value="custom">Custom Coordinates...</option>
      </select>
      <div id="settings-custom-coords" class="settings-custom-coords" style="display: none;">
        <input type="number" id="settings-lat-input" step="0.0001" placeholder="Latitude">
        <input type="number" id="settings-lon-input" step="0.0001" placeholder="Longitude">
      </div>
    </div>
    
    <div class="settings-section">
      <h3>Astronomy Engine & Î”T Uncertainty</h3>
      <p class="settings-description">Technical details about astronomical calculations and historical date accuracy.</p>
      
      <div id="astro-engine-info" class="settings-engine-info">
        <div class="engine-info-row">
          <span class="engine-info-label">Library:</span>
          <span id="astro-engine-name" class="engine-info-value">astronomy-engine v2.1.19</span>
        </div>
        <div class="engine-info-row">
          <span class="engine-info-label">Î”T Model:</span>
          <span id="astro-engine-delta" class="engine-info-value">NASA Eclipse with historical calibration</span>
        </div>
      </div>
      
      <div class="settings-info-box" style="display: block; margin-top: 15px;">
        <p><strong>What is Î”T (Delta T)?</strong></p>
        <p>Î”T is the difference between <em>Terrestrial Time</em> (uniform, based on atomic clocks) and <em>Universal Time</em> (based on Earth's rotation). Earth's rotation is gradually slowing due to tidal friction, causing Î”T to grow over centuries.</p>
        
        <p><strong>Why does this matter for ancient calendars?</strong></p>
        <p>When calculating ancient lunar phases, the uncertainty in Î”T means we cannot know the <em>exact</em> moment a conjunction or full moon occurred. If the moon event was close to sunset, this uncertainty could shift whether Day 1 started on that evening or the next.</p>
        
        <p><strong>Î”T Uncertainty Thresholds Used:</strong></p>
        <table style="width: 100%; border-collapse: collapse; margin: 10px 0; font-size: 0.9em;">
          <thead>
            <tr style="border-bottom: 1px solid rgba(255,255,255,0.3);">
              <th style="text-align: left; padding: 5px;">Era</th>
              <th style="text-align: right; padding: 5px;">Uncertainty</th>
              <th style="text-align: left; padding: 5px 5px 5px 15px;">Notes</th>
            </tr>
          </thead>
          <tbody style="color: rgba(255,255,255,0.8);">
            <tr><td style="padding: 4px 5px;">1600â€“2100 AD</td><td style="text-align: right; padding: 4px 5px;">~0 hours</td><td style="padding: 4px 5px 4px 15px;">Modern records, negligible error</td></tr>
            <tr><td style="padding: 4px 5px;">1000â€“1600 AD</td><td style="text-align: right; padding: 4px 5px;">Â±0.25 hours</td><td style="padding: 4px 5px 4px 15px;">Medieval eclipse records</td></tr>
            <tr><td style="padding: 4px 5px;">500â€“1000 AD</td><td style="text-align: right; padding: 4px 5px;">Â±0.5 hours</td><td style="padding: 4px 5px 4px 15px;">Late antiquity</td></tr>
            <tr><td style="padding: 4px 5px;">1â€“500 AD</td><td style="text-align: right; padding: 4px 5px;">Â±1 hour</td><td style="padding: 4px 5px 4px 15px;">Roman era</td></tr>
            <tr><td style="padding: 4px 5px;">500â€“1 BC</td><td style="text-align: right; padding: 4px 5px;">Â±1.5 hours</td><td style="padding: 4px 5px 4px 15px;">Classical antiquity</td></tr>
            <tr><td style="padding: 4px 5px;">1000â€“500 BC</td><td style="text-align: right; padding: 4px 5px;">Â±2 hours</td><td style="padding: 4px 5px 4px 15px;">Iron Age, Babylonian records</td></tr>
            <tr><td style="padding: 4px 5px;">1500â€“1000 BC</td><td style="text-align: right; padding: 4px 5px;">Â±3 hours</td><td style="padding: 4px 5px 4px 15px;">Late Bronze Age (Exodus era)</td></tr>
            <tr><td style="padding: 4px 5px;">2000â€“1500 BC</td><td style="text-align: right; padding: 4px 5px;">Â±4 hours</td><td style="padding: 4px 5px 4px 15px;">Middle Bronze Age</td></tr>
            <tr><td style="padding: 4px 5px;">Before 2000 BC</td><td style="text-align: right; padding: 4px 5px;">Â±5+ hours</td><td style="padding: 4px 5px 4px 15px;">Early Bronze Age and earlier</td></tr>
          </tbody>
        </table>
        
        <p style="font-size: 0.85em; color: rgba(255,255,255,0.6); margin-top: 10px;">
          <strong>Source:</strong> Based on NASA eclipse calibration data and Espenak-Meeus polynomial models. 
          See <a href="https://eclipse.gsfc.nasa.gov/SEcat5/deltat.html" target="_blank" style="color: #7ec8e3;">NASA Î”T page</a>.
        </p>
      </div>
    </div>
  </div>

  <!-- Day Detail Panel - slides up when a day is selected -->
  <div id="day-detail-panel" class="day-detail-panel hidden">
    <div class="day-detail-header">
      <div class="day-detail-date">
        <span class="day-detail-lunar"></span>
        <span class="day-detail-gregorian-row">
          <span class="day-detail-gregorian"></span>
          <button class="day-detail-jump-btn" onclick="toggleDateJump()" title="Jump to another date">â‡¥</button>
        </span>
      </div>
      <div class="day-detail-astro-times"></div>
    </div>
    <div class="day-detail-content">
      <div class="day-detail-feasts"></div>
      <div class="day-detail-info"></div>
      <div class="day-detail-dateline"></div>
      <div class="day-detail-profile-compare"></div>
    </div>
  </div>

  <!-- Feast table hidden from main page - shown in export modal -->
  <div class="feast-list" style="display: none;">
    <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px; margin-bottom: 15px;">
      <h3 style="margin: 0;">Appointed Times for <span id="feast-year">2026</span></h3>
      <button class="btn" onclick="openInCalendar()" title="Download all Sabbaths and Feasts for this year">ğŸ“… Export Year to Calendar App</button>
    </div>
    <div class="feast-table-container">
    <table class="feast-table">
      <thead>
        <tr>
          <th>Feast</th>
          <th>Date</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody id="feast-tbody"></tbody>
    </table>
    </div>
  </div>
</div>

<!-- Profile Name Modal -->
<div id="profile-modal-overlay" class="profile-modal-overlay" onclick="closeProfileModal(event)">
  <div class="profile-modal" onclick="event.stopPropagation()">
    <h3 id="profile-modal-title">Create New Profile</h3>
    <input type="text" id="profile-modal-input" class="profile-modal-input" placeholder="Enter profile name" onkeydown="handleProfileModalKeydown(event)">
    <div id="profile-modal-error" class="profile-modal-error"></div>
    <div class="profile-modal-buttons">
      <button class="profile-modal-btn cancel" onclick="closeProfileModal()">Cancel</button>
      <button id="profile-modal-save-btn" class="profile-modal-btn save" onclick="saveProfileModal()">Create</button>
    </div>
  </div>
</div>

<!-- Sabbath Tester Page -->
<div id="sabbath-tester-page" style="display: none;">
  <div class="sabbath-tester-header">
    <h2>ğŸ”¬ Sabbath Theory Tester</h2>
    <button class="close-btn" onclick="navigateTo('calendar')" aria-label="Close">âœ•</button>
  </div>
  <div class="sabbath-tester-content">
    <div class="sabbath-tester-intro" style="background: rgba(0,0,0,0.2); padding: 16px; border-radius: 10px; margin-bottom: 20px; color: #ccc; line-height: 1.6;">
      <p style="margin: 0 0 10px 0;">This tool tests various <strong style="color: #7ec8e3;">lunar calendar theories</strong> against historical biblical events where specific weekdays are mentioned in Scripture.</p>
      <p style="margin: 0 0 14px 0;">All tests assume a <strong style="color: #7ec8e3;">fixed Saturday Sabbath</strong> and <strong style="color: #7ec8e3;">Jerusalem location</strong>. The goal is to determine which combination of moon phase (Full, Dark, or Crescent) and day-start time (Daybreak or Sunset) produces dates that align with the biblical record.</p>
      <div style="display: flex; flex-wrap: wrap; gap: 16px; padding-top: 10px; border-top: 1px solid rgba(126, 200, 227, 0.2);">
        <div style="display: flex; align-items: center; gap: 6px;">
          <span style="font-size: 1.2em;">âš–ï¸</span>
          <span><strong style="color: #7ec8e3;">Scale</strong> â€” New Moon on or after Spring Equinox</span>
        </div>
        <div style="display: flex; align-items: center; gap: 6px;">
          <span style="font-size: 1.2em;">ğŸ‘</span>
          <span><strong style="color: #7ec8e3;">Lamb</strong> â€” Day 15 (Unleavened) on or after Spring Equinox</span>
        </div>
      </div>
    </div>
    <div id="sabbath-tester-loading" class="sabbath-test-loading">
      Loading tests...
    </div>
    <div id="sabbath-tester-results"></div>
  </div>
</div>

<!-- Export/Feasts Page -->
<div id="export-page" class="export-page" style="display: none;">
  <div class="settings-page-header export-header">
    <h2>Appointed Times for <span id="export-year">2026</span></h2>
    <button class="btn export-download-btn" onclick="openInCalendar()">ğŸ“… Export</button>
  </div>
  <div class="export-settings-context">
    <span id="export-context-text">Loading settings...</span>
  </div>
  <div class="settings-content" style="padding-top: 0;">
    <div class="feast-table-container">
      <table class="feast-table">
        <thead>
          <tr>
            <th>Feast</th>
            <th>Date</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody id="export-feast-tbody"></tbody>
      </table>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/astronomy-engine@2.1.19/astronomy.browser.min.js"></script>
<!-- offline-geocode-city: Currently has browser compatibility bug (GitHub issue #2)
     Keeping reference for when it's fixed. Falls back to CITY_SLUGS. -->
<!-- <script src="https://cdn.jsdelivr.net/npm/offline-geocode-city@1.0.2/dist/index.iife.js"></script> -->
<script src="/lunar-calendar-engine.js"></script>
<script src="/sabbath-tester.js"></script>
<script src="/astronomy-utils.js"></script>
<script src="/calendar-core.js"></script>
<script>
// ============================================================================
// ASTRONOMY ENGINE ABSTRACTION LAYER
// ============================================================================
// This abstraction allows switching between different astronomy calculation
// libraries (astronomy-engine, Swiss Ephemeris WASM, etc.) without changing
// the rest of the codebase.

// Available engines registry
const AstroEngines = {
  // Cache for Virgo rule calculations, keyed by year
  virgoCache: {}
};

// Currently active engine instance
let activeAstroEngine = null;

// Engine interface definition (for documentation):
// {
//   name: string,                          // Human-readable name
//   version: string,                       // Library version
//   deltaTModel: string,                   // Î”T model used
//   isLoaded: boolean,                     // Whether engine is ready
//   
//   // Core methods:
//   searchMoonPhase(phase, startDate, limitDays) => { date: Date } | null
//   getSeasons(year) => { mar_equinox: { date: Date }, ... }
//   searchRiseSet(body, observer, direction, startDate, limitDays) => { date: Date } | null
//   searchAltitude(body, observer, direction, startDate, limitDays, altitude) => { date: Date } | null
//   getEquator(body, date, observer) => { ra: number, dec: number }
//   getHorizon(date, observer, ra, dec) => { altitude: number, azimuth: number }
//   getDeltaT(date) => number (in seconds)
//   createObserver(lat, lon, elevation) => observer object
// }

// ============================================================================
// ASTRONOMY-ENGINE IMPLEMENTATION
// ============================================================================
AstroEngines.astronomyEngine = {
  name: 'astronomy-engine',
  version: '2.1.19',
  deltaTModel: 'Espenak-Meeus polynomial',
  deltaTNote: 'Good for modern dates; ~9.5h Î”T uncertainty at 1500 BC',
  isLoaded: true, // Loaded synchronously via script tag
  
  searchMoonPhase(phase, startDate, limitDays) {
    return Astronomy.SearchMoonPhase(phase, startDate, limitDays);
  },
  
  getSeasons(year) {
    return Astronomy.Seasons(year);
  },
  
  searchRiseSet(body, observer, direction, startDate, limitDays) {
    const astroBody = body === 'sun' ? Astronomy.Body.Sun : Astronomy.Body.Moon;
    return Astronomy.SearchRiseSet(astroBody, observer, direction, startDate, limitDays);
  },
  
  searchAltitude(body, observer, direction, startDate, limitDays, altitude) {
    const astroBody = body === 'sun' ? Astronomy.Body.Sun : Astronomy.Body.Moon;
    return Astronomy.SearchAltitude(astroBody, observer, direction, startDate, limitDays, altitude);
  },
  
  getEquator(body, date, observer) {
    // Validate date before calling astronomy-engine
    if (!date || isNaN(date.getTime())) {
      return { ra: 0, dec: 0 };
    }
    try {
      const astroBody = body === 'sun' ? Astronomy.Body.Sun : Astronomy.Body.Moon;
      const result = Astronomy.Equator(astroBody, date, observer, true, true);
      
      // Validate result
      if (result && isFinite(result.ra) && isFinite(result.dec)) {
        return result;
      }
      return { ra: 0, dec: 0 };
    } catch (err) {
      return { ra: 0, dec: 0 };
    }
  },
  
  getHorizon(date, observer, ra, dec) {
    // Validate inputs before calling astronomy-engine
    if (!date || isNaN(date.getTime()) || !isFinite(ra) || !isFinite(dec)) {
      return { altitude: 0, azimuth: 0 };
    }
    try {
      const result = Astronomy.Horizon(date, observer, ra, dec, 'normal');
      if (result && isFinite(result.altitude) && isFinite(result.azimuth)) {
        return result;
      }
      return { altitude: 0, azimuth: 0 };
    } catch (err) {
      return { altitude: 0, azimuth: 0 };
    }
  },
  
  getDeltaT(date) {
    // astronomy-engine doesn't expose DeltaT directly, but we can calculate it
    // from the difference between TT and UT
    const astroTime = new Astronomy.AstroTime(date);
    return (astroTime.tt - astroTime.ut) * 86400; // Convert days to seconds
  },
  
  createObserver(lat, lon, elevation = 0) {
    return new Astronomy.Observer(lat, lon, elevation);
  }
};

// ============================================================================
// SWISS EPHEMERIS WASM IMPLEMENTATION (@swisseph/browser - self-hosted)
// ============================================================================
AstroEngines.swissEphemeris = {
  name: 'Swiss Ephemeris',
  version: 'Loading...',
  deltaTModel: 'Moshier Ephemeris',
  deltaTNote: 'Built-in analytical ephemeris; good for dates from 3000 BC to 3000 AD',
  isLoaded: false,
  _swe: null,
  _module: null,
  _loadPromise: null,
  
  async load() {
    if (this.isLoaded) return true;
    if (this._loadPromise) return this._loadPromise;
    
    this._loadPromise = (async () => {
      try {
        // Dynamic import of self-hosted @swisseph/browser
        const module = await import('/lib/swisseph/swisseph-browser.js');
        this._module = module;
        
        // Create SwissEphemeris instance and initialize WASM with explicit path
        this._swe = new module.SwissEphemeris();
        await this._swe.init('/lib/swisseph/swisseph.wasm');
        
        this.version = '1.1.0';
        this.isLoaded = true;
        console.log('Swiss Ephemeris WASM loaded successfully');
        return true;
      } catch (err) {
        console.error('Failed to load Swiss Ephemeris WASM:', err);
        this.isLoaded = false;
        return false;
      }
    })();
    
    return this._loadPromise;
  },
  
  // Julian Day conversion helpers
  _dateToJD(date) {
    const y = date.getUTCFullYear();
    const m = date.getUTCMonth() + 1;
    const d = date.getUTCDate();
    const h = date.getUTCHours() + date.getUTCMinutes() / 60 + date.getUTCSeconds() / 3600;
    
    const a = Math.floor((14 - m) / 12);
    const yy = y + 4800 - a;
    const mm = m + 12 * a - 3;
    
    // Julian calendar for dates before Oct 15, 1582
    // Gregorian calendar for dates on or after Oct 15, 1582
    let jdn;
    if (y < 1582 || (y === 1582 && (m < 10 || (m === 10 && d < 15)))) {
      jdn = d + Math.floor((153 * mm + 2) / 5) + 365 * yy + Math.floor(yy / 4) - 32083;
    } else {
      jdn = d + Math.floor((153 * mm + 2) / 5) + 365 * yy + Math.floor(yy / 4) - Math.floor(yy / 100) + Math.floor(yy / 400) - 32045;
    }
    return jdn + (h - 12) / 24;
  },
  
  _jdToDate(jd) {
    // Helper to create Date with proper year handling (including negative years)
    const createDate = (year, month, day, h, min, sec) => {
      // JavaScript Date.UTC interprets years 0-99 as 1900-1999
      // We need to use setUTCFullYear for ancient dates
      const date = new Date(Date.UTC(2000, month - 1, day, h, min, sec));
      date.setUTCFullYear(year);
      return date;
    };
    
    if (!this._swe) {
      // Manual Julian Day to calendar date conversion
      const z = Math.floor(jd + 0.5);
      const f = jd + 0.5 - z;
      let a = z;
      if (z >= 2299161) {
        const alpha = Math.floor((z - 1867216.25) / 36524.25);
        a = z + 1 + alpha - Math.floor(alpha / 4);
      }
      const b = a + 1524;
      const c = Math.floor((b - 122.1) / 365.25);
      const d = Math.floor(365.25 * c);
      const e = Math.floor((b - d) / 30.6001);
      
      const day = b - d - Math.floor(30.6001 * e);
      const month = e < 14 ? e - 1 : e - 13;
      const year = month > 2 ? c - 4716 : c - 4715;
      
      const hours = f * 24;
      const h = Math.floor(hours);
      const minutes = (hours - h) * 60;
      const min = Math.floor(minutes);
      const sec = Math.floor((minutes - min) * 60);
      
      return createDate(year, month, day, h, min, sec);
    }
    
    // Use library's conversion
    try {
      const cal = this._swe.julianDayToDate(jd);
      // The library might return hours as a decimal or separate hour/minute/second fields
      let h = 0, min = 0, sec = 0;
      if (typeof cal.hours === 'number') {
        h = Math.floor(cal.hours);
        min = Math.floor((cal.hours % 1) * 60);
        sec = Math.floor(((cal.hours % 1) * 60 % 1) * 60);
      } else if (typeof cal.hour === 'number') {
        h = cal.hour;
        min = cal.minute || 0;
        sec = Math.floor(cal.second || 0);
      }
      
      return createDate(cal.year, cal.month, cal.day, h, min, sec);
    } catch (err) {
      console.warn('Swiss Ephemeris julianDayToDate failed, using manual conversion:', err);
      // Fall through to manual calculation
      const z = Math.floor(jd + 0.5);
      const f = jd + 0.5 - z;
      let a = z;
      if (z >= 2299161) {
        const alpha = Math.floor((z - 1867216.25) / 36524.25);
        a = z + 1 + alpha - Math.floor(alpha / 4);
      }
      const b = a + 1524;
      const c = Math.floor((b - 122.1) / 365.25);
      const d = Math.floor(365.25 * c);
      const e = Math.floor((b - d) / 30.6001);
      
      const day = b - d - Math.floor(30.6001 * e);
      const month = e < 14 ? e - 1 : e - 13;
      const year = month > 2 ? c - 4716 : c - 4715;
      
      const hours = f * 24;
      const hh = Math.floor(hours);
      const minutes = (hours - hh) * 60;
      const mm = Math.floor(minutes);
      const ss = Math.floor((minutes - mm) * 60);
      
      return createDate(year, month, day, hh, mm, ss);
    }
  },
  
  // Get Moon-Sun elongation for phase calculations
  _getMoonSunElongation(jd) {
    if (!this._swe || !this._module) return null;
    
    try {
      const Planet = this._module.Planet;
      const sunPos = this._swe.calculatePosition(jd, Planet.Sun);
      const moonPos = this._swe.calculatePosition(jd, Planet.Moon);
      
      if (sunPos.longitude === undefined || moonPos.longitude === undefined) {
        return null;
      }
      
      let elongation = moonPos.longitude - sunPos.longitude;
      while (elongation < 0) elongation += 360;
      while (elongation >= 360) elongation -= 360;
      return elongation;
    } catch (err) {
      return null;
    }
  },
  
  searchMoonPhase(phase, startDate, limitDays) {
    if (!this.isLoaded || !this._swe) {
      return AstroEngines.astronomyEngine.searchMoonPhase(phase, startDate, limitDays);
    }
    
    const startJD = this._dateToJD(startDate);
    const endJD = startJD + limitDays;
    const step = 1;
    
    let prevJD = startJD;
    let prevElong = this._getMoonSunElongation(prevJD);
    if (prevElong === null) {
      return AstroEngines.astronomyEngine.searchMoonPhase(phase, startDate, limitDays);
    }
    
    const targetPhase = phase % 360;
    
    for (let jd = startJD + step; jd <= endJD; jd += step) {
      let elong = this._getMoonSunElongation(jd);
      if (elong === null) continue;
      
      // Check for phase crossing (handling 360â†’0 wrap)
      let crossed = false;
      if (targetPhase === 0) {
        // New moon: elongation wraps from ~359Â° down to ~1Â° (crosses 0Â°)
        // This happens when prevElong is high (>300) and elong is low (<60)
        if (prevElong > 300 && elong < 60) crossed = true;
      } else if (targetPhase === 180) {
        // Full moon: elongation crossing 180 from below
        if (prevElong < 180 && elong >= 180) crossed = true;
      } else {
        // Other phases
        if ((prevElong < targetPhase && elong >= targetPhase) ||
            (prevElong > targetPhase && elong <= targetPhase && Math.abs(prevElong - elong) < 180)) {
          crossed = true;
        }
      }
      
      if (crossed) {
        // Refine with bisection
        let lo = prevJD, hi = jd;
        for (let i = 0; i < 20; i++) { // ~1 second precision
          const mid = (lo + hi) / 2;
          const midElong = this._getMoonSunElongation(mid);
          if (midElong === null) break;
          
          if (targetPhase === 0) {
            // New moon: we want to find where elongation is closest to 0
            // If midElong > 180, we're before the crossing (moon catching up)
            if (midElong > 180) lo = mid; else hi = mid;
          } else if (targetPhase === 180) {
            if (midElong < 180) lo = mid; else hi = mid;
          } else {
            if (midElong < targetPhase) lo = mid; else hi = mid;
          }
        }
        
        const resultJD = (lo + hi) / 2;
        return { date: this._jdToDate(resultJD), jd: resultJD };
      }
      
      prevJD = jd;
      prevElong = elong;
    }
    
    return null;
  },
  
  getSeasons(year) {
    if (!this.isLoaded || !this._swe || !this._module) {
      return AstroEngines.astronomyEngine.getSeasons(year);
    }
    
    try {
      const Planet = this._module.Planet;
      
      // Start search around March 1
      // Use setUTCFullYear for proper handling of negative/ancient years
      const startDate = new Date(Date.UTC(2000, 2, 1));
      startDate.setUTCFullYear(year);
      let jd = this._dateToJD(startDate);
      const endJD = jd + 30;
      
      let prevLon = null;
      for (; jd <= endJD; jd += 0.5) {
        const sunPos = this._swe.calculatePosition(jd, Planet.Sun);
        const lon = sunPos.longitude;
        
        // Spring equinox: Sun crossing 0Â° from ~359Â° to ~1Â°
        if (prevLon !== null && prevLon > 350 && lon < 10) {
          // Refine with bisection
          let lo = jd - 0.5, hi = jd;
          for (let i = 0; i < 20; i++) {
            const mid = (lo + hi) / 2;
            const midPos = this._swe.calculatePosition(mid, Planet.Sun);
            const midLon = midPos.longitude;
            if (midLon > 180) lo = mid; else hi = mid;
          }
          
          return {
            mar_equinox: { date: this._jdToDate((lo + hi) / 2) }
          };
        }
        prevLon = lon;
      }
    } catch (err) {
      console.warn('Error finding equinox with Swiss Ephemeris:', err);
    }
    
    // Fallback
    return AstroEngines.astronomyEngine.getSeasons(year);
  },
  
  searchRiseSet(body, observer, direction, startDate, limitDays) {
    // Swiss Ephemeris rise/set calculation is complex, use fallback for now
    return AstroEngines.astronomyEngine.searchRiseSet(body, observer, direction, startDate, limitDays);
  },
  
  searchAltitude(body, observer, direction, startDate, limitDays, altitude) {
    return AstroEngines.astronomyEngine.searchAltitude(body, observer, direction, startDate, limitDays, altitude);
  },
  
  getEquator(body, date, observer) {
    if (!this.isLoaded || !this._swe || !this._module) {
      return AstroEngines.astronomyEngine.getEquator(body, date, observer);
    }
    
    try {
      const Planet = this._module.Planet;
      const CalculationFlag = this._module.CalculationFlag;
      const planet = body === 'sun' ? Planet.Sun : Planet.Moon;
      const jd = this._dateToJD(date);
      
      // Get equatorial coordinates
      const pos = this._swe.calculatePosition(jd, planet, CalculationFlag.Equatorial);
      
      // Validate result - if invalid, fall back to astronomy-engine
      if (pos && isFinite(pos.rightAscension) && isFinite(pos.declination)) {
        return {
          ra: pos.rightAscension / 15, // Convert degrees to hours
          dec: pos.declination
        };
      }
      
      // Invalid result, fall back
      return AstroEngines.astronomyEngine.getEquator(body, date, observer);
    } catch (err) {
      return AstroEngines.astronomyEngine.getEquator(body, date, observer);
    }
  },
  
  getHorizon(date, observer, ra, dec) {
    // Use astronomy-engine for horizon conversion (simpler)
    return AstroEngines.astronomyEngine.getHorizon(date, observer, ra, dec);
  },
  
  getDeltaT(date) {
    if (!this.isLoaded || !this._swe) {
      return AstroEngines.astronomyEngine.getDeltaT(date);
    }
    
    try {
      const jd = this._dateToJD(date);
      const deltaT = this._swe.deltaT(jd);
      return deltaT * 86400; // Convert days to seconds
    } catch (err) {
      return AstroEngines.astronomyEngine.getDeltaT(date);
    }
  },
  
  createObserver(lat, lon, elevation = 0) {
    // Use astronomy-engine observer format for compatibility
    return new Astronomy.Observer(lat, lon, elevation);
  }
};

// ============================================================================
// HYBRID ENGINE: Swiss Ephemeris calibrated against NASA Eclipse anchors
// ============================================================================
// This approach uses Swiss Ephemeris for precise local calculations, but
// calibrates the Î”T model against NASA eclipse data to reduce drift for 
// ancient dates. NASA eclipses are observable historical events with known
// times, providing ground truth for Î”T corrections.
// ============================================================================
AstroEngines.nasaEclipse = {
  name: 'Hybrid (Swiss Eph + NASA)',
  version: '1.0',
  deltaTModel: 'NASA Eclipse Calibrated',
  deltaTNote: 'Swiss Ephemeris calculations aligned to NASA eclipse anchors',
  isLoaded: false,
  _eclipses: null,  // Array of {jd, y, t} where t='n' (new) or 'f' (full)
  _loadPromise: null,
  _offsetCache: new Map(), // Cache offset calculations by year
  
  async load() {
    if (this.isLoaded) return true;
    if (this._loadPromise) return this._loadPromise;
    
    this._loadPromise = (async () => {
      try {
        const response = await fetch('/data/eclipses.json');
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        this._eclipses = await response.json();
        this.isLoaded = true;
        console.log(`NASA Eclipse data loaded: ${this._eclipses.length} eclipses`);
        return true;
      } catch (err) {
        console.error('Failed to load NASA eclipse data:', err);
        this.isLoaded = false;
        return false;
      }
    })();
    
    return this._loadPromise;
  },
  
  // Julian Day conversion (handles both Julian and Gregorian calendars)
  _dateToJD(date) {
    const y = date.getUTCFullYear();
    const m = date.getUTCMonth() + 1;
    const d = date.getUTCDate();
    const h = date.getUTCHours() + date.getUTCMinutes() / 60 + date.getUTCSeconds() / 3600;
    
    const a = Math.floor((14 - m) / 12);
    const yy = y + 4800 - a;
    const mm = m + 12 * a - 3;
    
    // Julian calendar for dates before Oct 15, 1582
    // Gregorian calendar for dates on or after Oct 15, 1582
    let jdn;
    if (y < 1582 || (y === 1582 && (m < 10 || (m === 10 && d < 15)))) {
      // Julian calendar
      jdn = d + Math.floor((153 * mm + 2) / 5) + 365 * yy + Math.floor(yy / 4) - 32083;
    } else {
      // Gregorian calendar
      jdn = d + Math.floor((153 * mm + 2) / 5) + 365 * yy + Math.floor(yy / 4) - Math.floor(yy / 100) + Math.floor(yy / 400) - 32045;
    }
    return jdn + (h - 12) / 24;
  },
  
  _jdToDate(jd) {
    const createDate = (year, month, day, h, min, sec) => {
      const date = new Date(Date.UTC(2000, month - 1, day, h, min, sec));
      date.setUTCFullYear(year);
      return date;
    };
    
    const z = Math.floor(jd + 0.5);
    const f = jd + 0.5 - z;
    let a = z;
    if (z >= 2299161) {
      const alpha = Math.floor((z - 1867216.25) / 36524.25);
      a = z + 1 + alpha - Math.floor(alpha / 4);
    }
    const b = a + 1524;
    const c = Math.floor((b - 122.1) / 365.25);
    const d = Math.floor(365.25 * c);
    const e = Math.floor((b - d) / 30.6001);
    
    const day = b - d - Math.floor(30.6001 * e);
    const month = e < 14 ? e - 1 : e - 13;
    const year = month > 2 ? c - 4716 : c - 4715;
    
    const hours = f * 24;
    const hh = Math.floor(hours);
    const minutes = (hours - hh) * 60;
    const mm = Math.floor(minutes);
    const ss = Math.floor((minutes - mm) * 60);
    
    return createDate(year, month, day, hh, mm, ss);
  },
  
  // Find eclipse of given type before or after a JD
  _findEclipse(targetJD, type, direction) {
    if (!this._eclipses) return null;
    
    // Binary search for approximate position
    let lo = 0, hi = this._eclipses.length - 1;
    while (lo < hi) {
      const mid = Math.floor((lo + hi) / 2);
      if (this._eclipses[mid].jd < targetJD) lo = mid + 1;
      else hi = mid;
    }
    
    if (direction < 0) {
      // Search backward for eclipse of this type
      for (let i = lo - 1; i >= 0; i--) {
        if (this._eclipses[i].t === type) return this._eclipses[i];
      }
    } else {
      // Search forward for eclipse of this type
      for (let i = lo; i < this._eclipses.length; i++) {
        if (this._eclipses[i].t === type) return this._eclipses[i];
      }
    }
    return null;
  },
  
  // Find the nearest eclipse (any type) to a given JD
  _findNearestEclipse(targetJD) {
    if (!this._eclipses || this._eclipses.length === 0) return null;
    
    let lo = 0, hi = this._eclipses.length - 1;
    while (lo < hi) {
      const mid = Math.floor((lo + hi) / 2);
      if (this._eclipses[mid].jd < targetJD) lo = mid + 1;
      else hi = mid;
    }
    
    // Check both lo and lo-1 to find closest
    const candidates = [];
    if (lo > 0) candidates.push(this._eclipses[lo - 1]);
    if (lo < this._eclipses.length) candidates.push(this._eclipses[lo]);
    
    let nearest = null;
    let minDist = Infinity;
    for (const e of candidates) {
      const dist = Math.abs(e.jd - targetJD);
      if (dist < minDist) {
        minDist = dist;
        nearest = e;
      }
    }
    return nearest;
  },
  
  // Check if a given date has a lunar eclipse (blood moon)
  // Returns true if there's a lunar eclipse within 0.5 days of the given date
  hasLunarEclipse(date) {
    if (!this._eclipses) {
      return false;
    }
    
    const jd = this._dateToJD(date);
    
    // Binary search to find nearby eclipses
    let lo = 0, hi = this._eclipses.length - 1;
    while (lo < hi) {
      const mid = Math.floor((lo + hi) / 2);
      if (this._eclipses[mid].jd < jd) lo = mid + 1;
      else hi = mid;
    }
    
    // Check nearby eclipses (within a day on either side)
    for (let i = Math.max(0, lo - 2); i < Math.min(this._eclipses.length, lo + 3); i++) {
      const e = this._eclipses[i];
      const diff = Math.abs(e.jd - jd);
      if (e.t === 'f' && diff < 1.0) {
        return true;
      }
    }
    return false;
  },
  
  // Get the exact time of a lunar eclipse for a given date
  // Returns a Date object or null if no eclipse found
  getLunarEclipseTime(date) {
    if (!this._eclipses) {
      return null;
    }
    
    const jd = this._dateToJD(date);
    
    // Binary search to find nearby eclipses
    let lo = 0, hi = this._eclipses.length - 1;
    while (lo < hi) {
      const mid = Math.floor((lo + hi) / 2);
      if (this._eclipses[mid].jd < jd) lo = mid + 1;
      else hi = mid;
    }
    
    // Check nearby eclipses (within a day on either side)
    for (let i = Math.max(0, lo - 2); i < Math.min(this._eclipses.length, lo + 3); i++) {
      const e = this._eclipses[i];
      const diff = Math.abs(e.jd - jd);
      if (e.t === 'f' && diff < 1.0) {
        // Convert JD to Date
        return this._jdToDate(e.jd);
      }
    }
    return null;
  },
  
  // Helper to create Date with proper year handling (including negative years)
  _createDate(year, month, day, hour, minute, second) {
    // JavaScript Date.UTC interprets years 0-99 as 1900-1999
    // We need to use setUTCFullYear for all dates to be safe
    const date = new Date(Date.UTC(2000, month - 1, day, hour || 0, minute || 0, second || 0));
    date.setUTCFullYear(year);
    return date;
  },
  
  // Calculate the Î”T offset between Swiss Ephemeris and NASA eclipse
  // This is the key to the hybrid approach
  _calculateOffset(nearYear, eclipseType) {
    const cacheKey = `${nearYear}_${eclipseType}`;
    if (this._offsetCache.has(cacheKey)) {
      return this._offsetCache.get(cacheKey);
    }
    
    if (!AstroEngines.swissEphemeris.isLoaded) {
      return 0;
    }
    
    // Find a NASA eclipse near the target year
    const midYearDate = this._createDate(nearYear, 7, 1, 0, 0, 0);
    const approxJD = this._dateToJD(midYearDate);
    
    const nasaEclipse = this._findEclipse(approxJD, eclipseType, -1) || 
                        this._findEclipse(approxJD, eclipseType, 1);
    
    if (!nasaEclipse) {
      return 0;
    }
    
    // Get what Swiss Ephemeris calculates for this same moon phase
    const searchStart = this._jdToDate(nasaEclipse.jd - 3);
    const phase = eclipseType === 'n' ? 0 : 180;
    
    try {
      const sweResult = AstroEngines.swissEphemeris.searchMoonPhase(phase, searchStart, 10);
      if (!sweResult || !sweResult.date) {
        return 0;
      }
      
      // Use JD directly if available (avoids Date round-trip issues with ancient dates)
      const sweJD = sweResult.jd || this._dateToJD(sweResult.date);
      
      // Sanity check - offset should be reasonable (less than a few days)
      const offset = nasaEclipse.jd - sweJD;
      if (!isFinite(offset) || Math.abs(offset) > 5) {
        return 0;
      }
      
      this._offsetCache.set(cacheKey, offset);
      return offset;
    } catch (err) {
      console.warn(`Error calculating offset for year ${nearYear}:`, err);
      return 0;
    }
  },
  
  // Hybrid moon phase search:
  // 1. Use Swiss Ephemeris for precise phase calculation
  // 2. Apply Î”T correction from nearest NASA eclipse anchor
  searchMoonPhase(phase, startDate, limitDays) {
    try {
      if (!AstroEngines.swissEphemeris.isLoaded) {
        return this._searchMoonPhaseInterpolate(phase, startDate, limitDays);
      }
      
      if (!this.isLoaded || !this._eclipses) {
        return AstroEngines.swissEphemeris.searchMoonPhase(phase, startDate, limitDays);
      }
      
      const sweResult = AstroEngines.swissEphemeris.searchMoonPhase(phase, startDate, limitDays);
      if (!sweResult || !sweResult.date) return null;
      
      if (isNaN(sweResult.date.getTime())) {
        return this._searchMoonPhaseInterpolate(phase, startDate, limitDays);
      }
      
      // For modern dates (1600-2100 CE), Swiss Eph is already accurate
      const year = sweResult.date.getUTCFullYear();
      if (year >= 1600 && year <= 2100) {
        return sweResult;
      }
      
      // For ancient/future dates, apply NASA eclipse calibration
      const eclipseType = (phase === 0 || phase === 360) ? 'n' : 'f';
      const offset = this._calculateOffset(year, eclipseType);
      
      if (!isFinite(offset) || Math.abs(offset) < 0.001) {
        return sweResult;
      }
      
      // Apply the offset correction using JD directly if available
      const sweJD = sweResult.jd || this._dateToJD(sweResult.date);
      const correctedJD = sweJD + offset;
      
      if (!isFinite(correctedJD)) {
        return sweResult;
      }
      
      return { date: this._jdToDate(correctedJD) };
    } catch (err) {
      return this._searchMoonPhaseInterpolate(phase, startDate, limitDays);
    }
  },
  
  // Pure interpolation fallback (original algorithm)
  _searchMoonPhaseInterpolate(phase, startDate, limitDays) {
    if (!this.isLoaded || !this._eclipses) {
      return AstroEngines.astronomyEngine.searchMoonPhase(phase, startDate, limitDays);
    }
    
    const targetJD = this._dateToJD(startDate);
    const endJD = targetJD + limitDays;
    const SYNODIC_MONTH = 29.530588853;
    
    const wantNewMoon = (phase === 0 || phase === 360);
    const eclipseType = wantNewMoon ? 'n' : 'f';
    
    const eclipseBefore = this._findEclipse(targetJD, eclipseType, -1);
    const eclipseAfter = this._findEclipse(targetJD, eclipseType, 1);
    
    if (!eclipseBefore && !eclipseAfter) {
      return AstroEngines.astronomyEngine.searchMoonPhase(phase, startDate, limitDays);
    }
    
    let localSynodicMonth = SYNODIC_MONTH;
    if (eclipseBefore && eclipseAfter) {
      const span = eclipseAfter.jd - eclipseBefore.jd;
      const lunations = Math.round(span / SYNODIC_MONTH);
      if (lunations > 0) {
        localSynodicMonth = span / lunations;
      }
    }
    
    let anchorEclipse, direction;
    if (!eclipseBefore) {
      anchorEclipse = eclipseAfter;
      direction = -1;
    } else if (!eclipseAfter) {
      anchorEclipse = eclipseBefore;
      direction = 1;
    } else {
      const distBefore = targetJD - eclipseBefore.jd;
      const distAfter = eclipseAfter.jd - targetJD;
      if (distBefore <= distAfter) {
        anchorEclipse = eclipseBefore;
        direction = 1;
      } else {
        anchorEclipse = eclipseAfter;
        direction = -1;
      }
    }
    
    let resultJD;
    if (direction > 0) {
      const lunationsFromAnchor = Math.ceil((targetJD - anchorEclipse.jd) / localSynodicMonth);
      resultJD = anchorEclipse.jd + lunationsFromAnchor * localSynodicMonth;
    } else {
      const lunationsFromAnchor = Math.ceil((anchorEclipse.jd - targetJD) / localSynodicMonth);
      resultJD = anchorEclipse.jd - (lunationsFromAnchor - 1) * localSynodicMonth;
    }
    
    while (resultJD < targetJD) resultJD += localSynodicMonth;
    if (resultJD > endJD) return null;
    
    return { date: this._jdToDate(resultJD) };
  },
  
  // Use Swiss Ephemeris or astronomy-engine for other calculations
  getSeasons(year) {
    return AstroEngines.swissEphemeris.isLoaded 
      ? AstroEngines.swissEphemeris.getSeasons(year)
      : AstroEngines.astronomyEngine.getSeasons(year);
  },
  
  searchRiseSet(body, observer, direction, startDate, limitDays) {
    return AstroEngines.astronomyEngine.searchRiseSet(body, observer, direction, startDate, limitDays);
  },
  
  searchAltitude(body, observer, direction, startDate, limitDays, altitude) {
    return AstroEngines.astronomyEngine.searchAltitude(body, observer, direction, startDate, limitDays, altitude);
  },
  
  getEquator(body, date, observer) {
    return AstroEngines.swissEphemeris.isLoaded 
      ? AstroEngines.swissEphemeris.getEquator(body, date, observer)
      : AstroEngines.astronomyEngine.getEquator(body, date, observer);
  },
  
  getHorizon(date, observer, ra, dec) {
    return AstroEngines.astronomyEngine.getHorizon(date, observer, ra, dec);
  },
  
  getDeltaT(date) {
    // We don't have direct Î”T values, but the eclipse times incorporate it
    return AstroEngines.swissEphemeris.isLoaded 
      ? AstroEngines.swissEphemeris.getDeltaT(date)
      : AstroEngines.astronomyEngine.getDeltaT(date);
  },
  
  createObserver(lat, lon, elevation = 0) {
    return new Astronomy.Observer(lat, lon, elevation);
  },
  
  // Estimate Î”T uncertainty in hours based on year
  // Since we use NASA eclipse anchors for calibration, uncertainty is reduced
  // compared to raw Î”T models. These values represent residual uncertainty.
  // Reference: https://eclipse.gsfc.nasa.gov/SEcat5/uncertainty.html
  getDeltaTUncertainty(year) {
    // Modern dates (1600-2100): uncertainty is negligible
    if (year >= 1600 && year <= 2100) {
      return 0;
    }
    
    // For ancient dates, uncertainty grows but our hybrid calibration helps
    // These are practical estimates for when day-boundary could be affected:
    // - 500 BC: ~0.5 hours
    // - 1000 BC: ~1 hour
    // - 2000 BC: ~2 hours
    // - 3000 BC: ~3-4 hours
    const yearsFromPresent = Math.abs(year - 2000);
    
    if (yearsFromPresent <= 500) return 0.25;
    if (yearsFromPresent <= 1000) return 0.5;
    if (yearsFromPresent <= 1500) return 1;
    if (yearsFromPresent <= 2000) return 1.5;
    if (yearsFromPresent <= 2500) return 2;
    if (yearsFromPresent <= 3000) return 2.5;
    if (yearsFromPresent <= 4000) return 3;
    if (yearsFromPresent <= 5000) return 4;
    return 6; // Very ancient dates
  }
};

// ============================================================================
// ENGINE MANAGEMENT FUNCTIONS
// ============================================================================

function getAstroEngine() {
  if (!activeAstroEngine) {
    activeAstroEngine = AstroEngines.astronomyEngine;
  }
  return activeAstroEngine;
}

async function setAstroEngine(engineId) {
  const engine = AstroEngines[engineId];
  if (!engine) {
    console.error(`Unknown astronomy engine: ${engineId}`);
    return false;
  }
  
  // If engine needs async loading, do it
  if (engine.load && !engine.isLoaded) {
    const loaded = await engine.load();
    if (!loaded) {
      console.error(`Failed to load engine: ${engineId}`);
      return false;
    }
  }
  
  activeAstroEngine = engine;
  state.astronomyEngine = engineId;
  saveState();
  
  // Update UI
  updateAstroEngineUI();
  
  return true;
}

function updateAstroEngineUI() {
  const engine = getAstroEngine();
  
  // Update engine info display
  const nameEl = document.getElementById('astro-engine-name');
  const deltaEl = document.getElementById('astro-engine-delta');
  
  if (nameEl) nameEl.textContent = `${engine.name} v${engine.version}`;
  if (deltaEl) deltaEl.textContent = engine.deltaTModel;
  
  // Update button states
  document.querySelectorAll('.astro-engine-btn').forEach(btn => {
    btn.classList.toggle('selected', btn.dataset.engine === state.astronomyEngine);
  });
}

// UI handler for selecting astronomy engine (currently disabled - Swiss Ephemeris requires self-hosting)
// The abstraction layer is in place for future engine support
function selectAstroEngine(engineId) {
  if (engineId !== 'astronomyEngine') {
    console.log('Swiss Ephemeris WASM requires self-hosting. Using astronomy-engine.');
  }
}

// Initialize astronomy engine - Hybrid approach combines Swiss Ephemeris precision with NASA eclipse calibration
async function initializeAstroEngine() {
  // Load Swiss Ephemeris for precise calculations
  let sweLoaded = false;
  try {
    sweLoaded = await AstroEngines.swissEphemeris.load();
  } catch (err) {
    console.warn('Swiss Ephemeris not available:', err.message);
  }
  
  // Load NASA Eclipse data for Î”T calibration
  let nasaLoaded = false;
  try {
    nasaLoaded = await AstroEngines.nasaEclipse.load();
  } catch (err) {
    console.warn('NASA Eclipse data not available:', err.message);
  }
  
  // Choose the best available engine configuration
  if (nasaLoaded && sweLoaded) {
    // Best case: Hybrid mode - Swiss Ephemeris calibrated against NASA eclipses
    activeAstroEngine = AstroEngines.nasaEclipse;
    state.astronomyEngine = 'nasaEclipse';
    console.log('Using Hybrid mode: Swiss Ephemeris + NASA Eclipse calibration');
    console.log('  - Modern dates (1600-2100): Swiss Ephemeris direct');
    console.log('  - Ancient dates: Swiss Ephemeris with NASA Î”T correction');
  } else if (nasaLoaded) {
    // NASA data but no Swiss Eph - use interpolation fallback
    activeAstroEngine = AstroEngines.nasaEclipse;
    state.astronomyEngine = 'nasaEclipse';
    console.log('Using NASA Eclipse interpolation (Swiss Ephemeris not available)');
  } else if (sweLoaded) {
    // Swiss Eph but no NASA data - use Swiss Eph alone
    activeAstroEngine = AstroEngines.swissEphemeris;
    state.astronomyEngine = 'swissEphemeris';
    console.log('Using Swiss Ephemeris (no NASA calibration)');
  } else {
    // Fallback to astronomy-engine
    activeAstroEngine = AstroEngines.astronomyEngine;
    state.astronomyEngine = 'astronomyEngine';
    console.log('Using astronomy-engine for calculations');
  }
  
  updateAstroEngineUI();
}

// Make these available globally
window.AstroEngines = AstroEngines;
window.getAstroEngine = getAstroEngine;
window.setAstroEngine = setAstroEngine;
window.updateAstroEngineUI = updateAstroEngineUI;
window.selectAstroEngine = selectAstroEngine;
window.initializeAstroEngine = initializeAstroEngine;

const MONTH_NAMES = [
  '1st Month', '2nd Month', '3rd Month', '4th Month', '5th Month', '6th Month',
  '7th Month', '8th Month', '9th Month', '10th Month', '11th Month', '12th Month', '13th Month'
];

// Shofar SVG icon for Renewed Moon - larger and more distinct
const SHOFAR_ICON = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 20" width="1.4em" height="1.2em" style="vertical-align:middle"><path fill="#A67C00" stroke="#5C4300" stroke-width="1" d="M21 3c-1 0-2 .5-3 1.2c-1.5 1-3 2.5-4 4.3c-1 1.8-2 3.5-3.5 5c-1.5 1.5-3.5 2.5-6 2.5c-1.5 0-2.5 1-2.5 2s1 2 2.5 2c2 0 4-.5 5.5-1.5c1.5-1 3-2.5 4-4c1-1.5 2-3 3-4.5c1-1.5 2-2.5 3-3c.8-.4 1.5-1 1.5-2S22 3 21 3z"/><circle fill="#5C4300" cx="4" cy="17" r="1.2"/></svg>';

// Order matters: single-day feasts should come AFTER multi-day feasts so they take priority
// Order matters for overlapping feasts: specific single-day feasts listed AFTER multi-day feasts take priority
const FEASTS = [
  // Renewed Moon Day - first day of every month (first light after full moon when waning moon is 12Â°+ above western horizon)
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 1, day: 1, description: 'First light after full moon â€” waning moon 12Â°+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 2, day: 1, description: 'First light after full moon â€” waning moon 12Â°+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 3, day: 1, description: 'First light after full moon â€” waning moon 12Â°+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 4, day: 1, description: 'First light after full moon â€” waning moon 12Â°+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 5, day: 1, description: 'First light after full moon â€” waning moon 12Â°+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 6, day: 1, description: 'First light after full moon â€” waning moon 12Â°+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 7, day: 1, description: 'First light after full moon â€” waning moon 12Â°+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 8, day: 1, description: 'First light after full moon â€” waning moon 12Â°+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 9, day: 1, description: 'First light after full moon â€” waning moon 12Â°+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 10, day: 1, description: 'First light after full moon â€” waning moon 12Â°+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 11, day: 1, description: 'First light after full moon â€” waning moon 12Â°+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 12, day: 1, description: 'First light after full moon â€” waning moon 12Â°+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 13, day: 1, description: 'First light after full moon â€” waning moon 12Â°+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  // Specific feasts
  { name: 'Last Supper', shortName: 'Last Supper', icon: 'ğŸğŸ·', month: 1, day: 13, description: 'The Last Supper - bread and wine', chapter: '/chapters/18-appointed-times/#passover' },
  { name: 'Passover', shortName: 'Passover', icon: 'ğŸ‘â€ ', month: 1, day: 14, description: 'Lamb slain at twilight', chapter: '/chapters/18-appointed-times/#passover' },
  { name: 'Unleavened Bread', shortName: 'Unleavened', icon: 'ğŸ«“', month: 1, day: 15, endDay: 21, description: 'High Sabbath, no leaven for 7 days', chapter: '/chapters/18-appointed-times/#unleavened-bread' },
  { name: 'First Fruits', shortName: 'First Fruits', icon: 'ğŸŒ¾', month: 1, day: 16, description: 'Wave sheaf offering (also Unleavened 2)', chapter: '/chapters/18-appointed-times/#first-fruits-of-barley' },
  { name: 'Atzeret of Unleavened', shortName: 'Atzeret', icon: 'ğŸ•', month: 1, day: 21, description: 'Solemn assembly - 7th day of Unleavened Bread', chapter: '/chapters/18-appointed-times/#unleavened-bread' },
  { name: 'Shavuot', shortName: 'Shavuot', icon: 'ğŸŒ¾', month: 3, day: 16, description: '7 complete weeks after First Fruits', chapter: '/chapters/18-appointed-times/#shavuot---first-fruits-of-wheat' },
  { name: 'Trumpets', shortName: 'Trumpets', icon: 'ğŸº', month: 7, day: 1, description: 'Day of shouting/blowing', chapter: '/chapters/18-appointed-times/#trumpets---first-fruits-of-oil' },
  { name: 'Atonement', shortName: 'Atonement', icon: 'ğŸ©¸', month: 7, day: 10, description: 'Yom Kippur - day of fasting', chapter: '/chapters/18-appointed-times/#day-of-atonement' },
  { name: 'Tabernacles', shortName: 'Tabernacles', icon: 'â›º', month: 7, day: 15, endDay: 21, description: 'Feast of Booths', chapter: '/chapters/18-appointed-times/#tabernacles' },
  { name: 'Atzeret', shortName: 'Atzeret', icon: 'ğŸ•', month: 7, day: 22, description: 'Shemini Atzeret - Last Great Day', chapter: '/chapters/18-appointed-times/#atzeret---last-great-day' },
  { name: 'Hanukkah', shortName: 'Hanukkah', icon: 'ğŸ•', month: 9, day: 25, endDay: 30, description: 'Festival of Dedication (8 days)', chapter: '/chapters/18-appointed-times/#hanukkah', continuesNextMonth: true },
  { name: 'Hanukkah', shortName: 'Hanukkah', icon: 'ğŸ•', month: 10, day: 1, endDay: 2, description: 'Festival of Dedication (continued)', chapter: '/chapters/18-appointed-times/#hanukkah', startDayNum: 7 },
  { name: 'Atzeret of Hanukkah', shortName: 'Atzeret', icon: 'ğŸ•', month: 10, day: 2, description: 'Atzeret - 8th day of Hanukkah', chapter: '/chapters/18-appointed-times/#hanukkah' },
  { name: 'Purim', shortName: 'Purim', icon: 'ğŸ“œ', month: 12, day: 14, endDay: 15, description: 'Feast of Lots - deliverance from Haman', chapter: '/chapters/18-appointed-times/#purim' }
];

const SCRIPTURES = [
  { text: "It shall be established forever like the moon, even like the trustworthy witness in the sky.", ref: "Psalms 89:37" },
  { text: "He appointed the moon for seasons; the sun knows its going down.", ref: "Psalms 104:19" },
  { text: "And God said, Let there be lights in the firmament... for signs, and for seasons, and for days, and years.", ref: "Genesis 1:14" },
  { text: "Blow the trumpet at the new moon, at the full moon, on our feast day.", ref: "Psalms 81:3" }
];

// Central state object with defaults
const defaultState = {
  year: new Date().getFullYear(),
  lat: 31.7683,
  lon: 35.2137,
  city: '31.7683,35.2137', // Store the city select value directly
  moonPhase: 'full',
  dayStartTime: 'morning',  // 'evening' or 'morning'
  dayStartAngle: 12,        // 0, 6, 12, or 18 degrees below horizon
  yearStartRule: 'equinox', // 'equinox', '13daysBefore', or 'virgoFeet'
  crescentThreshold: 18,    // Hours after conjunction for crescent visibility (12, 15.5, 18, or 24)
  sabbathMode: 'lunar',     // 'lunar', 'saturday', 'sunday', 'friday', 'none'
  selectedProfile: 'timeTested', // Currently selected profile ID
  astronomyEngine: 'astronomyEngine', // 'astronomyEngine' or 'swissEphemeris'
  lunarMonths: [],
  currentMonthIndex: 0,
  highlightedLunarDay: 1,  // Default to day 1
  selectedTimestamp: null,  // UTC timestamp of selected moment
  pendingNavigationDate: null,  // Used when switching profiles to navigate to same Gregorian date
  viewTime: null  // Custom view time (null = use current time)
};

// Migrate old crescentThreshold values (degrees) to new format (hours)
// Old format: 5, 8, 10, 12 degrees
// New format: 12, 15.5, 18, 24 hours
function migrateCrescentThreshold(value) {
  if (value === undefined) return 18; // Default
  // Valid new values
  if (value === 12 || value === 15.5 || value === 18 || value === 24) return value;
  // Old values that need migration - default to 18h
  if (value === 5 || value === 8 || value === 10) return 18;
  // Unknown value, use default
  return 18;
}

// Load saved state from localStorage or use defaults
function loadState() {
  const saved = localStorage.getItem('lunarCalendarState');
  if (saved) {
    try {
      const parsed = JSON.parse(saved);
      return {
        ...defaultState,
        year: parsed.year || defaultState.year,
        lat: parsed.lat || defaultState.lat,
        lon: parsed.lon || defaultState.lon,
        city: parsed.city || '',
        moonPhase: parsed.moonPhase || defaultState.moonPhase,
        dayStartTime: parsed.dayStartTime || defaultState.dayStartTime,
        dayStartAngle: parsed.dayStartAngle !== undefined ? parsed.dayStartAngle : defaultState.dayStartAngle,
        yearStartRule: parsed.yearStartRule || defaultState.yearStartRule,
        crescentThreshold: migrateCrescentThreshold(parsed.crescentThreshold),
        sabbathMode: parsed.sabbathMode || defaultState.sabbathMode,
        selectedProfile: parsed.selectedProfile || defaultState.selectedProfile
        // astronomyEngine is always 'astronomyEngine' for now (Swiss Ephemeris requires self-hosting)
      };
    } catch (e) {
      return { ...defaultState };
    }
  }
  return { ...defaultState };
}

// ============================================================================
// WORLD CLOCK - Profile + Location combinations for comparison
// ============================================================================

// Get default world clock entries (stable - not dependent on current navigation state)
function getDefaultWorldClockEntries() {
  const entries = [];
  const seen = new Set();
  
  // Helper to add unique entries
  const addEntry = (profileId, locationSlug, locationName) => {
    const key = `${profileId}:${locationSlug}`;
    if (seen.has(key)) return;
    seen.add(key);
    entries.push({ profileId, locationSlug, locationName });
  };
  
  // User's saved GPS location (from localStorage) - stable across navigation
  const savedLoc = getSavedUserLocation();
  if (savedLoc) {
    const savedSlug = getClosestCitySlug(savedLoc.lat, savedLoc.lon, Infinity) || 'jerusalem';
    const savedName = savedLoc.city || formatCitySlug(savedSlug);
    // Add Time-Tested at user's location first
    addEntry('timeTested', savedSlug, savedName);
  }
  
  // All presets in Jerusalem
  for (const [profileId, profile] of Object.entries(PRESET_PROFILES)) {
    addEntry(profileId, 'jerusalem', 'Jerusalem');
  }
  
  return entries;
}

// Load world clock entries from localStorage
function loadWorldClockEntries() {
  try {
    const saved = localStorage.getItem('worldClockEntries');
    if (saved) {
      return JSON.parse(saved);
    }
  } catch (e) {
    console.error('Error loading world clock entries:', e);
  }
  return null;  // null means use defaults
}

// Save world clock entries to localStorage
function saveWorldClockEntries(entries) {
  try {
    localStorage.setItem('worldClockEntries', JSON.stringify(entries));
  } catch (e) {
    console.error('Error saving world clock entries:', e);
  }
}

// Get current world clock entries (saved or defaults)
// Once defaults are generated, they're saved to keep the list stable
function getWorldClockEntries() {
  let entries = loadWorldClockEntries();
  if (!entries) {
    entries = getDefaultWorldClockEntries();
    saveWorldClockEntries(entries);  // Save so list stays stable
  }
  return entries;
}

// Add a world clock entry
function addWorldClockEntry(profileId, locationSlug, locationName) {
  const entries = getWorldClockEntries();
  const key = `${profileId}:${locationSlug}`;
  
  // Check for duplicates
  const exists = entries.some(e => `${e.profileId}:${e.locationSlug}` === key);
  if (exists) return false;
  
  entries.push({ profileId, locationSlug, locationName });
  saveWorldClockEntries(entries);
  return true;
}

// Remove a world clock entry
function removeWorldClockEntry(index) {
  const entries = getWorldClockEntries();
  if (index >= 0 && index < entries.length) {
    entries.splice(index, 1);
    saveWorldClockEntries(entries);
    return true;
  }
  return false;
}

// Reset world clock to defaults
function resetWorldClockEntries() {
  localStorage.removeItem('worldClockEntries');
}

// Format city slug for display
function formatCitySlug(slug) {
  return slug.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
}

// ============================================================================
// VIEW TIME - Current time being viewed (for "This Moment" comparisons)
// ============================================================================

let viewTimeInterval = null;

// Get the current view time - returns UTC timestamp
// getViewTime moved to calendar-core.js

// Get current local time at the set location
function getLocalTimeAtCurrentLocation() {
  const now = new Date();
  const tzOffsetHours = Math.round(state.lon / 15);
  const localMs = now.getTime() + (tzOffsetHours * 60 * 60 * 1000);
  return new Date(localMs);
}

// Start live time updates - DISABLED: time only updates on explicit user action
function startLiveTimeUpdates() {
  // No longer auto-update - time is set once and stays until user changes it
  // User must explicitly click "Use Current Time" to update to now
}

// ============================================================================
// ABOUT MODAL
// ============================================================================

function showAboutModal() {
  const overlay = document.getElementById('about-modal-overlay');
  if (overlay) {
    overlay.classList.add('visible');
  } else {
    console.error('About modal overlay not found - modal HTML may be missing');
  }
}

function closeAboutModal(event) {
  // If called from overlay click, only close if clicking the overlay itself
  if (event && event.target !== event.currentTarget) return;
  
  const overlay = document.getElementById('about-modal-overlay');
  
  // Track dismissals: increment count and store today's date
  const dismissCount = parseInt(localStorage.getItem('aboutModalDismissCount') || '0');
  const newCount = dismissCount + 1;
  localStorage.setItem('aboutModalDismissCount', newCount.toString());
  
  // Store today's date (YYYY-MM-DD format)
  const today = new Date().toISOString().split('T')[0];
  localStorage.setItem('aboutModalLastDismissDate', today);
  
  if (overlay) {
    overlay.classList.remove('visible');
  }
  
  // If URL is /about, navigate back to calendar
  if (window.location.pathname === '/about' || window.location.pathname === '/about/') {
    updateURL();
  }
}

function shouldShowAboutModal() {
  // Never show if dismissed 3+ times
  const dismissCount = parseInt(localStorage.getItem('aboutModalDismissCount') || '0');
  if (dismissCount >= 3) {
    return false;
  }
  
  // Check if already shown today
  const lastDismissDate = localStorage.getItem('aboutModalLastDismissDate');
  const today = new Date().toISOString().split('T')[0];
  
  // Show if never dismissed, or if last dismissal was on a different day
  return !lastDismissDate || lastDismissDate !== today;
}

function resetAboutModal() {
  localStorage.removeItem('aboutModalDismissCount');
  localStorage.removeItem('aboutModalLastDismissDate');
}

// ============================================================================
// PWA INSTALL FUNCTIONALITY
// ============================================================================

let deferredInstallPrompt = null;

// Check if running as installed PWA
function isInstalledPWA() {
  return window.matchMedia('(display-mode: standalone)').matches ||
         window.navigator.standalone === true;
}

// Check if iOS
function isIOS() {
  return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
}

// Initialize install button visibility
function initInstallButton() {
  const installBtn = document.getElementById('install-app-btn');
  if (!installBtn) return;
  
  // Don't show if already installed
  if (isInstalledPWA()) {
    installBtn.style.display = 'none';
    return;
  }
  
  // On iOS, always show (since no beforeinstallprompt)
  if (isIOS()) {
    installBtn.style.display = '';
    return;
  }
  
  // On other platforms, wait for beforeinstallprompt event
  // Button stays hidden until event fires
}

// Listen for the beforeinstallprompt event
window.addEventListener('beforeinstallprompt', (e) => {
  // Prevent the mini-infobar from appearing on mobile
  e.preventDefault();
  // Stash the event so it can be triggered later
  deferredInstallPrompt = e;
  // Show the install button
  const installBtn = document.getElementById('install-app-btn');
  if (installBtn) {
    installBtn.style.display = '';
  }
});

// Listen for successful install
window.addEventListener('appinstalled', () => {
  // Hide the install button
  const installBtn = document.getElementById('install-app-btn');
  if (installBtn) {
    installBtn.style.display = 'none';
  }
  deferredInstallPrompt = null;
  console.log('PWA was installed');
});

// Handle install button click
async function handleInstallClick() {
  // Close the menu
  const menu = document.getElementById('nav-menu');
  const overlay = document.getElementById('nav-menu-overlay');
  if (menu.classList.contains('open')) {
    menu.classList.remove('open');
    overlay.classList.remove('open');
  }
  
  // iOS - show instructions modal
  if (isIOS()) {
    showIOSInstallModal();
    return;
  }
  
  // Other platforms - use the deferred prompt
  if (!deferredInstallPrompt) {
    // Fallback: show generic instructions or the prompt wasn't available
    console.log('Install prompt not available');
    return;
  }
  
  // Show the install prompt
  deferredInstallPrompt.prompt();
  
  // Wait for the user's response
  const { outcome } = await deferredInstallPrompt.userChoice;
  console.log(`User response to install prompt: ${outcome}`);
  
  // Clear the deferred prompt - it can only be used once
  deferredInstallPrompt = null;
  
  // Hide the install button if accepted
  if (outcome === 'accepted') {
    const installBtn = document.getElementById('install-app-btn');
    if (installBtn) {
      installBtn.style.display = 'none';
    }
  }
}

// iOS install modal functions
function showIOSInstallModal() {
  const overlay = document.getElementById('ios-install-overlay');
  if (overlay) {
    overlay.classList.add('visible');
  }
}

function closeIOSInstallModal(event) {
  if (event && event.target !== event.currentTarget) return;
  const overlay = document.getElementById('ios-install-overlay');
  if (overlay) {
    overlay.classList.remove('visible');
  }
}

// Update the time display in the header (shows local time at current location)
// updateTimeDisplay moved to calendar-core.js

// Show time picker modal
function showTimePicker() {
  let modal = document.getElementById('time-picker-modal');
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'time-picker-modal';
    modal.className = 'time-picker-modal';
    modal.innerHTML = `
      <div class="time-picker-content">
        <div class="time-picker-header">
          <h3>Set Date Time</h3>
          <button class="close-btn" onclick="hideTimePicker()">Ã—</button>
        </div>
        <div class="time-picker-form">
          <div class="time-picker-row">
            <label>Date:</label>
            <input type="date" id="time-picker-date">
          </div>
          <div class="time-picker-row">
            <label id="time-picker-time-label">Time:</label>
            <input type="time" id="time-picker-time">
          </div>
          <div class="time-picker-buttons">
            <button class="btn secondary" onclick="setTimeToNowInPicker()">Set to Now</button>
            <button class="btn primary" onclick="applyTimePickerAndClose()">Apply</button>
          </div>
        </div>
      </div>
    `;
    document.body.appendChild(modal);
  }
  
  // Pre-fill with currently selected calendar date and view time
  // Get the date from the currently highlighted day in the calendar
  const monthData = state.lunarMonths?.[state.currentMonthIndex];
  const dayData = monthData?.days?.find(d => d.lunarDay === state.highlightedLunarDay);
  
  // Get the UTC timestamp to convert to location's local time
  let utcTimestamp;
  if (dayData?.gregorianDate) {
    // Use selectedTimestamp if available (more precise), otherwise use sunrise of the day
    utcTimestamp = state.selectedTimestamp || getSunriseTimestamp(dayData.gregorianDate);
  } else {
    // Fallback to view time
    utcTimestamp = getViewTime().getTime();
  }
  
  // Convert UTC timestamp to local time at the selected location
  const localTimeAtLocation = utcToLocalTime(utcTimestamp, state.lon);
  
  // Update the time label to show the current location
  const locationName = getCurrentLocationName();
  const timeLabel = document.getElementById('time-picker-time-label');
  if (timeLabel) {
    timeLabel.textContent = `${locationName} Time:`;
  }
  
  // Format date as YYYY-MM-DD (using UTC methods since utcToLocalTime returns a Date where UTC methods give local time)
  const year = localTimeAtLocation.getUTCFullYear();
  const month = String(localTimeAtLocation.getUTCMonth() + 1).padStart(2, '0');
  const day = String(localTimeAtLocation.getUTCDate()).padStart(2, '0');
  document.getElementById('time-picker-date').value = `${year}-${month}-${day}`;
  
  // Format time as HH:MM (from local time at location)
  const hours = String(localTimeAtLocation.getUTCHours()).padStart(2, '0');
  const minutes = String(localTimeAtLocation.getUTCMinutes()).padStart(2, '0');
  document.getElementById('time-picker-time').value = `${hours}:${minutes}`;
  
  modal.style.display = 'flex';
}

// Hide time picker
function hideTimePicker() {
  const modal = document.getElementById('time-picker-modal');
  if (modal) modal.style.display = 'none';
}

// Update the picker inputs to show current date/time (doesn't change state)
function setTimeToNowInPicker() {
  const now = new Date();
  const tzOffsetHours = Math.round(state.lon / 15);
  const localMs = now.getTime() + (tzOffsetHours * 60 * 60 * 1000);
  const localDate = new Date(localMs);
  
  // Format date as YYYY-MM-DD
  const year = localDate.getUTCFullYear();
  const month = String(localDate.getUTCMonth() + 1).padStart(2, '0');
  const day = String(localDate.getUTCDate()).padStart(2, '0');
  document.getElementById('time-picker-date').value = `${year}-${month}-${day}`;
  
  // Format time as HH:MM
  const hours = String(localDate.getUTCHours()).padStart(2, '0');
  const minutes = String(localDate.getUTCMinutes()).padStart(2, '0');
  document.getElementById('time-picker-time').value = `${hours}:${minutes}`;
}

// Apply the picker values to state and close the dialog
function applyTimePickerAndClose() {
  const dateVal = document.getElementById('time-picker-date').value;
  const timeVal = document.getElementById('time-picker-time').value;
  
  if (dateVal && timeVal) {
    // Parse as local time at current location
    const [year, month, day] = dateVal.split('-').map(Number);
    const [hours, minutes] = timeVal.split(':').map(Number);
    const localMs = Date.UTC(year, month - 1, day, hours, minutes, 0);
    
    // Convert from location's local time back to UTC
    const tzOffsetHours = Math.round(state.lon / 15);
    const utcMs = localMs - (tzOffsetHours * 60 * 60 * 1000);
    
    state.viewTime = utcMs;
    state.selectedTimestamp = utcMs;  // Also update selectedTimestamp so day detail refreshes
    
    // Navigate to the selected date
    navigateToTimestamp(utcMs, year, month - 1, day);
    updateTimeDisplay();
    refreshDayDetailIfVisible();  // Refresh day detail to update "This Moment on Other Calendars"
  }
  
  hideTimePicker();
}

// navigateToTimestamp moved to calendar-core.js

// Get current UTC time
function getCurrentUTCTime() {
  return new Date();
}

// Get local time string for a location based on longitude
function getLocalTimeForLocation(lat, lon) {
  const viewTime = getViewTime();
  // Approximate timezone from longitude (1 hour per 15 degrees)
  const tzOffsetHours = Math.round(lon / 15);
  // Convert UTC time to local time at that longitude
  const utcMs = viewTime.getTime();
  const localMs = utcMs + (tzOffsetHours * 60 * 60 * 1000);
  const localDate = new Date(localMs);
  // Format as HH:MM using UTC methods since we already adjusted
  const hours = localDate.getUTCHours();
  const minutes = localDate.getUTCMinutes();
  const ampm = hours >= 12 ? 'PM' : 'AM';
  const h12 = hours % 12 || 12;
  return `${h12}:${minutes.toString().padStart(2, '0')} ${ampm}`;
}

// Navigate to a world clock entry
function navigateToWorldClockEntry(profileId, locationSlug) {
  const profile = PROFILES[profileId] || PRESET_PROFILES[profileId];
  const coords = CITY_SLUGS[locationSlug];
  if (!profile || !coords) return;
  
  // Apply profile
  state.moonPhase = profile.moonPhase;
  state.dayStartTime = profile.dayStartTime;
  state.dayStartAngle = profile.dayStartAngle;
  state.yearStartRule = profile.yearStartRule;
  state.crescentThreshold = profile.crescentThreshold ?? 18;
  state.sabbathMode = profile.sabbathMode;
  state.selectedProfile = profileId;
  
  // Apply location
  state.lat = coords.lat;
  state.lon = coords.lon;
  
  // Regenerate and navigate
  saveState();
  regenerateCalendarPreservingScroll();
}

// Remove world clock entry and refresh the UI
function removeWorldClockEntryAndRefresh(index) {
  removeWorldClockEntry(index);
  refreshDayDetailIfVisible();
}

// ============================================================================
// UNIFIED LOCATION PICKER - Used for header location and World Clock
// ============================================================================

// Current picker mode and callback
let locationPickerMode = 'header';  // 'header' or 'worldclock'
let locationPickerCallback = null;

// Open location picker for header (changes current location)
function openLocationPickerForHeader() {
  locationPickerMode = 'header';
  locationPickerCallback = null;  // Changes applied during preview
  showUnifiedLocationPicker('Select Location', false);
}

// Open location picker for World Clock (adds new entry)
function openLocationPickerForWorldClock() {
  locationPickerMode = 'worldclock';
  locationPickerCallback = (locationSlug, locationName, coords, profileId) => {
    if (addWorldClockEntry(profileId, locationSlug, locationName)) {
      refreshDayDetailIfVisible();
    } else {
      alert('This calendar is already in your list.');
    }
  };
  showUnifiedLocationPicker('Add Calendar', true);
}

// Show the unified location picker
function showUnifiedLocationPicker(title, showProfileSelect) {
  const picker = document.getElementById('city-picker');
  const overlay = document.getElementById('city-picker-overlay');
  const header = picker.querySelector('.city-picker-header h3');
  
  // Reset preview state
  previewedLocationSlug = null;
  previewedLocationCoords = null;
  
  // Update title
  if (header) header.textContent = title;
  
  // Show/hide profile selector
  let profileRow = document.getElementById('city-picker-profile-row');
  if (showProfileSelect) {
    if (!profileRow) {
      // Create profile selector row
      profileRow = document.createElement('div');
      profileRow.id = 'city-picker-profile-row';
      profileRow.className = 'city-picker-profile-row';
      profileRow.innerHTML = `
        <label>Profile:</label>
        <select id="city-picker-profile-select" class="city-picker-select"></select>
      `;
      const controls = picker.querySelector('.city-picker-controls');
      controls.parentNode.insertBefore(profileRow, controls);
    }
    profileRow.style.display = 'flex';
    populatePickerProfileSelect();
  } else if (profileRow) {
    profileRow.style.display = 'none';
  }
  
  // Show/hide confirm button for World Clock mode
  let confirmRow = document.getElementById('city-picker-confirm-row');
  if (showProfileSelect) {
    if (!confirmRow) {
      confirmRow = document.createElement('div');
      confirmRow.id = 'city-picker-confirm-row';
      confirmRow.className = 'city-picker-confirm-row';
      confirmRow.innerHTML = `
        <button class="btn secondary" onclick="toggleCityPicker()">Cancel</button>
        <button class="btn primary" onclick="confirmWorldClockAdd()">Add Calendar</button>
      `;
      picker.appendChild(confirmRow);
    }
    confirmRow.style.display = 'flex';
  } else if (confirmRow) {
    confirmRow.style.display = 'none';
  }
  
  picker.style.display = 'block';
  overlay.classList.add('visible');
  document.body.style.overflow = 'hidden';
  renderCityPickerMap();
  populateCityDropdown();
  updateCityPickerLocationName();
}

// Confirm adding a World Clock entry
function confirmWorldClockAdd() {
  // Use the previewed location, or current selection from dropdown
  let slug = previewedLocationSlug;
  let coords = previewedLocationCoords;
  
  if (!slug) {
    // Fallback to dropdown selection
    const select = document.getElementById('city-picker-select');
    slug = select ? select.value : null;
    coords = slug ? CITY_SLUGS[slug] : null;
  }
  
  if (!slug || !coords) {
    alert('Please select a location first.');
    return;
  }
  
  const locationName = formatCitySlug(slug);
  confirmLocationSelection(slug, locationName, coords);
}

// Populate profile select in the picker
function populatePickerProfileSelect() {
  const select = document.getElementById('city-picker-profile-select');
  if (!select) return;
  
  select.innerHTML = '';
  for (const [id, profile] of Object.entries(PROFILES)) {
    const opt = document.createElement('option');
    opt.value = id;
    opt.textContent = `${renderProfileIconText(profile)} ${profile.name}`;
    if (id === (state.selectedProfile || 'timeTested')) {
      opt.selected = true;
    }
    select.appendChild(opt);
  }
}

// Get currently selected profile in picker (for World Clock mode)
function getPickerSelectedProfile() {
  const select = document.getElementById('city-picker-profile-select');
  return select ? select.value : (state.selectedProfile || 'timeTested');
}

// Called when a location is confirmed in the picker
function confirmLocationSelection(locationSlug, locationName, coords) {
  if (locationPickerCallback) {
    const profileId = locationPickerMode === 'worldclock' ? getPickerSelectedProfile() : null;
    locationPickerCallback(locationSlug, locationName, coords, profileId);
  }
  toggleCityPicker();
}

// Show modal to add new world clock entry (now uses unified picker)
function showAddWorldClockModal() {
  openLocationPickerForWorldClock();
}

// Legacy function for compatibility
function hideAddWorldClockModal() {
  toggleCityPicker();
}

// Legacy function kept for old modal (no longer used but kept for safety)
function addWorldClockFromModal() {
  // Now handled by confirmLocationSelection
}

// Save settings to localStorage
function saveState() {
  const toSave = {
    year: state.year,
    lat: state.lat,
    lon: state.lon,
    city: state.city,
    moonPhase: state.moonPhase,
    dayStartTime: state.dayStartTime,
    dayStartAngle: state.dayStartAngle,
    yearStartRule: state.yearStartRule,
    crescentThreshold: state.crescentThreshold,
    sabbathMode: state.sabbathMode,
    selectedProfile: state.selectedProfile
    // astronomyEngine not saved - always uses astronomy-engine for now
  };
  localStorage.setItem('lunarCalendarState', JSON.stringify(toSave));
}

// Update URL with current calendar state for sharing (uses SEO-friendly paths)
function updateURL() {
  updatePathURL();
}

// Load state from URL (supports both path-based and legacy query params)
function loadFromURL() {
  // Parse the new path-based URL
  const urlState = parsePathURL();
  
  // Handle special views
  if (urlState.view === 'about') {
    showAboutModal();
    return;
  }
  
  if (urlState.view === 'sabbath-tester') {
    const sabbathTesterPage = document.getElementById('sabbath-tester-page');
    const calendarOutput = document.getElementById('calendar-output');
    const dayDetailPanel = document.getElementById('day-detail-panel');
    calendarOutput.style.display = 'none';
    dayDetailPanel.style.display = 'none';
    sabbathTesterPage.style.display = 'block';
    renderSabbathTester();
    return;
  }
  
  if (urlState.view === 'feasts') {
    toggleExportModal(true);
    return;
  }
  
  // Handle Gregorian date lookup - find lunar date and redirect
  if (urlState.view === 'gregorian-lookup') {
    handleGregorianLookup(urlState);
    return;
  }
  
  // Redirect pre-Gregorian dates to Julian URL
  if (urlState.view === 'redirect-to-julian') {
    const yearStr = formatYearForURL(urlState.gregorianYear);
    const month = urlState.gregorianMonth || 1;
    const day = urlState.gregorianDay || 1;
    window.location.replace(`/julian/${yearStr}/${month}/${day}/`);
    return;
  }
  
  // Handle Julian date lookup - convert to Gregorian internally
  if (urlState.view === 'julian-lookup') {
    handleJulianLookup(urlState);
    return;
  }
  
  // If URL needs redirect to canonical format, do it after calendar loads
  if (urlState.needsRedirect) {
    // Will redirect to canonical URL after initial load
    setTimeout(() => {
      const canonicalURL = buildPathURL();
      window.history.replaceState({}, '', canonicalURL);
    }, 100);
  }
  
  // Apply URL state to app state
  const { needsRegenerate, month, day, view } = applyURLState(urlState);
  
  // Regenerate if settings changed
  if (needsRegenerate) {
    updateUI();
    generateCalendar();
  }
  
  // Apply month after calendar generation
  if (month !== null && month !== undefined) {
    const monthIndex = month - 1; // Convert to 0-indexed
    if (monthIndex >= 0 && monthIndex < state.lunarMonths.length) {
      state.currentMonthIndex = monthIndex;
    }
  }
  
  // Apply day - default to 1 if not specified
  const effectiveDay = (day !== null && day !== undefined) ? day : 1;
  state.highlightedLunarDay = effectiveDay;
  const monthData = state.lunarMonths[state.currentMonthIndex];
  const dayObj = monthData?.days.find(d => d.lunarDay === effectiveDay);
  if (dayObj) {
    state.selectedTimestamp = getSunriseTimestamp(dayObj.gregorianDate);
    const gotoDate = document.getElementById('goto-date');
    if (gotoDate) gotoDate.value = formatLocalDatetime(state.selectedTimestamp);
    showDayDetail(dayObj, monthData);
  }
  
  // Re-render
  renderMonth(state.lunarMonths[state.currentMonthIndex]);
  updateMonthButtons();
}

const state = loadState();

// Track which profile is being edited in the settings page (separate from active calendar profile)
let editingProfileId = null;

// Update UI to reflect current state
function updateUI() {
  document.getElementById('year-input').value = state.year;
  // Show BC label only when needed (no AD suffix)
  const yearVal = state.year;
  if (yearVal <= 0) {
    document.getElementById('year-display').textContent = `(${Math.abs(yearVal - 1)} BC)`;
  } else {
    document.getElementById('year-display').textContent = '';  // No AD suffix for positive years
  }
  document.getElementById('feast-year').textContent = formatYear(state.year);
  document.getElementById('lat-input').value = state.lat;
  document.getElementById('lon-input').value = state.lon;
  document.getElementById('moon-phase-select').value = state.moonPhase;
  document.getElementById('city-select').value = state.city || '';
  
  // Update all button states
  updateMoonPhaseButtons();
  updateDayStartButtons();
  updateYearStartButtons();
  updateCrescentThresholdVisibility();
  updateCrescentThresholdButtons();
  updateProfileButtons();
  
  // Show/hide custom coordinates
  const customCoords = document.getElementById('custom-coords');
  if (customCoords) {
    customCoords.style.display = state.city === '' ? 'block' : 'none';
  }
}

// Navigation Menu Functions
function toggleNavMenu() {
  const overlay = document.getElementById('nav-menu-overlay');
  const menu = document.getElementById('nav-menu');
  
  if (menu.classList.contains('open')) {
    menu.classList.remove('open');
    overlay.classList.remove('open');
  } else {
    menu.classList.add('open');
    overlay.classList.add('open');
  }
}

function navigateTo(page) {
  // Close the menu if it's open (don't toggle)
  const menu = document.getElementById('nav-menu');
  const overlay = document.getElementById('nav-menu-overlay');
  if (menu.classList.contains('open')) {
    menu.classList.remove('open');
    overlay.classList.remove('open');
  }
  
  const calendarOutput = document.getElementById('calendar-output');
  const dayDetailPanel = document.getElementById('day-detail-panel');
  const settingsPage = document.getElementById('settings-page');
  const settingsOverlay = document.getElementById('settings-page-overlay');
  const exportPage = document.getElementById('export-page');
  const sabbathTesterPage = document.getElementById('sabbath-tester-page');
  
  // Hide all pages and reset body state
  document.documentElement.classList.remove('feasts-open');
  document.body.classList.remove('feasts-open');
  document.body.classList.remove('sabbath-tester-open');
  document.body.style.overflow = ''; // Restore scrolling
  
  // Close settings slide-in
  settingsPage.classList.remove('visible');
  settingsOverlay.classList.remove('visible');
  
  // Hide export page and sabbath tester
  exportPage.style.display = 'none';
  sabbathTesterPage.style.display = 'none';
  
  switch(page) {
    case 'calendar':
      calendarOutput.style.display = 'block';
      if (state.highlightedLunarDay !== null) {
        dayDetailPanel.classList.remove('hidden');
        dayDetailPanel.style.display = '';
        refreshDayDetailIfVisible();
      }
      updateURL();
      break;
    case 'feasts':
      document.documentElement.classList.add('feasts-open');
      document.body.classList.add('feasts-open');
      calendarOutput.style.display = 'none';
      dayDetailPanel.style.display = 'none';
      exportPage.style.display = 'block';
      exportPage.scrollTop = 0;
      updateExportTable();
      updateURLWithView('feasts');
      break;
    case 'settings':
      // Show calendar in background, open settings slide-in
      calendarOutput.style.display = 'block';
      if (state.highlightedLunarDay !== null) {
        dayDetailPanel.classList.remove('hidden');
        dayDetailPanel.style.display = '';
      }
      settingsPage.classList.add('visible');
      settingsOverlay.classList.add('visible');
      document.body.style.overflow = 'hidden'; // Prevent background scrolling
      updateSettingsPageState();
      settingsPage.scrollTop = 0;
      break;
    case 'sabbath-tester':
      calendarOutput.style.display = 'none';
      dayDetailPanel.style.display = 'none';
      sabbathTesterPage.style.display = 'block';
      sabbathTesterPage.scrollTop = 0;
      document.body.classList.add('sabbath-tester-open');
      renderSabbathTester();
      updateURLWithView('sabbath-tester');
      break;
    case 'about':
      // Show calendar in background, open about modal
      calendarOutput.style.display = 'block';
      if (state.highlightedLunarDay !== null) {
        dayDetailPanel.classList.remove('hidden');
        dayDetailPanel.style.display = '';
      }
      showAboutModal();
      updateURLWithView('about');
      break;
  }
}

function toggleSettings() {
  const settingsPage = document.getElementById('settings-page');
  const settingsOverlay = document.getElementById('settings-page-overlay');
  
  const isOpening = !settingsPage.classList.contains('visible');
  
  if (isOpening) {
    // Show settings slide-in
    settingsPage.classList.add('visible');
    settingsOverlay.classList.add('visible');
    document.body.style.overflow = 'hidden'; // Prevent background scrolling
    
    // Initialize editing profile to current active profile
    editingProfileId = state.selectedProfile || 'timeTested';
    
    // Update dropdown to show current profile
    const select = document.getElementById('profile-select');
    if (select) select.value = editingProfileId;
    
    // Update settings page state
    updateSettingsPageState();
    displayProfileSettings(editingProfileId);
  } else {
    // Hide settings slide-in
    settingsPage.classList.remove('visible');
    settingsOverlay.classList.remove('visible');
    document.body.style.overflow = ''; // Restore scrolling
    
    // Refresh day detail if visible
    refreshDayDetailIfVisible();
  }
}

// Open the location picker (for header - changes current location)
function openLocationPicker() {
  openLocationPickerForHeader();
}

// Profile Picker Functions
function toggleProfilePicker(event) {
  const picker = document.getElementById('profile-picker');
  const overlay = document.getElementById('profile-picker-overlay');
  
  if (picker.style.display === 'none') {
    // Position dropdown near the moon icon
    const moonIcon = document.querySelector('.full-moon-info');
    if (moonIcon) {
      const rect = moonIcon.getBoundingClientRect();
      picker.style.top = (rect.bottom + 8) + 'px';
      picker.style.left = Math.max(8, rect.left) + 'px';
      
      // Make sure it doesn't go off screen to the right
      const pickerWidth = 320;
      if (rect.left + pickerWidth > window.innerWidth) {
        picker.style.left = (window.innerWidth - pickerWidth - 8) + 'px';
      }
    }
    
    picker.style.display = 'block';
    overlay.classList.add('visible');
    populateProfilePicker();
  } else {
    picker.style.display = 'none';
    overlay.classList.remove('visible');
  }
}

function populateProfilePicker() {
  const list = document.getElementById('profile-picker-list');
  if (!list) return;
  
  const currentProfileId = getCurrentProfileId();
  
  let html = '';
  for (const [id, profile] of Object.entries(PROFILES)) {
    const isSelected = id === currentProfileId;
    // Generate hint from settings if not provided
    const hint = profile.hint || generateProfileHint(profile);
    html += `
      <div class="profile-option${isSelected ? ' selected' : ''}" onclick="selectProfile('${id}')">
        <div class="profile-option-icon">${renderProfileIcon(profile)}</div>
        <div class="profile-option-info">
          <div class="profile-option-name">${profile.name}</div>
          <div class="profile-option-hint">${hint}</div>
        </div>
        ${isSelected ? '<span style="color: #d4a017;">âœ“</span>' : ''}
      </div>
    `;
  }
  
  list.innerHTML = html;
}

// Generate a hint string from profile settings
function generateProfileHint(profile) {
  const parts = [];
  
  // Moon phase
  switch (profile.moonPhase) {
    case 'full': parts.push('Full Moon'); break;
    case 'dark': parts.push('Dark Moon'); break;
    case 'crescent': parts.push('Crescent Moon'); break;
  }
  
  // Day start
  if (profile.dayStartTime === 'evening') {
    parts.push(profile.dayStartAngle === 0 ? 'Sunset' : 'Evening');
  } else {
    parts.push(profile.dayStartAngle === 0 ? 'Sunrise' : 'Morning');
  }
  
  // Year start
  switch (profile.yearStartRule) {
    case 'virgoFeet': parts.push('Virgo Rule'); break;
    case '13daysBefore': parts.push('Passover Rule'); break;
  }
  
  // Sabbath
  switch (profile.sabbathMode) {
    case 'lunar': parts.push('Lunar Sabbath'); break;
    case 'saturday': parts.push('Saturday Sabbath'); break;
    case 'sunday': parts.push('Sunday Sabbath'); break;
    case 'friday': parts.push('Friday Sabbath'); break;
  }
  
  return parts.join(', ');
}

function getCurrentProfileId() {
  // First check if we have an explicitly selected profile that still exists
  if (state.selectedProfile && PROFILES[state.selectedProfile]) {
    return state.selectedProfile;
  }
  
  // Otherwise, check which profile matches current state settings
  for (const [id, profile] of Object.entries(PROFILES)) {
    if (state.moonPhase === profile.moonPhase &&
        state.dayStartTime === profile.dayStartTime &&
        state.dayStartAngle === profile.dayStartAngle &&
        state.yearStartRule === profile.yearStartRule &&
        state.sabbathMode === profile.sabbathMode &&
        (profile.moonPhase !== 'crescent' || state.crescentThreshold === profile.crescentThreshold)) {
      return id;
    }
  }
  return 'custom';
}

function selectProfile(profileId) {
  const profile = PROFILES[profileId];
  if (!profile) return;
  
  // Apply profile settings to state
  state.moonPhase = profile.moonPhase;
  state.dayStartTime = profile.dayStartTime;
  state.dayStartAngle = profile.dayStartAngle;
  state.yearStartRule = profile.yearStartRule;
  state.crescentThreshold = profile.crescentThreshold ?? 18;
  state.sabbathMode = profile.sabbathMode;
  state.selectedProfile = profileId;
  
  // Update the profile dropdown in settings page if it exists
  const select = document.getElementById('profile-select');
  if (select) {
    select.value = profileId;
  }
  
  // Close picker and regenerate
  toggleProfilePicker();
  saveState();
  regenerateCalendarPreservingScroll();
}

function toggleCityPicker() {
  const picker = document.getElementById('city-picker');
  const overlay = document.getElementById('city-picker-overlay');
  
  if (picker.style.display === 'none') {
    picker.style.display = 'block';
    overlay.classList.add('visible');
    document.body.style.overflow = 'hidden';
    renderCityPickerMap();
    populateCityDropdown();
    updateCityPickerLocationName();
  } else {
    picker.style.display = 'none';
    overlay.classList.remove('visible');
    document.body.style.overflow = '';
  }
}

function renderCityPickerMap() {
  const container = document.getElementById('city-picker-map');
  if (!container) return;
  
  // Get current moon event for the map visualization
  let moonEvent = new Date();
  if (state.lunarMonths && state.lunarMonths[state.currentMonthIndex]) {
    moonEvent = state.lunarMonths[state.currentMonthIndex].moonEvent;
  }
  
  container.innerHTML = renderDatelineVisualization(moonEvent);
  
  // Override the click handler on the map for city picker
  const map = container.querySelector('.dateline-map');
  if (map) {
    map.style.cursor = 'crosshair';
    // Remove inline onclick and set our handler
    map.removeAttribute('onclick');
    map.addEventListener('click', handleCityPickerMapClick);
  }
}

function handleCityPickerMapClick(event) {
  event.preventDefault();
  event.stopPropagation();
  
  const rect = event.currentTarget.getBoundingClientRect();
  const x = event.clientX - rect.left;
  const y = event.clientY - rect.top;
  
  // Convert click position to lat/lon
  const clickLon = (x / rect.width) * 360 - 180;
  const clickLat = 90 - (y / rect.height) * 180;
  
  // Snap to nearest city
  const nearestSlug = getClosestCitySlug(clickLat, clickLon, Infinity);
  if (nearestSlug && CITY_SLUGS[nearestSlug]) {
    const coords = CITY_SLUGS[nearestSlug];
    // Always preview - don't close dialog
    previewLocationSelection(nearestSlug, coords);
  }
}

// Track the currently previewed location for World Clock mode
let previewedLocationSlug = null;
let previewedLocationCoords = null;

function previewLocationSelection(slug, coords) {
  previewedLocationSlug = slug;
  previewedLocationCoords = coords;
  
  // Update the map marker to show preview
  state.lat = coords.lat;
  state.lon = coords.lon;
  renderCityPickerMap();
  updateCityPickerLocationName();
  updateCityDropdownSelection();
  
  // For header mode, apply changes immediately (but don't close dialog)
  if (locationPickerMode === 'header') {
    state.locationSource = 'url';
    regenerateCalendarPreservingScroll();
    const newURL = buildPathURL();
    window.history.replaceState({}, '', newURL);
    updateTimeDisplay();
  }
}

function updateCityDropdownSelection() {
  const select = document.getElementById('city-picker-select');
  if (!select) return;
  
  const lat = state.lat ?? 31.7683;
  const lon = state.lon ?? 35.2137;
  
  // Find closest city (no distance limit since we snap to cities)
  const currentSlug = getClosestCitySlug(lat, lon, Infinity);
  
  if (!currentSlug) {
    select.value = '';
    return;
  }
  
  // Check if option exists in dropdown
  let option = select.querySelector(`option[value="${currentSlug}"]`);
  
  if (!option && CITY_SLUGS[currentSlug]) {
    // City exists but not in dropdown - dynamically add it
    const displayName = currentSlug.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
    
    // Check if "Current Location" optgroup exists
    let currentLocGroup = select.querySelector('optgroup[label="Current Location"]');
    if (!currentLocGroup) {
      // Create new optgroup at the top (after the placeholder)
      currentLocGroup = document.createElement('optgroup');
      currentLocGroup.label = 'Current Location';
      select.insertBefore(currentLocGroup, select.firstChild.nextSibling);
    }
    
    // Clear old options in Current Location group and add new one
    currentLocGroup.innerHTML = `<option value="${currentSlug}">${displayName}</option>`;
    option = currentLocGroup.querySelector('option');
  }
  
  if (option) {
    select.value = currentSlug;
  }
}

// Curated list of main cities for dropdown (kept small and manageable)
const DROPDOWN_CITIES = {
  'Biblical': ['jerusalem', 'bethlehem', 'nazareth', 'jericho', 'hebron', 'ramses', 'goshen', 'wilderness-of-sin', 'cairo', 'alexandria', 'mt-sinai-saudi', 'mecca', 'medina'],
  'Middle East': ['tel-aviv', 'dubai', 'amman', 'baghdad', 'tehran', 'riyadh', 'istanbul', 'ankara', 'damascus', 'beirut'],
  'Americas': ['new-york', 'los-angeles', 'chicago', 'houston', 'phoenix', 'dallas', 'denver', 'miami', 'atlanta', 'seattle', 'boston', 'san-francisco', 'toronto', 'vancouver', 'mexico-city', 'sao-paulo', 'buenos-aires', 'lima', 'bogota'],
  'Europe': ['london', 'paris', 'berlin', 'rome', 'madrid', 'amsterdam', 'vienna', 'moscow', 'kiev', 'warsaw', 'athens', 'lisbon', 'dublin', 'stockholm', 'oslo', 'helsinki', 'zurich', 'brussels', 'prague', 'budapest'],
  'Asia': ['tokyo', 'beijing', 'shanghai', 'hong-kong', 'singapore', 'mumbai', 'delhi', 'bangalore', 'seoul', 'bangkok', 'jakarta', 'manila', 'kuala-lumpur', 'taipei', 'osaka', 'hanoi', 'karachi'],
  'Africa': ['johannesburg', 'lagos', 'nairobi', 'addis-ababa', 'casablanca', 'accra', 'dar-es-salaam', 'cape-town'],
  'Oceania': ['sydney', 'melbourne', 'brisbane', 'perth', 'auckland', 'wellington']
};

// Check if a city slug is in the curated dropdown list
function isInDropdownList(slug) {
  for (const cities of Object.values(DROPDOWN_CITIES)) {
    if (cities.includes(slug)) return true;
  }
  return false;
}

function populateCityDropdown() {
  const select = document.getElementById('city-picker-select');
  if (!select) return;
  
  // Find current city slug (no distance limit since we snap to cities)
  const currentSlug = getClosestCitySlug(state.lat ?? 31.7683, state.lon ?? 35.2137, Infinity);
  
  let html = '<option value="">-- Select a city --</option>';
  
  // If current location is a city not in the curated list, add it at the top
  if (currentSlug && CITY_SLUGS[currentSlug] && !isInDropdownList(currentSlug)) {
    const displayName = currentSlug.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
    html += `<optgroup label="Current Location">`;
    html += `<option value="${currentSlug}" selected>${displayName}</option>`;
    html += `</optgroup>`;
  }
  
  // Add curated cities by region
  for (const [region, cities] of Object.entries(DROPDOWN_CITIES)) {
    html += `<optgroup label="${region}">`;
    for (const slug of cities) {
      if (!CITY_SLUGS[slug]) continue;
      const displayName = slug.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
      const selected = slug === currentSlug ? ' selected' : '';
      html += `<option value="${slug}"${selected}>${displayName}</option>`;
    }
    html += '</optgroup>';
  }
  
  select.innerHTML = html;
}

function selectCityFromDropdown(slug) {
  if (!slug) return;
  
  const coords = CITY_SLUGS[slug];
  if (!coords) return;
  
  // Always preview - don't close dialog
  previewLocationSelection(slug, coords);
}

function useMyLocationFromPicker() {
  if (!navigator.geolocation) {
    alert('Geolocation is not supported by your browser');
    return;
  }
  
  // Show loading state
  const btn = document.querySelector('#city-picker .city-action-btn');
  const originalText = btn.textContent;
  btn.textContent = 'ğŸ“ Locating...';
  btn.disabled = true;
  
  navigator.geolocation.getCurrentPosition(
    (position) => {
      const gpsLat = position.coords.latitude;
      const gpsLon = position.coords.longitude;
      
      // Find nearest city to snap to
      const nearestSlug = getClosestCitySlug(gpsLat, gpsLon, Infinity);
      const coords = nearestSlug ? CITY_SLUGS[nearestSlug] : { lat: 31.7683, lon: 35.2137 };
      const locationName = nearestSlug ? formatCitySlug(nearestSlug) : 'Jerusalem';
      const slug = nearestSlug || 'jerusalem';
      
      // Save as user's default location
      saveUserLocation(coords.lat, coords.lon, locationName);
      
      // Reset button
      btn.textContent = originalText;
      btn.disabled = false;
      
      // Always preview - don't close dialog
      previewLocationSelection(slug, coords);
    },
    (error) => {
      btn.textContent = originalText;
      btn.disabled = false;
      console.warn('Geolocation failed:', error);
      alert('Could not get your location. Please select a city from the dropdown or click on the map.');
    },
    { enableHighAccuracy: true, timeout: 10000 }
  );
}

function updateCityPickerLocationName() {
  const nameSpan = document.getElementById('city-picker-location-name');
  if (nameSpan) {
    const name = getCurrentLocationName();
    const lat = state.lat ?? 31.7683;
    const lon = state.lon ?? 35.2137;
    const coordStr = `${lat.toFixed(2)}Â°${lat >= 0 ? 'N' : 'S'}, ${Math.abs(lon).toFixed(2)}Â°${lon >= 0 ? 'E' : 'W'}`;
    nameSpan.textContent = `${name} (${coordStr})`;
  }
}

function toggleExportModal(skipUrlUpdate = false) {
  const calendarOutput = document.getElementById('calendar-output');
  const dayDetailPanel = document.getElementById('day-detail-panel');
  const exportPage = document.getElementById('export-page');
  const settingsPage = document.getElementById('settings-page');
  const settingsOverlay = document.getElementById('settings-page-overlay');
  
  const isOpening = exportPage.style.display === 'none';
  
  if (isOpening) {
    // Hide calendar and settings, show export
    calendarOutput.style.display = 'none';
    dayDetailPanel.style.display = 'none';
    
    // Close settings slide-in if open
    settingsPage.classList.remove('visible');
    settingsOverlay.classList.remove('visible');
    document.body.style.overflow = ''; // Restore scrolling temporarily
    
    exportPage.style.display = 'block';
    
    // Scroll to top of page (with timeout to ensure DOM update)
    window.scrollTo(0, 0);
    document.documentElement.scrollTop = 0;
    document.body.scrollTop = 0;
    setTimeout(() => {
      window.scrollTo(0, 0);
      exportPage.scrollTop = 0;
    }, 0);
    
    // Update export table with current feast data
    updateExportTable();
    
    // Update URL with view=feasts
    if (!skipUrlUpdate) {
      updateURLWithView('feasts');
    }
  } else {
    // Show calendar, hide export
    calendarOutput.style.display = 'block';
    exportPage.style.display = 'none';
    
    // Reset day detail panel display and refresh if a day was selected
    dayDetailPanel.style.display = '';  // Reset inline style
    if (state.highlightedLunarDay !== null) {
      dayDetailPanel.classList.remove('hidden');
      refreshDayDetailIfVisible();
    }
    
    // Remove view parameter from URL
    if (!skipUrlUpdate) {
      updateURL();
    }
  }
}

function updateURLWithView(view) {
  let newURL;
  if (view === 'sabbath-tester') {
    newURL = '/sabbath-tester/';
  } else if (view === 'feasts') {
    // Build feasts URL with profile/year/location
    const profile = getCurrentProfileSlug();
    const location = getLocationSlug();
    newURL = `/feasts/${profile}/${state.year}/${location}/`;
  } else {
    // Calendar view - use standard path URL
    newURL = buildPathURL();
  }
  
  // Use pushState for navigation views so back button works
  window.history.pushState({ view: view }, '', newURL);
}

function updateExportTable() {
  // Update the year display
  document.getElementById('export-year').textContent = formatYear(state.year);
  
  // Update settings context
  const contextEl = document.getElementById('export-context-text');
  if (contextEl) {
    const moonLabel = getMoonLabel();
    const dayStartLabel = getDayStartLabel();
    const yearStartLabel = getYearStartLabel();
    
    // Get location name with coordinates
    const locationName = getCurrentLocationName();
    const coordStr = `${state.lat.toFixed(2)}Â°${state.lat >= 0 ? 'N' : 'S'}, ${Math.abs(state.lon).toFixed(2)}Â°${state.lon >= 0 ? 'E' : 'W'}`;
    // Show city name with coordinates, or just coordinates if it's a timezone region
    const locationLabel = !locationName.includes('/') 
      ? `${locationName} (${coordStr})`
      : coordStr;
    
    contextEl.innerHTML = `
      <span class="export-context-item">
        <span class="export-context-label">Month Start:</span>
        <span class="export-context-value">${moonLabel}</span>
      </span>
      <span class="export-context-item">
        <span class="export-context-label">Day Start:</span>
        <span class="export-context-value">${dayStartLabel}</span>
      </span>
      <span class="export-context-item">
        <span class="export-context-label">Year Start:</span>
        <span class="export-context-value">${yearStartLabel}</span>
      </span>
      <span class="export-context-item">
        <span class="export-context-label">Location:</span>
        <span class="export-context-value">${locationLabel}</span>
      </span>
    `;
  }
  
  // Copy the feast table content to the export modal
  const sourceTbody = document.getElementById('feast-tbody');
  const targetTbody = document.getElementById('export-feast-tbody');
  
  if (sourceTbody && targetTbody) {
    targetTbody.innerHTML = sourceTbody.innerHTML;
  }
}

function updateSettingsPageState() {
  // Update profile buttons
  updateProfileButtons();
  
  // Update moon phase buttons
  document.querySelectorAll('.settings-option-btn[data-phase]').forEach(btn => {
    btn.classList.toggle('selected', btn.dataset.phase === state.moonPhase);
  });
  
  // Update crescent threshold visibility and buttons
  updateCrescentThresholdVisibility();
  updateCrescentThresholdButtons();
  
  // Update day start buttons
  updateDayStartButtons();
  
  // Update year start buttons
  updateYearStartButtons();
  
  // Update sabbath buttons
  updateSabbathButtons();
  
  // Update city select - use the editing profile's location
  const profileId = editingProfileId || state.selectedProfile;
  const profile = PROFILES[profileId];
  const profileLat = profile?.lat ?? state.lat;
  const profileLon = profile?.lon ?? state.lon;
  
  const citySelect = document.getElementById('settings-city-select');
  const coordValue = `${profileLat},${profileLon}`;
  let found = false;
  
  for (let option of citySelect.options) {
    if (option.value === coordValue) {
      citySelect.value = coordValue;
      found = true;
      break;
    }
  }
  
  if (!found) {
    citySelect.value = 'custom';
    document.getElementById('settings-custom-coords').style.display = 'flex';
    document.getElementById('settings-lat-input').value = profileLat;
    document.getElementById('settings-lon-input').value = profileLon;
  } else {
    document.getElementById('settings-custom-coords').style.display = 'none';
  }
  
  // Render the map
  renderSettingsPageMap();
  
  // Update settings editability based on current profile
  updateSettingsEditability();
}

function renderSettingsPageMap() {
  const container = document.getElementById('settings-page-map');
  if (container && state.lunarMonths && state.lunarMonths[state.currentMonthIndex]) {
    const month = state.lunarMonths[state.currentMonthIndex];
    
    // Use the editing profile's location for the map marker
    const profileId = editingProfileId || state.selectedProfile;
    const profile = PROFILES[profileId];
    const mapOptions = profile ? { lat: profile.lat, lon: profile.lon } : {};
    
    container.innerHTML = renderDatelineVisualization(month.moonEvent, mapOptions);
    // Update map editability after rendering
    updateMapEditability();
  }
}

function updateMoonPhaseButtons() {
  // For main calendar UI, use state
  document.querySelectorAll('.moon-phase-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.phase === state.moonPhase);
  });
  // For settings page, use the editing profile
  const profileId = editingProfileId || state.selectedProfile;
  const profile = PROFILES[profileId];
  const editingPhase = profile ? profile.moonPhase : state.moonPhase;
  document.querySelectorAll('.settings-option-btn[data-phase]').forEach(btn => {
    btn.classList.toggle('selected', btn.dataset.phase === editingPhase);
  });
}

function selectMoonPhase(phase) {
  // Don't allow changes on preset profiles
  const profileId = editingProfileId || state.selectedProfile;
  if (PRESET_PROFILES[profileId]) return;
  
  // Update the editing profile
  if (PROFILES[profileId]) {
    PROFILES[profileId].moonPhase = phase;
    PROFILES[profileId].icon = getProfileIcon(phase);
    saveCustomProfiles();
  }
  
  document.getElementById('moon-phase-select').value = phase;
  updateMoonPhaseButtons();
  updateCrescentThresholdVisibility();
  updateYearStartButtons();  // Update year start icon to match moon phase
  
  // Only update state if editing the active profile
  if (profileId === state.selectedProfile) {
    state.moonPhase = phase;
    saveState();
    regenerateCalendarPreservingScroll();
  }
}

// ============================================================================
// ARCHITECTURE OVERVIEW
// ============================================================================
//
// PROFILES vs STATE:
//   - Profile = Calendar interpretation rules (how to calculate the calendar)
//   - State = Viewing context (what you're looking at: when, where)
//
// PROFILE FORMAT (compatible with LunarCalendarEngine.configure()):
//   {
//     // Engine configuration (required)
//     moonPhase: 'full' | 'dark' | 'crescent',
//     dayStartTime: 'morning' | 'evening',
//     dayStartAngle: 0 | 6 | 12 | 18,  // degrees below horizon
//     yearStartRule: 'equinox' | '13daysBefore' | 'virgoFeet',
//     sabbathMode: 'lunar' | 'saturday',  // not used by engine, UI only
//
//     // Crescent-specific (only used when moonPhase === 'crescent')
//     crescentThreshold: 18,  // hours after conjunction for visibility
//
//     // UI metadata
//     name: string,
//     icon: string,
//     hint: string,
//
//     // Location behavior
//     useLocalLocation: true,  // For presets: use saved/IP location
//     // OR for custom profiles with fixed location:
//     lat: number,
//     lon: number,
//     city: string
//   }
//
// STATE FORMAT (viewing context + active config):
//   {
//     selectedProfile: string,  // Profile ID
//     year: number,
//     currentMonthIndex: number,
//     highlightedLunarDay: number | null,
//     selectedTimestamp: number | null,
//     lat: number,
//     lon: number,
//     locationSource: 'saved' | 'ip' | 'gps' | 'url' | 'fixed',
//     lunarMonths: [...],  // Generated calendar data
//
//     // Active engine config (copied from profile or custom)
//     moonPhase, dayStartTime, dayStartAngle, yearStartRule, sabbathMode,
//     crescentThreshold,  // Only relevant when moonPhase === 'crescent'
//   }
//
// URL FORMAT:
//   Preset profiles: /profile/year/[month/[day/]]location/
//   Custom profiles: /custom/moon/[threshold?]/dayStart/sabbath/yearStart/year/[month/[day/]]location/
//
//   - Profile segment uses URL slugs (time-tested, ancient-traditional, 119-ministries)
//   - Custom profile encodes settings in path:
//     - moon: full, dark, crescent
//     - threshold (crescent only): opt (12h), min (15.5h), con (24h), or omitted (18h default)
//     - dayStart: morning, evening
//     - sabbath: lunar, saturday, sunday, friday, none
//     - yearStart: equinox, passover
//   - Location is city slug or lat,lon coordinates
//   - ?angle=N query param for dayStartAngle (0, 6, 12, 18)
//
// URL EXAMPLES:
//   /time-tested/2025/jerusalem/
//   /custom/full/morning/lunar/equinox/2025/jerusalem/
//   /custom/crescent/opt/evening/saturday/passover/2025/jerusalem/
//   /custom/crescent/evening/lunar/equinox/2025/jerusalem/ (default 18h threshold)
//
// URL CANONICALIZATION:
//   - If custom URL params match a built-in profile â†’ redirect to canonical URL
//   - This prevents duplicate content for SEO
//
// ============================================================================

// Preset profiles (built-in, cannot be deleted)
// timeTested is first as it's the default
const PRESET_PROFILES = {
  timeTested: {
    name: 'Time-Tested',
    hint: 'Full Moon, Morning Twilight, Lunar Sabbath',
    icon: 'ğŸŒ•',
    moonPhase: 'full',
    dayStartTime: 'morning',
    dayStartAngle: 12,
    yearStartRule: 'equinox',
    crescentThreshold: 18,
    sabbathMode: 'lunar',
    useLocalLocation: true  // Uses saved location or IP detection
  },
  ancientTraditional: {
    name: 'Ancient Traditional',
    hint: 'Crescent Moon, Evening, Saturday Sabbath, Passover Rule',
    icon: 'ğŸŒ’',
    moonPhase: 'crescent',
    dayStartTime: 'evening',
    dayStartAngle: 0,
    yearStartRule: '13daysBefore',
    crescentThreshold: 18,
    sabbathMode: 'saturday',
    useLocalLocation: true
  },
  ministries119: {
    name: '119 Ministries',
    hint: 'Dark Moon, Evening, Saturday Sabbath',
    icon: 'ğŸŒ‘',
    moonPhase: 'dark',
    dayStartTime: 'evening',
    dayStartAngle: 0,
    yearStartRule: 'equinox',
    crescentThreshold: 18,
    sabbathMode: 'saturday',
    useLocalLocation: true
  },
  creatorsCalendar: {
    name: "Creator's Calendar",
    hint: 'Full Moon, Evening, Virgo Rule, Lunar Sabbath',
    icon: 'ğŸŒ•',
    moonPhase: 'full',
    dayStartTime: 'evening',
    dayStartAngle: 0,
    yearStartRule: 'virgoFeet',
    crescentThreshold: 18,
    sabbathMode: 'lunar',
    useLocalLocation: true
  },
  traditionalLunar: {
    name: 'Traditional Lunar',
    hint: 'Crescent Moon, Evening, Lunar Sabbath',
    icon: 'ğŸŒ’',
    moonPhase: 'crescent',
    dayStartTime: 'evening',
    dayStartAngle: 0,
    yearStartRule: 'equinox',
    crescentThreshold: 18,
    sabbathMode: 'lunar',
    useLocalLocation: true
  }
};

// Combined profiles (presets + user-saved)
let PROFILES = { ...PRESET_PROFILES };

// Load custom profiles from localStorage
function loadCustomProfiles() {
  try {
    const saved = localStorage.getItem('customProfiles');
    if (saved) {
      const customProfiles = JSON.parse(saved);
      PROFILES = { ...PRESET_PROFILES, ...customProfiles };
    }
  } catch (e) {
    console.error('Error loading custom profiles:', e);
  }
}

// Save custom profiles to localStorage
function saveCustomProfiles() {
  const customProfiles = {};
  for (const [id, profile] of Object.entries(PROFILES)) {
    if (!PRESET_PROFILES[id]) {
      customProfiles[id] = profile;
    }
  }
  localStorage.setItem('customProfiles', JSON.stringify(customProfiles));
}

// Rebuild profile dropdown with all profiles
function rebuildProfileDropdown() {
  const select = document.getElementById('profile-select');
  if (!select) return;
  
  select.innerHTML = '';
  
  // Add preset profiles
  for (const [id, profile] of Object.entries(PRESET_PROFILES)) {
    const option = document.createElement('option');
    option.value = id;
    option.textContent = `${renderProfileIconText(profile)} ${profile.name} â€” ${profile.hint}`;
    select.appendChild(option);
  }
  
  // Add custom profiles (user-saved)
  const customIds = Object.keys(PROFILES).filter(id => !PRESET_PROFILES[id]);
  if (customIds.length > 0) {
    for (const id of customIds) {
      const profile = PROFILES[id];
      const option = document.createElement('option');
      option.value = id;
      option.textContent = `${renderProfileIconText(profile)} ${profile.name}`;
      select.appendChild(option);
    }
  }
  
  // Restore selection from state if valid, otherwise default to timeTested
  const profileToSelect = state.selectedProfile || 'timeTested';
  if ([...select.options].some(o => o.value === profileToSelect)) {
    select.value = profileToSelect;
  } else {
    select.value = 'timeTested';
    state.selectedProfile = 'timeTested';
  }
}

// Get the icon for a moon phase
function getProfileIcon(phase) {
  if (phase === 'full') return 'ğŸŒ•';
  if (phase === 'dark') return 'ğŸŒ‘';
  if (phase === 'crescent') return 'ğŸŒ’';
  return 'ğŸŒ•';
}

// Render profile icon HTML (supports both emoji and favicon URLs)
function renderProfileIcon(profile) {
  if (profile.faviconUrl) {
    return `<img src="${profile.faviconUrl}" alt="${profile.name}" onerror="this.style.display='none';this.nextSibling.style.display='inline'"><span style="display:none">${profile.icon || 'ğŸ“…'}</span>`;
  }
  return profile.icon || 'ğŸ“…';
}

// Render profile icon for plain text contexts (dropdown options)
function renderProfileIconText(profile) {
  // For text contexts (like <option>), we can only use emoji, not images
  return profile.icon || 'ğŸ“…';
}

// Extract engine-compatible config from a profile
// This is what gets passed to LunarCalendarEngine.configure()
function getEngineConfig(profile) {
  return {
    moonPhase: profile.moonPhase,
    dayStartTime: profile.dayStartTime,
    dayStartAngle: profile.dayStartAngle,
    yearStartRule: profile.yearStartRule,
    crescentThreshold: profile.crescentThreshold || 18
  };
}

// Check if current state matches a named profile's engine settings
function matchesProfile(profileId) {
  const profile = PROFILES[profileId];
  if (!profile) return false;
  
  const baseMatch = state.moonPhase === profile.moonPhase &&
         state.dayStartTime === profile.dayStartTime &&
         state.dayStartAngle === profile.dayStartAngle &&
         state.yearStartRule === profile.yearStartRule &&
         state.sabbathMode === (profile.sabbathMode || 'lunar');
  
  // For crescent profiles, also check crescentThreshold
  if (profile.moonPhase === 'crescent') {
    return baseMatch && state.crescentThreshold === (profile.crescentThreshold || 18);
  }
  
  return baseMatch;
}

// Get the name of the currently selected profile (active on calendar)
function getCurrentProfileName() {
  const profileId = state.selectedProfile || 'timeTested';
  const profile = PROFILES[profileId];
  return profile ? profile.name : '';
}

// Known city coordinates for display lookup
const CITY_NAMES = {
  '31.7683,35.2137': 'Jerusalem',
  '40.7128,-74.006': 'New York',
  '34.0522,-118.2437': 'Los Angeles',
  '41.8781,-87.6298': 'Chicago',
  '29.7604,-95.3698': 'Houston',
  '33.749,-84.388': 'Atlanta',
  '47.6062,-122.3321': 'Seattle',
  '25.7617,-80.1918': 'Miami',
  '39.7392,-104.9903': 'Denver',
  '33.4484,-112.074': 'Phoenix',
  '51.5074,-0.1278': 'London',
  '48.8566,2.3522': 'Paris',
  '52.52,13.405': 'Berlin',
  '41.9028,12.4964': 'Rome',
  '55.7558,37.6173': 'Moscow',
  '35.6762,139.6503': 'Tokyo',
  '31.2304,121.4737': 'Shanghai',
  '22.3193,114.1694': 'Hong Kong',
  '1.3521,103.8198': 'Singapore',
  '-33.8688,151.2093': 'Sydney',
  '-23.5505,-46.6333': 'SÃ£o Paulo',
  '19.4326,-99.1332': 'Mexico City',
  '-34.6037,-58.3816': 'Buenos Aires',
  '30.0444,31.2357': 'Cairo',
  '28.6139,77.209': 'New Delhi',
  '-1.2921,36.8219': 'Nairobi'
};

// ========================================
// SEO-FRIENDLY URL ROUTING
// ========================================

// City slugs for URL routing (slug -> coordinates)
const CITY_SLUGS = {
  // Biblical / Middle East
  'jerusalem': { lat: 31.7683, lon: 35.2137 },
  'bethlehem': { lat: 31.7054, lon: 35.2024 },
  'nazareth': { lat: 32.6996, lon: 35.3035 },
  'jericho': { lat: 31.8500, lon: 35.4500 },
  'hebron': { lat: 31.5326, lon: 35.0998 },
  'ramses': { lat: 30.7879, lon: 31.8332 },  // Pi-Ramesses, ancient Egyptian capital (near modern Qantir)
  'goshen': { lat: 30.7833, lon: 31.5000 },  // Land of Goshen, eastern Nile Delta
  'wilderness-of-sin': { lat: 29.1500, lon: 33.4000 },  // Between Elim and Sinai
  'cairo': { lat: 30.0444, lon: 31.2357 },
  'baghdad': { lat: 33.3152, lon: 44.3661 },
  'damascus': { lat: 33.5138, lon: 36.2765 },
  'amman': { lat: 31.9454, lon: 35.9284 },
  'beirut': { lat: 33.8938, lon: 35.5018 },
  'tel-aviv': { lat: 32.0853, lon: 34.7818 },
  'alexandria': { lat: 31.2001, lon: 29.9187 },
  'mt-sinai-saudi': { lat: 28.5653, lon: 35.4058 },  // Jabal al-Maqla (Ron Wyatt site), Jabal al-Lawz range
  'mecca': { lat: 21.4225, lon: 39.8262 },
  'medina': { lat: 24.5247, lon: 39.5692 },
  'riyadh': { lat: 24.7136, lon: 46.6753 },
  'istanbul': { lat: 41.0082, lon: 28.9784 },
  'tehran': { lat: 35.6892, lon: 51.3890 },
  // North America
  'new-york': { lat: 40.7128, lon: -74.006 },
  'los-angeles': { lat: 34.0522, lon: -118.2437 },
  'chicago': { lat: 41.8781, lon: -87.6298 },
  'houston': { lat: 29.7604, lon: -95.3698 },
  'phoenix': { lat: 33.4484, lon: -112.074 },
  'philadelphia': { lat: 39.9526, lon: -75.1652 },
  'san-antonio': { lat: 29.4241, lon: -98.4936 },
  'san-diego': { lat: 32.7157, lon: -117.1611 },
  'dallas': { lat: 32.7767, lon: -96.7970 },
  'san-jose': { lat: 37.3382, lon: -121.8863 },
  'austin': { lat: 30.2672, lon: -97.7431 },
  'jacksonville': { lat: 30.3322, lon: -81.6557 },
  'fort-worth': { lat: 32.7555, lon: -97.3308 },
  'columbus': { lat: 39.9612, lon: -82.9988 },
  'charlotte': { lat: 35.2271, lon: -80.8431 },
  'san-francisco': { lat: 37.7749, lon: -122.4194 },
  'indianapolis': { lat: 39.7684, lon: -86.1581 },
  'seattle': { lat: 47.6062, lon: -122.3321 },
  'denver': { lat: 39.7392, lon: -104.9903 },
  'washington-dc': { lat: 38.9072, lon: -77.0369 },
  'boston': { lat: 42.3601, lon: -71.0589 },
  'nashville': { lat: 36.1627, lon: -86.7816 },
  'detroit': { lat: 42.3314, lon: -83.0458 },
  'portland': { lat: 45.5152, lon: -122.6784 },
  'las-vegas': { lat: 36.1699, lon: -115.1398 },
  'memphis': { lat: 35.1495, lon: -90.0490 },
  'louisville': { lat: 38.2527, lon: -85.7585 },
  'baltimore': { lat: 39.2904, lon: -76.6122 },
  'milwaukee': { lat: 43.0389, lon: -87.9065 },
  'albuquerque': { lat: 35.0844, lon: -106.6504 },
  'tucson': { lat: 32.2226, lon: -110.9747 },
  'atlanta': { lat: 33.749, lon: -84.388 },
  'miami': { lat: 25.7617, lon: -80.1918 },
  'minneapolis': { lat: 44.9778, lon: -93.2650 },
  'salt-lake-city': { lat: 40.7608, lon: -111.8910 },
  'anchorage': { lat: 61.2181, lon: -149.9003 },
  'honolulu': { lat: 21.3069, lon: -157.8583 },
  'toronto': { lat: 43.6532, lon: -79.3832 },
  'vancouver': { lat: 49.2827, lon: -123.1207 },
  'montreal': { lat: 45.5017, lon: -73.5673 },
  'mexico-city': { lat: 19.4326, lon: -99.1332 },
  // Europe
  'london': { lat: 51.5074, lon: -0.1278 },
  'paris': { lat: 48.8566, lon: 2.3522 },
  'berlin': { lat: 52.52, lon: 13.405 },
  'madrid': { lat: 40.4168, lon: -3.7038 },
  'rome': { lat: 41.9028, lon: 12.4964 },
  'vienna': { lat: 48.2082, lon: 16.3738 },
  'amsterdam': { lat: 52.3676, lon: 4.9041 },
  'brussels': { lat: 50.8503, lon: 4.3517 },
  'stockholm': { lat: 59.3293, lon: 18.0686 },
  'oslo': { lat: 59.9139, lon: 10.7522 },
  'copenhagen': { lat: 55.6761, lon: 12.5683 },
  'helsinki': { lat: 60.1699, lon: 24.9384 },
  'dublin': { lat: 53.3498, lon: -6.2603 },
  'lisbon': { lat: 38.7223, lon: -9.1393 },
  'barcelona': { lat: 41.3851, lon: 2.1734 },
  'munich': { lat: 48.1351, lon: 11.5820 },
  'milan': { lat: 45.4642, lon: 9.1900 },
  'zurich': { lat: 47.3769, lon: 8.5417 },
  'geneva': { lat: 46.2044, lon: 6.1432 },
  'moscow': { lat: 55.7558, lon: 37.6173 },
  'saint-petersburg': { lat: 59.9311, lon: 30.3609 },
  'kiev': { lat: 50.4501, lon: 30.5234 },
  'warsaw': { lat: 52.2297, lon: 21.0122 },
  'prague': { lat: 50.0755, lon: 14.4378 },
  'budapest': { lat: 47.4979, lon: 19.0402 },
  'bucharest': { lat: 44.4268, lon: 26.1025 },
  'athens': { lat: 37.9838, lon: 23.7275 },
  // Asia
  'tokyo': { lat: 35.6762, lon: 139.6503 },
  'osaka': { lat: 34.6937, lon: 135.5023 },
  'seoul': { lat: 37.5665, lon: 126.9780 },
  'beijing': { lat: 39.9042, lon: 116.4074 },
  'shanghai': { lat: 31.2304, lon: 121.4737 },
  'hong-kong': { lat: 22.3193, lon: 114.1694 },
  'taipei': { lat: 25.0330, lon: 121.5654 },
  'singapore': { lat: 1.3521, lon: 103.8198 },
  'bangkok': { lat: 13.7563, lon: 100.5018 },
  'kuala-lumpur': { lat: 3.1390, lon: 101.6869 },
  'jakarta': { lat: -6.2088, lon: 106.8456 },
  'manila': { lat: 14.5995, lon: 120.9842 },
  'hanoi': { lat: 21.0285, lon: 105.8542 },
  'ho-chi-minh': { lat: 10.8231, lon: 106.6297 },
  'mumbai': { lat: 19.0760, lon: 72.8777 },
  'new-delhi': { lat: 28.6139, lon: 77.209 },
  'bangalore': { lat: 12.9716, lon: 77.5946 },
  'kolkata': { lat: 22.5726, lon: 88.3639 },
  'chennai': { lat: 13.0827, lon: 80.2707 },
  'karachi': { lat: 24.8607, lon: 67.0011 },
  'lahore': { lat: 31.5204, lon: 74.3587 },
  'dhaka': { lat: 23.8103, lon: 90.4125 },
  // Oceania
  'sydney': { lat: -33.8688, lon: 151.2093 },
  'melbourne': { lat: -37.8136, lon: 144.9631 },
  'brisbane': { lat: -27.4698, lon: 153.0251 },
  'perth': { lat: -31.9505, lon: 115.8605 },
  'auckland': { lat: -36.8485, lon: 174.7633 },
  'wellington': { lat: -41.2865, lon: 174.7762 },
  // South America
  'sao-paulo': { lat: -23.5505, lon: -46.6333 },
  'rio-de-janeiro': { lat: -22.9068, lon: -43.1729 },
  'buenos-aires': { lat: -34.6037, lon: -58.3816 },
  'bogota': { lat: 4.7110, lon: -74.0721 },
  'lima': { lat: -12.0464, lon: -77.0428 },
  'santiago': { lat: -33.4489, lon: -70.6693 },
  'caracas': { lat: 10.4806, lon: -66.9036 },
  // Africa
  'johannesburg': { lat: -26.2041, lon: 28.0473 },
  'cape-town': { lat: -33.9249, lon: 18.4241 },
  'lagos': { lat: 6.5244, lon: 3.3792 },
  'nairobi': { lat: -1.2921, lon: 36.8219 },
  'addis-ababa': { lat: 9.0320, lon: 38.7469 },
  'casablanca': { lat: 33.5731, lon: -7.5898 },
  'tunis': { lat: 36.8065, lon: 10.1815 },
  'algiers': { lat: 36.7538, lon: 3.0588 },
  'accra': { lat: 5.6037, lon: -0.1870 },
  'dakar': { lat: 14.7167, lon: -17.4677 }
};

// Reverse lookup: coordinates to slug
const COORDS_TO_SLUG = {};
for (const [slug, coords] of Object.entries(CITY_SLUGS)) {
  COORDS_TO_SLUG[`${coords.lat},${coords.lon}`] = slug;
}

// Named profile configurations for short URLs
// IMPORTANT: When adding new profiles, also update calendarRoutes in 404.html
// to enable client-side routing for the new profile URLs!
const PROFILE_CONFIGS = {
  'time-tested': {
    moonPhase: 'full',
    dayStartTime: 'morning',
    dayStartAngle: 12,
    sabbathMode: 'lunar',
    yearStartRule: 'equinox'
  },
  'ancient-traditional': {
    moonPhase: 'crescent',
    dayStartTime: 'evening',
    dayStartAngle: 0,
    sabbathMode: 'saturday',
    yearStartRule: '13daysBefore'  // "passover" rule - Day 15 on or after equinox
  },
  '119-ministries': {
    moonPhase: 'dark',
    dayStartTime: 'evening',
    dayStartAngle: 0,
    sabbathMode: 'saturday',
    yearStartRule: 'equinox'
  },
  'creators-calendar': {
    moonPhase: 'full',
    dayStartTime: 'evening',
    dayStartAngle: 0,
    sabbathMode: 'lunar',
    yearStartRule: 'virgoFeet'
  },
  'traditional-lunar': {
    moonPhase: 'crescent',
    dayStartTime: 'evening',
    dayStartAngle: 0,
    sabbathMode: 'lunar',
    yearStartRule: 'equinox'
  }
};

// URL to internal value mappings
const YEAR_START_URL_MAP = {
  'equinox': 'equinox',
  'passover': '13daysBefore',
  'lamb': '13daysBefore',
  'virgo': 'virgoFeet',
  'virgo-feet': 'virgoFeet',
  'creators': 'virgoFeet'
};
const YEAR_START_INTERNAL_TO_URL = {
  'equinox': 'equinox',
  '13daysBefore': 'passover',
  'virgoFeet': 'virgo'
};

// Crescent threshold URL mappings (18h is default, omitted from URL)
const CRESCENT_THRESHOLD_TO_URL = {
  12: 'opt',      // Optimistic (optical aids)
  15.5: 'min',    // Minimum naked-eye
  24: 'con'       // Conservative
};
const CRESCENT_THRESHOLD_FROM_URL = {
  'opt': 12,
  'min': 15.5,
  'con': 24
};

// Find closest city slug from coordinates (within ~100km)
function getClosestCitySlug(lat, lon, maxDistKm = 500) {
  let closestSlug = null;
  let closestDist = Infinity;
  
  for (const [slug, coords] of Object.entries(CITY_SLUGS)) {
    const dist = haversineDistance(lat, lon, coords.lat, coords.lon);
    if (dist < closestDist && dist < maxDistKm) {
      closestDist = dist;
      closestSlug = slug;
    }
  }
  
  return closestSlug;
}

// Haversine distance in km
function haversineDistance(lat1, lon1, lat2, lon2) {
  const R = 6371; // Earth's radius in km
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
            Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

// Get current profile slug based on state
function getCurrentProfileSlug() {
  for (const [slug, config] of Object.entries(PROFILE_CONFIGS)) {
    if (state.moonPhase === config.moonPhase &&
        state.dayStartTime === config.dayStartTime &&
        state.dayStartAngle === config.dayStartAngle &&
        state.sabbathMode === config.sabbathMode &&
        state.yearStartRule === config.yearStartRule) {
      return slug;
    }
  }
  return 'custom';
}

// Get location slug for URL
function getLocationSlug() {
  // Default to Jerusalem if location not set
  const lat = state.lat ?? 31.7683;
  const lon = state.lon ?? 35.2137;
  
  // Try exact match first
  const coordKey = `${lat},${lon}`;
  if (COORDS_TO_SLUG[coordKey]) {
    return COORDS_TO_SLUG[coordKey];
  }
  
  // Find closest city (no distance limit)
  const closest = getClosestCitySlug(lat, lon, Infinity);
  if (closest) {
    return closest;
  }
  
  // Ultimate fallback
  return 'jerusalem';
}

// Build SEO-friendly URL from current state
function buildPathURL(options = {}) {
  const profile = getCurrentProfileSlug();
  const locationSlug = getLocationSlug();
  
  // Build segments - always include profile, year, and location for clear SEO URLs
  const segments = [];
  
  // Profile always included (explicit is better for SEO/analytics)
  segments.push(profile);
  
  // For custom profiles, encode settings in path segments
  // Format: /custom/moon/[threshold?]/dayStart/sabbath/yearStart/year/location/
  if (profile === 'custom') {
    // Moon phase: full, dark, crescent
    segments.push(state.moonPhase);
    
    // Crescent threshold (only if crescent and non-default)
    if (state.moonPhase === 'crescent' && state.crescentThreshold !== 18) {
      const thresholdSlug = CRESCENT_THRESHOLD_TO_URL[state.crescentThreshold];
      if (thresholdSlug) {
        segments.push(thresholdSlug);
      }
    }
    
    // Day start time: morning, evening
    segments.push(state.dayStartTime);
    
    // Sabbath mode: lunar, saturday, etc.
    segments.push(state.sabbathMode);
    
    // Year start rule: equinox, passover
    segments.push(YEAR_START_INTERNAL_TO_URL[state.yearStartRule] || 'equinox');
  }
  
  // Year always included (use BC format for negative years)
  segments.push(formatYearForURL(state.year));
  
  // Month (lunar month number, 1-indexed) - always include
  const monthNum = (state.currentMonthIndex || 0) + 1;
  segments.push(monthNum.toString());
  
  // Day (lunar day) - always include, default to 1
  const lunarDay = state.highlightedLunarDay || 1;
  segments.push(lunarDay.toString());
  
  // Location always included (explicit is better for SEO/analytics)
  segments.push(locationSlug);
  
  // Build path
  let path = '/' + segments.join('/');
  if (!path.endsWith('/')) {
    path += '/';
  }
  
  // Query params (only for time or dayStartAngle which isn't in path)
  const params = new URLSearchParams();
  
  // dayStartAngle is not easily encodable in path, keep as query param for custom
  if (profile === 'custom' && state.dayStartAngle !== 0) {
    params.set('angle', state.dayStartAngle);
  }
  
  // Time parameter if specific time is set
  if (options.includeTime && state.selectedTimestamp) {
    const d = new Date(state.selectedTimestamp);
    params.set('time', `${d.getHours()}:${String(d.getMinutes()).padStart(2, '0')}`);
  }
  
  const queryString = params.toString();
  return queryString ? `${path}?${queryString}` : path;
}

// Parse year from URL segment
// Supports: 2025, 32 (literal year 32 AD), -1445, 1446BC, 1446bc
// Returns internal year representation (1 BC = 0, 2 BC = -1, etc.)
function parseYearFromURL(yearStr) {
  if (!yearStr) return null;
  
  // Check for BC suffix (e.g., "1446BC", "1446bc")
  const bcMatch = yearStr.match(/^(\d+)[Bb][Cc]$/);
  if (bcMatch) {
    const bcYear = parseInt(bcMatch[1]);
    // Convert BC to internal: 1 BC = 0, 2 BC = -1, 1446 BC = -1445
    return -(bcYear - 1);
  }
  
  // Check for negative year (already in internal format)
  if (/^-\d+$/.test(yearStr)) {
    return parseInt(yearStr);
  }
  
  // Positive integer - treat as literal year (32 = year 32 AD, not 1932)
  if (/^\d+$/.test(yearStr)) {
    return parseInt(yearStr);
  }
  
  return null;
}

// Format year for URL (reverse of parseYearFromURL)
function formatYearForURL(year) {
  if (year <= 0) {
    // Convert internal to BC: 0 = 1BC, -1 = 2BC, -1445 = 1446BC
    const bcYear = Math.abs(year - 1);
    return `${bcYear}bc`;
  }
  return year.toString();
}

// Parse SEO-friendly URL path into state
function parsePathURL() {
  const path = window.location.pathname;
  const segments = path.split('/').filter(s => s.length > 0);
  const params = new URLSearchParams(window.location.search);
  
  // Check for special views first
  if (segments[0] === 'about') {
    return { view: 'about' };
  }
  if (segments[0] === 'sabbath-tester') {
    return { view: 'sabbath-tester' };
  }
  if (segments[0] === 'feasts') {
    return { view: 'feasts', segments: segments.slice(1) };
  }
  
  // Handle Gregorian date lookup: /gregorian/year/month/day/
  // Only valid for 1582 and later (Gregorian calendar start)
  if (segments[0] === 'gregorian') {
    const result = {
      view: 'gregorian-lookup',
      profile: 'time-tested',
      gregorianYear: null,
      gregorianMonth: null,
      gregorianDay: null
    };
    
    if (segments.length >= 2) {
      const parsedYear = parseYearFromURL(segments[1]);
      if (parsedYear !== null) result.gregorianYear = parsedYear;
    }
    if (segments.length >= 3) {
      const month = parseInt(segments[2]);
      if (month >= 1 && month <= 12) result.gregorianMonth = month;
    }
    if (segments.length >= 4) {
      const day = parseInt(segments[3]);
      if (day >= 1 && day <= 31) result.gregorianDay = day;
    }
    
    // If year is before Gregorian calendar (1582), redirect to Julian
    if (result.gregorianYear !== null && result.gregorianYear < 1582) {
      result.view = 'redirect-to-julian';
    }
    
    return result;
  }
  
  // Handle Julian date lookup: /julian/year/month/day/
  // Julian dates are converted to Gregorian internally but URL stays Julian
  if (segments[0] === 'julian') {
    const result = {
      view: 'julian-lookup',
      profile: 'time-tested',
      julianYear: null,
      julianMonth: null,
      julianDay: null
    };
    
    if (segments.length >= 2) {
      const parsedYear = parseYearFromURL(segments[1]);
      if (parsedYear !== null) result.julianYear = parsedYear;
    }
    if (segments.length >= 3) {
      const month = parseInt(segments[2]);
      if (month >= 1 && month <= 12) result.julianMonth = month;
    }
    if (segments.length >= 4) {
      const day = parseInt(segments[3]);
      if (day >= 1 && day <= 31) result.julianDay = day;
    }
    
    return result;
  }
  
  // Default state
  const result = {
    profile: 'time-tested',
    year: new Date().getFullYear(),
    month: null,
    day: null,
    location: 'jerusalem',
    view: 'calendar',
    needsRedirect: false
  };
  
  if (segments.length === 0) {
    // Root URL - redirect to canonical
    result.needsRedirect = true;
    return result;
  }
  
  let segmentIndex = 0;
  
  // First segment MUST be a profile name
  const first = segments[0];
  if (PROFILE_CONFIGS[first]) {
    result.profile = first;
    segmentIndex++;
  } else if (first === 'custom') {
    result.profile = 'custom';
    segmentIndex++;
    
    // For custom profiles, parse path segments:
    // /custom/moon/[threshold?]/dayStart/sabbath/yearStart/year/location/
    
    // Parse moon phase: full, dark, crescent
    if (segmentIndex < segments.length) {
      const moonSeg = segments[segmentIndex];
      if (moonSeg === 'full' || moonSeg === 'dark' || moonSeg === 'crescent') {
        result.moonPhase = moonSeg;
        segmentIndex++;
        
        // If crescent, check for threshold: opt, min, con
        if (moonSeg === 'crescent' && segmentIndex < segments.length) {
          const thresholdSeg = segments[segmentIndex];
          if (CRESCENT_THRESHOLD_FROM_URL[thresholdSeg] !== undefined) {
            result.crescentThreshold = CRESCENT_THRESHOLD_FROM_URL[thresholdSeg];
            segmentIndex++;
          }
          // else: default 18h, don't consume segment
        }
      }
    }
    
    // Parse dayStart: morning, evening
    if (segmentIndex < segments.length) {
      const dayStartSeg = segments[segmentIndex];
      if (dayStartSeg === 'morning' || dayStartSeg === 'evening') {
        result.dayStartTime = dayStartSeg;
        segmentIndex++;
      }
    }
    
    // Parse sabbath: lunar, saturday, sunday, friday, none
    if (segmentIndex < segments.length) {
      const sabbathSeg = segments[segmentIndex];
      if (['lunar', 'saturday', 'sunday', 'friday', 'none'].includes(sabbathSeg)) {
        result.sabbathMode = sabbathSeg;
        segmentIndex++;
      }
    }
    
    // Parse yearStart: equinox, passover
    if (segmentIndex < segments.length) {
      const yearStartSeg = segments[segmentIndex];
      if (yearStartSeg === 'equinox' || yearStartSeg === 'passover') {
        result.yearStartRule = YEAR_START_URL_MAP[yearStartSeg] || yearStartSeg;
        segmentIndex++;
      }
    }
  } else {
    // Not a valid profile - redirect to canonical URL with defaults
    result.needsRedirect = true;
    return result;
  }
  
  // Next segment: year (required)
  // Supports: 2025, 32, -1445, 1446BC, 1446bc
  if (segmentIndex < segments.length) {
    const yearStr = segments[segmentIndex];
    const parsedYear = parseYearFromURL(yearStr);
    if (parsedYear !== null) {
      result.year = parsedYear;
      segmentIndex++;
    }
  }
  
  // Parse remaining segments: could be month, day, or location
  // Format: .../year/[month/[day/]]location/
  const remaining = segments.slice(segmentIndex);
  
  if (remaining.length === 1) {
    // Just location
    result.location = remaining[0];
  } else if (remaining.length === 2) {
    // month + location
    if (/^\d+$/.test(remaining[0]) && parseInt(remaining[0]) >= 1 && parseInt(remaining[0]) <= 13) {
      result.month = parseInt(remaining[0]);
    }
    result.location = remaining[1];
  } else if (remaining.length >= 3) {
    // month + day + location
    if (/^\d+$/.test(remaining[0]) && parseInt(remaining[0]) >= 1 && parseInt(remaining[0]) <= 13) {
      result.month = parseInt(remaining[0]);
    }
    if (/^\d+$/.test(remaining[1]) && parseInt(remaining[1]) >= 1 && parseInt(remaining[1]) <= 30) {
      result.day = parseInt(remaining[1]);
    }
    result.location = remaining[2];
  }
  
  // Validate location - if not recognized, flag for redirect
  if (result.location && !CITY_SLUGS[result.location] && !/^-?\d+\.?\d*,-?\d+\.?\d*$/.test(result.location)) {
    result.needsRedirect = true;
  }
  
  // Parse query params (dayStartAngle still uses query param)
  if (params.has('angle')) result.dayStartAngle = parseInt(params.get('angle'));
  if (params.has('threshold')) result.crescentThreshold = parseInt(params.get('threshold'));
  if (params.has('time')) result.time = params.get('time');
  
  return result;
}

// Apply parsed URL state to app state
function applyURLState(urlState) {
  let needsRegenerate = false;
  
  // Apply profile settings
  if (urlState.profile && PROFILE_CONFIGS[urlState.profile]) {
    const config = PROFILE_CONFIGS[urlState.profile];
    if (state.moonPhase !== config.moonPhase) {
      state.moonPhase = config.moonPhase;
      needsRegenerate = true;
    }
    if (state.dayStartTime !== config.dayStartTime) {
      state.dayStartTime = config.dayStartTime;
      needsRegenerate = true;
    }
    if (state.dayStartAngle !== config.dayStartAngle) {
      state.dayStartAngle = config.dayStartAngle;
      needsRegenerate = true;
    }
    if (state.sabbathMode !== config.sabbathMode) {
      state.sabbathMode = config.sabbathMode;
      needsRegenerate = true;
    }
    if (state.yearStartRule !== config.yearStartRule) {
      state.yearStartRule = config.yearStartRule;
      needsRegenerate = true;
    }
  }
  
  // Apply custom settings from query params
  if (urlState.moonPhase) { state.moonPhase = urlState.moonPhase; needsRegenerate = true; }
  if (urlState.dayStartTime) { state.dayStartTime = urlState.dayStartTime; needsRegenerate = true; }
  if (urlState.dayStartAngle !== undefined) { state.dayStartAngle = urlState.dayStartAngle; needsRegenerate = true; }
  if (urlState.sabbathMode) { state.sabbathMode = urlState.sabbathMode; needsRegenerate = true; }
  if (urlState.yearStartRule) { state.yearStartRule = urlState.yearStartRule; needsRegenerate = true; }
  if (urlState.crescentThreshold !== undefined) { state.crescentThreshold = urlState.crescentThreshold; needsRegenerate = true; }
  
  // Apply year
  if (urlState.year && urlState.year !== state.year) {
    state.year = urlState.year;
    needsRegenerate = true;
  }
  
  // Apply location
  if (urlState.location) {
    let lat, lon;
    if (CITY_SLUGS[urlState.location]) {
      lat = CITY_SLUGS[urlState.location].lat;
      lon = CITY_SLUGS[urlState.location].lon;
    }
    if (lat !== undefined && lon !== undefined && (lat !== state.lat || lon !== state.lon)) {
      state.lat = lat;
      state.lon = lon;
      needsRegenerate = true;
    }
  }
  
  return { needsRegenerate, month: urlState.month, day: urlState.day, view: urlState.view };
}

// Update browser URL without reload
function updatePathURL() {
  const newURL = buildPathURL();
  if (window.location.pathname + window.location.search !== newURL) {
    window.history.replaceState({}, '', newURL);
  }
}

// Navigate with path URL and push to history
function navigateToPathURL(options = {}) {
  const newURL = buildPathURL(options);
  window.history.pushState({}, '', newURL);
}

// Convert Julian date to Gregorian date
// Julian calendar lags behind Gregorian by a growing number of days
function julianToGregorian(year, month, day) {
  // Calculate Julian Day Number for Julian calendar date
  let a = Math.floor((14 - month) / 12);
  let y = year + 4800 - a;
  let m = month + 12 * a - 3;
  
  // Julian calendar JDN formula
  let jdn = day + Math.floor((153 * m + 2) / 5) + 365 * y + Math.floor(y / 4) - 32083;
  
  // Convert JDN back to Gregorian calendar
  let b = jdn + 32044;
  let c = Math.floor((4 * b + 3) / 146097);
  let d = b - Math.floor(146097 * c / 4);
  let e = Math.floor((4 * d + 3) / 1461);
  let f = d - Math.floor(1461 * e / 4);
  let g = Math.floor((5 * f + 2) / 153);
  
  let gregDay = f - Math.floor((153 * g + 2) / 5) + 1;
  let gregMonth = g + 3 - 12 * Math.floor(g / 10);
  let gregYear = 100 * c + e - 4800 + Math.floor(g / 10);
  
  return { year: gregYear, month: gregMonth, day: gregDay };
}

// Handle Gregorian date lookup - find lunar date and redirect
async function handleGregorianLookup(urlState) {
  const { gregorianYear, gregorianMonth, gregorianDay } = urlState;
  
  // Default to today if not specified
  const now = new Date();
  const year = gregorianYear !== null ? gregorianYear : now.getFullYear();
  const month = gregorianMonth !== null ? gregorianMonth : (now.getMonth() + 1);
  const day = gregorianDay !== null ? gregorianDay : now.getDate();
  
  // Set state to the year containing this Gregorian date
  state.year = year;
  
  // Generate calendar for this year
  updateUI();
  await generateCalendar();
  
  // Find the Gregorian date in the lunar calendar
  const targetDate = new Date(year, month - 1, day, 12, 0, 0);
  const targetDateStr = targetDate.toISOString().split('T')[0];
  
  let foundMonth = null;
  let foundDay = null;
  
  for (let m = 0; m < state.lunarMonths.length; m++) {
    const lunarMonth = state.lunarMonths[m];
    for (let d = 0; d < lunarMonth.days.length; d++) {
      const lunarDay = lunarMonth.days[d];
      if (lunarDay.gregorianDate.toISOString().split('T')[0] === targetDateStr) {
        foundMonth = m;
        foundDay = lunarDay.lunarDay;
        break;
      }
    }
    if (foundMonth !== null) break;
  }
  
  if (foundMonth !== null) {
    state.currentMonthIndex = foundMonth;
    state.highlightedLunarDay = foundDay;
    
    // Show the day
    const lunarMonth = state.lunarMonths[foundMonth];
    const dayObj = lunarMonth.days.find(d => d.lunarDay === foundDay);
    if (dayObj) {
      renderMonth(lunarMonth);
      showDayDetail(dayObj, lunarMonth);
    }
  }
  
  // Redirect to canonical lunar URL
  const canonicalURL = buildPathURL();
  window.history.replaceState({}, '', canonicalURL);
}

// Handle Julian date lookup - convert to Gregorian and find lunar date
async function handleJulianLookup(urlState) {
  const { julianYear, julianMonth, julianDay } = urlState;
  
  // Default to today if not specified (in Julian)
  const now = new Date();
  const year = julianYear !== null ? julianYear : now.getFullYear();
  const month = julianMonth !== null ? julianMonth : (now.getMonth() + 1);
  const day = julianDay !== null ? julianDay : now.getDate();
  
  // Convert Julian to Gregorian
  const greg = julianToGregorian(year, month, day);
  
  // Set state to the year containing this Gregorian date
  state.year = greg.year;
  
  // Generate calendar for this year
  updateUI();
  await generateCalendar();
  
  // Find the Gregorian date in the lunar calendar
  const targetDate = new Date(greg.year, greg.month - 1, greg.day, 12, 0, 0);
  const targetDateStr = targetDate.toISOString().split('T')[0];
  
  let foundMonth = null;
  let foundDay = null;
  
  for (let m = 0; m < state.lunarMonths.length; m++) {
    const lunarMonth = state.lunarMonths[m];
    for (let d = 0; d < lunarMonth.days.length; d++) {
      const lunarDay = lunarMonth.days[d];
      if (lunarDay.gregorianDate.toISOString().split('T')[0] === targetDateStr) {
        foundMonth = m;
        foundDay = lunarDay.lunarDay;
        break;
      }
    }
    if (foundMonth !== null) break;
  }
  
  if (foundMonth !== null) {
    state.currentMonthIndex = foundMonth;
    state.highlightedLunarDay = foundDay;
    
    // Show the day
    const lunarMonth = state.lunarMonths[foundMonth];
    const dayObj = lunarMonth.days.find(d => d.lunarDay === foundDay);
    if (dayObj) {
      renderMonth(lunarMonth);
      showDayDetail(dayObj, lunarMonth);
    }
  }
  
  // Redirect to canonical lunar URL
  const canonicalURL = buildPathURL();
  window.history.replaceState({}, '', canonicalURL);
}

// getTimezoneFromLongitude moved to astronomy-utils.js

// Get a display name for the current location
// Always shows the actual location name, never "Your Area (via IP)" etc.
// Optionally accepts lat/lon to look up a specific location
function getCurrentLocationName(optLat, optLon) {
  // Use provided coordinates or fall back to state
  const lat = optLat ?? state.lat ?? 31.7683;
  const lon = optLon ?? state.lon ?? 35.2137;
  
  // First, try to find city name from known cities (exact match)
  const coordValue = `${lat},${lon}`;
  if (CITY_NAMES[coordValue]) {
    return CITY_NAMES[coordValue];
  }
  
  // Try to find closest city slug match (500km radius)
  const slug = getClosestCitySlug(lat, lon, 500);
  if (slug && CITY_SLUGS[slug]) {
    // Convert slug to display name (capitalize, replace hyphens)
    return slug.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
  }
  
  // If still no match, find the absolute closest city (no limit)
  const closestSlug = getClosestCitySlug(lat, lon, Infinity);
  if (closestSlug && CITY_SLUGS[closestSlug]) {
    const cityName = closestSlug.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
    return `Near ${cityName}`;
  }
  
  // Last resort: region name based on longitude
  return getTimezoneFromLongitude(lon);
}

// Refresh location via IP if the current profile uses "Your Location"
function refreshLocationIfNeeded() {
  const profileId = state.selectedProfile || 'timeTested';
  const profile = PROFILES[profileId];
  
  // Only refresh for profiles with useCurrentLocation
  if (!profile || !profile.useCurrentLocation) return;
  
  // Use IP-based geolocation (no permission prompt)
  getLocationFromIP()
    .then(location => {
      if (location) {
        const newLat = Math.round(location.lat * 10000) / 10000;
        const newLon = Math.round(location.lon * 10000) / 10000;
        
        // Only update if location has changed significantly (>0.01 degrees â‰ˆ 1km)
        if (Math.abs(newLat - state.lat) > 0.01 || Math.abs(newLon - state.lon) > 0.01) {
          state.lat = newLat;
          state.lon = newLon;
          state.city = 'ip-based';
          state.locationSource = 'ip';
          
          // Update UI
          document.getElementById('lat-input').value = state.lat;
          document.getElementById('lon-input').value = state.lon;
          
          // Regenerate calendar with new location
          saveState();
          generateCalendar({ preserveMonth: true });
          renderSettingsPageMap();
        }
      }
    })
    .catch(error => {
      // Silently fail - keep existing location
      console.log('IP geolocation refresh failed, keeping saved location');
    });
}

// Check if a profile name is unique
function isProfileNameUnique(name, excludeId = null) {
  const normalizedName = name.trim().toLowerCase();
  for (const [id, profile] of Object.entries(PROFILES)) {
    if (id !== excludeId && profile.name.toLowerCase() === normalizedName) {
      return false;
    }
  }
  return true;
}

// Track modal mode: 'create' or 'edit'
let profileModalMode = 'create';
let profileModalEditId = null;

// Clone current profile settings as a new custom profile
function cloneProfile() {
  const profileId = editingProfileId || state.selectedProfile;
  const currentProfile = PROFILES[profileId];
  
  // Suggest a name based on current profile
  const suggestedName = currentProfile ? currentProfile.name + ' Copy' : 'My Profile';
  
  showProfileModal('create', suggestedName);
}

// Edit the name of the current custom profile
function editProfileName() {
  const profileId = editingProfileId || state.selectedProfile;
  
  // Can't edit presets
  if (PRESET_PROFILES[profileId]) return;
  
  const currentProfile = PROFILES[profileId];
  if (!currentProfile) return;
  
  showProfileModal('edit', currentProfile.name, profileId);
}

function showProfileModal(mode, defaultName, editId = null) {
  profileModalMode = mode;
  profileModalEditId = editId;
  
  const overlay = document.getElementById('profile-modal-overlay');
  const input = document.getElementById('profile-modal-input');
  const error = document.getElementById('profile-modal-error');
  const title = document.getElementById('profile-modal-title');
  const saveBtn = document.getElementById('profile-modal-save-btn');
  
  title.textContent = mode === 'edit' ? 'Rename Profile' : 'Create New Profile';
  saveBtn.textContent = mode === 'edit' ? 'Save' : 'Create';
  
  input.value = defaultName || '';
  error.textContent = '';
  overlay.classList.add('visible');
  
  // Focus and select the input text
  setTimeout(() => {
    input.focus();
    input.select();
  }, 100);
}

function closeProfileModal(event) {
  // If event exists and target is not the overlay itself, don't close
  if (event && event.target !== event.currentTarget) return;
  
  const overlay = document.getElementById('profile-modal-overlay');
  overlay.classList.remove('visible');
  profileModalMode = 'create';
  profileModalEditId = null;
}

function handleProfileModalKeydown(event) {
  if (event.key === 'Enter') {
    saveProfileModal();
  } else if (event.key === 'Escape') {
    closeProfileModal();
  }
}

function saveProfileModal() {
  const input = document.getElementById('profile-modal-input');
  const error = document.getElementById('profile-modal-error');
  const select = document.getElementById('profile-select');
  
  let name = input.value.trim();
  
  if (!name) {
    error.textContent = 'Please enter a profile name.';
    input.focus();
    return;
  }
  
  // Check for unique name (exclude current profile when editing)
  if (!isProfileNameUnique(name, profileModalEditId)) {
    error.textContent = 'A profile with this name already exists.';
    input.focus();
    return;
  }
  
  // Get the profile being cloned from (editing profile, not necessarily active profile)
  const sourceProfileId = editingProfileId || state.selectedProfile;
  const sourceProfile = PROFILES[sourceProfileId] || {};
  
  if (profileModalMode === 'edit' && profileModalEditId) {
    // Edit existing profile name
    PROFILES[profileModalEditId].name = name;
    saveCustomProfiles();
    rebuildProfileDropdown();
    if (select) select.value = profileModalEditId;
    editingProfileId = profileModalEditId;
  } else {
    // Create new profile based on the currently editing profile's settings
    const id = 'custom_' + Date.now();
    PROFILES[id] = {
      name: name,
      icon: sourceProfile.icon || getProfileIcon(sourceProfile.moonPhase || 'full'),
      moonPhase: sourceProfile.moonPhase || 'full',
      dayStartTime: sourceProfile.dayStartTime || 'morning',
      dayStartAngle: sourceProfile.dayStartAngle ?? 12,
      yearStartRule: sourceProfile.yearStartRule || 'equinox',
      crescentThreshold: sourceProfile.crescentThreshold ?? 18,
      sabbathMode: sourceProfile.sabbathMode || 'lunar',
      lat: sourceProfile.lat ?? state.lat,
      lon: sourceProfile.lon ?? state.lon,
      city: sourceProfile.city || state.city
    };
    
    saveCustomProfiles();
    
    // Switch to editing the new profile (don't apply to calendar yet)
    editingProfileId = id;
    rebuildProfileDropdown();
    if (select) select.value = id;
  }
  
  updateProfileButtonStates();
  updateSettingsEditability();
  
  // Close the modal
  closeProfileModal();
}

// Delete the currently selected custom profile
function deleteCustomProfile() {
  const profileId = editingProfileId || state.selectedProfile;
  
  // Can't delete presets
  if (PRESET_PROFILES[profileId]) return;
  
  const profile = PROFILES[profileId];
  if (!confirm(`Delete profile "${profile.name}"?`)) return;
  
  delete PROFILES[profileId];
  saveCustomProfiles();
  
  // If we deleted the active profile, switch to Time-Tested
  if (profileId === state.selectedProfile) {
    state.selectedProfile = 'timeTested';
    applyProfile('timeTested');
  }
  
  // Reset editing to first available profile
  editingProfileId = 'timeTested';
  rebuildProfileDropdown();
  
  // Switch to Time-Tested preset (Jerusalem)
  applyProfile('timeTested');
}

// Update delete and edit button states based on editing profile
function updateProfileButtonStates() {
  const deleteBtn = document.getElementById('profile-delete-btn');
  const editBtn = document.getElementById('profile-edit-btn');
  
  const profileId = editingProfileId || state.selectedProfile;
  const isPreset = !!PRESET_PROFILES[profileId];
  
  // Delete and edit enabled only for user-saved profiles (not presets)
  if (deleteBtn) deleteBtn.disabled = isPreset;
  if (editBtn) editBtn.disabled = isPreset;
}

// Enable/disable settings controls based on whether editing profile is editable
function updateSettingsEditability() {
  const profileId = editingProfileId || state.selectedProfile;
  const isPreset = !!PRESET_PROFILES[profileId];
  
  // Get all settings controls
  const settingsContainer = document.getElementById('settings-page');
  if (!settingsContainer) return;
  
  // Toggle disabled state on settings buttons and selects (but not profile controls)
  const controls = settingsContainer.querySelectorAll('.settings-option-btn, .settings-select:not(#profile-select), #settings-lat-input, #settings-lon-input');
  controls.forEach(control => {
    if (isPreset) {
      control.disabled = true;
      control.classList.add('disabled');
    } else {
      control.disabled = false;
      control.classList.remove('disabled');
    }
  });
  
  // Also disable/enable the location button
  const locationBtn = settingsContainer.querySelector('.settings-location-btn');
  if (locationBtn) {
    locationBtn.disabled = isPreset;
    locationBtn.classList.toggle('disabled', isPreset);
  }
  
  // Update all maps to show disabled state
  updateMapEditability();
}

// Update map click hint and disabled state based on editing profile
function updateMapEditability() {
  const profileId = editingProfileId || state.selectedProfile;
  const isPreset = !!PRESET_PROFILES[profileId];
  
  // Update all dateline maps
  document.querySelectorAll('.dateline-map').forEach(map => {
    map.classList.toggle('disabled', isPreset);
  });
  
  // Update click hints
  document.querySelectorAll('.dateline-click-hint').forEach(hint => {
    if (isPreset) {
      hint.style.display = 'none';
    } else {
      hint.style.display = '';
    }
  });
}

// Initialize custom profiles on load
loadCustomProfiles();

// Get feast icons for a given lunar month and day
function getFeastIconsForLunarDay(month, day) {
  const icons = [];
  for (const f of FEASTS) {
    if (f.month === month) {
      if (f.endDay) {
        // Multi-day feast
        if (day >= f.day && day <= f.endDay) {
          if (!icons.includes(f.icon)) icons.push(f.icon);
        }
      } else if (f.day === day) {
        // Single-day feast
        if (!icons.includes(f.icon)) icons.push(f.icon);
      }
    }
  }
  return icons;
}

// Switch to a profile and navigate to the same Gregorian date
function switchToProfileAndNavigate(profileId, timestamp) {
  // Store the target date to navigate to after calendar regenerates
  state.pendingNavigationDate = new Date(timestamp);
  
  // Apply the profile (this will trigger calendar regeneration)
  applyProfile(profileId);
}

// Navigate to a pending date after calendar regeneration
function navigateToPendingDate() {
  if (!state.pendingNavigationDate) return;
  
  const targetDateStr = state.pendingNavigationDate.toISOString().split('T')[0];
  state.pendingNavigationDate = null; // Clear the pending navigation
  
  // Find this Gregorian date in the new calendar
  for (let m = 0; m < state.lunarMonths.length; m++) {
    const month = state.lunarMonths[m];
    for (let d = 0; d < month.days.length; d++) {
      const day = month.days[d];
      if (day.gregorianDate.toISOString().split('T')[0] === targetDateStr) {
        state.currentMonthIndex = m;
        state.highlightedLunarDay = day.lunarDay;
        renderMonth(month);
        showDayDetail(day, month);
        return;
      }
    }
  }
}

function applyProfile(profileId) {
  const profile = PROFILES[profileId];
  if (!profile) return;
  
  state.selectedProfile = profileId;
  state.moonPhase = profile.moonPhase;
  state.dayStartTime = profile.dayStartTime;
  state.dayStartAngle = profile.dayStartAngle;
  state.yearStartRule = profile.yearStartRule;
  state.crescentThreshold = profile.crescentThreshold;
  state.sabbathMode = profile.sabbathMode || 'lunar';
  
  if (profile.useLocalLocation) {
    // Use saved location first, then fall back to IP detection
    const savedLocation = getSavedUserLocation();
    if (savedLocation) {
      state.lat = savedLocation.lat;
      state.lon = savedLocation.lon;
      state.city = savedLocation.city || 'saved';
      state.locationSource = 'saved';
      updateLocationUI();
      finishApplyProfile();
    } else {
      // No saved location - use IP-based geolocation
      getLocationFromIP()
        .then(location => {
          if (location) {
            state.lat = location.lat;
            state.lon = location.lon;
            state.city = 'ip-based';
            state.locationSource = 'ip';
            updateLocationUI();
          }
          finishApplyProfile();
        })
        .catch(error => {
          console.log('IP geolocation error, keeping current location');
          finishApplyProfile();
        });
    }
  } else if (profile.lat !== undefined) {
    // Custom profile with fixed location
    state.lat = profile.lat;
    state.lon = profile.lon;
    state.city = profile.city;
    state.locationSource = 'fixed';
    updateLocationUI();
    finishApplyProfile();
  } else {
    finishApplyProfile();
  }
}

// Get saved user location from localStorage
function getSavedUserLocation() {
  try {
    const saved = localStorage.getItem('userDefaultLocation');
    if (saved) {
      return JSON.parse(saved);
    }
  } catch (e) {
    console.error('Error loading saved location:', e);
  }
  return null;
}

// Save user location preference to localStorage
function saveUserLocation(lat, lon, city) {
  try {
    localStorage.setItem('userDefaultLocation', JSON.stringify({ lat, lon, city }));
  } catch (e) {
    console.error('Error saving location:', e);
  }
}

// Get approximate location from IP (no permission required)
async function getLocationFromIP() {
  try {
    // Try ipapi.co first (HTTPS, reliable)
    const response = await fetch('https://ipapi.co/json/', { 
      timeout: 5000,
      cache: 'no-store'
    });
    if (response.ok) {
      const data = await response.json();
      if (data.latitude && data.longitude) {
        return { 
          lat: data.latitude, 
          lon: data.longitude,
          city: data.city,
          country: data.country_name
        };
      }
    }
  } catch (e) {
    console.log('IP geolocation failed:', e);
  }
  return null;
}

// Get exact GPS location (requires user permission) - used in profile editor
function getExactLocation() {
  const profileId = editingProfileId || state.selectedProfile;
  
  // Don't allow changes on preset profiles
  if (PRESET_PROFILES[profileId]) return;
  
  if (!navigator.geolocation) {
    alert('GPS is not available on this device');
    return;
  }
  
  // Show loading indicator
  const btn = document.querySelector('.exact-location-btn');
  if (btn) {
    btn.textContent = 'ğŸ“ Getting location...';
    btn.disabled = true;
  }
  
  navigator.geolocation.getCurrentPosition(
    (position) => {
      const lat = Math.round(position.coords.latitude * 10000) / 10000;
      const lon = Math.round(position.coords.longitude * 10000) / 10000;
      
      // Find nearest city to snap to
      const nearestSlug = getClosestCitySlug(lat, lon, Infinity);
      const nearestCoords = nearestSlug ? CITY_SLUGS[nearestSlug] : { lat, lon };
      const finalLat = nearestCoords.lat;
      const finalLon = nearestCoords.lon;
      
      // Profile editor only updates the profile's location
      if (PROFILES[profileId]) {
        PROFILES[profileId].lat = finalLat;
        PROFILES[profileId].lon = finalLon;
        PROFILES[profileId].city = nearestSlug || 'gps';
        saveCustomProfiles();
      }
      
      // Update settings page inputs
      const settingsLatInput = document.getElementById('settings-lat-input');
      const settingsLonInput = document.getElementById('settings-lon-input');
      const settingsCitySelect = document.getElementById('settings-city-select');
      const settingsCustomCoords = document.getElementById('settings-custom-coords');
      
      // Try to select the nearest city in the dropdown
      const coordValue = `${finalLat},${finalLon}`;
      let found = false;
      if (settingsCitySelect) {
        for (let option of settingsCitySelect.options) {
          if (option.value === coordValue) {
            settingsCitySelect.value = coordValue;
            found = true;
            break;
          }
        }
      }
      
      if (!found) {
        if (settingsCitySelect) settingsCitySelect.value = 'custom';
        if (settingsCustomCoords) settingsCustomCoords.style.display = 'flex';
        if (settingsLatInput) settingsLatInput.value = finalLat;
        if (settingsLonInput) settingsLonInput.value = finalLon;
      } else {
        if (settingsCustomCoords) settingsCustomCoords.style.display = 'none';
      }
      
      renderSettingsPageMap();
      
      // Update button
      if (btn) {
        btn.textContent = 'ğŸ“ Location Saved!';
        setTimeout(() => {
          btn.textContent = 'ğŸ“ Use My Location';
          btn.disabled = false;
        }, 2000);
      }
    },
    (error) => {
      console.log('GPS error:', error);
      alert('Could not get your exact location. Please check your browser permissions.');
      if (btn) {
        btn.textContent = 'ğŸ“ Use Exact Location';
        btn.disabled = false;
      }
    },
    { enableHighAccuracy: true, timeout: 10000 }
  );
}

function updateLocationUI() {
  document.getElementById('lat-input').value = state.lat;
  document.getElementById('lon-input').value = state.lon;
  document.getElementById('city-select').value = state.city || '';
  const settingsCitySelect = document.getElementById('settings-city-select');
  if (settingsCitySelect) settingsCitySelect.value = state.city || '';
}

function finishApplyProfile() {
  // Update all UI elements
  document.getElementById('moon-phase-select').value = state.moonPhase;
  updateMoonPhaseButtons();
  updateDayStartButtons();
  updateYearStartButtons();
  updateCrescentThresholdVisibility();
  updateCrescentThresholdButtons();
  updateSabbathButtons();
  updateProfileButtons();
  updateSettingsEditability();
  
  // Save and regenerate (preserving scroll position)
  saveState();
  regenerateCalendarPreservingScroll();
}

function getMatchingProfile() {
  // Determine which profile matches current state (if any)
  for (const [id, profile] of Object.entries(PROFILES)) {
    if (profile.moonPhase === state.moonPhase &&
        profile.dayStartTime === state.dayStartTime &&
        profile.dayStartAngle === state.dayStartAngle &&
        profile.yearStartRule === state.yearStartRule &&
        profile.crescentThreshold === state.crescentThreshold &&
        (profile.sabbathMode || 'lunar') === state.sabbathMode) {
      // Check location match for non-current-location profiles
      if (profile.useCurrentLocation) {
        // For "current location" profiles, any location works
        return id;
      } else if (Math.abs(profile.lat - state.lat) < 0.01 && Math.abs(profile.lon - state.lon) < 0.01) {
        return id;
      }
    }
  }
  return null; // No matching profile
}

function updateProfileButtons() {
  // Profile settings are now saved directly by individual setting functions
  // This just updates UI state
  updateProfileButtonStates();
}

function onProfileSelectChange(profileId) {
  // Only change which profile is being edited in settings, don't apply to calendar state
  editingProfileId = profileId;
  displayProfileSettings(profileId);
  updateSettingsEditability();
  updateProfileButtonStates();
}

// Display a profile's settings in the settings UI without applying to state
function displayProfileSettings(profileId) {
  const profile = PROFILES[profileId];
  if (!profile) return;
  
  // Update UI to show this profile's settings
  const moonPhaseSelect = document.getElementById('moon-phase-select');
  if (moonPhaseSelect) moonPhaseSelect.value = profile.moonPhase;
  
  // Update moon phase buttons (use 'selected' class for settings buttons)
  document.querySelectorAll('.settings-option-btn[data-phase]').forEach(btn => {
    btn.classList.toggle('selected', btn.dataset.phase === profile.moonPhase);
  });
  
  // Update day start buttons
  document.querySelectorAll('.settings-option-btn[data-day-start]').forEach(btn => {
    btn.classList.toggle('selected', btn.dataset.dayStart === profile.dayStartTime);
  });
  document.querySelectorAll('.settings-option-btn[data-angle]').forEach(btn => {
    const angle = parseInt(btn.dataset.angle);
    btn.classList.toggle('selected', angle === profile.dayStartAngle);
  });
  
  // Update year start buttons
  document.querySelectorAll('.settings-option-btn[data-year-start]').forEach(btn => {
    btn.classList.toggle('selected', btn.dataset.yearStart === profile.yearStartRule);
  });
  
  // Update crescent threshold buttons
  document.querySelectorAll('.settings-option-btn[data-threshold]').forEach(btn => {
    const threshold = parseFloat(btn.dataset.threshold);
    btn.classList.toggle('selected', threshold === (profile.crescentThreshold ?? 18));
  });
  
  // Update sabbath buttons
  document.querySelectorAll('.settings-option-btn[data-sabbath]').forEach(btn => {
    btn.classList.toggle('selected', btn.dataset.sabbath === profile.sabbathMode);
  });
  
  // Update crescent threshold visibility
  const crescentSection = document.getElementById('crescent-threshold-section');
  if (crescentSection) {
    crescentSection.style.display = profile.moonPhase === 'crescent' ? 'block' : 'none';
  }
  
  // Update year start explanations
  const equinoxExplanation = document.getElementById('equinox-rule-explanation');
  if (equinoxExplanation) {
    if (profile.yearStartRule === 'equinox') {
      equinoxExplanation.innerHTML = getEquinoxMethodologyHtml({ showCalculation: false });
      equinoxExplanation.style.display = 'block';
    } else {
      equinoxExplanation.style.display = 'none';
    }
  }
  
  const lambExplanation = document.getElementById('lamb-rule-explanation');
  if (lambExplanation) {
    if (profile.yearStartRule === '13daysBefore') {
      lambExplanation.innerHTML = getPassoverMethodologyHtml({ showCalculation: false });
      lambExplanation.style.display = 'block';
    } else {
      lambExplanation.style.display = 'none';
    }
  }
  
  const virgoExplanation = document.getElementById('virgo-rule-explanation');
  if (virgoExplanation) {
    if (profile.yearStartRule === 'virgoFeet') {
      const virgoCalc = getVirgoCalculation(state.year);
      virgoExplanation.innerHTML = getVirgoMethodologyHtml({ 
        showCalculation: !!virgoCalc, 
        virgoCalc: virgoCalc 
      });
      virgoExplanation.style.display = 'block';
    } else {
      virgoExplanation.style.display = 'none';
    }
  }
  
  // Update location display for this profile
  const profileLat = profile.lat ?? state.lat;
  const profileLon = profile.lon ?? state.lon;
  const citySelect = document.getElementById('settings-city-select');
  const coordValue = `${profileLat},${profileLon}`;
  let found = false;
  
  if (citySelect) {
    for (let option of citySelect.options) {
      if (option.value === coordValue) {
        citySelect.value = coordValue;
        found = true;
        break;
      }
    }
    
    if (!found && (profileLat !== undefined && profileLon !== undefined)) {
      citySelect.value = 'custom';
      document.getElementById('settings-custom-coords').style.display = 'flex';
      document.getElementById('settings-lat-input').value = profileLat;
      document.getElementById('settings-lon-input').value = profileLon;
    } else if (found) {
      document.getElementById('settings-custom-coords').style.display = 'none';
    }
  }
  
  // Update the map to show this profile's location
  renderSettingsPageMap();
}

function resetToDefaults() {
  // Apply Time-Tested profile as default (Jerusalem, no location prompt)
  applyProfile('timeTested');
}

// Sabbath Tester code is loaded from sabbath-tester.js





// Sabbath Tester code moved to sabbath-tester.js

// Helper to regenerate calendar while preserving scroll position
function regenerateCalendarPreservingScroll() {
  const scrollTop = window.scrollY || document.documentElement.scrollTop;
  generateCalendar({ preserveMonth: true });
  updateURL();
  renderSettingsPageMap();
  
  // Check for pending navigation (from profile switching)
  if (state.pendingNavigationDate) {
    navigateToPendingDate();
  } else {
    refreshDayDetailIfVisible();
  }
  
  requestAnimationFrame(() => {
    window.scrollTo(0, scrollTop);
  });
}

function selectDayStartTime(time) {
  // Don't allow changes on preset profiles
  const profileId = editingProfileId || state.selectedProfile;
  if (PRESET_PROFILES[profileId]) return;
  
  // Update the editing profile
  if (PROFILES[profileId]) {
    PROFILES[profileId].dayStartTime = time;
    saveCustomProfiles();
  }
  
  updateDayStartButtons();
  
  // Only update state if editing the active profile
  if (profileId === state.selectedProfile) {
    state.dayStartTime = time;
    saveState();
    regenerateCalendarPreservingScroll();
  }
}

function selectDayStartAngle(angle) {
  // Don't allow changes on preset profiles
  const profileId = editingProfileId || state.selectedProfile;
  if (PRESET_PROFILES[profileId]) return;
  
  // Update the editing profile
  if (PROFILES[profileId]) {
    PROFILES[profileId].dayStartAngle = angle;
    saveCustomProfiles();
  }
  
  updateDayStartButtons();
  
  // Only update state if editing the active profile
  if (profileId === state.selectedProfile) {
    state.dayStartAngle = angle;
    saveState();
    regenerateCalendarPreservingScroll();
  }
}

function selectYearStartRule(rule) {
  // Don't allow changes on preset profiles
  const profileId = editingProfileId || state.selectedProfile;
  if (PRESET_PROFILES[profileId]) return;
  
  // Update the editing profile
  if (PROFILES[profileId]) {
    PROFILES[profileId].yearStartRule = rule;
    saveCustomProfiles();
  }
  
  updateYearStartButtons();
  
  // Only update state if editing the active profile
  if (profileId === state.selectedProfile) {
    state.yearStartRule = rule;
    saveState();
    regenerateCalendarPreservingScroll();
  }
}

function updateDayStartButtons() {
  // Use the editing profile for settings page
  const profileId = editingProfileId || state.selectedProfile;
  const profile = PROFILES[profileId];
  const dayStartTime = profile ? profile.dayStartTime : state.dayStartTime;
  const dayStartAngle = profile ? profile.dayStartAngle : state.dayStartAngle;
  
  // Update day start time buttons (evening/morning)
  document.querySelectorAll('.settings-option-btn[data-daystart]').forEach(btn => {
    btn.classList.toggle('selected', btn.dataset.daystart === dayStartTime);
  });
  // Update angle buttons
  document.querySelectorAll('.settings-option-btn[data-angle]').forEach(btn => {
    btn.classList.toggle('selected', parseInt(btn.dataset.angle) === dayStartAngle);
  });
}

function updateYearStartButtons() {
  // Use the editing profile for settings page
  const profileId = editingProfileId || state.selectedProfile;
  const profile = PROFILES[profileId];
  const yearStartRule = profile ? profile.yearStartRule : state.yearStartRule;
  
  document.querySelectorAll('.settings-option-btn[data-yearstart]').forEach(btn => {
    btn.classList.toggle('selected', btn.dataset.yearstart === yearStartRule);
  });
  
  // Update the "Renewed Moon after Equinox" icon to match current moon phase
  const iconEl = document.getElementById('yearstart-equinox-icon');
  if (iconEl) {
    iconEl.textContent = getMoonIcon();
  }
  
  // Show/hide the year start rule explanations - all populated dynamically
  const equinoxExplanation = document.getElementById('equinox-rule-explanation');
  if (equinoxExplanation) {
    if (yearStartRule === 'equinox') {
      equinoxExplanation.innerHTML = getEquinoxMethodologyHtml({ showCalculation: false });
      equinoxExplanation.style.display = 'block';
    } else {
      equinoxExplanation.style.display = 'none';
    }
  }
  
  const lambExplanation = document.getElementById('lamb-rule-explanation');
  if (lambExplanation) {
    if (yearStartRule === '13daysBefore') {
      lambExplanation.innerHTML = getPassoverMethodologyHtml({ showCalculation: false });
      lambExplanation.style.display = 'block';
    } else {
      lambExplanation.style.display = 'none';
    }
  }
  
  const virgoExplanation = document.getElementById('virgo-rule-explanation');
  if (virgoExplanation) {
    if (yearStartRule === 'virgoFeet') {
      // Populate with shared methodology content, including calculation if available
      const virgoCalc = getVirgoCalculation(state.year);
      virgoExplanation.innerHTML = getVirgoMethodologyHtml({ 
        showCalculation: !!virgoCalc, 
        virgoCalc: virgoCalc 
      });
      virgoExplanation.style.display = 'block';
    } else {
      virgoExplanation.style.display = 'none';
    }
  }
}

function selectCrescentThreshold(threshold) {
  // Don't allow changes on preset profiles
  const profileId = editingProfileId || state.selectedProfile;
  if (PRESET_PROFILES[profileId]) return;
  
  // Update the editing profile
  if (PROFILES[profileId]) {
    PROFILES[profileId].crescentThreshold = threshold;
    saveCustomProfiles();
  }
  
  updateCrescentThresholdButtons();
  
  // Only update state if editing the active profile
  if (profileId === state.selectedProfile) {
    state.crescentThreshold = threshold;
    saveState();
    regenerateCalendarPreservingScroll();
  }
}

function selectSabbathMode(mode) {
  // Don't allow changes on preset profiles
  const profileId = editingProfileId || state.selectedProfile;
  if (PRESET_PROFILES[profileId]) return;
  
  // Update the editing profile
  if (PROFILES[profileId]) {
    PROFILES[profileId].sabbathMode = mode;
    saveCustomProfiles();
  }
  
  // Clear dropdown when selecting a button option
  const dropdown = document.getElementById('sabbath-day-select');
  if (dropdown) dropdown.value = '';
  updateSabbathButtons();
  
  // Only update state if editing the active profile
  if (profileId === state.selectedProfile) {
    state.sabbathMode = mode;
    saveState();
    regenerateCalendarPreservingScroll();
  }
}

function updateSabbathButtons() {
  // Use the editing profile for settings page
  const profileId = editingProfileId || state.selectedProfile;
  const profile = PROFILES[profileId];
  const sabbathMode = profile ? profile.sabbathMode : state.sabbathMode;
  
  document.querySelectorAll('.settings-option-btn[data-sabbath]').forEach(btn => {
    btn.classList.toggle('selected', btn.dataset.sabbath === sabbathMode);
  });
  
  // Update the dropdown to reflect current selection
  const dropdown = document.getElementById('sabbath-day-select');
  if (dropdown) {
    const dropdownDays = ['none', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday'];
    if (dropdownDays.includes(sabbathMode)) {
      dropdown.value = sabbathMode;
    } else {
      dropdown.value = '';
    }
  }
}

function selectSabbathDayFromDropdown(day) {
  if (!day) return;
  
  // Don't allow changes on preset profiles
  const profileId = editingProfileId || state.selectedProfile;
  if (PRESET_PROFILES[profileId]) {
    // Reset dropdown to empty
    document.getElementById('sabbath-day-select').value = '';
    return;
  }
  
  state.sabbathMode = day;
  // Deselect the button options when selecting from dropdown
  document.querySelectorAll('.settings-option-btn[data-sabbath]').forEach(btn => {
    btn.classList.remove('selected');
  });
  updateSabbathButtons();
  updateProfileButtons();
  saveState();
  regenerateCalendarPreservingScroll();
}

// Determine if a day is a sabbath based on current sabbathMode
function isSabbath(day) {
  switch (state.sabbathMode) {
    case 'lunar':
      // Lunar sabbath: days 8, 15, 22, 29
      return [8, 15, 22, 29].includes(day.lunarDay);
    case 'sunday':
      return getCorrectWeekday(day.gregorianDate) === 0;
    case 'monday':
      return getCorrectWeekday(day.gregorianDate) === 1;
    case 'tuesday':
      return getCorrectWeekday(day.gregorianDate) === 2;
    case 'wednesday':
      return getCorrectWeekday(day.gregorianDate) === 3;
    case 'thursday':
      return getCorrectWeekday(day.gregorianDate) === 4;
    case 'friday':
      return getCorrectWeekday(day.gregorianDate) === 5;
    case 'saturday':
      return getCorrectWeekday(day.gregorianDate) === 6;
    case 'none':
      return false;
    default:
      return [8, 15, 22, 29].includes(day.lunarDay);
  }
}

function updateCrescentThresholdButtons() {
  // Use the editing profile for settings page
  const profileId = editingProfileId || state.selectedProfile;
  const profile = PROFILES[profileId];
  const crescentThreshold = profile ? (profile.crescentThreshold ?? 18) : state.crescentThreshold;
  
  document.querySelectorAll('.settings-option-btn[data-threshold]').forEach(btn => {
    btn.classList.toggle('selected', parseFloat(btn.dataset.threshold) === crescentThreshold);
  });
}

function updateCrescentThresholdVisibility() {
  // Use the editing profile for settings page
  const profileId = editingProfileId || state.selectedProfile;
  const profile = PROFILES[profileId];
  const moonPhase = profile ? profile.moonPhase : state.moonPhase;
  
  const section = document.getElementById('crescent-threshold-section');
  if (section) {
    section.style.display = moonPhase === 'crescent' ? 'block' : 'none';
  }
}

function renderSettingsMap() {
  const container = document.getElementById('settings-map-container');
  if (container && state.lunarMonths && state.lunarMonths[state.currentMonthIndex]) {
    const month = state.lunarMonths[state.currentMonthIndex];
    container.innerHTML = renderDatelineVisualization(month.moonEvent);
    // Update map editability after rendering
    updateMapEditability();
  }
}

// Month Picker Popup
function toggleMonthPicker() {
  const overlay = document.getElementById('month-picker-overlay');
  const picker = document.getElementById('month-picker');
  const isOpen = overlay.classList.contains('open');
  
  if (!isOpen) {
    // Opening - update the picker content
    updateMonthPicker();
  }
  
  overlay.classList.toggle('open');
  picker.style.display = isOpen ? 'none' : 'block';
}

function updateMonthPicker() {
  // Just show the year number (no BC/AD suffix - the dropdown handles that)
  const displayYear = state.year <= 0 ? Math.abs(state.year - 1) : state.year;
  document.getElementById('picker-year').textContent = displayYear;
  updateEraButtons();
  
  const grid = document.getElementById('month-grid');
  grid.innerHTML = '';
  
  const monthNames = ['1st', '2nd', '3rd', '4th', '5th', '6th', '7th', '8th', '9th', '10th', '11th', '12th', 'ğŸ“…13th'];
  
  for (let i = 0; i < 13; i++) {
    const btn = document.createElement('button');
    btn.textContent = monthNames[i];
    
    if (i >= state.lunarMonths.length) {
      btn.classList.add('disabled');
      btn.disabled = true;
    } else if (i === state.currentMonthIndex) {
      btn.classList.add('active');
    }
    
    // Add tooltip for 13th month
    if (i === 12) {
      btn.title = 'Intercalary 13th month';
    }
    
    btn.onclick = () => {
      if (i < state.lunarMonths.length) {
        selectMonth(i);
        toggleMonthPicker();
      }
    };
    
    grid.appendChild(btn);
  }
  
  // Add "Today" button - positioned in 4th column (under 12th month)
  // First add an empty spacer for the 3rd column position
  const spacer1 = document.createElement('div');
  spacer1.style.visibility = 'hidden';
  grid.appendChild(spacer1);
  
  const spacer2 = document.createElement('div');
  spacer2.style.visibility = 'hidden';
  grid.appendChild(spacer2);
  
  const todayBtn = document.createElement('button');
  todayBtn.textContent = 'Today';
  todayBtn.className = 'today-btn';
  todayBtn.title = 'Jump to today';
  todayBtn.onclick = () => {
    toggleMonthPicker();
    jumpToToday();
  };
  grid.appendChild(todayBtn);
}

function showYearInput() {
  const display = document.getElementById('picker-year');
  const input = document.getElementById('picker-year-input');
  
  display.style.visibility = 'hidden';
  input.classList.add('visible');
  
  // Convert internal year to display year (always positive)
  if (state.year <= 0) {
    input.value = Math.abs(state.year - 1);
  } else {
    input.value = state.year;
  }
  
  input.focus();
  input.select();
}

function hideYearInput() {
  const display = document.getElementById('picker-year');
  const input = document.getElementById('picker-year-input');
  
  display.style.visibility = '';
  input.classList.remove('visible');
}

function getPickerEra() {
  return state.year <= 0 ? 'BC' : 'AD';
}

function changeEra(era) {
  const input = document.getElementById('picker-year-input');
  const currentEra = getPickerEra();
  
  if (era === currentEra) return;
  
  // Get current display year
  let displayYear;
  if (input.classList.contains('visible')) {
    displayYear = parseInt(input.value) || 1;
  } else {
    displayYear = state.year <= 0 ? Math.abs(state.year - 1) : state.year;
  }
  
  // Convert to new era
  let newInternalYear;
  if (era === 'BC') {
    newInternalYear = -(displayYear - 1);
  } else {
    newInternalYear = displayYear;
  }
  
  // Validate range
  if (newInternalYear >= -3999 && newInternalYear <= 4000) {
    state.year = newInternalYear;
    document.getElementById('year-input').value = state.year;
    generateCalendar();
    updateMonthPicker();
  }
}

function updateEraButtons() {
  const eraSelect = document.getElementById('era-select');
  if (eraSelect) {
    eraSelect.value = state.year <= 0 ? 'BC' : 'AD';
  }
}

function applyYearInput() {
  const input = document.getElementById('picker-year-input');
  let displayYear = parseInt(input.value);
  
  if (isNaN(displayYear) || displayYear < 1 || displayYear > 4000) {
    hideYearInput();
    return;
  }
  
  // Convert display year to internal year based on current era
  const isBC = state.year <= 0;
  let internalYear;
  if (isBC) {
    internalYear = -(displayYear - 1);
  } else {
    internalYear = displayYear;
  }
  
  // Validate range: -3999 (4000 BC) to 4000 (4000 AD)
  if (internalYear >= -3999 && internalYear <= 4000) {
    state.year = internalYear;
    document.getElementById('year-input').value = state.year;
    generateCalendar();
    updateMonthPicker();
  }
  
  hideYearInput();
}

function changePickerYear(delta) {
  const newYear = state.year + delta;
  
  // Validate range: -3999 (4000 BC) to 4000 (4000 AD)
  if (newYear >= -3999 && newYear <= 4000) {
    state.year = newYear;
    document.getElementById('year-input').value = state.year;
    generateCalendar();
    updateMonthPicker();
    updateEraButtons();
  }
}

// Date Jump Popup
function toggleDateJump() {
  const overlay = document.getElementById('date-jump-overlay');
  const popup = document.getElementById('date-jump-popup');
  const isOpen = overlay.classList.contains('open');
  
  if (!isOpen) {
    // Opening - sync the datetime input
    const gotoDate = document.getElementById('goto-date').value;
    const datetimeInput = document.getElementById('jump-datetime');
    const ancientDisplay = document.getElementById('jump-ancient-display');
    const ancientDateText = document.getElementById('jump-ancient-date');
    
    if (gotoDate) {
      // Modern date - show datetime picker
      datetimeInput.value = gotoDate;
      datetimeInput.style.display = 'block';
      ancientDisplay.style.display = 'none';
    } else if (state.selectedTimestamp) {
      // Ancient date - show text display instead
      const date = new Date(state.selectedTimestamp);
      const dateStr = formatDisplayDate(date);
      ancientDateText.textContent = dateStr;
      datetimeInput.style.display = 'none';
      ancientDisplay.style.display = 'block';
    }
  }
  
  overlay.classList.toggle('open');
  popup.style.display = isOpen ? 'none' : 'block';
}

function executeJumpToDate() {
  const datetime = document.getElementById('jump-datetime').value;
  if (!datetime) {
    alert('Please enter a date');
    return;
  }
  document.getElementById('goto-date').value = datetime;
  jumpToDate();
  toggleDateJump();
}

function jumpToTodayFromPopup() {
  toggleDateJump();
  jumpToToday();
}

function addDaysFromPopup(direction) {
  const datetime = document.getElementById('jump-datetime').value;
  const days = parseInt(document.getElementById('jump-days').value) || 1;
  
  // For ancient dates, datetime input will be empty, use selectedTimestamp
  let utcTimestamp;
  if (datetime) {
    utcTimestamp = parseDatetimeLocal(datetime);
  } else if (state.selectedTimestamp) {
    utcTimestamp = state.selectedTimestamp;
  } else {
    alert('Please select a date first');
    return;
  }
  const newTimestamp = utcTimestamp + (direction * days * 24 * 60 * 60 * 1000);
  
  const formattedDate = formatLocalDatetime(newTimestamp);
  if (formattedDate) {
    // Modern date - update datetime input
    document.getElementById('jump-datetime').value = formattedDate;
    document.getElementById('jump-datetime').style.display = 'block';
    document.getElementById('jump-ancient-display').style.display = 'none';
  } else {
    // Ancient date - update text display
    const date = new Date(newTimestamp);
    document.getElementById('jump-ancient-date').textContent = formatDisplayDate(date);
    document.getElementById('jump-datetime').style.display = 'none';
    document.getElementById('jump-ancient-display').style.display = 'block';
  }
  
  document.getElementById('goto-date').value = formattedDate;
  state.selectedTimestamp = newTimestamp;
  jumpToDate();
}

function handleMapClick(event) {
  // Don't allow map clicks when on a preset profile
  const profileId = editingProfileId || state.selectedProfile;
  if (PRESET_PROFILES[profileId]) {
    return; // Preset profiles are read-only
  }
  
  const mapEl = event.currentTarget;
  const rect = mapEl.getBoundingClientRect();
  
  // Calculate click position as percentage
  const xPercent = (event.clientX - rect.left) / rect.width;
  const yPercent = (event.clientY - rect.top) / rect.height;
  
  // Convert to lat/lon (equirectangular projection)
  // X: 0% = -180Â°, 100% = 180Â°
  // Y: 0% = 90Â° (north), 100% = -90Â° (south)
  const lon = (xPercent * 360) - 180;
  const lat = 90 - (yPercent * 180);
  
  // Round to 2 decimal places
  const roundedLat = Math.round(lat * 100) / 100;
  const roundedLon = Math.round(lon * 100) / 100;
  
  // Check if we're in profile editor mode (settings page is visible with editingProfileId set)
  const settingsPage = document.getElementById('settings-page');
  const isInProfileEditor = settingsPage && settingsPage.classList.contains('visible') && editingProfileId;
  
  if (isInProfileEditor) {
    // Profile editor mode - only update the profile's location, not state
    if (PROFILES[profileId]) {
      PROFILES[profileId].lat = roundedLat;
      PROFILES[profileId].lon = roundedLon;
      PROFILES[profileId].city = '';
      saveCustomProfiles();
    }
    
    // Update settings page inputs only
    const settingsLatInput = document.getElementById('settings-lat-input');
    const settingsLonInput = document.getElementById('settings-lon-input');
    const settingsCitySelect = document.getElementById('settings-city-select');
    const settingsCustomCoords = document.getElementById('settings-custom-coords');
    
    if (settingsLatInput) settingsLatInput.value = roundedLat;
    if (settingsLonInput) settingsLonInput.value = roundedLon;
    if (settingsCitySelect) settingsCitySelect.value = 'custom';
    if (settingsCustomCoords) settingsCustomCoords.style.display = 'flex';
    
    renderSettingsPageMap();
  } else {
    // Calendar page mode - update state
    state.lat = roundedLat;
    state.lon = roundedLon;
    state.city = ''; // Clear city selection
    
    // Update main inputs
    document.getElementById('lat-input').value = state.lat;
    document.getElementById('lon-input').value = state.lon;
    document.getElementById('city-select').value = '';
    
    // Show custom coords on main page
    const customCoords = document.getElementById('custom-coords');
    if (customCoords) customCoords.style.display = 'block';
    
    // Save and regenerate (preserve current month for location changes)
    saveState();
    generateCalendar({ preserveMonth: true });
    updateURL();
    
    // Update the settings maps (both containers)
    renderSettingsMap();
    refreshDayDetailIfVisible();
  }
}

function useCurrentLocation() {
  const btn = document.querySelector('.location-btn');
  const originalText = btn.textContent;
  
  if (!navigator.geolocation) {
    alert('Geolocation is not supported by your browser');
    return;
  }
  
  btn.textContent = 'ğŸ“ Getting location...';
  btn.disabled = true;
  
  navigator.geolocation.getCurrentPosition(
    function(position) {
      // Success
      state.lat = Math.round(position.coords.latitude * 10000) / 10000;
      state.lon = Math.round(position.coords.longitude * 10000) / 10000;
      state.city = ''; // Clear city selection
      
      document.getElementById('lat-input').value = state.lat;
      document.getElementById('lon-input').value = state.lon;
      document.getElementById('city-select').value = '';
      document.getElementById('custom-coords').style.display = 'block';
      
      updateProfileButtons();  // Check if settings match a profile
      saveState();
      generateCalendar({ preserveMonth: true });
      updateURL();
      renderSettingsMap();
      refreshDayDetailIfVisible();
      
      btn.textContent = 'âœ“ Location set!';
      setTimeout(() => {
        btn.textContent = originalText;
        btn.disabled = false;
      }, 2000);
    },
    function(error) {
      // Error
      let message = 'Unable to get location';
      switch(error.code) {
        case error.PERMISSION_DENIED:
          message = 'Location access denied. Please enable location permissions.';
          break;
        case error.POSITION_UNAVAILABLE:
          message = 'Location information unavailable.';
          break;
        case error.TIMEOUT:
          message = 'Location request timed out.';
          break;
      }
      alert(message);
      btn.textContent = originalText;
      btn.disabled = false;
    },
    {
      enableHighAccuracy: false,
      timeout: 10000,
      maximumAge: 300000 // Cache for 5 minutes
    }
  );
}

document.getElementById('city-select').addEventListener('change', function() {
  const customCoords = document.getElementById('custom-coords');
  
  if (this.value === '') {
    // Custom selected - show coordinate inputs
    customCoords.style.display = 'block';
    state.city = '';
    return;
  }
  
  if (this.value) {
    customCoords.style.display = 'none';
    const [lat, lon] = this.value.split(',').map(Number);
    state.lat = lat;
    state.lon = lon;
    state.city = this.value;
    saveState();
    updateUI();
    generateCalendar({ preserveMonth: true });
    updateURL();
    renderSettingsMap();
    refreshDayDetailIfVisible();
  }
});

// Settings page city select handler
document.getElementById('settings-city-select').addEventListener('change', function() {
  // Don't allow changes on preset profiles
  const profileId = editingProfileId || state.selectedProfile;
  if (PRESET_PROFILES[profileId]) return;
  
  const customCoords = document.getElementById('settings-custom-coords');
  
  if (this.value === 'current') {
    // Use geolocation
    useCurrentLocationFromSettings();
    return;
  }
  
  if (this.value === 'custom') {
    customCoords.style.display = 'flex';
    state.city = '';
    return;
  }
  
  if (this.value) {
    customCoords.style.display = 'none';
    const [lat, lon] = this.value.split(',').map(Number);
    
    // Profile editor only updates the profile's location, not state
    if (!PRESET_PROFILES[profileId] && PROFILES[profileId]) {
      PROFILES[profileId].lat = lat;
      PROFILES[profileId].lon = lon;
      PROFILES[profileId].city = this.value;
      saveCustomProfiles();
    }
    
    renderSettingsPageMap();
  }
});

// Settings page custom coordinate inputs
document.getElementById('settings-lat-input').addEventListener('change', function() {
  // Don't allow changes on preset profiles
  const profileId = editingProfileId || state.selectedProfile;
  if (PRESET_PROFILES[profileId]) return;
  
  const lat = parseFloat(this.value);
  
  // Profile editor only updates the profile's location, not state
  if (PROFILES[profileId]) {
    PROFILES[profileId].lat = lat;
    PROFILES[profileId].city = '';
    saveCustomProfiles();
  }
  
  renderSettingsPageMap();
});

document.getElementById('settings-lon-input').addEventListener('change', function() {
  // Don't allow changes on preset profiles
  const profileId = editingProfileId || state.selectedProfile;
  if (PRESET_PROFILES[profileId]) return;
  
  const lon = parseFloat(this.value);
  
  // Profile editor only updates the profile's location, not state
  if (PROFILES[profileId]) {
    PROFILES[profileId].lon = lon;
    PROFILES[profileId].city = '';
    saveCustomProfiles();
  }
  
  renderSettingsPageMap();
});

function useCurrentLocationFromSettings() {
  const select = document.getElementById('settings-city-select');
  const profileId = editingProfileId || state.selectedProfile;
  
  // Don't allow changes on preset profiles
  if (PRESET_PROFILES[profileId]) return;
  
  if (!navigator.geolocation) {
    alert('Geolocation is not supported by your browser');
    // Reset to first city option
    select.value = '31.7683,35.2137';
    return;
  }
  
  navigator.geolocation.getCurrentPosition(
    function(position) {
      const lat = Math.round(position.coords.latitude * 10000) / 10000;
      const lon = Math.round(position.coords.longitude * 10000) / 10000;
      
      // Profile editor only updates the profile's location, not state
      if (PROFILES[profileId]) {
        PROFILES[profileId].lat = lat;
        PROFILES[profileId].lon = lon;
        PROFILES[profileId].city = '';
        saveCustomProfiles();
      }
      
      // Update settings inputs to show the detected location
      document.getElementById('settings-lat-input').value = lat;
      document.getElementById('settings-lon-input').value = lon;
      
      // Show custom coordinates with the detected location
      select.value = 'custom';
      document.getElementById('settings-custom-coords').style.display = 'flex';
      
      renderSettingsPageMap();
    },
    function(error) {
      alert('Unable to get your location. Please select a city or enter coordinates manually.');
      // Reset to first city option
      select.value = '31.7683,35.2137';
    },
    { timeout: 10000, enableHighAccuracy: true }
  );
}

// Auto-regenerate when inputs change
function regenerateAndUpdateURL() {
  generateCalendar();
  updateURL();
}
document.getElementById('year-input').addEventListener('change', regenerateAndUpdateURL);
document.getElementById('moon-phase-select').addEventListener('change', regenerateAndUpdateURL);
document.getElementById('lat-input').addEventListener('change', function() {
  state.city = ''; // Clear city selection when manually editing coordinates
  generateCalendar({ preserveMonth: true });
  updateURL();
  refreshDayDetailIfVisible();
});
document.getElementById('lon-input').addEventListener('change', function() {
  state.city = ''; // Clear city selection when manually editing coordinates
  generateCalendar({ preserveMonth: true });
  updateURL();
  refreshDayDetailIfVisible();
});

function changeYear(delta) {
  state.year += delta;
  state.highlightedLunarDay = 1;  // Default to day 1
  state.selectedTimestamp = null;
  updateUI();
  generateCalendar();
  updateURL();
}

function addDaysToDate(direction) {
  const dateInput = document.getElementById('goto-date').value;
  const daysValue = parseInt(document.getElementById('add-days').value);
  
  if (!dateInput) {
    alert('Please select a date first');
    return;
  }
  
  if (isNaN(daysValue) || daysValue <= 0) {
    alert('Please enter a positive number of days');
    return;
  }
  
  const daysToAdd = daysValue * direction; // direction: 1 = forward, -1 = backward
  
  // Parse current datetime as local time at location, get UTC timestamp
  const utcTimestamp = parseDatetimeLocal(dateInput);
  // Add days in milliseconds
  const newTimestamp = utcTimestamp + daysToAdd * 24 * 60 * 60 * 1000;
  
  // Update the datetime input with new local time
  document.getElementById('goto-date').value = formatLocalDatetime(newTimestamp);
  
  // Jump to the new date
  jumpToDate();
}

function jumpToDate() {
  const dateInput = document.getElementById('goto-date').value;
  
  // For ancient dates, dateInput will be empty - use selectedTimestamp
  let utcTimestamp;
  if (dateInput) {
    utcTimestamp = parseDatetimeLocal(dateInput);
  } else if (state.selectedTimestamp) {
    utcTimestamp = state.selectedTimestamp;
  } else {
    alert('Please enter a date');
    return;
  }
  
  const targetDate = new Date(utcTimestamp);
  const targetYear = targetDate.getUTCFullYear();
  
  // Helper function to search in current lunar months
  function searchInCurrentMonths() {
    for (let m = 0; m < state.lunarMonths.length; m++) {
      const month = state.lunarMonths[m];
      for (let d = 0; d < month.days.length; d++) {
        const day = month.days[d];
        if (day.gregorianDate.toDateString() === targetDate.toDateString()) {
          return { month: m, dayIndex: d };
        }
      }
    }
    return null;
  }
  
  // First try current lunar months
  let found = searchInCurrentMonths();
  
  // If not found, try different lunar years
  // Lunar years span ~March to ~March, so we need to try year-1, year, and year+1
  if (!found) {
    const yearsToTry = [targetYear, targetYear - 1, targetYear + 1];
    
    for (const lunarYear of yearsToTry) {
      if (lunarYear === state.year) continue; // Already tried
      
      state.year = lunarYear;
      updateUI();
      generateCalendar(); // This also updates dateline overview
      
      found = searchInCurrentMonths();
      if (found) break;
    }
  }
  
  if (found) {
    state.currentMonthIndex = found.month;
    const dayObj = state.lunarMonths[found.month].days[found.dayIndex];
    state.highlightedLunarDay = dayObj.lunarDay;
    // Store the actual timestamp from the input (preserves time)
    state.selectedTimestamp = targetDate.getTime();
    renderMonth(state.lunarMonths[state.currentMonthIndex]);
    updateMonthButtons();
    updateURL();
    showDayDetail(dayObj, state.lunarMonths[found.month]);
  } else {
    alert('Date not found in lunar calendar. The Astronomy library may not support this date range.');
  }
}

function selectMonth(index) {
  // Preserve the current day number when switching months
  const previousDay = state.highlightedLunarDay || 1;
  state.currentMonthIndex = index;
  
  // Carry day selection to new month, clamping to valid range
  const newMonth = state.lunarMonths[index];
  const maxDay = newMonth.days.length;
  state.highlightedLunarDay = Math.min(previousDay, maxDay);
  
  // Update selectedTimestamp for the new month's day
  const dayObj = newMonth.days.find(d => d.lunarDay === state.highlightedLunarDay);
  if (dayObj) {
    state.selectedTimestamp = getSunriseTimestamp(dayObj.gregorianDate);
    document.getElementById('goto-date').value = formatLocalDatetime(state.selectedTimestamp);
  }
  
  renderMonth(state.lunarMonths[state.currentMonthIndex]);
  updateMonthButtons();
  updateURL();
  
  // Show day detail for the carried-over day
  if (dayObj) {
    showDayDetail(dayObj, newMonth);
  }
}

function navigateMonth(direction) {
  const newIndex = state.currentMonthIndex + direction;
  const previousDay = state.highlightedLunarDay || 1;
  
  if (newIndex < 0) {
    // Go to previous year, last month
    state.year -= 1;
    updateUI();
    generateCalendar();
    // Jump to last month of previous year
    state.currentMonthIndex = state.lunarMonths.length - 1;
    
    // Preserve day selection, clamped to valid range
    const newMonth = state.lunarMonths[state.currentMonthIndex];
    const maxDay = newMonth.days.length;
    state.highlightedLunarDay = Math.min(previousDay, maxDay);
    const dayObj = newMonth.days.find(d => d.lunarDay === state.highlightedLunarDay);
    if (dayObj) {
      state.selectedTimestamp = getSunriseTimestamp(dayObj.gregorianDate);
      document.getElementById('goto-date').value = formatLocalDatetime(state.selectedTimestamp);
      showDayDetail(dayObj, newMonth);
    }
    
    renderMonth(state.lunarMonths[state.currentMonthIndex]);
    updateMonthButtons();
    updateURL();
  } else if (newIndex >= state.lunarMonths.length) {
    // Go to next year, first month
    state.year += 1;
    updateUI();
    generateCalendar();
    // Already at first month (generateCalendar sets to 0)
    
    // Preserve day selection, clamped to valid range
    const newMonth = state.lunarMonths[state.currentMonthIndex];
    const maxDay = newMonth.days.length;
    state.highlightedLunarDay = Math.min(previousDay, maxDay);
    const dayObj = newMonth.days.find(d => d.lunarDay === state.highlightedLunarDay);
    if (dayObj) {
      state.selectedTimestamp = getSunriseTimestamp(dayObj.gregorianDate);
      document.getElementById('goto-date').value = formatLocalDatetime(state.selectedTimestamp);
      showDayDetail(dayObj, newMonth);
    }
    
    renderMonth(state.lunarMonths[state.currentMonthIndex]);
    updateURL();
  } else {
    // Normal month navigation within same year
    selectMonth(newIndex);
  }
}

// updateMonthButtons moved to calendar-core.js
// renderMonthButtons moved to calendar-core.js

// formatYear moved to calendar-core.js
// GREGORIAN_REFORM_DATE moved to calendar-core.js

// Convert a JavaScript Date (which is proleptic Gregorian) to Julian calendar date
// Returns { year, month, day } in Julian calendar
function gregorianToJulian(date) {
  // JavaScript dates are in proleptic Gregorian calendar
  // We need to convert to Julian for dates before 1582-10-15
  const year = date.getFullYear();
  const month = date.getMonth(); // 0-indexed
  const day = date.getDate();
  
  // Calculate Julian Day Number from Gregorian date
  const a = Math.floor((14 - (month + 1)) / 12);
  const y = year + 4800 - a;
  const m = (month + 1) + 12 * a - 3;
  
  // Julian Day Number for Gregorian calendar
  const jdn = day + Math.floor((153 * m + 2) / 5) + 365 * y + Math.floor(y / 4) - Math.floor(y / 100) + Math.floor(y / 400) - 32045;
  
  // Convert JDN back to Julian calendar date
  const c = jdn + 32082;
  const d = Math.floor((4 * c + 3) / 1461);
  const e = c - Math.floor(1461 * d / 4);
  const n = Math.floor((5 * e + 2) / 153);
  
  const julianDay = e - Math.floor((153 * n + 2) / 5) + 1;
  const julianMonth = n + 3 - 12 * Math.floor(n / 10); // 1-indexed
  const julianYear = d - 4800 + Math.floor(n / 10);
  
  return { year: julianYear, month: julianMonth - 1, day: julianDay }; // month 0-indexed to match JS
}

// isBeforeGregorianReform moved to calendar-core.js

// Calculate Julian Day Number from Julian calendar date (year, month 0-indexed, day)
function julianCalendarToJDN(year, month, day) {
  // Convert 0-indexed month to 1-indexed
  const m = month + 1;
  const a = Math.floor((14 - m) / 12);
  const y = year + 4800 - a;
  const mm = m + 12 * a - 3;
  // Julian calendar formula
  return day + Math.floor((153 * mm + 2) / 5) + 365 * y + Math.floor(y / 4) - 32083;
}

// Calculate day of week from Julian Day Number (0 = Sunday, 6 = Saturday)
function jdnToWeekday(jdn) {
  return (jdn + 1) % 7;
}

// getCorrectWeekday moved to astronomy-utils.js

// Get formatted date components (handles Julian calendar for pre-1582 dates)
// Note: Dates from _jdToDate() already have Julian calendar components stored,
// so we just use getFullYear/getMonth/getDate directly - no conversion needed.
function getFormattedDateParts(date) {
  const weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
  const months = ['January', 'February', 'March', 'April', 'May', 'June', 
                  'July', 'August', 'September', 'October', 'November', 'December'];
  const shortMonths = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  
  // For ancient dates, use UTC methods to avoid timezone issues
  // The astronomy engine's _jdToDate already stores Julian calendar values
  const year = date.getUTCFullYear();
  const month = date.getUTCMonth();
  const day = date.getUTCDate();
  const isJulian = isBeforeGregorianReform(date);
  
  // Calculate weekday from Julian Day Number for correct result
  // (JavaScript's getUTCDay() uses proleptic Gregorian internally, which is wrong for Julian dates)
  let weekday;
  if (isJulian) {
    const jdn = julianCalendarToJDN(year, month, day);
    weekday = jdnToWeekday(jdn);
  } else {
    weekday = date.getUTCDay();
  }
  
  // Year string: only BC suffix, never AD
  const yearStr = year <= 0 ? `${Math.abs(year - 1)} BC` : `${year}`;
  
  return {
    year,
    yearStr,
    month,
    day,
    weekday,
    weekdayName: weekdays[weekday],
    monthName: months[month],
    shortMonthName: shortMonths[month],
    isJulian,
    calendarSuffix: isJulian ? ' (Julian)' : ''
  };
}

// Format a date for display in day detail panel: "Monday, January 1, 2025"
function formatDisplayDate(date) {
  const parts = getFormattedDateParts(date);
  return `${parts.weekdayName}, ${parts.monthName} ${parts.day}, ${parts.yearStr}${parts.calendarSuffix}`;
}

function getMoonIcon() {
  if (state.moonPhase === 'full') return 'ğŸŒ•';
  if (state.moonPhase === 'dark') return 'ğŸŒ‘';
  if (state.moonPhase === 'crescent') return 'ğŸŒ’';
  return 'ğŸŒ•';
}

// Get the moon phase icon for a specific date, but ONLY if a quarter phase
// (new moon 0Â°, first quarter 90Â°, full moon 180Â°, last quarter 270Â°) occurs during this lunar day
// Uses the calendar's day start/end definition (sunset, sunrise, etc.) rather than UTC midnight
function getMoonPhaseIconForDate(date) {
  try {
    // Get the lunar day start time for this date based on current calendar config
    const dayStartTs = getDayStartTime(date);
    
    // The lunar day runs from this day start to the next day's start
    // Calculate next day's start by getting the day start for tomorrow's Gregorian date
    const tomorrowGregorian = new Date(date.getTime());
    tomorrowGregorian.setUTCDate(tomorrowGregorian.getUTCDate() + 1);
    const dayEndTs = getDayStartTime(tomorrowGregorian);
    
    const startOfDay = new Date(dayStartTs);
    const endOfDay = new Date(dayEndTs);
    
    const elongStart = getElongationForDate(startOfDay);
    const elongEnd = getElongationForDate(endOfDay);
    
    if (elongStart === null || elongEnd === null) return '';
    
    // Check each of the 4 major quarters
    const quarters = [
      { angle: 0, icon: 'ğŸŒ‘' },    // New Moon
      { angle: 90, icon: 'ğŸŒ“' },   // First Quarter
      { angle: 180, icon: 'ğŸŒ•' },  // Full Moon
      { angle: 270, icon: 'ğŸŒ—' }   // Last Quarter
    ];
    
    for (const quarter of quarters) {
      if (phaseOccursDuringDay(elongStart, elongEnd, quarter.angle)) {
        return quarter.icon;
      }
    }
    
    return ''; // No quarter phase on this day
  } catch (err) {
    console.warn('Error calculating moon phase:', err);
    return '';
  }
}

// Check if a phase angle is crossed between two elongation values
function phaseOccursDuringDay(elongStart, elongEnd, targetAngle) {
  // Elongation increases over time (moon moves ~12Â° per day relative to sun)
  // Handle the 360Â°â†’0Â° wraparound for new moon
  
  if (targetAngle === 0) {
    // New moon: elongation wraps from ~350+ to ~10-
    // This happens when elongStart is high (>300) and elongEnd is lower OR 
    // when elongStart > 350 and elongEnd is small
    if (elongStart > 300 && elongEnd < elongStart) {
      // Could be wraparound or normal decrease (shouldn't normally decrease much)
      // If elongEnd is small (<60), it wrapped around
      if (elongEnd < 60) return true;
    }
    // Also check if we're very close to 0 on either end
    if (elongStart > 350 || elongEnd < 10) {
      if (elongStart > 350 && elongEnd < 60) return true;
    }
  } else {
    // For other phases (90, 180, 270): check if targetAngle is between start and end
    // Normal case: elongation increases
    if (elongStart <= targetAngle && elongEnd >= targetAngle) return true;
    
    // Edge case: day spans the 360â†’0 boundary but target is not 0
    // In this case, elongStart > elongEnd due to wraparound
    if (elongStart > elongEnd) {
      // Wrapped around - check both segments
      if (elongStart <= targetAngle || elongEnd >= targetAngle) return true;
    }
  }
  
  return false;
}

// Get moon-sun elongation for a date
function getElongationForDate(date) {
  // For Swiss Ephemeris, use the elongation function directly
  if (AstroEngines.swissEphemeris.isLoaded && AstroEngines.swissEphemeris._dateToJD) {
    const jd = AstroEngines.swissEphemeris._dateToJD(date);
    const elongation = AstroEngines.swissEphemeris._getMoonSunElongation(jd);
    if (elongation !== null) return elongation;
  }
  
  // Fallback: use astronomy-engine
  try {
    const engine = getAstroEngine();
    const observer = engine.createObserver(state.lat, state.lon, 0);
    const sunEq = engine.getEquator('sun', date, observer);
    const moonEq = engine.getEquator('moon', date, observer);
    
    if (sunEq && moonEq) {
      let sunRA = sunEq.ra * 15;
      let moonRA = moonEq.ra * 15;
      let elongation = moonRA - sunRA;
      while (elongation < 0) elongation += 360;
      while (elongation >= 360) elongation -= 360;
      return elongation;
    }
  } catch (err) {}
  
  return null;
}

// Calculate angular distance between two angles (0-360), handling wraparound
function angularDistance(a, b) {
  let diff = Math.abs(a - b);
  if (diff > 180) diff = 360 - diff;
  return diff;
}

function getMoonLabel() {
  if (state.moonPhase === 'full') return 'Full Moon';
  if (state.moonPhase === 'dark') return 'Dark Moon';
  if (state.moonPhase === 'crescent') return 'Crescent';
  return 'New Moon';
}

// Get dynamic description for Renewed Moon based on current moon phase setting
function getRenewedMoonDescription() {
  const dayStartLabel = getDayStartLabel();
  const isCrescentSunset = state.moonPhase === 'crescent' && 
                           state.dayStartTime === 'evening' && 
                           state.dayStartAngle === 0;
  
  if (state.moonPhase === 'full') {
    return `Month begins at ${dayStartLabel} after full moon`;
  } else if (state.moonPhase === 'dark') {
    return `Month begins at ${dayStartLabel} after dark moon (conjunction)`;
  } else if (state.moonPhase === 'crescent') {
    if (isCrescentSunset) {
      return 'Month begins at sunset when first crescent is sighted';
    }
    return `Month begins at ${dayStartLabel} after crescent sighting`;
  }
  return 'Beginning of the month';
}

// generateCalendar moved to calendar-core.js

// findMoonEvents moved to calendar-core.js

// getLocalDateFromUTC moved to astronomy-utils.js

// Calculate what lunar day a timestamp falls on for a given profile's settings
// Returns { day: number, month: number } or null if unable to calculate
function getLunarDayForTimestamp(timestamp, profile) {
  try {
    const date = new Date(timestamp);
    let year = date.getFullYear();
    
    // Temporarily store current state and apply profile settings
    const savedState = {
      moonPhase: state.moonPhase,
      dayStartTime: state.dayStartTime,
      dayStartAngle: state.dayStartAngle,
      yearStartRule: state.yearStartRule,
      crescentThreshold: state.crescentThreshold,
      lat: state.lat,
      lon: state.lon
    };
    
    // Apply profile settings temporarily (with defaults for undefined values)
    state.moonPhase = profile.moonPhase || 'full';
    state.dayStartTime = profile.dayStartTime || 'morning';
    state.dayStartAngle = profile.dayStartAngle ?? 12;
    state.yearStartRule = profile.yearStartRule || 'equinox';
    state.crescentThreshold = profile.crescentThreshold ?? 18;
    state.lat = profile.lat ?? 31.7683;
    state.lon = profile.lon ?? 35.2137;
    
    const engine = getAstroEngine();
    
    // Check if timestamp is before this year's spring equinox - if so, use previous year
    const thisYearEquinox = engine.getSeasons(year).mar_equinox.date;
    if (date < thisYearEquinox) {
      year = year - 1;
    }
    
    // Find moon events for the year (need events spanning into next year)
    const moonEvents = findMoonEvents(year, profile.moonPhase);
    if (!moonEvents || moonEvents.length === 0) {
      Object.assign(state, savedState);
      return null;
    }
    
    // Find the spring equinox for the lunar year
    const springEquinox = engine.getSeasons(year).mar_equinox.date;
    
    // Find the first moon event on or after the spring equinox for Nisan
    let nissanMoon = null;
    for (const event of moonEvents) {
      if (event >= springEquinox) {
        nissanMoon = event;
        break;
      }
    }
    
    // If no moon event after equinox, check the last one before
    if (!nissanMoon && moonEvents.length > 0) {
      for (let i = moonEvents.length - 1; i >= 0; i--) {
        if (moonEvents[i] < springEquinox) {
          nissanMoon = moonEvents[i];
          break;
        }
      }
    }
    
    if (!nissanMoon) {
      Object.assign(state, savedState);
      return null;
    }
    
    // Build simplified lunar months to find the day
    const observerLon = profile.lon;
    let currentMoonIdx = moonEvents.findIndex(m => Math.abs(m.getTime() - nissanMoon.getTime()) < 1000);
    if (currentMoonIdx === -1) currentMoonIdx = moonEvents.findIndex(m => m >= nissanMoon);
    
    // Iterate through months to find where the timestamp falls
    for (let m = 0; m < 13 && currentMoonIdx < moonEvents.length - 1; m++) {
      const moonEvent = moonEvents[currentMoonIdx];
      const nextMoonEvent = moonEvents[currentMoonIdx + 1];
      
      // Calculate month start date (similar to buildLunarMonths)
      const moonEventLocalDate = new Date(moonEvent.getTime());
      const monthStartDate = new Date(Date.UTC(
        moonEventLocalDate.getUTCFullYear(),
        moonEventLocalDate.getUTCMonth(),
        moonEventLocalDate.getUTCDate(),
        0, 0, 0
      ));
      
      // Apply day offset based on settings
      if ((profile.moonPhase === 'dark' || profile.moonPhase === 'full' || profile.moonPhase === 'crescent') && profile.dayStartTime === 'evening') {
        const sunsetOnMoonDate = getSunsetTimestamp(moonEventLocalDate);
        if (sunsetOnMoonDate != null) {
          const moonEventLocalTime = moonEvent.getTime() + (observerLon / 15) * 60 * 60 * 1000;
          const sunsetLocalTime = sunsetOnMoonDate + (observerLon / 15) * 60 * 60 * 1000;
          if (moonEventLocalTime > sunsetLocalTime) {
            monthStartDate.setUTCDate(monthStartDate.getUTCDate() + 1);
          }
        }
      }
      
      // Calculate next month start
      const nextMoonEventLocalDate = new Date(nextMoonEvent.getTime());
      const nextMonthStart = new Date(Date.UTC(
        nextMoonEventLocalDate.getUTCFullYear(),
        nextMoonEventLocalDate.getUTCMonth(),
        nextMoonEventLocalDate.getUTCDate(),
        0, 0, 0
      ));
      
      if ((profile.moonPhase === 'dark' || profile.moonPhase === 'full' || profile.moonPhase === 'crescent') && profile.dayStartTime === 'evening') {
        const sunsetOnNextMoonDate = getSunsetTimestamp(nextMoonEventLocalDate);
        if (sunsetOnNextMoonDate != null) {
          const nextMoonEventLocalTime = nextMoonEvent.getTime() + (observerLon / 15) * 60 * 60 * 1000;
          const nextSunsetLocalTime = sunsetOnNextMoonDate + (observerLon / 15) * 60 * 60 * 1000;
          if (nextMoonEventLocalTime > nextSunsetLocalTime) {
            nextMonthStart.setUTCDate(nextMonthStart.getUTCDate() + 1);
          }
        }
      }
      
      // Check if timestamp falls in this month
      const timestampDate = new Date(timestamp);
      const timestampDayStart = new Date(Date.UTC(
        timestampDate.getUTCFullYear(),
        timestampDate.getUTCMonth(),
        timestampDate.getUTCDate(),
        0, 0, 0
      ));
      
      if (timestampDayStart >= monthStartDate && timestampDayStart < nextMonthStart) {
        // Found the month - calculate the day
        const dayOffset = Math.floor((timestampDayStart - monthStartDate) / (24 * 60 * 60 * 1000));
        const lunarDay = dayOffset + 1;
        
        // Restore state
        Object.assign(state, savedState);
        return { day: lunarDay, month: m + 1 };
      }
      
      currentMoonIdx++;
    }
    
    // Restore state
    Object.assign(state, savedState);
    return null;
  } catch (e) {
    console.warn('Error calculating lunar day for profile:', e);
    return null;
  }
}

// buildLunarMonths moved to calendar-core.js

// formatShortDate moved to calendar-core.js
// formatFullDate moved to calendar-core.js

// Calculate the "dateline" longitude - the first place to start the new day
// At any UTC time H, solar noon is at longitude = (12 - H) * 15 degrees
// Sunrise occurs 90Â° to the WEST of the subsolar point (6 hours earlier in local time)
// Sunset occurs 90Â° to the EAST of the subsolar point (6 hours later in local time)
// The dateline is where the day start event is occurring at the moment of the moon event
// This is the first place on Earth to begin a new day
function calculateDatelineLongitude(moonEventDate, moonPhase) {
  // Get UTC hours as decimal
  const utcHours = moonEventDate.getUTCHours() + moonEventDate.getUTCMinutes() / 60;
  
  // The subsolar point (where it's local noon) at this UTC time
  // At UTC 12:00, noon is at 0Â° (Greenwich)
  // At UTC 0:00, noon is at 180Â° (International Date Line)
  const subsolarLon = (12 - utcHours) * 15;
  
  let datelineLon;
  if (state.dayStartTime === 'evening') {
    // Sunset is 90Â° to the EAST of the subsolar point
    // (At any instant, places east of noon are in afternoon/evening)
    datelineLon = subsolarLon + 90;
    // Adjust for twilight angle - evening twilight occurs BEFORE sunset (further east)
    // Roughly 4Â° of longitude per 1Â° of sun angle (varies by latitude)
    datelineLon += state.dayStartAngle * 4;
  } else {
    // Sunrise is 90Â° to the WEST of the subsolar point
    // (At any instant, places west of noon are in morning)
    datelineLon = subsolarLon - 90;
    // Adjust for twilight angle - morning twilight occurs BEFORE sunrise (further east)
    // For morning, twilight starts earlier, so we add to move east
    datelineLon += state.dayStartAngle * 4;
  }
  
  // Normalize to -180 to 180
  while (datelineLon > 180) datelineLon -= 360;
  while (datelineLon < -180) datelineLon += 360;
  
  return datelineLon;
}

function getDatelineCity(lon) {
  // Find approximate region for the dateline longitude
  if (lon >= 140 || lon < -170) return 'Pacific Ocean (Date Line)';
  if (lon >= 120) return 'Japan / Philippines';
  if (lon >= 100) return 'China / Southeast Asia';
  if (lon >= 70) return 'India / Central Asia';
  if (lon >= 35) return 'Middle East';
  if (lon >= 10) return 'Europe / Africa';
  if (lon >= -30) return 'Atlantic Ocean';
  if (lon >= -50) return 'South America (East)';
  if (lon >= -70) return 'South America (West) / Caribbean';
  if (lon >= -85) return 'Americas (Eastern US / Central America)';
  if (lon >= -105) return 'Americas (Central US / Mexico)';
  if (lon >= -120) return 'Americas (West Coast)';
  if (lon >= -150) return 'Alaska / Hawaii';
  return 'Pacific Ocean';
}

// Get the day start event name for display
function getDayStartEventName() {
  if (state.dayStartAngle === 0) {
    return state.dayStartTime === 'evening' ? 'Sunset' : 'Sunrise';
  } else if (state.dayStartAngle === 6) {
    return state.dayStartTime === 'evening' ? 'Civil Dusk' : 'Civil Dawn';
  } else if (state.dayStartAngle === 12) {
    return state.dayStartTime === 'evening' ? 'Nautical Dusk' : 'Nautical Dawn';
  } else if (state.dayStartAngle === 18) {
    return state.dayStartTime === 'evening' ? 'Astronomical Dusk' : 'Astronomical Dawn';
  }
  return state.dayStartTime === 'evening' ? 'Evening Twilight' : 'Morning Twilight';
}

// Get the day start icon for the marker
function getDayStartIcon() {
  return state.dayStartTime === 'evening' ? 'ğŸŒ…' : 'â˜€';
}

function renderDatelineVisualization(moonEventDate, options = {}) {
  const utcHours = moonEventDate.getUTCHours() + moonEventDate.getUTCMinutes() / 60;
  const datelineLon = calculateDatelineLongitude(moonEventDate, state.moonPhase);
  
  // Convert longitude to percentage position (lon -180 = 0%, lon 180 = 100%)
  const position = ((datelineLon + 180) / 360) * 100;
  
  const region = getDatelineCity(datelineLon);
  const lonStr = datelineLon >= 0 
    ? `${Math.abs(datelineLon).toFixed(1)}Â°E` 
    : `${Math.abs(datelineLon).toFixed(1)}Â°W`;
  
  // Format moon event date for display
  const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  const moonDateStr = `${months[moonEventDate.getUTCMonth()]} ${moonEventDate.getUTCDate()}, ${moonEventDate.getUTCFullYear()}`;
  const utcTimeStr = `${Math.floor(utcHours).toString().padStart(2,'0')}:${Math.round((utcHours % 1) * 60).toString().padStart(2,'0')} UTC`;
  
  // Get day start event name and icon based on settings
  const dayStartEvent = getDayStartEventName();
  const dayStartIcon = getDayStartIcon();
  const markerLabel = dayStartEvent.toUpperCase();
  
  // Current location marker position - use provided options or fall back to state
  const currentLat = options.lat ?? state.lat ?? 31.7683;
  const currentLon = options.lon ?? state.lon ?? 35.2137;
  const locX = ((currentLon + 180) / 360) * 100;
  const locY = ((90 - currentLat) / 180) * 100;
  
  // Get location display name (city name or region) - use the provided coordinates
  const locationName = getCurrentLocationName(currentLat, currentLon);
  const coordStr = `${currentLat.toFixed(2)}Â°${currentLat >= 0 ? 'N' : 'S'}, ${Math.abs(currentLon).toFixed(2)}Â°${currentLon >= 0 ? 'E' : 'W'}`;
  // Show city name with coordinates, or just coordinates if it's a timezone region
  const locationDisplay = !locationName.includes('/') 
    ? `${locationName} (${coordStr})`
    : coordStr;
  
  return `
    <div class="dateline-container">
      <div class="dateline-label">${dayStartEvent} line at moment of ${getMoonLabel()} â€” ${moonDateStr} â€” ${utcTimeStr}</div>
      <div class="dateline-map" onclick="handleMapClick(event)">
        <div class="dateline-map-bg">
          <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/23/Blue_Marble_2002.png/1280px-Blue_Marble_2002.png" 
               alt="World Map"
               draggable="false"
               style="user-select: none; -webkit-user-drag: none; pointer-events: none;"
               onerror="this.style.display='none'">
        </div>
        <div class="dateline-marker" style="left: ${position}%">
          <span class="dateline-marker-icon">${dayStartIcon}</span>
          <span class="dateline-marker-label">${markerLabel}</span>
        </div>
        <div class="dateline-location-marker" style="left: ${locX}%; top: ${locY}%" title="${locationName}: ${coordStr}"><div class="dateline-location-pin"></div></div>
      </div>
      <div class="dateline-cities">
        <span>180Â°W</span>
        <span>90Â°W</span>
        <span>0Â°</span>
        <span>90Â°E</span>
        <span>180Â°E</span>
      </div>
      <div class="dateline-info">Day start line: ${lonStr} â€” ${region}</div>
      <div class="dateline-info" style="color: #7ec8e3;">Your location: ${locationDisplay}</div>
      <div class="dateline-click-hint">Click map to change location â€¢ First to reach ${dayStartEvent.toLowerCase()} after ${getMoonLabel()} starts month first</div>
    </div>
  `;
}

function formatMoonDateTime(date) {
  const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
  
  // UTC date and time - use correct weekday calculation for ancient dates
  const utcDay = days[getCorrectWeekday(date)];
  const utcMonth = months[date.getUTCMonth()];
  const utcDate = date.getUTCDate();
  const utcHours = date.getUTCHours().toString().padStart(2, '0');
  const utcMins = date.getUTCMinutes().toString().padStart(2, '0');
  
  // Local date and time
  const localDay = days[date.getDay()];
  const localMonth = months[date.getMonth()];
  const localDate = date.getDate();
  const localHours = date.getHours().toString().padStart(2, '0');
  const localMins = date.getMinutes().toString().padStart(2, '0');
  
  // Get timezone abbreviation
  const tzName = Intl.DateTimeFormat('en-US', { timeZoneName: 'short' }).formatToParts(date)
    .find(part => part.type === 'timeZoneName')?.value || 'Local';
  
  // Check if UTC and local are on different calendar days
  const sameDay = (date.getUTCDate() === date.getDate() && 
                   date.getUTCMonth() === date.getMonth() &&
                   date.getUTCFullYear() === date.getFullYear());
  
  if (sameDay) {
    return `${localDay}, ${localMonth} ${localDate}<br>` +
           `UTC: ${utcHours}:${utcMins}<br>` +
           `${tzName}: ${localHours}:${localMins}`;
  } else {
    // Show both dates when they differ
    return `UTC: ${utcDay}, ${utcMonth} ${utcDate} ${utcHours}:${utcMins}<br>` +
           `${tzName}: ${localDay}, ${localMonth} ${localDate} ${localHours}:${localMins}`;
  }
}

// renderMonth moved to calendar-core.js

// jumpToFeast moved to calendar-core.js
// renderFeastTable moved to calendar-core.js

// Handle browser back/forward buttons
window.addEventListener('popstate', function(event) {
  // Parse the path-based URL
  const urlState = parsePathURL();
  
  if (urlState.view === 'sabbath-tester') {
    // Navigate back to sabbath tester
    const sabbathTesterPage = document.getElementById('sabbath-tester-page');
    const calendarOutput = document.getElementById('calendar-output');
    const dayDetailPanel = document.getElementById('day-detail-panel');
    const exportPage = document.getElementById('export-page');
    
    calendarOutput.style.display = 'none';
    dayDetailPanel.style.display = 'none';
    exportPage.style.display = 'none';
    sabbathTesterPage.style.display = 'block';
    renderSabbathTester();
  } else if (urlState.view === 'feasts') {
    navigateTo('feasts');
  } else {
    // Navigate to calendar with URL state
    const { needsRegenerate, month, day } = applyURLState(urlState);
    if (needsRegenerate) {
      updateUI();
      generateCalendar();
    }
    if (month !== null || day !== null) {
      if (month !== null) state.currentMonthIndex = month - 1;
      if (day !== null) state.highlightedLunarDay = day;
      renderMonth(state.lunarMonths[state.currentMonthIndex]);
      updateMonthButtons();
    }
    navigateTo('calendar');
  }
});

document.addEventListener('DOMContentLoaded', async function() {
  // Clear any lingering overflow classes from previous sessions
  document.body.classList.remove('sabbath-tester-open', 'feasts-open');
  document.documentElement.classList.remove('feasts-open');
  document.body.style.overflow = '';
  
  // Check for redirect path from 404 page (GitHub Pages SPA routing)
  const redirectPath = sessionStorage.getItem('redirectPath');
  if (redirectPath) {
    sessionStorage.removeItem('redirectPath');
    // Replace the current URL with the intended path
    window.history.replaceState({}, '', redirectPath);
  }
  
  // Rebuild profile dropdown with any saved custom profiles
  rebuildProfileDropdown();
  
  // Initialize settings editability (presets are read-only)
  updateSettingsEditability();
  
  // Initialize astronomy engine (loads Swiss Ephemeris WASM)
  await initializeAstroEngine();
  
  // Check if URL has path data or query params - if so, load from URL
  const path = window.location.pathname;
  const hasPathData = path !== '/' && path !== '/index.html';
  const hasQueryData = window.location.search.length > 0;
  
  if (hasPathData || hasQueryData) {
    // URL has state - restore from URL
    updateUI(); // Set UI from localStorage first
    generateCalendar();
    loadFromURL(); // Then override with URL params/path
  } else {
    // No URL data - always jump to today's date on fresh load
    jumpToToday();
    updateURL(); // Set initial URL
  }
  
  // Start live time updates for header display
  updateTimeDisplay();
  startLiveTimeUpdates();
  
  // Show about modal on page load (greeting) - at most once per day, max 3 dismissals
  // Wait for calendar to be fully rendered before showing modal
  setTimeout(() => {
    if (shouldShowAboutModal()) {
      showAboutModal();
    }
  }, 1000);  // Increased delay to ensure calendar is rendered
  
  // Initialize PWA install button
  initInstallButton();
  
  // Event delegation for feast table clicks
  document.getElementById('feast-tbody').addEventListener('click', function(e) {
    const link = e.target.closest('.feast-jump');
    if (link) {
      e.preventDefault();
      const monthIdx = parseInt(link.dataset.month);
      const lunarDay = parseInt(link.dataset.day);
      jumpToFeast(monthIdx, lunarDay);
    }
  });
  
  // Event delegation for calendar day cell clicks - update goto-date input and highlight
  document.getElementById('calendar-output').addEventListener('click', function(e) {
    // Check for day cell click
    const cell = e.target.closest('.day-cell[data-date]');
    if (cell) {
      // Find the lunar day for this cell and store the timestamp
      const lunarDayEl = cell.querySelector('.lunar-day');
      if (lunarDayEl) {
        const lunarDay = parseInt(lunarDayEl.textContent);
        const month = state.lunarMonths[state.currentMonthIndex];
        const dayObj = month.days.find(d => d.lunarDay === lunarDay);
        if (dayObj) {
          // Calculate sunrise time at selected location for this day
          state.selectedTimestamp = getSunriseTimestamp(dayObj.gregorianDate);
          document.getElementById('goto-date').value = formatLocalDatetime(state.selectedTimestamp);
          showDayDetail(dayObj, month);
        }
        state.highlightedLunarDay = lunarDay;
        renderMonth(state.lunarMonths[state.currentMonthIndex]);
        updateURL();
      }
      return;
    }
    
    // Check for new-moon-box (Day 1) click
    const newMoonBox = e.target.closest('.new-moon-box[data-date]');
    if (newMoonBox) {
      const month = state.lunarMonths[state.currentMonthIndex];
      const dayObj = month.days.find(d => d.lunarDay === 1);
      if (dayObj) {
        // Calculate sunrise time at selected location for this day
        state.selectedTimestamp = getSunriseTimestamp(dayObj.gregorianDate);
        document.getElementById('goto-date').value = formatLocalDatetime(state.selectedTimestamp);
        showDayDetail(dayObj, month);
      }
      state.highlightedLunarDay = 1;
      renderMonth(state.lunarMonths[state.currentMonthIndex]);
      updateURL();
    }
  });
});

// Helper function to refresh day detail panel if one is currently shown
function refreshDayDetailIfVisible() {
  if (state.highlightedLunarDay !== null && state.lunarMonths[state.currentMonthIndex]) {
    const month = state.lunarMonths[state.currentMonthIndex];
    const dayObj = month.days.find(d => d.lunarDay === state.highlightedLunarDay);
    if (dayObj) {
      showDayDetail(dayObj, month);
    }
  }
}

// Show the day detail panel with information about the selected day
function showDayDetail(dayObj, month) {
  const panel = document.getElementById('day-detail-panel');
  
  // Populate lunar date
  const ordinal = getOrdinalSuffix(month.monthNumber);
  const lunarDateStr = `Day ${dayObj.lunarDay} of the ${month.monthNumber}${ordinal} Month`;
  panel.querySelector('.day-detail-lunar').textContent = lunarDateStr;
  
  // Populate gregorian/julian date
  const gregDate = dayObj.gregorianDate;
  panel.querySelector('.day-detail-gregorian').textContent = formatDisplayDate(gregDate);
  
  // Populate feasts
  const feastsContainer = panel.querySelector('.day-detail-feasts');
  feastsContainer.innerHTML = '';
  
  if (dayObj.feasts && dayObj.feasts.length > 0) {
    for (const f of dayObj.feasts) {
      const feast = f.feast;
      const dayNum = f.dayNum;
      const nameText = dayNum ? `${feast.name} (Day ${dayNum})` : feast.name;
      
      // Check if this is a Renewed Moon feast and we have moon event data
      let basisHtml = '';
      let stellariumLink = ''; // Initialize for all feasts
      if (feast.name === 'Renewed Moon' && dayObj.lunarDay === 1 && month.moonEvent) {
        const moonEventTime = month.moonEvent;
        const signName = getMoonLabel();
        
        // Format moon event date in a friendly way
        const moonEventDate = new Date(moonEventTime);
        const moonParts = getFormattedDateParts(moonEventDate);
        const dayOfWeek = moonParts.weekdayName;
        const monthName = moonParts.shortMonthName;
        const dayNum = moonParts.day;
        const daySuffix = getOrdinalSuffix(dayNum);
        const year = moonParts.yearStr;
        
        // Format times in observer's local time (based on longitude), not browser timezone
        const moonLocalTime = utcToLocalTime(moonEventDate.getTime(), state.lon);
        const moonTimeStr = `${moonLocalTime.getUTCHours() % 12 || 12}:${String(moonLocalTime.getUTCMinutes()).padStart(2, '0')} ${moonLocalTime.getUTCHours() >= 12 ? 'PM' : 'AM'}`;
        
        const dayStartLabel = getDayStartLabel();
        
        // For dark/full moon mode with evening start, calculate margin to same-day sunset
        // This is the key margin that determines whether a 30th day was added to the prior month
        let sameDaySunset = null;
        let marginToSunsetMs = 0;
        let conjunctionAfterSunset = false;
        
        if ((state.moonPhase === 'dark' || state.moonPhase === 'full') && state.dayStartTime === 'evening') {
          sameDaySunset = getSunsetTimestamp(moonEventDate);
          const sameDaySunrise = getSunriseTimestamp(moonEventDate);
          marginToSunsetMs = sameDaySunset - moonEventTime.getTime();
          
          // Key insight: if the moon event is between midnight and sunrise (early morning),
          // it's actually part of the PREVIOUS evening's "day" in Hebrew calendar terms.
          const moonLocalTime = moonEventTime.getTime() + (state.lon / 15) * 60 * 60 * 1000;
          const sunriseLocalTime = sameDaySunrise + (state.lon / 15) * 60 * 60 * 1000;
          const sunsetLocalTime = sameDaySunset + (state.lon / 15) * 60 * 60 * 1000;
          
          const isBeforeSunrise = moonLocalTime < sunriseLocalTime;
          const isAfterSunset = moonLocalTime > sunsetLocalTime;
          
          // For early morning events (before sunrise), calculate margin from previous sunset
          if (isBeforeSunrise) {
            const prevDate = new Date(moonEventDate.getTime());
            prevDate.setUTCDate(prevDate.getUTCDate() - 1);
            const prevSunset = getSunsetTimestamp(prevDate);
            marginToSunsetMs = prevSunset - moonEventTime.getTime(); // Will be negative (after sunset)
            conjunctionAfterSunset = true;
          } else {
            conjunctionAfterSunset = isAfterSunset;
          }
        }
        
        // Get the day start time (sunset that starts Day 1)
        const dayStartTimestamp = getDayStartTime(dayObj.gregorianDate);
        const dayStartLocalTime = utcToLocalTime(dayStartTimestamp, state.lon);
        const dayStartStr = `${dayStartLocalTime.getUTCHours() % 12 || 12}:${String(dayStartLocalTime.getUTCMinutes()).padStart(2, '0')} ${dayStartLocalTime.getUTCHours() >= 12 ? 'PM' : 'AM'}`;
        
        // For the margin calculation (used for uncertainty warning), use the same-day sunset margin
        // This tells us how close the conjunction was to sunset on that day
        const marginMs = sameDaySunset !== null ? Math.abs(marginToSunsetMs) : Math.abs(dayStartTimestamp - moonEventTime.getTime());
        const marginMins = Math.round(marginMs / (1000 * 60));
        const marginHours = Math.floor(marginMins / 60);
        const marginMinsRemainder = marginMins % 60;
        
        let marginStr = '';
        if (marginHours > 0 && marginMinsRemainder > 0) {
          marginStr = `${marginHours} hour${marginHours > 1 ? 's' : ''} ${marginMinsRemainder} minute${marginMinsRemainder > 1 ? 's' : ''}`;
        } else if (marginHours > 0) {
          marginStr = `${marginHours} hour${marginHours > 1 ? 's' : ''}`;
        } else {
          marginStr = `${marginMinsRemainder} minute${marginMinsRemainder > 1 ? 's' : ''}`;
        }
        
        // Determine tense based on whether the date is past or future
        const now = new Date();
        const isPast = moonEventDate < now;
        const occurVerb = isPast ? 'occurred' : 'will occur';
        
        // Check if this is crescent + sunset mode (special case where crescent day IS Day 1)
        const isCrescentSunset = state.moonPhase === 'crescent' && 
                                 state.dayStartTime === 'evening' && 
                                 state.dayStartAngle === 0;
        
        // Get moon altitude at sunset for crescent mode
        let crescentAltitudeInfo = '';
        if (state.moonPhase === 'crescent') {
          // The moonEventTime is already the "forged" crescent event (conjunction + threshold hours)
          // Calculate the actual conjunction time
          const conjunctionDate = new Date(moonEventTime.getTime() - state.crescentThreshold * 60 * 60 * 1000);
          
          // For crescent visibility, we need to find the sunset when the crescent would be visible
          // This is the first sunset AFTER the conjunction
          let checkDate = new Date(conjunctionDate);
          let sightingData = getMoonAltitudeAtSunset(checkDate);
          
          // If the sunset on conjunction day is BEFORE the conjunction, check next day
          if (sightingData && sightingData.sunsetTime.getTime() < conjunctionDate.getTime()) {
            checkDate = new Date(conjunctionDate.getTime() + 24 * 60 * 60 * 1000);
            sightingData = getMoonAltitudeAtSunset(checkDate);
          }
          
          if (sightingData) {
            const altStr = sightingData.moonAltitude.toFixed(1);
            const elongStr = sightingData.elongation.toFixed(1);
            const sunsetFormatted = formatTimeInObserverTimezone(sightingData.sunsetTime);
            const sunsetDateStr = formatAncientDate(sightingData.sunsetTime);
            const conjTimeFormatted = formatTimeInObserverTimezone(conjunctionDate);
            const conjDateStr = formatAncientDate(conjunctionDate);
            
            // Determine visibility status
            let visibilityNote = '';
            if (sightingData.moonAltitude < 0) {
              visibilityNote = ' (below horizon - not visible)';
            } else if (sightingData.moonAltitude < 5) {
              visibilityNote = ' (very low - difficult to see)';
            } else if (sightingData.elongation < 7) {
              visibilityNote = ' (too close to sun - difficult to see)';
            } else if (sightingData.moonAltitude >= 5 && sightingData.elongation >= 7) {
              visibilityNote = ' (likely visible)';
            }
            
            crescentAltitudeInfo = ` Conjunction: ${conjDateStr} ${conjTimeFormatted.full}. Crescent check on ${sunsetDateStr} at sunset (${sunsetFormatted.time}): moon ${altStr}Â° altitude, ${elongStr}Â° from sun${visibilityNote}.`;
          }
        }
        
        // Generate Stellarium Web link for all moon phases
        // Use an appropriate viewing time based on moon phase and day start
        let stellariumDateTime;
        
        if (state.moonPhase === 'crescent') {
          // For crescent, use sunset time when you'd look for the crescent
          // Same logic as crescent altitude info: first sunset AFTER the conjunction
          const conjunctionForLink = new Date(moonEventTime.getTime() - state.crescentThreshold * 60 * 60 * 1000);
          let checkDateForLink = new Date(conjunctionForLink);
          let moonDataForLink = getMoonAltitudeAtSunset(checkDateForLink);
          
          // If sunset on conjunction day is before conjunction, check next day
          if (moonDataForLink && moonDataForLink.sunsetTime.getTime() < conjunctionForLink.getTime()) {
            checkDateForLink = new Date(conjunctionForLink.getTime() + 24 * 60 * 60 * 1000);
            moonDataForLink = getMoonAltitudeAtSunset(checkDateForLink);
          }
          
          if (moonDataForLink) {
            // Use the sunset time on the crescent sighting day
            stellariumDateTime = moonDataForLink.sunsetTime;
          } else {
            stellariumDateTime = moonEventDate;
          }
        } else if (state.moonPhase === 'full') {
          // For full moon, use early morning before sunrise when moon is visible in west
          // Get the day start time for Day 1
          const day1Date = dayObj.gregorianDate;
          const dayStartTs = getDayStartTime(day1Date);
          stellariumDateTime = new Date(dayStartTs);
        } else {
          // For dark moon (conjunction), use the moon event time
          // Note: dark moon isn't visible, but this shows the sky at that moment
          stellariumDateTime = moonEventDate;
        }
        
        const stellariumDate = stellariumDateTime.toISOString().split('.')[0] + 'Z';
        stellariumLink = `<a href="https://stellarium-web.org/?date=${stellariumDate}&lat=${state.lat}&lng=${state.lon}" target="_blank" rel="noopener" class="stellarium-link"><img src="https://stellarium-web.org/favicon.ico" alt="" onerror="this.style.display='none'">View in Stellarium</a>`;
        
        // Build explanation based on moon phase type and day start settings
        // Stellarium link is stored separately to put in header
        let explanationText = '';
        
        if ((state.moonPhase === 'dark' || state.moonPhase === 'full') && state.dayStartTime === 'evening') {
          // For dark/full moon with evening start, explain the margin to sunset
          const beforeAfterSunset = conjunctionAfterSunset ? 'after' : 'before';
          const moonLabel = state.moonPhase === 'dark' ? 'Dark Moon (conjunction)' : 'Full Moon';
          
          if (conjunctionAfterSunset) {
            // Conjunction was after sunset - a 30th day was added to the prior month
            explanationText = `The ${moonLabel} ${occurVerb} on ${dayOfWeek}, ${monthName} ${dayNum}${daySuffix}, ${year} at ${moonTimeStr}, ` +
              `which was ${marginStr} after sunset (${dayStartStr}). Since it occurred after sunset, ` +
              `the prior month had 30 days, and this month begins at the following evening's sunset.`;
          } else {
            // Conjunction was before sunset - month starts at this sunset
            explanationText = `The ${moonLabel} ${occurVerb} on ${dayOfWeek}, ${monthName} ${dayNum}${daySuffix}, ${year} at ${moonTimeStr}, ` +
              `which was ${marginStr} before sunset. The month begins at sunset (${dayStartStr}).`;
          }
        } else if (state.moonPhase === 'crescent') {
          if (isCrescentSunset) {
            explanationText = `The first visible Crescent Moon ${occurVerb} on ${dayOfWeek}, ${monthName} ${dayNum}${daySuffix}, ${year}. ` +
              `The month begins immediately at sunset following the sighting.${crescentAltitudeInfo}`;
          } else {
            explanationText = `The first visible Crescent Moon ${occurVerb} on ${dayOfWeek}, ${monthName} ${dayNum}${daySuffix}, ${year}. ` +
              `The month begins at the next ${dayStartLabel} (${dayStartStr}).${crescentAltitudeInfo}`;
          }
        } else {
          explanationText = `The ${signName} ${occurVerb} on ${dayOfWeek}, ${monthName} ${dayNum}${daySuffix}, ${year} at ${moonTimeStr}. ` +
            `The month begins at ${dayStartLabel} (${dayStartStr}).`;
        }
        
        // Check if the margin is within Î”T uncertainty for ancient dates
        let uncertaintyWarningHtml = '';
        const eventYear = moonEventDate.getUTCFullYear();
        const uncertaintyHours = AstroEngines.nasaEclipse.getDeltaTUncertainty(eventYear);
        const marginHoursValue = marginMins / 60;
        
        if (uncertaintyHours > 0 && marginHoursValue <= uncertaintyHours) {
          // Get the prior month's day count to determine which direction the error could go
          // Lunar months are always 29 or 30 days
          const currentMonthIdx = state.lunarMonths.findIndex(m => m.monthNumber === month.monthNumber);
          const priorMonth = currentMonthIdx > 0 ? state.lunarMonths[currentMonthIdx - 1] : null;
          const priorMonthDays = priorMonth ? priorMonth.daysInMonth : 29;
          
          let warningExplanation = '';
          if (state.moonPhase === 'dark' || state.moonPhase === 'full') {
            if (priorMonthDays === 29) {
              // Prior month has 29 days - only possible error is it should be 30
              warningExplanation = `If the actual ${getMoonLabel()} occurred later than calculated, ` +
                `it may have been after sunset, meaning the prior month would have had 30 days, ` +
                `and all dates in this month would be one day later than shown.`;
            } else {
              // Prior month has 30 days - only possible error is it should be 29
              warningExplanation = `If the actual ${getMoonLabel()} occurred earlier than calculated, ` +
                `it may have been before sunset, meaning the prior month would have had only 29 days, ` +
                `and all dates in this month would be one day earlier than shown.`;
            }
          } else if (state.moonPhase === 'crescent') {
            warningExplanation = `If the crescent was actually visible earlier or later than calculated, ` +
              `Day 1 could fall on the previous or next day, shifting all dates in this month.`;
          } else {
            warningExplanation = `The actual Day 1 could potentially fall on the previous or next day.`;
          }
          
          uncertaintyWarningHtml = `
            <div class="uncertainty-warning">
              <span class="warning-icon">âš ï¸</span>
              <strong>Date Uncertainty:</strong> The ${marginStr} margin between the ${getMoonLabel()} and sunset 
              is within the estimated Â±${uncertaintyHours} hour uncertainty for astronomical calculations at this date. 
              ${warningExplanation}
            </div>
          `;
        }
        
        basisHtml = `
          <div class="feast-basis">
            ${explanationText}
          </div>
          ${uncertaintyWarningHtml}
        `;
      }
      
      // Generate dynamic description for Renewed Moon based on current moon phase setting
      const feastDescription = feast.name === 'Renewed Moon' 
        ? getRenewedMoonDescription() 
        : feast.description;
      
      // For Renewed Moon on Day 1, include the Stellarium link in the header
      const showStellarium = feast.name === 'Renewed Moon' && dayObj.lunarDay === 1 && stellariumLink;
      
      const item = document.createElement('div');
      item.className = 'day-detail-feast-item';
      item.innerHTML = `
        <div class="day-detail-feast-icon">${feast.icon}</div>
        <div class="day-detail-feast-info">
          <div class="day-detail-feast-header">
            <div class="day-detail-feast-name">${nameText}</div>
            ${showStellarium ? stellariumLink : ''}
          </div>
          <div class="day-detail-feast-desc">${feastDescription}</div>
          ${basisHtml}
          ${feast.chapter ? `<a href="${feast.chapter}" class="day-detail-feast-link">Learn more &rarr;</a>` : ''}
        </div>
      `;
      feastsContainer.appendChild(item);
    }
  } else if (!dayObj.equinox) {
    feastsContainer.innerHTML = '<div class="day-detail-no-feast">No appointed times on this day</div>';
  }
  
  // Add equinox info if this day has the spring equinox
  if (dayObj.equinox) {
    const equinoxDate = dayObj.equinox.date;
    const eqParts = getFormattedDateParts(equinoxDate);
    const dayOfWeek = eqParts.weekdayName;
    const monthName = eqParts.monthName;
    const dayNum = eqParts.day;
    const daySuffix = getOrdinalSuffix(dayNum);
    const year = eqParts.yearStr;
    const timeStr = equinoxDate.toLocaleTimeString('en-US', { 
      hour: 'numeric', minute: '2-digit', hour12: true 
    });
    
    const now = new Date();
    const isPast = equinoxDate < now;
    const verb = isPast ? 'occurred' : 'will occur';
    
    const item = document.createElement('div');
    item.className = 'day-detail-feast-item';
    item.innerHTML = `
      <div class="day-detail-feast-icon">â˜€ï¸âš–ï¸</div>
      <div class="day-detail-feast-info">
        <div class="day-detail-feast-name">Spring Equinox</div>
        <div class="day-detail-feast-desc">The moment when day and night are equal in length, marking the astronomical beginning of spring.</div>
        <div class="feast-basis">
          The Spring Equinox ${verb} on ${dayOfWeek}, ${monthName} ${dayNum}${daySuffix}, ${year} at ${timeStr}.
        </div>
        <a href="/chapters/08-when-does-the-year-start/" class="day-detail-feast-link">Learn more &rarr;</a>
      </div>
    `;
    feastsContainer.appendChild(item);
  }
  
  // Add blood moon (lunar eclipse) info if this day has one
  if (dayObj.isBloodMoon) {
    const bloodMoonDate = dayObj.gregorianDate;
    const bmParts = getFormattedDateParts(bloodMoonDate);
    const dayOfWeek = bmParts.weekdayName;
    const monthName = bmParts.monthName;
    const dayNum = bmParts.day;
    const daySuffix = getOrdinalSuffix(dayNum);
    const year = bmParts.yearStr;
    
    const now = new Date();
    const isPast = bloodMoonDate < now;
    const verb = isPast ? 'occurred' : 'will occur';
    
    // Get the exact eclipse time for Stellarium link
    const eclipseTime = AstroEngines.nasaEclipse.getLunarEclipseTime(dayObj.gregorianDate);
    let eclipseTimeStr = '';
    let stellariumBloodMoonLink = '';
    if (eclipseTime) {
      const eclipseFormatted = formatTimeInObserverTimezone(eclipseTime);
      eclipseTimeStr = ` at ${eclipseFormatted.full}`;
      const stellariumDate = eclipseTime.toISOString().split('.')[0] + 'Z';
      stellariumBloodMoonLink = `<a href="https://stellarium-web.org/?date=${stellariumDate}&lat=${state.lat}&lng=${state.lon}" target="_blank" rel="noopener" class="stellarium-link"><img src="https://stellarium-web.org/favicon.ico" alt="" onerror="this.style.display='none'">View in Stellarium</a>`;
    }
    
    const item = document.createElement('div');
    item.className = 'day-detail-feast-item';
    item.innerHTML = `
      <div class="day-detail-feast-icon blood-moon-icon">ğŸŒ•</div>
      <div class="day-detail-feast-info">
        <div class="day-detail-feast-header">
          <div class="day-detail-feast-name" style="color: #ff6b6b;">Blood Moon (Total Lunar Eclipse)</div>
          ${stellariumBloodMoonLink}
        </div>
        <div class="day-detail-feast-desc">A total lunar eclipse occurs when the Earth passes between the Sun and Moon, 
          casting Earth's shadow on the lunar surface. The Moon appears deep red due to sunlight filtered through Earth's atmosphere.</div>
        <div class="feast-basis">
          A total lunar eclipse ${verb} on ${dayOfWeek}, ${monthName} ${dayNum}${daySuffix}, ${year}${eclipseTimeStr}. 
          In Scripture, blood moons are often associated with significant prophetic events (Joel 2:31, Acts 2:20, Revelation 6:12).
        </div>
      </div>
    `;
    feastsContainer.appendChild(item);
  }
  
  // Add uncertainty warning for any uncertain day
  if (dayObj.isUncertain && month.dateUncertainty) {
    const item = document.createElement('div');
    item.className = 'day-detail-feast-item';
    
    const prob = month.dateUncertaintyProbability || 0;
    let warningText = '';
    if (month.dateUncertainty === '-') {
      if (dayObj.lunarDay === 30) {
        warningText = `There is a ~${prob}% probability this Day 30 does not exist. The margin between this month's ${getMoonLabel()} and sunset 
          is within the estimated uncertainty for astronomical calculations at this ancient date. 
          If the ${getMoonLabel()} actually occurred before sunset, the prior month would have only 29 days, 
          and all dates in this month would be one day earlier than shown.`;
      } else {
        warningText = `There is a ~${prob}% probability this date is one day earlier than shown. The ${getMoonLabel()} occurred very close to sunset, 
          and if it was actually before sunset, the prior month would have only 29 days instead of 30.`;
      }
    } else if (month.dateUncertainty === '+') {
      warningText = `There is a ~${prob}% probability this date is one day later than shown. The ${getMoonLabel()} occurred very close to sunset, 
        and if it was actually after sunset, the prior month would have 30 days instead of 29.`;
    }
    
    item.innerHTML = `
      <div class="day-detail-feast-icon">âš ï¸</div>
      <div class="day-detail-feast-info">
        <div class="day-detail-feast-name">Date Uncertainty: ~${prob}% chance dates are ${month.dateUncertainty === '-' ? 'earlier' : 'later'}</div>
        <div class="uncertainty-warning" style="margin-top: 0.5rem;">
          ${warningText}
        </div>
      </div>
    `;
    feastsContainer.appendChild(item);
  }
  
  // Add year start explanation for 1st day of 1st month, or 13th month explanation
  if (dayObj.lunarDay === 1 && (month.monthNumber === 1 || month.monthNumber === 13)) {
    const item = document.createElement('div');
    item.className = 'day-detail-feast-item day-detail-year-info';
    
    const totalMonths = state.lunarMonths.length;
    const has13thMonth = totalMonths === 13;
    const moonLabel = getMoonLabel();
    
    // Get spring equinox for this lunar year
    const springEquinox = getAstroEngine().getSeasons(state.year).mar_equinox.date;
    const seqParts = getFormattedDateParts(springEquinox);
    const equinoxDateStr = `${seqParts.weekdayName}, ${seqParts.monthName} ${seqParts.day}${getOrdinalSuffix(seqParts.day)}, ${seqParts.yearStr}${seqParts.calendarSuffix}`;
    
    // Check if we're in crescent + sunset mode
    const isCrescentSunset = state.moonPhase === 'crescent' && 
                             state.dayStartTime === 'evening' && 
                             state.dayStartAngle === 0;
    
    // Calculate time from equinox to month start (day 1 day-start)
    // For crescent+sunset, use the moon event time (crescent sighting = sunset)
    let day1StartTs;
    if (isCrescentSunset && month.moonEvent) {
      day1StartTs = month.moonEvent.getTime();
    } else {
      day1StartTs = getDayStartTime(dayObj.gregorianDate);
    }
    const diffMs = day1StartTs - springEquinox.getTime();
    const diffTotalHours = diffMs / (1000 * 60 * 60);
    const diffDays = Math.floor(Math.abs(diffTotalHours) / 24);
    const diffHours = Math.round(Math.abs(diffTotalHours) % 24);
    
    let timingStr = '';
    if (diffDays > 0 && diffHours > 0) {
      timingStr = `${diffDays} day${diffDays !== 1 ? 's' : ''} and ${diffHours} hour${diffHours !== 1 ? 's' : ''}`;
    } else if (diffDays > 0) {
      timingStr = `${diffDays} day${diffDays !== 1 ? 's' : ''}`;
    } else {
      timingStr = `${diffHours} hour${diffHours !== 1 ? 's' : ''}`;
    }
    const beforeAfter = diffMs >= 0 ? 'after' : 'before';
    
    if (month.monthNumber === 1) {
      // Positive reason: explain why year CAN start here using current moon phase setting
      const dayStartLabel = getDayStartLabel();
      const day1StartDate = new Date(day1StartTs);
      const day1StartStr = day1StartDate.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
      const day1Parts = getFormattedDateParts(day1StartDate);
      const day1DateStr = `${day1Parts.weekdayName}, ${day1Parts.monthName} ${day1Parts.day}${getOrdinalSuffix(day1Parts.day)}`;
      
      let yearMonthInfo = '';
      let virgoExplanationHtml = '';
      
      // For Virgo rule, use shared methodology function
      if (state.yearStartRule === 'virgoFeet') {
        const virgoCalc = getVirgoCalculation(state.year);
        if (virgoCalc) {
          // Use the shared methodology function with calculation details
          virgoExplanationHtml = getVirgoMethodologyHtml({ 
            showCalculation: true, 
            virgoCalc: virgoCalc 
          });
          yearMonthInfo = ''; // Content is in virgoExplanationHtml
        } else {
          yearMonthInfo = `Day 1 begins at ${dayStartLabel} (${day1DateStr} at ${day1StartStr}). Using Moon Under Virgo's Feet rule.`;
        }
      } else if (state.yearStartRule === '13daysBefore') {
        // Passover rule - use shared function
        virgoExplanationHtml = getPassoverMethodologyHtml({
          showCalculation: true,
          equinoxDate: equinoxDateStr,
          day1Date: `${day1DateStr} at ${day1StartStr}`,
          timingStr: timingStr,
          beforeAfter: beforeAfter
        });
        yearMonthInfo = ''; // Content is in virgoExplanationHtml
      } else {
        // Equinox rule - use shared function
        virgoExplanationHtml = getEquinoxMethodologyHtml({
          showCalculation: true,
          equinoxDate: equinoxDateStr,
          day1Date: `${day1DateStr} at ${day1StartStr}`,
          timingStr: timingStr,
          beforeAfter: beforeAfter
        });
        yearMonthInfo = ''; // Content is in virgoExplanationHtml
      }
      
      // Determine icon based on rule
      let ruleIcon = 'ğŸ“…';
      if (state.yearStartRule === 'virgoFeet') ruleIcon = 'â™';
      else if (state.yearStartRule === '13daysBefore') ruleIcon = 'ğŸ‘';
      else ruleIcon = 'âš–ï¸';
      
      item.innerHTML = `
        <div class="day-detail-feast-icon">${ruleIcon}</div>
        <div class="day-detail-feast-info">
          <div class="day-detail-feast-name">Lunar Year ${state.year} Begins</div>
          <div class="day-detail-feast-desc">${yearMonthInfo}</div>
          ${virgoExplanationHtml}
        </div>
      `;
      feastsContainer.appendChild(item);
      
      // Add click handler for equinox link
      const equinoxLink = item.querySelector('.equinox-link');
      if (equinoxLink) {
        equinoxLink.addEventListener('click', (e) => {
          e.preventDefault();
          jumpToEquinoxDate(springEquinox);
        });
      }
    } else if (month.monthNumber === 13) {
      // Explain why 13th month exists: its day-start is BEFORE the next year's start point
      const nextEquinox = getAstroEngine().getSeasons(state.year + 1).mar_equinox.date;
      const neqParts = getFormattedDateParts(nextEquinox);
      const nextEquinoxDateStr = `${neqParts.weekdayName}, ${neqParts.monthName} ${neqParts.day}${getOrdinalSuffix(neqParts.day)}, ${neqParts.yearStr}${neqParts.calendarSuffix}`;
      
      // Get the 13th month's moon event (crescent/full/dark)
      const month13MoonEvent = month.moonEvent;
      let moonEventStr = '';
      let dayStartStr = '';
      let timingExplanation = '';
      
      if (month13MoonEvent) {
        const moonParts = getFormattedDateParts(month13MoonEvent);
        const moonTimeStr = month13MoonEvent.toLocaleTimeString('en-US', { 
          hour: 'numeric', minute: '2-digit', hour12: true 
        });
        moonEventStr = `${moonParts.weekdayName}, ${moonParts.monthName} ${moonParts.day}${getOrdinalSuffix(moonParts.day)}, ${moonParts.yearStr} at ${moonTimeStr}`;
        
        // Check if we're in crescent + sunset mode
        const isCrescentSunset = state.moonPhase === 'crescent' && 
                                 state.dayStartTime === 'evening' && 
                                 state.dayStartAngle === 0;
        
        // Calculate when Day 1 starts (day-start time)
        // For crescent+sunset, the month starts at the crescent sighting time (which IS sunset)
        let dayStartTimestamp;
        if (isCrescentSunset) {
          dayStartTimestamp = month13MoonEvent.getTime();
        } else {
          dayStartTimestamp = getDayStartTime(dayObj.gregorianDate);
        }
        const dayStartDate = new Date(dayStartTimestamp);
        const dayStartLabel = getDayStartLabel();
        const dsTimeStr = dayStartDate.toLocaleTimeString('en-US', { 
          hour: 'numeric', minute: '2-digit', hour12: true 
        });
        const dsParts = getFormattedDateParts(dayStartDate);
        dayStartStr = `${dsParts.weekdayName}, ${dsParts.monthName} ${dsParts.day}${getOrdinalSuffix(dsParts.day)} at ${dsTimeStr}`;
        
        // Calculate time from 13th month day-start to next equinox
        const diffToEquinoxMs = nextEquinox.getTime() - dayStartTimestamp;
        const diffToEquinoxHours = diffToEquinoxMs / (1000 * 60 * 60);
        const diffDays = Math.floor(diffToEquinoxHours / 24);
        const diffHours = Math.round(diffToEquinoxHours % 24);
        
        let diffStr = '';
        if (diffDays > 0 && diffHours > 0) {
          diffStr = `${diffDays} day${diffDays !== 1 ? 's' : ''} and ${diffHours} hour${diffHours !== 1 ? 's' : ''}`;
        } else if (diffDays > 0) {
          diffStr = `${diffDays} day${diffDays !== 1 ? 's' : ''}`;
        } else {
          diffStr = `${diffHours} hour${diffHours !== 1 ? 's' : ''}`;
        }
        
        timingExplanation = `The ${moonLabel} for this month was sighted on ${moonEventStr}. ` +
          `Day 1 begins at ${dayStartLabel} (${dayStartStr}), which is ${diffStr} before the ` +
          `<a href="#" class="equinox-link" data-equinox-date="${nextEquinox.toISOString()}">Spring Equinox (${nextEquinoxDateStr})</a>. ` +
          `Since this day-start falls before the equinox, this qualifies as the 13th month of the current year rather than the 1st month of the next year.`;
      }
      
      item.innerHTML = `
        <div class="day-detail-feast-icon">ğŸ“…</div>
        <div class="day-detail-feast-info">
          <div class="day-detail-feast-name">13th Month (Intercalary)</div>
          <div class="day-detail-feast-desc">${timingExplanation}</div>
        </div>
      `;
      feastsContainer.appendChild(item);
      
      // Add click handler for equinox link
      const equinoxLink = item.querySelector('.equinox-link');
      if (equinoxLink) {
        equinoxLink.addEventListener('click', (e) => {
          e.preventDefault();
          jumpToEquinoxDate(nextEquinox);
        });
      }
    }
  }
  
  // Populate astronomical times in header (to the right of date info)
  const astroTimesContainer = panel.querySelector('.day-detail-astro-times');
  const astroTimes = getAstronomicalTimes(dayObj.gregorianDate);
  if (astroTimes) {
    astroTimesContainer.innerHTML = `
      <div class="astro-times-title">â˜€ï¸ Astronomical Times</div>
      <div class="astro-times-row">
        <div class="astro-times-group">
          <div class="astro-time"><span class="astro-label">Daybreak:</span> <span class="astro-value">${astroTimes.firstLight}</span></div>
          <div class="astro-time"><span class="astro-label">Sunrise:</span> <span class="astro-value">${astroTimes.sunrise}</span></div>
        </div>
        <div class="astro-times-group">
          <div class="astro-time"><span class="astro-label">Sunset:</span> <span class="astro-value">${astroTimes.sunset}</span></div>
          <div class="astro-time"><span class="astro-label">Twilight:</span> <span class="astro-value">${astroTimes.nauticalTwilight}</span></div>
        </div>
      </div>
    `;
  } else {
    astroTimesContainer.innerHTML = '';
  }
  
  // Populate additional info
  const infoContainer = panel.querySelector('.day-detail-info');
  let infoHtml = '';
  
  if (isSabbath(dayObj)) {
    const sabbathLabel = state.sabbathMode === 'lunar' ? 'Lunar Sabbath' : 
                         state.sabbathMode === 'saturday' ? 'Shabbat' :
                         state.sabbathMode === 'sunday' ? 'Lord\'s Day' :
                         state.sabbathMode === 'friday' ? 'Jumu\'ah' : 
                         'Rest Day';
    infoHtml += `<div class="day-detail-sabbath">ğŸ•¯ï¸ ${sabbathLabel}</div>`;
  }
  
  if (dayObj.moonPhase && dayObj.lunarDay !== 1) {
    infoHtml += `<div>Moon phase: ${dayObj.moonPhase}</div>`;
  }
  
  infoContainer.innerHTML = infoHtml;
  
  // Populate dateline visualization for Day 1
  const datelineContainer = panel.querySelector('.day-detail-dateline');
  if (dayObj.lunarDay === 1 && month.moonEvent) {
    const datelineHtml = renderDatelineVisualization(month.moonEvent);
    datelineContainer.innerHTML = datelineHtml;
  } else {
    datelineContainer.innerHTML = '';
  }
  
  // Populate profile comparison section (World Clock style)
  const compareContainer = panel.querySelector('.day-detail-profile-compare');
  // Use selectedTimestamp if available (when a specific day is selected), otherwise use viewTime
  const viewTime = state.selectedTimestamp ? new Date(state.selectedTimestamp) : getViewTime();
  const checkTimestamp = viewTime.getTime();
  
  const entries = getWorldClockEntries();
  
  if (entries.length > 0) {
    let compareHtml = `
      <div class="profile-compare-header">
        <span class="profile-compare-title">ğŸ“… This Moment on Other Calendars</span>
        <button class="world-clock-add-btn" onclick="showAddWorldClockModal()" title="Add Calendar">+</button>
      </div>`;
    compareHtml += `<div class="profile-compare-grid">`;
    
    let hasResults = false;
    entries.forEach((entry, index) => {
      const profile = PROFILES[entry.profileId] || PRESET_PROFILES[entry.profileId];
      if (!profile) return;
      
      // Create a temp profile with the entry's location
      const coords = CITY_SLUGS[entry.locationSlug];
      if (!coords) return;
      
      const tempProfile = {
        ...profile,
        lat: coords.lat,
        lon: coords.lon
      };
      
      const lunarDayInfo = getLunarDayForTimestamp(checkTimestamp, tempProfile);
      if (!lunarDayInfo) return;
      
      hasResults = true;
      
      // Check if this is the current view
      const currentLocSlug = getLocationSlug();
      const isCurrent = entry.profileId === (state.selectedProfile || 'timeTested') && 
                        entry.locationSlug === currentLocSlug;
      
      // Get feast icons for this lunar day/month
      const feastIcons = getFeastIconsForLunarDay(lunarDayInfo.month, lunarDayInfo.day);
      const feastHtml = feastIcons.length > 0 ? `<div class="profile-compare-feasts">${feastIcons.join('')}</div>` : '';
      
      // Get local time for this location
      const localTime = getLocalTimeForLocation(coords.lat, coords.lon);
      
      compareHtml += `
        <div class="profile-compare-item${isCurrent ? ' current' : ''}" onclick="navigateToWorldClockEntry('${entry.profileId}', '${entry.locationSlug}')">
          <button class="world-clock-remove-btn" onclick="event.stopPropagation(); removeWorldClockEntryAndRefresh(${index})" title="Remove">Ã—</button>
          <span class="profile-compare-name">${renderProfileIcon(profile)} ${profile.name}</span>
          <span class="profile-compare-day">Day ${lunarDayInfo.day} of Month ${lunarDayInfo.month}</span>
          <span class="profile-compare-location">${entry.locationName || formatCitySlug(entry.locationSlug)} Â· ${localTime}</span>
          ${feastHtml}
        </div>
      `;
    });
    
    compareHtml += `</div>`;
    
    if (hasResults) {
      compareContainer.innerHTML = compareHtml;
    } else {
      compareContainer.innerHTML = '';
    }
  } else {
    compareContainer.innerHTML = '';
  }
  
  // Show the panel (reset both inline style and class)
  panel.style.display = '';  // Reset any inline display:none from settings page
  panel.classList.remove('hidden');
}

function closeDayDetail() {
  document.getElementById('day-detail-panel').classList.add('hidden');
}

function getOrdinalSuffix(n) {
  const s = ['th', 'st', 'nd', 'rd'];
  const v = n % 100;
  return s[(v - 20) % 10] || s[v] || s[0];
}

// Jump to a specific equinox date and highlight that day
function jumpToEquinoxDate(equinoxDate) {
  const targetDate = new Date(equinoxDate);
  
  // Find this date in the current lunar months
  for (let m = 0; m < state.lunarMonths.length; m++) {
    const month = state.lunarMonths[m];
    for (let d = 0; d < month.days.length; d++) {
      const day = month.days[d];
      // Check if equinox falls on this day
      if (day.equinox && day.equinox.date.toDateString() === targetDate.toDateString()) {
        state.currentMonthIndex = m;
        state.highlightedLunarDay = day.lunarDay;
        state.selectedTimestamp = getSunriseTimestamp(day.gregorianDate);
        document.getElementById('goto-date').value = formatLocalDatetime(state.selectedTimestamp);
        renderMonth(state.lunarMonths[state.currentMonthIndex]);
        updateMonthButtons();
        updateURL();
        showDayDetail(day, month);
        return;
      }
    }
  }
  
  // If not found in current year's months, the equinox might be in a different year
  // Navigate to that year first
  const equinoxYear = targetDate.getFullYear();
  if (equinoxYear !== state.year) {
    state.year = equinoxYear;
    updateUI();
    generateCalendar();
    // Try again after regenerating
    jumpToEquinoxDate(equinoxDate);
  }
}

function jumpToToday() {
  const now = new Date();
  const utcTimestamp = now.getTime();
  
  // Get the current date at the selected location (based on longitude)
  // utcToLocalTime returns a Date where UTC methods give local time at location
  const localDateAtLocation = utcToLocalTime(utcTimestamp, state.lon);
  const targetYear = localDateAtLocation.getUTCFullYear();
  const targetMonth = localDateAtLocation.getUTCMonth();
  const targetDay = localDateAtLocation.getUTCDate();
  
  // Update goto-date input with local time at selected location
  document.getElementById('goto-date').value = formatLocalDatetime(utcTimestamp);
  
  // Determine which lunar year today belongs to
  // Use UTC comparison - the calendar builds months based on UTC moon events
  const springEquinox = getAstroEngine().getSeasons(targetYear).mar_equinox.date;
  const lunarYear = utcTimestamp < springEquinox.getTime() ? targetYear - 1 : targetYear;
  
  // Update state year (keep other settings from localStorage)
  state.year = lunarYear;
  
  // Update UI with all state (including saved location/moon phase settings)
  updateUI();
  
  // Generate calendar for today's lunar year
  generateCalendar();
  
  // Find today in the generated months
  // Calendar dates are stored as browser-local Date objects but represent the date at the location
  for (let m = 0; m < state.lunarMonths.length; m++) {
    const month = state.lunarMonths[m];
    for (let d = 0; d < month.days.length; d++) {
      const day = month.days[d];
      const gd = day.gregorianDate;
      // Compare year/month/day - both represent the date at the observer's location
      if (gd.getFullYear() === targetYear && 
          gd.getMonth() === targetMonth && 
          gd.getDate() === targetDay) {
        state.currentMonthIndex = m;
        state.highlightedLunarDay = day.lunarDay;
        state.selectedTimestamp = utcTimestamp;
        renderMonth(state.lunarMonths[m]);
        updateMonthButtons();
        showDayDetail(day, month);
        return;
      }
    }
  }
  
  // Fallback: if today not found, just show first month
  state.currentMonthIndex = 0;
  renderMonth(state.lunarMonths[0]);
  updateMonthButtons();
}

// Open ICS directly in calendar app
async function openInCalendar() {
  const icsContent = generateICSContent();
  if (!icsContent) return;
  
  const filename = `lunar-sabbath-calendar-${state.year}.ics`;
  const blob = new Blob([icsContent], { type: 'text/calendar' });
  const file = new File([blob], filename, { type: 'text/calendar' });
  
  // Try Web Share API first (works great on mobile and some desktop)
  if (navigator.share && navigator.canShare && navigator.canShare({ files: [file] })) {
    try {
      await navigator.share({
        files: [file],
        title: 'Lunar Sabbath Calendar',
        text: `Sabbaths and Feasts for ${formatYear(state.year)}`
      });
      return;
    } catch (err) {
      if (err.name !== 'AbortError') {
        console.log('Share failed, falling back to download');
      } else {
        return; // User cancelled
      }
    }
  }
  
  // Fallback: Download the file
  exportToICS();
  
  // Close the export modal after successful download
  const exportPage = document.getElementById('export-page');
  if (exportPage && exportPage.style.display !== 'none') {
    toggleExportModal();
  }
}

// Generate ICS content for calendar export
function generateICSContent() {
  if (!state.lunarMonths || state.lunarMonths.length === 0) {
    alert('Please generate a calendar first');
    return null;
  }
  
  const events = [];
  const yearLabel = formatYear(state.year);
  
  // Collect all Sabbaths and Feasts
  for (const month of state.lunarMonths) {
    for (const day of month.days) {
      // Add Sabbaths
      if (isSabbath(day)) {
        const sabbathLabel = state.sabbathMode === 'lunar' ? 'Lunar Sabbath' : 
                             state.sabbathMode === 'saturday' ? 'Shabbat' :
                             state.sabbathMode === 'sunday' ? 'Lord\'s Day' :
                             state.sabbathMode === 'friday' ? 'Jumu\'ah' : 
                             'Rest Day';
        events.push({
          date: day.gregorianDate,
          title: `${sabbathLabel} (${MONTH_NAMES[month.monthNumber - 1]} ${day.lunarDay})`,
          description: `${sabbathLabel} - Day ${day.lunarDay} of ${MONTH_NAMES[month.monthNumber - 1]}`,
          allDay: true
        });
      }
      
      // Add Feasts
      if (day.feast) {
        let title = day.feast.name;
        if (day.feastDayNum) {
          title += ` Day ${day.feastDayNum}`;
        }
        events.push({
          date: day.gregorianDate,
          title: title,
          description: day.feast.description + ` (${MONTH_NAMES[month.monthNumber - 1]} ${day.lunarDay})`,
          allDay: true
        });
      }
      
      // Add New Moon days
      if (day.isNewMoon) {
        events.push({
          date: day.gregorianDate,
          title: `New Moon - ${MONTH_NAMES[month.monthNumber - 1]}`,
          description: `Start of ${MONTH_NAMES[month.monthNumber - 1]} (Lunar Month ${month.monthNumber})`,
          allDay: true
        });
      }
    }
  }
  
  // Sort events by date
  events.sort((a, b) => a.date.getTime() - b.date.getTime());
  
  // Generate ICS content
  let ics = [
    'BEGIN:VCALENDAR',
    'VERSION:2.0',
    'PRODID:-//LunarSabbath.net//Lunar Sabbath Calendar//EN',
    'CALSCALE:GREGORIAN',
    'METHOD:PUBLISH',
    `X-WR-CALNAME:Lunar Sabbath Calendar ${yearLabel}`
  ];
  
  for (const event of events) {
    const dateStr = formatICSDate(event.date);
    const uid = `${dateStr}-${event.title.replace(/\s+/g, '-')}@lunarsabbath.net`;
    
    ics.push('BEGIN:VEVENT');
    ics.push(`UID:${uid}`);
    ics.push(`DTSTART;VALUE=DATE:${dateStr}`);
    ics.push(`DTEND;VALUE=DATE:${dateStr}`);
    ics.push(`SUMMARY:${escapeICS(event.title)}`);
    ics.push(`DESCRIPTION:${escapeICS(event.description)}`);
    ics.push('END:VEVENT');
  }
  
  ics.push('END:VCALENDAR');
  
  return ics.join('\r\n');
}

// Export Sabbaths and Feasts to ICS file for calendar import
function exportToICS() {
  const icsContent = generateICSContent();
  if (!icsContent) return;
  
  // Download the file
  const blob = new Blob([icsContent], { type: 'text/calendar;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = `lunar-sabbath-calendar-${state.year}.ics`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

function formatICSDate(date) {
  const year = date.getFullYear();
  const month = (date.getMonth() + 1).toString().padStart(2, '0');
  const day = date.getDate().toString().padStart(2, '0');
  return `${year}${month}${day}`;
}

function escapeICS(text) {
  // Escape special characters for ICS format
  return text
    .replace(/\\/g, '\\\\')
    .replace(/;/g, '\\;')
    .replace(/,/g, '\\,')
    .replace(/\n/g, '\\n');
}

// Register Service Worker for PWA functionality
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js')
      .then((registration) => {
        console.log('ServiceWorker registered:', registration.scope);
      })
      .catch((error) => {
        console.log('ServiceWorker registration failed:', error);
      });
  });
}

// Track book PDF download with GoatCounter
function trackBookDownload() {
  if (typeof goatcounter !== 'undefined' && goatcounter.count) {
    goatcounter.count({
      path: '/download/book-pdf',
      title: 'Book PDF Download',
      event: true
    });
  }
}
</script>

<!-- GoatCounter Analytics -->
<script data-goatcounter="https://lunarsabbath.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
</body>
</html>

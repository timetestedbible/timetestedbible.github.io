---
layout: null
title: "Lunar Sabbath Calendar"
---
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#1a3a5c">
  <meta name="description" content="A time-tested lunar calendar for tracking Sabbaths and appointed times">
  <title>{{ page.title }}</title>
  <link rel="icon" type="image/svg+xml" href="/icons/icon.svg">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/icon-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/icon-16.png">
  <link rel="manifest" href="/manifest.json">
  <link rel="apple-touch-icon" href="/icons/icon-192.png">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #1a3a5c;
      min-height: 100vh;
    }

* {
  box-sizing: border-box;
}

/* Top Navigation Bar */
.top-nav {
  position: sticky;
  top: 0;
  z-index: 1000;
  background: linear-gradient(180deg, #0d2840 0%, #1a3a5c 100%);
  padding: 10px 15px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-bottom: 1px solid rgba(255,255,255,0.1);
}

.top-nav-brand {
  display: flex;
  flex-direction: column;
}

.top-nav-title {
  font-size: 1.3em;
  color: #7ec8e3;
  font-weight: bold;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
  font-family: 'Georgia', serif;
}

.top-nav-tagline {
  font-size: 0.75em;
  color: #d4a017;
  font-style: italic;
  font-family: 'Georgia', serif;
}

.hamburger-btn {
  background: none;
  border: none;
  color: #7ec8e3;
  font-size: 28px;
  cursor: pointer;
  padding: 8px;
  line-height: 1;
  border-radius: 8px;
  transition: background 0.2s;
}

.hamburger-btn:hover {
  background: rgba(255,255,255,0.1);
}

/* Hamburger Menu Dropdown */
.nav-menu-overlay {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0,0,0,0.5);
  z-index: 999;
}

.nav-menu-overlay.open {
  display: block;
}

.nav-menu {
  position: fixed;
  top: 0;
  right: -280px;
  width: 280px;
  height: 100%;
  background: linear-gradient(180deg, #1a3a5c 0%, #0d2840 100%);
  z-index: 1001;
  transition: right 0.3s ease;
  box-shadow: -4px 0 20px rgba(0,0,0,0.5);
  display: flex;
  flex-direction: column;
}

.nav-menu.open {
  right: 0;
}

.nav-menu-header {
  padding: 15px 20px;
  border-bottom: 1px solid rgba(255,255,255,0.1);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.nav-menu-header h3 {
  margin: 0;
  color: #7ec8e3;
  font-family: 'Georgia', serif;
}

.nav-menu-close {
  background: none;
  border: none;
  color: #7ec8e3;
  font-size: 24px;
  cursor: pointer;
  padding: 4px 8px;
}

.nav-menu-items {
  flex: 1;
  padding: 10px 0;
  overflow-y: auto;
}

.nav-menu-item {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 15px 20px;
  color: white;
  text-decoration: none;
  font-size: 1.1em;
  font-family: 'Georgia', serif;
  border: none;
  background: none;
  width: 100%;
  text-align: left;
  cursor: pointer;
  transition: background 0.2s;
}

.nav-menu-item:hover {
  background: rgba(255,255,255,0.1);
}

.nav-menu-item .icon {
  font-size: 1.3em;
  width: 30px;
  text-align: center;
}

.nav-menu-item.active {
  background: rgba(212, 160, 23, 0.2);
  border-left: 3px solid #d4a017;
}

.nav-menu-divider {
  height: 1px;
  background: rgba(255,255,255,0.1);
  margin: 10px 20px;
}

.calendar-app {
  max-width: 900px;
  margin: 0 auto;
  padding: 8px;
  font-family: 'Georgia', serif;
  min-height: 100vh;
}

.calendar-controls {
  display: flex;
  flex-wrap: wrap;
  gap: 15px;
  margin-bottom: 20px;
  padding: 15px;
  background: #1a3a5c;
  border-radius: 8px;
  color: white;
}

.control-group {
  display: flex;
  flex-direction: column;
  gap: 5px;
}

.control-group label {
  font-size: 0.85em;
  opacity: 0.9;
}

.control-group input, .control-group select {
  padding: 8px 12px;
  border: none;
  border-radius: 4px;
  font-size: 1em;
}

.btn {
  padding: 10px 20px;
  background: #d4a017;
  color: #1a3a5c;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-weight: bold;
  align-self: flex-end;
}

.btn:hover {
  background: #e8b830;
}

/* Month Calendar Container */
.month-calendar {
  background: linear-gradient(180deg, #1a3a5c 0%, #2a5a8c 100%);
  overflow: hidden;
  margin-bottom: 0;
  border-radius: 12px;
}

/* Header Section */
.calendar-header {
  display: grid;
  grid-template-columns: 1fr auto;
  padding: 0;
  background: linear-gradient(180deg, #0d2840 0%, #1a3a5c 100%);
  color: white;
  align-items: stretch;
  gap: 0;
  width: 100%;
  overflow: hidden;
}

.header-left {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 10px 15px;
  min-width: 0;
  overflow: hidden;
}

.calendar-title {
  text-align: left;
  padding: 5px 10px;
  flex: 1;
}

.calendar-title .site-title {
  font-size: 1.6em;
  color: #7ec8e3;
  font-weight: bold;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
  margin-bottom: 2px;
}

.calendar-title .site-tagline .book-link {
  text-decoration: none;
  font-size: 1.1em;
  margin-left: 6px;
  opacity: 0.8;
  transition: opacity 0.2s;
}

.calendar-title .site-tagline .book-link:hover {
  opacity: 1;
}

.calendar-title .site-tagline {
  font-size: 0.85em;
  color: #d4a017;
  font-style: italic;
  margin-bottom: 4px;
}

.calendar-title .profile-name {
  font-size: 0.85em;
  color: #7ec8e3;
  margin-bottom: 2px;
}

.calendar-title .month-name {
  font-size: 1.2em;
  color: #d4a017;
  display: flex;
  align-items: center;
  gap: 6px;
}

.calendar-title .dropdown-arrow {
  font-size: 0.6em;
  opacity: 0.7;
}

.calendar-title .year {
  font-size: 1em;
  color: #7ec8e3;
  font-weight: bold;
  margin-top: 2px;
}

.calendar-title:hover {
  background: rgba(255,255,255,0.1);
}

/* Month Picker Popup */
.month-picker-overlay {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0,0,0,0.5);
  z-index: 1000;
}

.month-picker-overlay.open {
  display: block;
}

.month-picker {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: #1a3a5c;
  border-radius: 20px;
  padding: 28px;
  z-index: 1001;
  width: 70%;
  max-width: 630px;
  box-shadow: 0 10px 40px rgba(0,0,0,0.5);
}

.month-picker-header {
  display: flex;
  justify-content: center;
  align-items: center;
  margin-bottom: 24px;
  padding-bottom: 16px;
  border-bottom: 1px solid rgba(255,255,255,0.2);
  position: relative;
}

.month-picker-header h3 {
  margin: 0;
  color: #7ec8e3;
  font-size: 1.5em;
}

.month-picker .close-btn {
  position: absolute;
  top: -8px;
  right: -8px;
  background: rgba(255,255,255,0.1);
  border: none;
  color: #fff;
  font-size: 1.3em;
  cursor: pointer;
  padding: 12px 16px;
  line-height: 1;
  border-radius: 10px;
  min-width: 48px;
  min-height: 48px;
}

.month-picker .close-btn:hover {
  background: rgba(255,255,255,0.2);
}

.year-nav {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 20px;
  margin-bottom: 20px;
}

.year-nav button {
  background: #0d2840;
  border: none;
  color: #d4a017;
  padding: 16px 24px;
  border-radius: 12px;
  cursor: pointer;
  font-size: 1.5em;
  min-width: 58px;
  min-height: 58px;
}

.year-nav button:hover {
  background: #2a5a8c;
}

.year-nav .year-display {
  color: #fff;
  font-size: 1.5em;
  font-weight: bold;
  min-width: 130px;
  text-align: center;
  cursor: pointer;
  padding: 8px 12px;
  border-radius: 8px;
  transition: background 0.2s;
}

.year-nav .year-display:hover {
  background: rgba(255,255,255,0.1);
}

.year-nav .year-input {
  font-size: 1.5em;
  font-weight: bold;
  width: 120px;
  text-align: center;
  padding: 8px 12px;
  border: 2px solid #d4a017;
  border-radius: 8px;
  background: #0d2840;
  color: #fff;
  font-family: inherit;
}

.month-grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 12px;
}

.month-grid button {
  background: #0d2840;
  border: none;
  color: #fff;
  padding: 18px 10px;
  border-radius: 12px;
  cursor: pointer;
  font-size: 1.1em;
  transition: all 0.2s;
  min-height: 58px;
}

.month-grid button:hover {
  background: #2a5a8c;
}

.month-grid button.active {
  background: #d4a017;
  color: #1a3a5c;
  font-weight: bold;
}

.month-grid button.disabled {
  opacity: 0.3;
  cursor: not-allowed;
}

/* Date Jump Popup */
.date-jump-overlay {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0,0,0,0.5);
  z-index: 1000;
}

.date-jump-overlay.open {
  display: block;
}

.date-jump-popup {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: #1a3a5c;
  border-radius: 20px;
  padding: 28px;
  z-index: 1001;
  width: 70%;
  max-width: 630px;
  box-shadow: 0 10px 40px rgba(0,0,0,0.5);
}

.date-jump-popup h3 {
  margin: 0 0 24px 0;
  color: #7ec8e3;
  font-size: 1.5em;
  text-align: center;
}

.date-jump-popup .close-btn {
  position: absolute;
  top: 16px;
  right: 16px;
  background: rgba(255,255,255,0.1);
  border: none;
  color: #fff;
  font-size: 1.3em;
  cursor: pointer;
  padding: 12px 16px;
  line-height: 1;
  border-radius: 10px;
  min-width: 48px;
  min-height: 48px;
}

.date-jump-popup .close-btn:hover {
  background: rgba(255,255,255,0.2);
}

.date-jump-popup input {
  width: 100%;
  padding: 18px;
  border: none;
  border-radius: 12px;
  background: #0d2840;
  color: #fff;
  font-size: 1.2em;
  margin-bottom: 20px;
  box-sizing: border-box;
  min-height: 60px;
}

.date-jump-popup .btn-row {
  display: flex;
  gap: 14px;
  margin-bottom: 24px;
}

.date-jump-popup .btn {
  flex: 1;
  padding: 18px;
  background: #d4a017;
  color: #1a3a5c;
  border: none;
  border-radius: 12px;
  cursor: pointer;
  font-weight: bold;
  font-size: 1.2em;
  min-height: 60px;
}

.date-jump-popup .btn:hover {
  background: #e5b328;
}

.date-jump-popup .btn.secondary {
  background: #2a5a8c;
  color: #fff;
}

.date-jump-popup .btn.secondary:hover {
  background: #3a6a9c;
}

.days-jump {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 12px;
  padding-top: 20px;
  margin-top: 8px;
  border-top: 1px solid rgba(255,255,255,0.2);
}

.days-jump input {
  width: 100px;
  text-align: center;
  margin-bottom: 0;
  min-height: 58px;
  font-size: 1.3em;
  border-radius: 12px;
}

.days-jump button {
  background: #0d2840;
  border: none;
  color: #d4a017;
  padding: 16px 24px;
  border-radius: 12px;
  cursor: pointer;
  font-size: 1.5em;
  min-height: 58px;
  min-width: 58px;
}

.days-jump button:hover {
  background: #2a5a8c;
}

.days-jump span {
  color: #ccc;
  font-size: 1.2em;
  margin-left: 4px;
}

/* Old jump button styles removed - button is now in day detail header */

.full-moon-info {
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  border-radius: 10px;
  padding: 6px;
  transition: background 0.2s;
}

.full-moon-info:hover {
  background: rgba(255,255,255,0.1);
}

.full-moon-info .moon-icon {
  font-size: 68px;
  line-height: 1;
}

.moon-icon-wrapper {
  position: relative;
  display: inline-block;
}

.moon-gear-badge {
  position: absolute;
  bottom: -4px;
  right: -2px;
  font-size: 22px;
  color: #7ec8e3;
  opacity: 0.7;
  text-shadow: 0 1px 2px rgba(0,0,0,0.5);
}

.full-moon-info:hover .moon-gear-badge {
  opacity: 1;
}

/* Export/Feasts page specific styles */
html.feasts-open,
body.feasts-open {
  overflow: hidden !important;
  height: 100%;
}

#export-page {
  position: fixed;
  top: 55px; /* Below the top nav */
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 100;
  overflow-y: auto;
  border-radius: 0;
  margin: 0;
  background: linear-gradient(180deg, #1a3a5c 0%, #2a5a8c 100%);
}

#export-page .settings-page-header {
  position: sticky;
  top: 0;
  z-index: 10;
}

#export-page .export-header {
  display: flex;
  flex-wrap: nowrap;
  gap: 10px;
  align-items: center;
  justify-content: space-between;
  padding: 15px 20px;
}

#export-page .export-header h2 {
  flex: 1;
  text-align: left;
  font-size: 1.2em;
  margin: 0;
  line-height: 1.2;
}

#export-page .export-download-btn {
  padding: 10px 16px;
  font-size: 0.95em;
  white-space: nowrap;
  flex-shrink: 0;
}

.export-settings-context {
  background: rgba(0,0,0,0.3);
  padding: 12px 20px;
  font-size: 0.9em;
  color: #ccc;
  border-bottom: 1px solid rgba(255,255,255,0.1);
}

.export-settings-context span {
  display: flex;
  flex-wrap: wrap;
  gap: 8px 20px;
  justify-content: center;
}

.export-context-item {
  display: inline-flex;
  align-items: center;
  gap: 5px;
}

.export-context-label {
  color: #888;
}

.export-context-value {
  color: #d4a017;
  font-weight: 500;
}

/* Dateline Visualization */
.dateline-container {
  margin-top: 20px;
  padding: 15px;
  background: rgba(0,0,0,0.2);
  border-radius: 8px;
  width: 100%;
}

.dateline-label {
  font-size: 0.7em;
  color: #7ec8e3;
  margin-bottom: 5px;
}

.dateline-map {
  position: relative;
  aspect-ratio: 2 / 1;
  background: #1a3a5c;
  border-radius: 8px;
  overflow: hidden;
  cursor: crosshair;
}

.dateline-map.disabled {
  cursor: not-allowed;
  opacity: 0.7;
}

.dateline-map-bg {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  /* Fallback gradient if image fails */
  background: linear-gradient(to bottom, 
    #1a4a6e 0%, 
    #2d6a4f 20%, 
    #2d6a4f 40%,
    #1a4a6e 50%,
    #2d6a4f 60%,
    #1a4a6e 100%);
}

.dateline-map-bg img {
  width: 100%;
  height: 100%;
  object-fit: fill;
  opacity: 0.85;
}

.dateline-location-marker {
  position: absolute;
  width: 14px;
  height: 14px;
  transform: translate(-50%, -50%);
  z-index: 5;
  pointer-events: none;
}

/* Vertical dashed line */
.dateline-location-marker::before {
  content: '';
  position: absolute;
  left: 50%;
  top: 0;
  width: 0;
  height: 100vh;
  border-left: 1px dashed rgba(255, 100, 100, 0.8);
  transform: translateX(-50%) translateY(-50vh);
}

/* Horizontal dashed line */
.dateline-location-marker::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 0;
  width: 100vw;
  height: 0;
  border-top: 1px dashed rgba(255, 100, 100, 0.8);
  transform: translateY(-50%) translateX(-50vw);
}

/* Central red dot */
.dateline-location-pin {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  width: 12px;
  height: 12px;
  background: #ff3333;
  border: 2px solid #fff;
  border-radius: 50%;
  box-shadow: 0 0 6px rgba(255, 0, 0, 0.8), 0 0 12px rgba(255, 50, 50, 0.5);
}

.dateline-click-hint {
  font-size: 0.6em;
  color: #7ec8e3;
  text-align: center;
  margin-top: 3px;
  font-style: italic;
}

.dateline-marker {
  position: absolute;
  top: 0;
  bottom: 0;
  width: 3px;
  background: linear-gradient(to bottom, #ffcc00, #ff6b6b);
  box-shadow: 0 0 15px rgba(255,107,107,0.8), 0 0 30px rgba(255,204,0,0.5);
  z-index: 10;
  pointer-events: none;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: space-between;
}

.dateline-marker-icon {
  position: absolute;
  top: 5px;
  left: 50%;
  transform: translateX(-50%);
  color: #ffcc00;
  font-size: 18px;
  text-shadow: 0 0 10px rgba(255,204,0,0.8);
}

.dateline-marker-label {
  position: absolute;
  bottom: 5px;
  left: 50%;
  transform: translateX(-50%);
  color: #ffcc00;
  font-size: 8px;
  font-weight: bold;
  text-shadow: 0 0 5px rgba(0,0,0,0.8);
  white-space: nowrap;
}

.dateline-cities {
  display: flex;
  justify-content: space-between;
  font-size: 0.65em;
  color: #7ec8e3;
  margin-top: 5px;
  padding: 0 5px;
}

.dateline-info {
  font-size: 0.65em;
  color: #d4a017;
  margin-top: 5px;
}


/* Day 1 in header - inherits from .day-cell */
.new-moon-box {
  aspect-ratio: unset;
  min-height: 80px;
  width: calc((min(100vw, 900px) - 16px) / 7);
  box-sizing: border-box;
  overflow: hidden;
  flex-shrink: 0;
}

.new-moon-box .gregorian {
  flex-direction: row;
  gap: 4px;
  white-space: nowrap;
}

.new-moon-box .gregorian .day-year {
  font-size: 0.85em;
}

/* Week Header */
.week-header {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  background: #1a3a5c;
  border-top: 2px solid #2a5a8c;
  border-left: 1px solid #2a5a8c;
  border-right: 1px solid #2a5a8c;
}

.week-header .day-label {
  padding: 10px 5px;
  text-align: center;
  color: white;
  font-size: 0.85em;
  border-right: 1px solid #2a5a8c;
}

.week-header .day-label:last-child {
  border-right: none;
}

.week-header .day-label.sabbath-header {
  background: #d4a017;
  color: #1a3a5c;
  font-weight: bold;
}

.week-header .day-label .day-name {
  font-weight: bold;
}

.week-header .day-label .weekday {
  font-size: 0.9em;
  opacity: 0.8;
}

/* Day Cycle Bar - shows daylight/night alignment with calendar days */
/* Gradient is generated dynamically based on actual sunrise/sunset times */
.day-cycle-bar {
  height: 6px;
  border-left: 1px solid #2a5a8c;
  border-right: 1px solid #2a5a8c;
}

/* Calendar Grid */
.calendar-grid {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  grid-template-rows: repeat(5, 1fr);
  background: #2a5a8c;
  aspect-ratio: 7 / 5;
}

.day-cell {
  aspect-ratio: 1;
  min-height: 70px;
  padding: 5px;
  background: #3a6a9c;
  border: 1px solid #2a5a8c;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  position: relative;
  color: white;
  cursor: pointer;
}

.day-cell:not(.empty):hover {
  background: #4a7aac;
}

.day-cell.empty {
  background: #2a5a8c;
}

.day-cell.quote-row-spacer {
  background: #0d2840;
}

.day-cell .gregorian {
  font-size: 1em;
  color: #fff;
  position: absolute;
  top: 5px;
  left: 5px;
  font-weight: 600;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
  display: flex;
  flex-direction: column;
  line-height: 1.2;
}

.day-cell .gregorian .day-year {
  font-size: 0.75em;
  color: #7ec8e3;
  font-weight: normal;
}

.day-cell .lunar-day {
  font-size: 2em;
  font-weight: bold;
  color: #e8e8e8;
}

.day-cell .moon-phase {
  font-size: 1.2em;
  position: absolute;
  top: 5px;
  right: 5px;
}

.day-cell .moon-phase.blood-moon {
  /* Blood red glow effect for lunar eclipse */
  filter: sepia(1) saturate(5) hue-rotate(320deg) brightness(0.9);
  text-shadow: 0 0 10px rgba(180, 0, 0, 1), 0 0 20px rgba(255, 50, 50, 0.8), 0 0 30px rgba(200, 0, 0, 0.6);
  background: rgba(139, 0, 0, 0.3);
  border-radius: 50%;
  padding: 2px 4px;
}

/* Sabbath Days - gold-tinted background for more contrast */
.day-cell.sabbath {
  background: linear-gradient(135deg, #4a5a6a 0%, #3a4a5a 100%);
  border: 1px solid #d4a01755;
}

.day-cell.sabbath .lunar-day {
  color: #ffd700;
  text-shadow: 0 0 8px rgba(212, 160, 23, 0.6), 1px 1px 2px rgba(0,0,0,0.5);
  font-weight: bold;
}

/* New Moon Day */
.day-cell.new-moon {
  background: linear-gradient(135deg, #1a4a7c 0%, #2a5a8c 100%);
}

.day-cell.new-moon .lunar-day {
  color: #7ec8e3;
}

/* New Moon that is also a Sabbath (fixed weekday sabbath falls on new moon) */
.day-cell.new-moon.sabbath {
  background: linear-gradient(135deg, #3a6a9c 0%, #2a5a8c 100%);
}

.day-cell.new-moon.sabbath .lunar-day {
  color: #d4a017;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
}

/* Highlighted/Selected Day */
.day-cell.highlighted {
  box-shadow: inset 0 0 0 3px #ff6b6b, 0 0 10px #ff6b6b;
  animation: pulse 1.5s ease-in-out 3;
}

@keyframes pulse {
  0%, 100% { box-shadow: inset 0 0 0 3px #ff6b6b, 0 0 10px #ff6b6b; }
  50% { box-shadow: inset 0 0 0 3px #ff6b6b, 0 0 20px #ff6b6b; }
}

/* Today's date - moderate warm highlight */
.day-cell.today {
  background: linear-gradient(135deg, #4a5535 0%, #3a4528 100%);
  border: 1px solid #7a9050;
}

.day-cell.today .gregorian {
  color: #b8d080;
}

/* When today is also a sabbath - combine both highlights */
.day-cell.today.sabbath {
  background: linear-gradient(135deg, #4a5535 0%, #3a4020 100%);
  border: 1px solid #7a9050;
}

.day-cell .feast-icons {
  font-size: 1em;
  position: absolute;
  bottom: 2px;
  right: 3px;
  text-align: right;
  line-height: 1;
  letter-spacing: 0.15em;
  line-height: 1.2;
  font-weight: bold;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
}

/* Scripture Quote - integrated into last row */
.scripture-quote {
  padding: 10px 15px;
  text-align: center;
  color: #d4a017;
  font-style: italic;
  background: #0d2840;
  font-size: 0.85em;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
}

.scripture-quote.span-4 {
  grid-column: span 4;
}

/* Month navigation cells in last row */
.month-nav-cell {
  background: #0d2840;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: background 0.2s;
}

.month-nav-cell:hover:not(.disabled) {
  background: #1a3a5c;
}

.month-nav-cell.disabled {
  cursor: default;
  opacity: 0.3;
}

.month-nav-cell .nav-arrow {
  color: #d4a017;
  font-size: 1.5em;
}

.scripture-quote .reference {
  color: #7ec8e3;
  font-style: normal;
  margin-left: 10px;
}

/* Settings Dialog */
/* Old settings overlay - now hidden, replaced by settings page */
.settings-overlay {
  display: none !important;
}

.settings-overlay.open {
  display: none !important;
}

/* Old settings dialog - now hidden, replaced by settings page */
.settings-dialog {
  display: none !important;
}

.settings-dialog.open {
  display: none !important;
}

.settings-header {
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 20px 24px 16px;
  color: white;
  border-bottom: 1px solid rgba(255,255,255,0.2);
  position: relative;
}

.settings-header h3 {
  margin: 0;
  font-size: 1.4em;
  color: #7ec8e3;
}

.settings-dialog .close-btn {
  position: absolute;
  top: 12px;
  right: 12px;
  background: rgba(255,255,255,0.1);
  border: none;
  color: white;
  font-size: 1.2em;
  cursor: pointer;
  padding: 12px 16px;
  line-height: 1;
  border-radius: 10px;
  min-width: 48px;
  min-height: 48px;
}

.settings-dialog .close-btn:hover {
  background: rgba(255,255,255,0.2);
}

.settings-content {
  padding: 24px;
}

.setting-group {
  margin-bottom: 24px;
}

.setting-group label {
  display: block;
  font-weight: bold;
  margin-bottom: 12px;
  color: #7ec8e3;
  font-size: 1.1em;
}

.setting-group select,
.setting-group input {
  width: 100%;
  padding: 16px;
  border: none;
  border-radius: 12px;
  font-size: 1.1em;
  box-sizing: border-box;
  background: #0d2840;
  color: #fff;
  min-height: 54px;
}

.city-select-styled {
  margin-top: 12px;
}

.setting-info {
  font-size: 0.95em;
  color: #aaa;
  padding-top: 16px;
  border-top: 1px solid rgba(255,255,255,0.2);
  text-align: center;
}

/* Moon Phase Buttons */
.moon-phase-buttons {
  display: flex;
  gap: 12px;
}

.moon-phase-btn {
  flex: 1;
  background: #0d2840;
  border: 3px solid transparent;
  border-radius: 14px;
  padding: 16px 10px;
  cursor: pointer;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  transition: all 0.2s;
  min-height: 90px;
}

.moon-phase-btn:hover {
  background: #2a5a8c;
}

.moon-phase-btn.active {
  border-color: #d4a017;
  background: #2a5a8c;
}

.moon-phase-btn .phase-icon {
  font-size: 2em;
}

.moon-phase-btn .phase-name {
  color: #fff;
  font-size: 0.85em;
  font-weight: bold;
}

/* Settings Map */
#settings-map-container {
  margin-bottom: 12px;
}

#settings-map-container .dateline-container {
  margin-top: 0;
  padding: 12px;
}


.location-btn {
  width: 100%;
  padding: 16px;
  background: #2a5a8c;
  color: #fff;
  border: none;
  border-radius: 12px;
  font-size: 1.1em;
  cursor: pointer;
  margin-top: 12px;
  min-height: 54px;
}

.location-btn:hover {
  background: #3a6a9c;
}

.location-btn {
  width: 100%;
  padding: 12px;
  background: #2a5a8c;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 1em;
  margin-bottom: 15px;
}

.location-btn:hover {
  background: #1a3a5c;
}

.location-btn:disabled {
  background: #ccc;
  cursor: not-allowed;
}


/* Month Navigation */
.month-nav {
  display: flex;
  justify-content: center;
  align-items: center;
  margin-bottom: 20px;
}

.month-buttons {
  display: flex;
  flex-wrap: nowrap;
  gap: 4px;
  justify-content: center;
  align-items: center;
  width: 100%;
}

.month-btn {
  flex: 1;
  min-width: 0;
  height: 40px;
  padding: 0;
  background: #1a3a5c;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 1em;
  font-weight: bold;
  transition: all 0.2s;
}

/* 13th month button with calendar icon overlay */
.month-btn.month-13 {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
}

.month-13-icon {
  font-size: 1.2em;
  position: relative;
}

.month-13-num {
  position: absolute;
  font-size: 0.6em;
  font-weight: bold;
  color: #1a3a5c;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -35%);
  text-shadow: 0 0 2px white, 0 0 2px white;
}

.month-btn:hover {
  background: #2a5a8c;
  transform: scale(1.05);
}

.month-btn.active {
  background: #d4a017;
  color: #1a3a5c;
}

.month-btn.disabled {
  opacity: 0.3;
  cursor: not-allowed;
}

/* Settings Page - Full Screen Slide-in */
.settings-page {
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  width: 100%;
  max-width: 500px;
  background: linear-gradient(180deg, #1a3a5c 0%, #0d1f33 100%);
  overflow-y: auto;
  z-index: 1000;
  transform: translateX(100%);
  transition: transform 0.3s ease-out;
  box-shadow: -5px 0 20px rgba(0, 0, 0, 0.5);
}

.settings-page.visible {
  transform: translateX(0);
}

.settings-page-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  z-index: 999;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s, visibility 0.3s;
}

.settings-page-overlay.visible {
  opacity: 1;
  visibility: visible;
}

@media (max-width: 500px) {
  .settings-page {
    max-width: 100%;
  }
}

.settings-page-header {
  display: flex;
  align-items: center;
  gap: 15px;
  padding: 15px 20px;
  background: linear-gradient(180deg, #0d2840 0%, #1a3a5c 100%);
  border-bottom: 2px solid #d4a017;
}

.settings-page-header h2 {
  margin: 0;
  color: #d4a017;
  font-size: 1.4em;
  flex: 1;
}

.settings-page-header .close-btn {
  background: rgba(255,255,255,0.1);
  border: none;
  color: #ccc;
  font-size: 1.2em;
  width: 36px;
  height: 36px;
  border-radius: 50%;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
}

.settings-page-header .close-btn:hover {
  background: rgba(255,255,255,0.2);
  color: white;
}

.profile-row {
  display: flex;
  gap: 8px;
  align-items: center;
}

.profile-row .profile-select {
  flex: 1;
}

.profile-icon-btn {
  background: rgba(255,255,255,0.1);
  border: 2px solid transparent;
  color: #fff;
  font-size: 1.4em;
  font-weight: bold;
  width: 44px;
  height: 44px;
  border-radius: 8px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
}

.profile-icon-btn:hover:not(:disabled) {
  background: rgba(255,255,255,0.2);
  border-color: #d4a017;
}

.profile-icon-btn:disabled {
  opacity: 0.3;
  cursor: not-allowed;
}

/* Profile Name Modal */
.profile-modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10000;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.2s, visibility 0.2s;
}

.profile-modal-overlay.visible {
  opacity: 1;
  visibility: visible;
}

.profile-modal {
  background: linear-gradient(135deg, #1a3a5c 0%, #0d1f33 100%);
  border: 1px solid #2a5a8c;
  border-radius: 12px;
  padding: 24px;
  min-width: 320px;
  max-width: 90vw;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
  transform: scale(0.9);
  transition: transform 0.2s;
}

.profile-modal-overlay.visible .profile-modal {
  transform: scale(1);
}

.profile-modal h3 {
  margin: 0 0 16px 0;
  color: #7ec8e3;
  font-size: 1.2em;
}

.profile-modal-input {
  width: 100%;
  padding: 12px 15px;
  font-size: 1.1em;
  background: rgba(0, 0, 0, 0.3);
  border: 1px solid #2a5a8c;
  border-radius: 8px;
  color: #fff;
  margin-bottom: 8px;
  box-sizing: border-box;
}

.profile-modal-input:focus {
  outline: none;
  border-color: #7ec8e3;
}

.profile-modal-error {
  color: #ff6b6b;
  font-size: 0.9em;
  margin-bottom: 12px;
  min-height: 1.2em;
}

.profile-modal-buttons {
  display: flex;
  gap: 12px;
  justify-content: flex-end;
}

.profile-modal-btn {
  padding: 10px 20px;
  border-radius: 8px;
  font-size: 1em;
  cursor: pointer;
  border: none;
  transition: background 0.2s;
}

.profile-modal-btn.cancel {
  background: rgba(255, 255, 255, 0.1);
  color: #aaa;
}

.profile-modal-btn.cancel:hover {
  background: rgba(255, 255, 255, 0.2);
}

.profile-modal-btn.save {
  background: #2a5a8c;
  color: #fff;
}

.profile-modal-btn.save:hover {
  background: #3a7ab8;
}

.settings-option-btn.disabled,
.settings-select.disabled,
.settings-location-btn.disabled {
  opacity: 0.4;
  cursor: not-allowed;
  pointer-events: none;
}

.settings-section {
  padding: 20px;
  border-bottom: 1px solid rgba(255,255,255,0.1);
}

.settings-section:last-child {
  border-bottom: none;
}

.settings-section h3 {
  margin: 0 0 8px 0;
  color: #7ec8e3;
  font-size: 1.2em;
}

.settings-description {
  margin: 0 0 15px 0;
  color: rgba(255,255,255,0.7);
  font-size: 0.9em;
}

.settings-options {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
}

.settings-row {
  display: flex;
  align-items: center;
  gap: 12px;
}

.settings-row-label {
  color: rgba(255,255,255,0.8);
  font-size: 0.95em;
  white-space: nowrap;
}

.settings-engine-info {
  margin-top: 15px;
  padding: 12px 15px;
  background: rgba(0,0,0,0.2);
  border-radius: 8px;
  border: 1px solid rgba(255,255,255,0.1);
}

.engine-info-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 4px 0;
}

.engine-info-row:not(:last-child) {
  border-bottom: 1px solid rgba(255,255,255,0.05);
}

.engine-info-label {
  color: rgba(255,255,255,0.6);
  font-size: 0.85em;
}

.engine-info-value {
  color: #7ec8e3;
  font-size: 0.9em;
  font-family: monospace;
}

.profile-select {
  width: 100%;
  padding: 12px 15px;
  font-size: 1.1em;
  background: #0d2840;
  color: #fff;
  border: 2px solid #d4a017;
  border-radius: 8px;
  cursor: pointer;
  font-family: inherit;
}

.profile-select:focus {
  outline: none;
  border-color: #7ec8e3;
}

.profile-select option {
  padding: 10px;
  background: #1a3a5c;
}

.settings-option-btn {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  padding: 15px 20px;
  background: rgba(255,255,255,0.1);
  border: 2px solid transparent;
  border-radius: 12px;
  color: white;
  cursor: pointer;
  flex: 1;
  min-width: 90px;
  transition: all 0.2s;
}

.settings-option-btn:hover {
  background: rgba(255,255,255,0.15);
}

.settings-option-btn.selected {
  border-color: #d4a017;
  background: rgba(212, 160, 23, 0.2);
}

.settings-option-btn .option-icon {
  font-size: 2.5em;
}

/* Moon phase icons in Month Starts section - extra large */
.settings-option-btn[data-phase] .option-icon {
  font-size: 3.5em;
}

.settings-option-btn .option-label {
  font-size: 0.85em;
  font-weight: 500;
}

.settings-option-btn .option-hint {
  font-size: 0.75em;
  opacity: 0.7;
  font-weight: normal;
}

#settings-page-map {
  margin-bottom: 15px;
}

#settings-page-map .dateline-container {
  margin-top: 0;
  padding: 12px;
  background: rgba(0,0,0,0.2);
  border-radius: 10px;
}

.settings-select {
  width: 100%;
  padding: 14px 16px;
  font-size: 1.1em;
  border: none;
  border-radius: 10px;
  background: rgba(255,255,255,0.1);
  color: white;
  cursor: pointer;
  margin-bottom: 12px;
}

.settings-select option,
.settings-select optgroup {
  background: #1a3a5c;
  color: white;
}

.settings-custom-coords {
  display: flex;
  gap: 10px;
  margin-bottom: 12px;
}

.settings-custom-coords input {
  flex: 1;
  padding: 12px 14px;
  font-size: 1em;
  border: none;
  border-radius: 8px;
  background: rgba(255,255,255,0.1);
  color: white;
}

.settings-custom-coords input::placeholder {
  color: rgba(255,255,255,0.5);
}

/* Day Detail Panel */
.day-detail-panel {
  background: linear-gradient(180deg, #0d2840 0%, #1a3a5c 100%);
  border-top: 3px solid #d4a017;
  padding: 15px 20px;
  margin-top: 0;
}

.day-detail-panel.hidden {
  display: none;
}

.day-detail-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 12px;
  flex-wrap: wrap;
  gap: 10px;
}

.day-detail-date {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.day-detail-header .day-detail-astro-times {
  display: flex;
  flex-direction: column;
  font-size: 0.85em;
  background: rgba(255, 200, 100, 0.1);
  padding: 8px 12px;
  border-radius: 8px;
  border: 1px solid rgba(255, 200, 100, 0.2);
}

.day-detail-header .astro-times-title {
  font-weight: 600;
  color: #f0c040;
  margin-bottom: 6px;
  font-size: 0.95em;
}

.day-detail-header .astro-times-row {
  display: flex;
  gap: 16px;
}

.day-detail-header .astro-times-group {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.day-detail-header .astro-time {
  display: flex;
  justify-content: space-between;
  gap: 12px;
  white-space: nowrap;
}

.day-detail-header .astro-label {
  color: #888;
  text-align: left;
}

.day-detail-header .astro-value {
  color: #ddd;
  font-family: monospace;
  text-align: right;
}

.day-detail-lunar {
  font-size: 1.4em;
  font-weight: bold;
  color: #d4a017;
}

.day-detail-gregorian {
  font-size: 1em;
  color: #7ec8e3;
}

.day-detail-gregorian-row {
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.day-detail-jump-btn {
  background: #d4a017;
  border: none;
  color: #1a3a5c;
  font-size: 1em;
  font-weight: bold;
  cursor: pointer;
  padding: 4px 10px;
  border-radius: 4px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  line-height: 1;
  transition: all 0.2s;
  white-space: nowrap;
  flex-shrink: 0;
}

.day-detail-jump-btn:hover {
  background: #e5b328;
  transform: scale(1.1);
}

.day-detail-content {
  color: #fff;
}

.day-detail-feasts {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.day-detail-feast-item {
  display: flex;
  align-items: flex-start;
  gap: 12px;
  padding: 10px 12px;
  background: rgba(42, 90, 140, 0.5);
  border-radius: 8px;
  border-left: 3px solid #28a745;
}

.day-detail-feast-icon {
  font-size: 1.5em;
  line-height: 1;
}

.day-detail-feast-icon.blood-moon-icon {
  filter: sepia(1) saturate(5) hue-rotate(320deg) brightness(0.9);
  text-shadow: 0 0 10px rgba(180, 0, 0, 1), 0 0 20px rgba(255, 50, 50, 0.8), 0 0 30px rgba(200, 0, 0, 0.6);
  background: rgba(139, 0, 0, 0.3);
  border-radius: 50%;
  padding: 4px 6px;
}

.day-detail-feast-info {
  flex: 1;
}

.day-detail-feast-name {
  font-weight: bold;
  color: #90ee90;
  font-size: 1.1em;
  margin-bottom: 4px;
}

.day-detail-feast-desc {
  color: #ccc;
  font-size: 0.95em;
  line-height: 1.4;
}

.day-detail-feast-link {
  display: inline-block;
  margin-top: 6px;
  color: #7ec8e3;
  text-decoration: none;
  font-size: 0.9em;
}

.day-detail-feast-link:hover {
  text-decoration: underline;
}

.equinox-link {
  color: #d4a017;
  text-decoration: none;
  font-weight: bold;
  cursor: pointer;
}

.equinox-link:hover {
  text-decoration: underline;
  color: #f0c040;
}

.day-detail-info {
  margin-top: 12px;
  padding-top: 12px;
  border-top: 1px solid rgba(126, 200, 227, 0.3);
  color: #aaa;
  font-size: 0.9em;
}

.day-detail-dateline {
  margin-top: 16px;
  padding-top: 12px;
  border-top: 1px solid rgba(126, 200, 227, 0.3);
}

.day-detail-dateline .dateline-container {
  margin-top: 0;
  padding: 10px;
  background: rgba(0, 0, 0, 0.2);
  border-radius: 8px;
}

.day-detail-dateline .dateline-map {
  cursor: default;
  pointer-events: none;
}

.day-detail-dateline .dateline-click-hint {
  display: none;
}

.day-detail-profile-compare {
  margin-top: 16px;
  padding-top: 12px;
  border-top: 1px solid rgba(126, 200, 227, 0.3);
}

.profile-compare-title {
  font-size: 0.9em;
  color: #7ec8e3;
  margin-bottom: 8px;
  font-weight: 600;
}

.profile-compare-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
  gap: 8px;
}

.profile-compare-item {
  display: flex;
  flex-direction: column;
  padding: 8px 10px;
  background: rgba(0, 0, 0, 0.2);
  border-radius: 6px;
  font-size: 0.85em;
  cursor: pointer;
  transition: background 0.2s, border-color 0.2s;
  border: 1px solid transparent;
}

.profile-compare-item:hover {
  background: rgba(126, 200, 227, 0.15);
  border-color: rgba(126, 200, 227, 0.3);
}

.profile-compare-item.current {
  background: rgba(212, 160, 23, 0.15);
  border: 1px solid rgba(212, 160, 23, 0.3);
}

.profile-compare-item.current:hover {
  background: rgba(212, 160, 23, 0.2);
}

.profile-compare-name {
  color: #aaa;
  font-size: 0.9em;
  margin-bottom: 4px;
}

.profile-compare-item.current .profile-compare-name {
  color: #d4a017;
}

.profile-compare-day {
  color: #fff;
  font-weight: 600;
  font-size: 1em;
}

.profile-compare-feasts {
  margin-top: 4px;
  font-size: 1.1em;
  line-height: 1.2;
}

/* Old astro-times styles removed - now styled in .day-detail-header */

.feast-basis {
  margin-top: 8px;
  padding: 8px 10px;
  background: rgba(0, 0, 0, 0.2);
  border-radius: 4px;
  font-size: 0.9em;
  color: #aaa;
  line-height: 1.5;
}

.feast-basis strong {
  color: #d4a017;
}

/* Uncertainty warning for ancient dates */
.uncertainty-warning {
  margin-top: 8px;
  padding: 8px 10px;
  background: rgba(255, 193, 7, 0.15);
  border: 1px solid rgba(255, 193, 7, 0.4);
  border-radius: 4px;
  font-size: 0.85em;
  color: #ffc107;
  line-height: 1.4;
}

.uncertainty-warning .warning-icon {
  margin-right: 6px;
}

/* Date uncertainty - gold colored Gregorian date text only */
.day-cell.date-uncertain .gregorian,
.new-moon-box.date-uncertain .gregorian {
  color: #ffc107;
  font-weight: bold;
}

.day-detail-sabbath {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  color: #d4a017;
  font-weight: bold;
  margin-bottom: 8px;
}

.day-detail-no-feast {
  color: #888;
  font-style: italic;
  padding: 10px 0;
}

/* Feast Table */
.feast-list {
  margin-top: 30px;
  padding: 0 10px;
}

.feast-list h3 {
  color: #1a3a5c;
  margin-bottom: 15px;
}

.feast-table {
  width: 100%;
  border-collapse: collapse;
  background: white;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  border-radius: 8px;
  overflow: hidden;
}

.feast-table th {
  background: #1a3a5c;
  color: white;
  padding: 12px;
  text-align: left;
}

.feast-table td {
  padding: 12px;
  border-bottom: 1px solid #eee;
}

.feast-table tr:hover {
  background: #f8f9fa;
}

.feast-table .feast-jump {
  cursor: pointer;
}

.feast-table .feast-jump:hover {
  text-decoration: underline !important;
}

.feast-table td a {
  display: block;
}

.info-box {
  background: #e7f3ff;
  border-left: 4px solid #1a3a5c;
  padding: 15px;
  margin: 20px 0;
  font-size: 0.95em;
  border-radius: 0 8px 8px 0;
}

@media (max-width: 768px) {
  .calendar-app {
    max-width: 100%;
    padding: 0;
  }
  
  .month-calendar,
  .settings-page {
    border-radius: 0;
  }
  
  .settings-dialog,
  .month-picker,
  .date-jump-popup {
    width: calc(100% - 16px);
    max-width: none;
  }
  
  .settings-page-header {
    padding: 12px 15px;
  }
  
  .settings-section {
    padding: 15px;
  }
  
  .settings-option-btn {
    padding: 12px 15px;
  }
  
  .settings-option-btn .option-icon {
    font-size: 2em;
  }
  
  .settings-option-btn[data-phase] .option-icon {
    font-size: 2.8em;
  }
  
  .calendar-controls {
    flex-direction: column;
    gap: 10px;
    padding: 10px;
  }
  
  .control-group {
    width: 100%;
  }
  
  .control-group input,
  .control-group select {
    width: 100%;
    min-height: 44px; /* Touch-friendly */
  }
  
  .btn {
    min-height: 44px;
    font-size: 1em;
    flex: 1;
  }
  
  .control-group div[style*="display: flex"] {
    width: 100%;
  }
  
  
  .month-buttons {
    gap: 3px;
  }
  
  .month-btn {
    min-height: 36px;
    padding: 6px 2px;
    font-size: 0.85em;
  }
  
  .month-btn.month-13:not(.has-13) {
    display: none; /* Hide 13th month button on mobile unless year has 13 months */
  }
  
  .calendar-header {
    grid-template-columns: 1fr minmax(55px, calc(100vw / 7));
    gap: 0;
    padding: 0;
  }
  
  .header-left {
    gap: 6px;
    padding: 8px 10px;
    flex-shrink: 1;
    overflow: hidden;
    align-items: flex-end;
  }
  
  .new-moon-box {
    min-height: 60px;
    padding: 3px;
    width: calc(100vw / 7);
    min-width: 55px;
    flex-shrink: 0;
    align-self: end;
  }
  
  .new-moon-box .gregorian {
    font-size: 0.75em;
  }
  
  .new-moon-box .lunar-day {
    font-size: 1.1em;
  }
  
  .new-moon-box .feast-icons {
    font-size: 0.7em;
  }
  
  .full-moon-info .moon-icon {
    font-size: 52px;
  }
  
  .moon-gear-badge {
    font-size: 18px;
    bottom: -3px;
    right: -1px;
  }
  
  .calendar-title .profile-name {
    font-size: 0.75em;
  }
  
  .calendar-title .month-name {
    font-size: 1em;
  }
  
  .calendar-title .year {
    font-size: 0.9em;
  }
  
  .full-moon-info {
    font-size: 0.85em;
  }
  
  .week-header {
    font-size: 0.65em;
    gap: 2px;
  }
  
  .week-header > div {
    padding: 5px 2px;
  }
  
  .calendar-grid {
    gap: 2px;
  }
  
  .day-cell {
    min-height: 55px;
    padding: 3px;
  }
  
  .day-cell .lunar-day {
    font-size: 1.2em;
  }
  
  .day-cell .gregorian {
    font-size: 0.85em;
    color: #fff;
  }
  
  .day-cell .gregorian .day-year {
    font-size: 0.9em;
    color: #ffd700;
    font-weight: bold;
  }
  
  .day-cell .moon-phase {
    font-size: 0.65em;
  }
  
  .feast-icons {
    font-size: 0.85em !important;
  }
  
  .scripture-quote {
    font-size: 0.75em;
    padding: 8px;
  }
  
  .month-nav-cell .nav-arrow {
    font-size: 1.2em;
  }
  
  /* Feast table responsive */
  .feast-table-container {
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
  }
  
  .feast-table {
    font-size: 0.85em;
    min-width: 400px;
  }
  
  .feast-table th,
  .feast-table td {
    padding: 8px 6px;
  }
  
  /* Day detail panel mobile */
  .day-detail-panel {
    padding: 12px 15px;
  }
  
  .day-detail-lunar {
    font-size: 1.2em;
  }
  
  .day-detail-gregorian {
    font-size: 0.9em;
  }
  
  .day-detail-header {
    flex-direction: column;
    align-items: stretch;
  }
  
  .day-detail-header .day-detail-astro-times {
    width: 100%;
    font-size: 0.8em;
    padding: 8px 10px;
  }
  
  .day-detail-header .astro-times-row {
    justify-content: space-between;
  }
  
  /* Top nav mobile */
  .top-nav {
    padding: 8px 12px;
  }
  
  .top-nav-title {
    font-size: 1.1em;
  }
  
  .top-nav-tagline {
    font-size: 0.65em;
  }
  
  .hamburger-btn {
    font-size: 24px;
    padding: 6px;
  }
}

@media (max-width: 480px) {
  .day-cell {
    min-height: 48px;
    padding: 2px;
  }
  
  .day-cell .lunar-day {
    font-size: 1em;
  }
  
  .day-cell .gregorian {
    font-size: 0.8em;
    color: #fff;
  }
  
  .day-cell .gregorian .day-year {
    font-size: 0.85em;
    color: #ffd700;
    font-weight: bold;
  }
  
  .day-cell .moon-phase {
    font-size: 0.5em;
  }
  
  .new-moon-box {
    min-height: 50px;
    padding: 2px;
    width: calc(100vw / 7);
  }
  
  .new-moon-box .gregorian {
    font-size: 0.7em;
  }
  
  .new-moon-box .gregorian .day-year {
    display: none;
  }
  
  .new-moon-box .lunar-day {
    font-size: 1em;
  }
  
  .new-moon-box .feast-icons {
    font-size: 0.6em;
  }
  
  .feast-icons {
    font-size: 0.75em !important;
  }
  
  .week-header {
    font-size: 0.55em;
  }
  
  .month-btn {
    min-height: 32px;
    padding: 4px 1px;
    font-size: 0.75em;
  }

  .scripture-quote {
    font-size: 0.6em;
    padding: 3px;
  }
  
  .month-nav-cell .nav-arrow {
    font-size: 1em;
  }
}

@media print {
  .calendar-controls, .month-nav button, .info-box {
    display: none;
  }
  
  .month-calendar {
    break-inside: avoid;
  }
}
  </style>
</head>
<body>

<!-- Top Navigation Bar -->
<nav class="top-nav">
  <div class="top-nav-brand" onclick="navigateTo('calendar')" style="cursor: pointer;">
    <div class="top-nav-title">Lunar Sabbath</div>
    <div class="top-nav-tagline">a time tested tradition</div>
  </div>
  <button class="hamburger-btn" onclick="toggleNavMenu()" aria-label="Menu">‚ò∞</button>
</nav>

<!-- Navigation Menu Overlay -->
<div id="nav-menu-overlay" class="nav-menu-overlay" onclick="toggleNavMenu()"></div>

<!-- Navigation Menu -->
<div id="nav-menu" class="nav-menu">
  <div class="nav-menu-header">
    <h3>Menu</h3>
    <button class="nav-menu-close" onclick="toggleNavMenu()">‚úï</button>
  </div>
  <div class="nav-menu-items">
    <button class="nav-menu-item" onclick="navigateTo('calendar')">
      <span class="icon">üìÖ</span>
      <span>Calendar</span>
    </button>
    <button class="nav-menu-item" onclick="navigateTo('feasts')">
      <span class="icon">üé∫</span>
      <span>Feasts</span>
    </button>
    <button class="nav-menu-item" onclick="navigateTo('settings')">
      <span class="icon">‚öôÔ∏è</span>
      <span>Settings</span>
    </button>
    <div class="nav-menu-divider"></div>
    <a class="nav-menu-item" href="/book/">
      <span class="icon">üìñ</span>
      <span>Read the Book</span>
    </a>
  </div>
</div>

<div class="calendar-app">
  <!-- Settings Dialog (hidden by default) -->
  <div id="settings-overlay" class="settings-overlay" onclick="if(event.target === this) toggleSettings()"></div>
  <div id="settings-dialog" class="settings-dialog">
    <div class="settings-header">
      <h3>Month Sign & Location</h3>
      <button onclick="toggleSettings()" class="close-btn">‚úï</button>
    </div>
    <div class="settings-content">
      <div class="setting-group">
        <label>Month Starts At</label>
        <div class="moon-phase-buttons">
          <button class="moon-phase-btn" data-phase="full" onclick="selectMoonPhase('full')">
            <span class="phase-icon">üåï</span>
            <span class="phase-name">Full Moon</span>
          </button>
          <button class="moon-phase-btn" data-phase="dark" onclick="selectMoonPhase('dark')">
            <span class="phase-icon">üåë</span>
            <span class="phase-name">Dark Moon</span>
          </button>
          <button class="moon-phase-btn" data-phase="crescent" onclick="selectMoonPhase('crescent')">
            <span class="phase-icon">üåí</span>
            <span class="phase-name">Crescent</span>
          </button>
        </div>
        <select id="moon-phase-select" style="display: none;">
          <option value="full">Full Moon</option>
          <option value="dark">Dark Moon (Conjunction)</option>
          <option value="crescent">Crescent Moon (First Visible)</option>
        </select>
      </div>
      
      <div class="setting-group">
        <label>Your Location</label>
        <div id="settings-map-container"></div>
        <select id="city-select" class="city-select-styled">
          <optgroup label="Biblical">
            <option value="31.7683,35.2137">Jerusalem</option>
          </optgroup>
          <optgroup label="United States">
            <option value="40.7128,-74.0060">New York (Eastern)</option>
            <option value="41.8781,-87.6298">Chicago (Central)</option>
            <option value="39.7392,-104.9903">Denver (Mountain)</option>
            <option value="34.0522,-118.2437">Los Angeles (Pacific)</option>
            <option value="61.2181,-149.9003">Anchorage (Alaska)</option>
            <option value="21.3069,-157.8583">Honolulu (Hawaii)</option>
          </optgroup>
          <optgroup label="International">
            <option value="51.5074,-0.1278">London</option>
            <option value="48.8566,2.3522">Paris</option>
            <option value="35.6762,139.6503">Tokyo</option>
            <option value="-33.8688,151.2093">Sydney</option>
          </optgroup>
          <option value="">Custom Coordinates...</option>
        </select>
        <div class="setting-group" id="custom-coords" style="display: none;">
          <div style="display: flex; gap: 10px; margin-top: 10px;">
            <input type="number" id="lat-input" value="31.7683" step="0.0001" placeholder="Latitude">
            <input type="number" id="lon-input" value="35.2137" step="0.0001" placeholder="Longitude">
          </div>
        </div>
        <button type="button" class="location-btn" onclick="useCurrentLocation()">üìç Use My Current Location</button>
      </div>
      
      <div class="setting-info">
        The location determines when the lunar day begins for you.
      </div>
    </div>
  </div>

  <!-- Hidden inputs for state -->
  <input type="number" id="year-input" value="2026" min="-4000" max="4000" style="display: none;">
  <span id="year-display" style="display: none;"></span>
  <input type="datetime-local" id="goto-date" step="60" style="display: none;">
  <input type="number" id="add-days" value="1" min="1" style="display: none;">
  
  <!-- Month Picker Popup -->
  <div id="month-picker-overlay" class="month-picker-overlay" onclick="if(event.target === this) toggleMonthPicker()"></div>
  <div id="month-picker" class="month-picker" style="display: none;">
    <div class="month-picker-header">
      <h3>Select Month</h3>
      <button class="close-btn" onclick="toggleMonthPicker()">‚úï</button>
    </div>
    <div class="year-nav">
      <button onclick="changePickerYear(-1)">‚óÄ</button>
      <span id="picker-year" class="year-display" onclick="showYearInput()" title="Click to enter year"></span>
      <input type="number" id="picker-year-input" class="year-input" style="display: none;" 
             onkeydown="if(event.key==='Enter') applyYearInput(); if(event.key==='Escape') hideYearInput();"
             onblur="hideYearInput()">
      <button onclick="changePickerYear(1)">‚ñ∂</button>
    </div>
    <div id="month-grid" class="month-grid"></div>
  </div>
  
  <!-- Date Jump Popup -->
  <div id="date-jump-overlay" class="date-jump-overlay" onclick="if(event.target === this) toggleDateJump()"></div>
  <div id="date-jump-popup" class="date-jump-popup" style="display: none;">
    <button class="close-btn" onclick="toggleDateJump()">‚úï</button>
    <h3>Jump to Date</h3>
    <div id="jump-ancient-display" style="display: none; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 4px; margin-bottom: 10px; text-align: center;">
      <div style="color: #d4a017; font-size: 1.1em;" id="jump-ancient-date"></div>
      <div style="color: #888; font-size: 0.85em; margin-top: 4px;">Date picker unavailable for BC dates</div>
    </div>
    <input type="datetime-local" id="jump-datetime" step="60">
    <div class="btn-row">
      <button class="btn secondary" onclick="jumpToTodayFromPopup()">Jump to Today</button>
    </div>
    <div class="days-jump">
      <button onclick="addDaysFromPopup(-1)">‚óÄ</button>
      <input type="number" id="jump-days" value="1" min="1">
      <button onclick="addDaysFromPopup(1)">‚ñ∂</button>
      <span>days</span>
    </div>
  </div>
  
  <!-- Hidden month buttons container (for compatibility) -->
  <div id="month-buttons" style="display: none;"></div>

  <div id="calendar-output"></div>

  <!-- Settings Page Overlay -->
  <div id="settings-page-overlay" class="settings-page-overlay" onclick="toggleSettings()"></div>
  
  <!-- Settings Page - slides in from right -->
  <div id="settings-page" class="settings-page">
    <div class="settings-page-header">
      <h2>Settings</h2>
      <button class="close-btn" onclick="navigateTo('calendar')" aria-label="Close">‚úï</button>
    </div>
    
    <div class="settings-section">
      <h3>Profile</h3>
      <p class="settings-description">Select a preset or customize settings below.</p>
      <div class="profile-row">
        <select id="profile-select" class="profile-select" onchange="onProfileSelectChange(this.value)">
          <option value="biblicalFull">üåï Biblical Full Moon ‚Äî Morning Nautical Twilight, Jerusalem</option>
          <option value="fullMoon">üåï Full Moon ‚Äî Morning Nautical Twilight, Your Location</option>
          <option value="biblicalDark">üåë Biblical Dark Moon ‚Äî Evening Sunset, Jerusalem</option>
          <option value="biblicalCrescent">üåí Biblical Crescent Moon ‚Äî Evening Sunset, Jerusalem</option>
        </select>
        <button id="profile-clone-btn" class="profile-icon-btn" onclick="cloneProfile()" title="Clone as new profile">+</button>
        <button id="profile-edit-btn" class="profile-icon-btn" onclick="editProfileName()" title="Rename profile" disabled>‚úèÔ∏è</button>
        <button id="profile-delete-btn" class="profile-icon-btn" onclick="deleteCustomProfile()" title="Delete profile" disabled>üóëÔ∏è</button>
      </div>
    </div>
    
    <div class="settings-section">
      <h3>Month Starts At</h3>
      <p class="settings-description">Choose which lunar phase marks the beginning of each month.</p>
      <div class="settings-options">
        <button class="settings-option-btn" data-phase="full" onclick="selectMoonPhase('full')">
          <span class="option-icon">üåï</span>
          <span class="option-label">Full Moon</span>
        </button>
        <button class="settings-option-btn" data-phase="dark" onclick="selectMoonPhase('dark')">
          <span class="option-icon">üåë</span>
          <span class="option-label">Dark Moon</span>
        </button>
        <button class="settings-option-btn" data-phase="crescent" onclick="selectMoonPhase('crescent')">
          <span class="option-icon">üåí</span>
          <span class="option-label">Crescent</span>
        </button>
      </div>
    </div>
    
    <div id="crescent-threshold-section" class="settings-section" style="display: none;">
      <h3>Crescent Visibility Timing</h3>
      <p class="settings-description">Hours after conjunction when crescent moon is considered visible.</p>
      <div class="settings-options">
        <button class="settings-option-btn" data-threshold="12" onclick="selectCrescentThreshold(12)">
          <span class="option-label">12h Optimistic</span>
          <span class="option-hint">Perfect conditions + optical aids</span>
        </button>
        <button class="settings-option-btn" data-threshold="15.5" onclick="selectCrescentThreshold(15.5)">
          <span class="option-label">15.5h Minimum</span>
          <span class="option-hint">Naked-eye record, ideal conditions</span>
        </button>
        <button class="settings-option-btn" data-threshold="18" onclick="selectCrescentThreshold(18)">
          <span class="option-label">18h Typical</span>
          <span class="option-hint">Standard naked-eye visibility</span>
        </button>
        <button class="settings-option-btn" data-threshold="24" onclick="selectCrescentThreshold(24)">
          <span class="option-label">24h Conservative</span>
          <span class="option-hint">Easily visible to anyone</span>
        </button>
      </div>
    </div>
    
    <div class="settings-section">
      <h3>Day Starts At</h3>
      <p class="settings-description">Choose when each day begins.</p>
      <div class="settings-options" style="margin-bottom: 15px;">
        <button class="settings-option-btn" data-daystart="evening" onclick="selectDayStartTime('evening')">
          <span class="option-icon">üåÖ</span>
          <span class="option-label">Evening</span>
        </button>
        <button class="settings-option-btn" data-daystart="morning" onclick="selectDayStartTime('morning')">
          <span class="option-icon">üåÑ</span>
          <span class="option-label">Morning</span>
        </button>
      </div>
      <p class="settings-description">Sun position below horizon:</p>
      <div class="settings-options">
        <button class="settings-option-btn" data-angle="0" onclick="selectDayStartAngle(0)">
          <span class="option-label">0¬∞ Horizon</span>
          <span class="option-hint">Sun at horizon</span>
        </button>
        <button class="settings-option-btn" data-angle="6" onclick="selectDayStartAngle(6)">
          <span class="option-label">6¬∞ Civil</span>
          <span class="option-hint">Bright stars visible</span>
        </button>
        <button class="settings-option-btn" data-angle="12" onclick="selectDayStartAngle(12)">
          <span class="option-label">12¬∞ Nautical</span>
          <span class="option-hint">Most stars visible</span>
        </button>
        <button class="settings-option-btn" data-angle="18" onclick="selectDayStartAngle(18)">
          <span class="option-label">18¬∞ Astronomical</span>
          <span class="option-hint">Fully dark</span>
        </button>
      </div>
    </div>
    
    <div class="settings-section">
      <h3>Year Starts At</h3>
      <p class="settings-description">Choose the rule for determining the first month of the year.</p>
      <div class="settings-options">
        <button class="settings-option-btn" data-yearstart="equinox" onclick="selectYearStartRule('equinox')">
          <span class="option-icon" id="yearstart-equinox-icon">üåï</span>
          <span class="option-label">Renewed Moon after Equinox</span>
          <span class="option-hint" id="yearstart-equinox-hint">Month 1 starts after spring equinox</span>
        </button>
        <button class="settings-option-btn" data-yearstart="13daysBefore" onclick="selectYearStartRule('13daysBefore')">
          <span class="option-icon">üêë</span>
          <span class="option-label">Passover after Equinox</span>
          <span class="option-hint" id="yearstart-passover-hint">Day 14 of Month 1 after equinox</span>
        </button>
      </div>
    </div>
    
    <div class="settings-section">
      <h3>Sabbath Day</h3>
      <p class="settings-description">Choose how the Sabbath day is determined and highlighted.</p>
      <div class="settings-options">
        <button class="settings-option-btn" data-sabbath="lunar" onclick="selectSabbathMode('lunar')">
          <span class="option-icon">üåï</span>
          <span class="option-label">Lunar Sabbath</span>
          <span class="option-hint">Days 8, 15, 22, 29 of each month</span>
        </button>
        <button class="settings-option-btn" data-sabbath="saturday" onclick="selectSabbathMode('saturday')">
          <span class="option-icon">ü™ê</span>
          <span class="option-label">Saturday</span>
          <span class="option-hint">Fixed weekly Sabbath</span>
        </button>
        <button class="settings-option-btn" data-sabbath="sunday" onclick="selectSabbathMode('sunday')">
          <span class="option-icon">‚òÄÔ∏è</span>
          <span class="option-label">Sunday</span>
          <span class="option-hint">Christian day of rest</span>
        </button>
      </div>
      <div class="settings-row" style="margin-top: 15px;">
        <label class="settings-row-label">Other fixed day:</label>
        <select id="sabbath-day-select" class="settings-select" onchange="selectSabbathDayFromDropdown(this.value)">
          <option value="">‚Äî Choose ‚Äî</option>
          <option value="none">None</option>
          <option value="monday">Monday</option>
          <option value="tuesday">Tuesday</option>
          <option value="wednesday">Wednesday</option>
          <option value="thursday">Thursday</option>
          <option value="friday">Friday</option>
        </select>
      </div>
    </div>
    
    <div class="settings-section">
      <h3>Astronomy Engine</h3>
      <p class="settings-description">The library used for calculating lunar phases and equinoxes. Different engines use different ŒîT models, which affects accuracy for ancient dates.</p>
      <div id="astro-engine-info" class="settings-engine-info">
        <div class="engine-info-row">
          <span class="engine-info-label">Library:</span>
          <span id="astro-engine-name" class="engine-info-value">astronomy-engine v2.1.19</span>
        </div>
        <div class="engine-info-row">
          <span class="engine-info-label">ŒîT Model:</span>
          <span id="astro-engine-delta" class="engine-info-value">Espenak-Meeus polynomial</span>
        </div>
        <div class="engine-info-row">
          <span class="engine-info-label">Note:</span>
          <span class="engine-info-value" style="color: rgba(255,255,255,0.6); font-family: inherit;">For ancient dates (before 500 BC), ŒîT uncertainty is ¬±hours. Different sources may vary.</span>
        </div>
      </div>
    </div>
    
    <div class="settings-section">
      <h3>Your Location</h3>
      <p class="settings-description">Your location determines the timing of sunrise, sunset, and twilight.</p>
      <div id="settings-page-map"></div>
      <select id="settings-city-select" class="settings-select">
        <option value="current">üìç Use Current Location</option>
        <optgroup label="Biblical">
          <option value="31.7683,35.2137">Jerusalem</option>
        </optgroup>
        <optgroup label="United States">
          <option value="40.7128,-74.0060">New York (Eastern)</option>
          <option value="41.8781,-87.6298">Chicago (Central)</option>
          <option value="39.7392,-104.9903">Denver (Mountain)</option>
          <option value="34.0522,-118.2437">Los Angeles (Pacific)</option>
          <option value="61.2181,-149.9003">Anchorage (Alaska)</option>
          <option value="21.3069,-157.8583">Honolulu (Hawaii)</option>
        </optgroup>
        <optgroup label="International">
          <option value="51.5074,-0.1278">London</option>
          <option value="48.8566,2.3522">Paris</option>
          <option value="35.6762,139.6503">Tokyo</option>
          <option value="-33.8688,151.2093">Sydney</option>
        </optgroup>
        <option value="custom">Custom Coordinates...</option>
      </select>
      <div id="settings-custom-coords" class="settings-custom-coords" style="display: none;">
        <input type="number" id="settings-lat-input" step="0.0001" placeholder="Latitude">
        <input type="number" id="settings-lon-input" step="0.0001" placeholder="Longitude">
      </div>
    </div>
  </div>

  <!-- Day Detail Panel - slides up when a day is selected -->
  <div id="day-detail-panel" class="day-detail-panel hidden">
    <div class="day-detail-header">
      <div class="day-detail-date">
        <span class="day-detail-lunar"></span>
        <span class="day-detail-gregorian-row">
          <span class="day-detail-gregorian"></span>
          <button class="day-detail-jump-btn" onclick="toggleDateJump()" title="Jump to another date">‚á•</button>
        </span>
      </div>
      <div class="day-detail-astro-times"></div>
    </div>
    <div class="day-detail-content">
      <div class="day-detail-feasts"></div>
      <div class="day-detail-info"></div>
      <div class="day-detail-dateline"></div>
      <div class="day-detail-profile-compare"></div>
    </div>
  </div>

  <!-- Feast table hidden from main page - shown in export modal -->
  <div class="feast-list" style="display: none;">
    <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px; margin-bottom: 15px;">
      <h3 style="margin: 0;">Appointed Times for <span id="feast-year">2026</span></h3>
      <button class="btn" onclick="openInCalendar()" title="Download all Sabbaths and Feasts for this year">üìÖ Export Year to Calendar App</button>
    </div>
    <div class="feast-table-container">
    <table class="feast-table">
      <thead>
        <tr>
          <th>Feast</th>
          <th>Date</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody id="feast-tbody"></tbody>
    </table>
    </div>
  </div>
</div>

<!-- Profile Name Modal -->
<div id="profile-modal-overlay" class="profile-modal-overlay" onclick="closeProfileModal(event)">
  <div class="profile-modal" onclick="event.stopPropagation()">
    <h3 id="profile-modal-title">Create New Profile</h3>
    <input type="text" id="profile-modal-input" class="profile-modal-input" placeholder="Enter profile name" onkeydown="handleProfileModalKeydown(event)">
    <div id="profile-modal-error" class="profile-modal-error"></div>
    <div class="profile-modal-buttons">
      <button class="profile-modal-btn cancel" onclick="closeProfileModal()">Cancel</button>
      <button id="profile-modal-save-btn" class="profile-modal-btn save" onclick="saveProfileModal()">Create</button>
    </div>
  </div>
</div>

<!-- Export/Feasts Page -->
<div id="export-page" class="export-page" style="display: none;">
  <div class="settings-page-header export-header">
    <h2>Appointed Times for <span id="export-year">2026</span></h2>
    <button class="btn export-download-btn" onclick="openInCalendar()">üìÖ Export</button>
  </div>
  <div class="export-settings-context">
    <span id="export-context-text">Loading settings...</span>
  </div>
  <div class="settings-content" style="padding-top: 0;">
    <div class="feast-table-container">
      <table class="feast-table">
        <thead>
          <tr>
            <th>Feast</th>
            <th>Date</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody id="export-feast-tbody"></tbody>
      </table>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/astronomy-engine@2.1.19/astronomy.browser.min.js"></script>
<script>
// ============================================================================
// ASTRONOMY ENGINE ABSTRACTION LAYER
// ============================================================================
// This abstraction allows switching between different astronomy calculation
// libraries (astronomy-engine, Swiss Ephemeris WASM, etc.) without changing
// the rest of the codebase.

// Available engines registry
const AstroEngines = {};

// Currently active engine instance
let activeAstroEngine = null;

// Engine interface definition (for documentation):
// {
//   name: string,                          // Human-readable name
//   version: string,                       // Library version
//   deltaTModel: string,                   // ŒîT model used
//   isLoaded: boolean,                     // Whether engine is ready
//   
//   // Core methods:
//   searchMoonPhase(phase, startDate, limitDays) => { date: Date } | null
//   getSeasons(year) => { mar_equinox: { date: Date }, ... }
//   searchRiseSet(body, observer, direction, startDate, limitDays) => { date: Date } | null
//   searchAltitude(body, observer, direction, startDate, limitDays, altitude) => { date: Date } | null
//   getEquator(body, date, observer) => { ra: number, dec: number }
//   getHorizon(date, observer, ra, dec) => { altitude: number, azimuth: number }
//   getDeltaT(date) => number (in seconds)
//   createObserver(lat, lon, elevation) => observer object
// }

// ============================================================================
// ASTRONOMY-ENGINE IMPLEMENTATION
// ============================================================================
AstroEngines.astronomyEngine = {
  name: 'astronomy-engine',
  version: '2.1.19',
  deltaTModel: 'Espenak-Meeus polynomial',
  deltaTNote: 'Good for modern dates; ~9.5h ŒîT uncertainty at 1500 BC',
  isLoaded: true, // Loaded synchronously via script tag
  
  searchMoonPhase(phase, startDate, limitDays) {
    return Astronomy.SearchMoonPhase(phase, startDate, limitDays);
  },
  
  getSeasons(year) {
    return Astronomy.Seasons(year);
  },
  
  searchRiseSet(body, observer, direction, startDate, limitDays) {
    const astroBody = body === 'sun' ? Astronomy.Body.Sun : Astronomy.Body.Moon;
    return Astronomy.SearchRiseSet(astroBody, observer, direction, startDate, limitDays);
  },
  
  searchAltitude(body, observer, direction, startDate, limitDays, altitude) {
    const astroBody = body === 'sun' ? Astronomy.Body.Sun : Astronomy.Body.Moon;
    return Astronomy.SearchAltitude(astroBody, observer, direction, startDate, limitDays, altitude);
  },
  
  getEquator(body, date, observer) {
    // Validate date before calling astronomy-engine
    if (!date || isNaN(date.getTime())) {
      return { ra: 0, dec: 0 };
    }
    try {
      const astroBody = body === 'sun' ? Astronomy.Body.Sun : Astronomy.Body.Moon;
      const result = Astronomy.Equator(astroBody, date, observer, true, true);
      
      // Validate result
      if (result && isFinite(result.ra) && isFinite(result.dec)) {
        return result;
      }
      return { ra: 0, dec: 0 };
    } catch (err) {
      return { ra: 0, dec: 0 };
    }
  },
  
  getHorizon(date, observer, ra, dec) {
    // Validate inputs before calling astronomy-engine
    if (!date || isNaN(date.getTime()) || !isFinite(ra) || !isFinite(dec)) {
      return { altitude: 0, azimuth: 0 };
    }
    try {
      const result = Astronomy.Horizon(date, observer, ra, dec, 'normal');
      if (result && isFinite(result.altitude) && isFinite(result.azimuth)) {
        return result;
      }
      return { altitude: 0, azimuth: 0 };
    } catch (err) {
      return { altitude: 0, azimuth: 0 };
    }
  },
  
  getDeltaT(date) {
    // astronomy-engine doesn't expose DeltaT directly, but we can calculate it
    // from the difference between TT and UT
    const astroTime = new Astronomy.AstroTime(date);
    return (astroTime.tt - astroTime.ut) * 86400; // Convert days to seconds
  },
  
  createObserver(lat, lon, elevation = 0) {
    return new Astronomy.Observer(lat, lon, elevation);
  }
};

// ============================================================================
// SWISS EPHEMERIS WASM IMPLEMENTATION (@swisseph/browser - self-hosted)
// ============================================================================
AstroEngines.swissEphemeris = {
  name: 'Swiss Ephemeris',
  version: 'Loading...',
  deltaTModel: 'Moshier Ephemeris',
  deltaTNote: 'Built-in analytical ephemeris; good for dates from 3000 BC to 3000 AD',
  isLoaded: false,
  _swe: null,
  _module: null,
  _loadPromise: null,
  
  async load() {
    if (this.isLoaded) return true;
    if (this._loadPromise) return this._loadPromise;
    
    this._loadPromise = (async () => {
      try {
        // Dynamic import of self-hosted @swisseph/browser
        const module = await import('/lib/swisseph/swisseph-browser.js');
        this._module = module;
        
        // Create SwissEphemeris instance and initialize WASM with explicit path
        this._swe = new module.SwissEphemeris();
        await this._swe.init('/lib/swisseph/swisseph.wasm');
        
        this.version = '1.1.0';
        this.isLoaded = true;
        console.log('Swiss Ephemeris WASM loaded successfully');
        return true;
      } catch (err) {
        console.error('Failed to load Swiss Ephemeris WASM:', err);
        this.isLoaded = false;
        return false;
      }
    })();
    
    return this._loadPromise;
  },
  
  // Julian Day conversion helpers
  _dateToJD(date) {
    const y = date.getUTCFullYear();
    const m = date.getUTCMonth() + 1;
    const d = date.getUTCDate();
    const h = date.getUTCHours() + date.getUTCMinutes() / 60 + date.getUTCSeconds() / 3600;
    
    const a = Math.floor((14 - m) / 12);
    const yy = y + 4800 - a;
    const mm = m + 12 * a - 3;
    
    // Julian calendar for dates before Oct 15, 1582
    // Gregorian calendar for dates on or after Oct 15, 1582
    let jdn;
    if (y < 1582 || (y === 1582 && (m < 10 || (m === 10 && d < 15)))) {
      jdn = d + Math.floor((153 * mm + 2) / 5) + 365 * yy + Math.floor(yy / 4) - 32083;
    } else {
      jdn = d + Math.floor((153 * mm + 2) / 5) + 365 * yy + Math.floor(yy / 4) - Math.floor(yy / 100) + Math.floor(yy / 400) - 32045;
    }
    return jdn + (h - 12) / 24;
  },
  
  _jdToDate(jd) {
    // Helper to create Date with proper year handling (including negative years)
    const createDate = (year, month, day, h, min, sec) => {
      // JavaScript Date.UTC interprets years 0-99 as 1900-1999
      // We need to use setUTCFullYear for ancient dates
      const date = new Date(Date.UTC(2000, month - 1, day, h, min, sec));
      date.setUTCFullYear(year);
      return date;
    };
    
    if (!this._swe) {
      // Manual Julian Day to calendar date conversion
      const z = Math.floor(jd + 0.5);
      const f = jd + 0.5 - z;
      let a = z;
      if (z >= 2299161) {
        const alpha = Math.floor((z - 1867216.25) / 36524.25);
        a = z + 1 + alpha - Math.floor(alpha / 4);
      }
      const b = a + 1524;
      const c = Math.floor((b - 122.1) / 365.25);
      const d = Math.floor(365.25 * c);
      const e = Math.floor((b - d) / 30.6001);
      
      const day = b - d - Math.floor(30.6001 * e);
      const month = e < 14 ? e - 1 : e - 13;
      const year = month > 2 ? c - 4716 : c - 4715;
      
      const hours = f * 24;
      const h = Math.floor(hours);
      const minutes = (hours - h) * 60;
      const min = Math.floor(minutes);
      const sec = Math.floor((minutes - min) * 60);
      
      return createDate(year, month, day, h, min, sec);
    }
    
    // Use library's conversion
    try {
      const cal = this._swe.julianDayToDate(jd);
      // The library might return hours as a decimal or separate hour/minute/second fields
      let h = 0, min = 0, sec = 0;
      if (typeof cal.hours === 'number') {
        h = Math.floor(cal.hours);
        min = Math.floor((cal.hours % 1) * 60);
        sec = Math.floor(((cal.hours % 1) * 60 % 1) * 60);
      } else if (typeof cal.hour === 'number') {
        h = cal.hour;
        min = cal.minute || 0;
        sec = Math.floor(cal.second || 0);
      }
      
      return createDate(cal.year, cal.month, cal.day, h, min, sec);
    } catch (err) {
      console.warn('Swiss Ephemeris julianDayToDate failed, using manual conversion:', err);
      // Fall through to manual calculation
      const z = Math.floor(jd + 0.5);
      const f = jd + 0.5 - z;
      let a = z;
      if (z >= 2299161) {
        const alpha = Math.floor((z - 1867216.25) / 36524.25);
        a = z + 1 + alpha - Math.floor(alpha / 4);
      }
      const b = a + 1524;
      const c = Math.floor((b - 122.1) / 365.25);
      const d = Math.floor(365.25 * c);
      const e = Math.floor((b - d) / 30.6001);
      
      const day = b - d - Math.floor(30.6001 * e);
      const month = e < 14 ? e - 1 : e - 13;
      const year = month > 2 ? c - 4716 : c - 4715;
      
      const hours = f * 24;
      const hh = Math.floor(hours);
      const minutes = (hours - hh) * 60;
      const mm = Math.floor(minutes);
      const ss = Math.floor((minutes - mm) * 60);
      
      return createDate(year, month, day, hh, mm, ss);
    }
  },
  
  // Get Moon-Sun elongation for phase calculations
  _getMoonSunElongation(jd) {
    if (!this._swe || !this._module) return null;
    
    try {
      const Planet = this._module.Planet;
      const sunPos = this._swe.calculatePosition(jd, Planet.Sun);
      const moonPos = this._swe.calculatePosition(jd, Planet.Moon);
      
      if (sunPos.longitude === undefined || moonPos.longitude === undefined) {
        return null;
      }
      
      let elongation = moonPos.longitude - sunPos.longitude;
      while (elongation < 0) elongation += 360;
      while (elongation >= 360) elongation -= 360;
      return elongation;
    } catch (err) {
      return null;
    }
  },
  
  searchMoonPhase(phase, startDate, limitDays) {
    if (!this.isLoaded || !this._swe) {
      return AstroEngines.astronomyEngine.searchMoonPhase(phase, startDate, limitDays);
    }
    
    const startJD = this._dateToJD(startDate);
    const endJD = startJD + limitDays;
    const step = 1;
    
    let prevJD = startJD;
    let prevElong = this._getMoonSunElongation(prevJD);
    if (prevElong === null) {
      return AstroEngines.astronomyEngine.searchMoonPhase(phase, startDate, limitDays);
    }
    
    const targetPhase = phase % 360;
    
    for (let jd = startJD + step; jd <= endJD; jd += step) {
      let elong = this._getMoonSunElongation(jd);
      if (elong === null) continue;
      
      // Check for phase crossing (handling 360‚Üí0 wrap)
      let crossed = false;
      if (targetPhase === 0) {
        // New moon: elongation wraps from ~359¬∞ down to ~1¬∞ (crosses 0¬∞)
        // This happens when prevElong is high (>300) and elong is low (<60)
        if (prevElong > 300 && elong < 60) crossed = true;
      } else if (targetPhase === 180) {
        // Full moon: elongation crossing 180 from below
        if (prevElong < 180 && elong >= 180) crossed = true;
      } else {
        // Other phases
        if ((prevElong < targetPhase && elong >= targetPhase) ||
            (prevElong > targetPhase && elong <= targetPhase && Math.abs(prevElong - elong) < 180)) {
          crossed = true;
        }
      }
      
      if (crossed) {
        // Refine with bisection
        let lo = prevJD, hi = jd;
        for (let i = 0; i < 20; i++) { // ~1 second precision
          const mid = (lo + hi) / 2;
          const midElong = this._getMoonSunElongation(mid);
          if (midElong === null) break;
          
          if (targetPhase === 0) {
            // New moon: we want to find where elongation is closest to 0
            // If midElong > 180, we're before the crossing (moon catching up)
            if (midElong > 180) lo = mid; else hi = mid;
          } else if (targetPhase === 180) {
            if (midElong < 180) lo = mid; else hi = mid;
          } else {
            if (midElong < targetPhase) lo = mid; else hi = mid;
          }
        }
        
        const resultJD = (lo + hi) / 2;
        return { date: this._jdToDate(resultJD), jd: resultJD };
      }
      
      prevJD = jd;
      prevElong = elong;
    }
    
    return null;
  },
  
  getSeasons(year) {
    if (!this.isLoaded || !this._swe || !this._module) {
      return AstroEngines.astronomyEngine.getSeasons(year);
    }
    
    try {
      const Planet = this._module.Planet;
      
      // Start search around March 1
      // Use setUTCFullYear for proper handling of negative/ancient years
      const startDate = new Date(Date.UTC(2000, 2, 1));
      startDate.setUTCFullYear(year);
      let jd = this._dateToJD(startDate);
      const endJD = jd + 30;
      
      let prevLon = null;
      for (; jd <= endJD; jd += 0.5) {
        const sunPos = this._swe.calculatePosition(jd, Planet.Sun);
        const lon = sunPos.longitude;
        
        // Spring equinox: Sun crossing 0¬∞ from ~359¬∞ to ~1¬∞
        if (prevLon !== null && prevLon > 350 && lon < 10) {
          // Refine with bisection
          let lo = jd - 0.5, hi = jd;
          for (let i = 0; i < 20; i++) {
            const mid = (lo + hi) / 2;
            const midPos = this._swe.calculatePosition(mid, Planet.Sun);
            const midLon = midPos.longitude;
            if (midLon > 180) lo = mid; else hi = mid;
          }
          
          return {
            mar_equinox: { date: this._jdToDate((lo + hi) / 2) }
          };
        }
        prevLon = lon;
      }
    } catch (err) {
      console.warn('Error finding equinox with Swiss Ephemeris:', err);
    }
    
    // Fallback
    return AstroEngines.astronomyEngine.getSeasons(year);
  },
  
  searchRiseSet(body, observer, direction, startDate, limitDays) {
    // Swiss Ephemeris rise/set calculation is complex, use fallback for now
    return AstroEngines.astronomyEngine.searchRiseSet(body, observer, direction, startDate, limitDays);
  },
  
  searchAltitude(body, observer, direction, startDate, limitDays, altitude) {
    return AstroEngines.astronomyEngine.searchAltitude(body, observer, direction, startDate, limitDays, altitude);
  },
  
  getEquator(body, date, observer) {
    if (!this.isLoaded || !this._swe || !this._module) {
      return AstroEngines.astronomyEngine.getEquator(body, date, observer);
    }
    
    try {
      const Planet = this._module.Planet;
      const CalculationFlag = this._module.CalculationFlag;
      const planet = body === 'sun' ? Planet.Sun : Planet.Moon;
      const jd = this._dateToJD(date);
      
      // Get equatorial coordinates
      const pos = this._swe.calculatePosition(jd, planet, CalculationFlag.Equatorial);
      
      // Validate result - if invalid, fall back to astronomy-engine
      if (pos && isFinite(pos.rightAscension) && isFinite(pos.declination)) {
        return {
          ra: pos.rightAscension / 15, // Convert degrees to hours
          dec: pos.declination
        };
      }
      
      // Invalid result, fall back
      return AstroEngines.astronomyEngine.getEquator(body, date, observer);
    } catch (err) {
      return AstroEngines.astronomyEngine.getEquator(body, date, observer);
    }
  },
  
  getHorizon(date, observer, ra, dec) {
    // Use astronomy-engine for horizon conversion (simpler)
    return AstroEngines.astronomyEngine.getHorizon(date, observer, ra, dec);
  },
  
  getDeltaT(date) {
    if (!this.isLoaded || !this._swe) {
      return AstroEngines.astronomyEngine.getDeltaT(date);
    }
    
    try {
      const jd = this._dateToJD(date);
      const deltaT = this._swe.deltaT(jd);
      return deltaT * 86400; // Convert days to seconds
    } catch (err) {
      return AstroEngines.astronomyEngine.getDeltaT(date);
    }
  },
  
  createObserver(lat, lon, elevation = 0) {
    // Use astronomy-engine observer format for compatibility
    return new Astronomy.Observer(lat, lon, elevation);
  }
};

// ============================================================================
// HYBRID ENGINE: Swiss Ephemeris calibrated against NASA Eclipse anchors
// ============================================================================
// This approach uses Swiss Ephemeris for precise local calculations, but
// calibrates the ŒîT model against NASA eclipse data to reduce drift for 
// ancient dates. NASA eclipses are observable historical events with known
// times, providing ground truth for ŒîT corrections.
// ============================================================================
AstroEngines.nasaEclipse = {
  name: 'Hybrid (Swiss Eph + NASA)',
  version: '1.0',
  deltaTModel: 'NASA Eclipse Calibrated',
  deltaTNote: 'Swiss Ephemeris calculations aligned to NASA eclipse anchors',
  isLoaded: false,
  _eclipses: null,  // Array of {jd, y, t} where t='n' (new) or 'f' (full)
  _loadPromise: null,
  _offsetCache: new Map(), // Cache offset calculations by year
  
  async load() {
    if (this.isLoaded) return true;
    if (this._loadPromise) return this._loadPromise;
    
    this._loadPromise = (async () => {
      try {
        const response = await fetch('/data/eclipses.json');
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        this._eclipses = await response.json();
        this.isLoaded = true;
        console.log(`NASA Eclipse data loaded: ${this._eclipses.length} eclipses`);
        return true;
      } catch (err) {
        console.error('Failed to load NASA eclipse data:', err);
        this.isLoaded = false;
        return false;
      }
    })();
    
    return this._loadPromise;
  },
  
  // Julian Day conversion (handles both Julian and Gregorian calendars)
  _dateToJD(date) {
    const y = date.getUTCFullYear();
    const m = date.getUTCMonth() + 1;
    const d = date.getUTCDate();
    const h = date.getUTCHours() + date.getUTCMinutes() / 60 + date.getUTCSeconds() / 3600;
    
    const a = Math.floor((14 - m) / 12);
    const yy = y + 4800 - a;
    const mm = m + 12 * a - 3;
    
    // Julian calendar for dates before Oct 15, 1582
    // Gregorian calendar for dates on or after Oct 15, 1582
    let jdn;
    if (y < 1582 || (y === 1582 && (m < 10 || (m === 10 && d < 15)))) {
      // Julian calendar
      jdn = d + Math.floor((153 * mm + 2) / 5) + 365 * yy + Math.floor(yy / 4) - 32083;
    } else {
      // Gregorian calendar
      jdn = d + Math.floor((153 * mm + 2) / 5) + 365 * yy + Math.floor(yy / 4) - Math.floor(yy / 100) + Math.floor(yy / 400) - 32045;
    }
    return jdn + (h - 12) / 24;
  },
  
  _jdToDate(jd) {
    const createDate = (year, month, day, h, min, sec) => {
      const date = new Date(Date.UTC(2000, month - 1, day, h, min, sec));
      date.setUTCFullYear(year);
      return date;
    };
    
    const z = Math.floor(jd + 0.5);
    const f = jd + 0.5 - z;
    let a = z;
    if (z >= 2299161) {
      const alpha = Math.floor((z - 1867216.25) / 36524.25);
      a = z + 1 + alpha - Math.floor(alpha / 4);
    }
    const b = a + 1524;
    const c = Math.floor((b - 122.1) / 365.25);
    const d = Math.floor(365.25 * c);
    const e = Math.floor((b - d) / 30.6001);
    
    const day = b - d - Math.floor(30.6001 * e);
    const month = e < 14 ? e - 1 : e - 13;
    const year = month > 2 ? c - 4716 : c - 4715;
    
    const hours = f * 24;
    const hh = Math.floor(hours);
    const minutes = (hours - hh) * 60;
    const mm = Math.floor(minutes);
    const ss = Math.floor((minutes - mm) * 60);
    
    return createDate(year, month, day, hh, mm, ss);
  },
  
  // Find eclipse of given type before or after a JD
  _findEclipse(targetJD, type, direction) {
    if (!this._eclipses) return null;
    
    // Binary search for approximate position
    let lo = 0, hi = this._eclipses.length - 1;
    while (lo < hi) {
      const mid = Math.floor((lo + hi) / 2);
      if (this._eclipses[mid].jd < targetJD) lo = mid + 1;
      else hi = mid;
    }
    
    if (direction < 0) {
      // Search backward for eclipse of this type
      for (let i = lo - 1; i >= 0; i--) {
        if (this._eclipses[i].t === type) return this._eclipses[i];
      }
    } else {
      // Search forward for eclipse of this type
      for (let i = lo; i < this._eclipses.length; i++) {
        if (this._eclipses[i].t === type) return this._eclipses[i];
      }
    }
    return null;
  },
  
  // Find the nearest eclipse (any type) to a given JD
  _findNearestEclipse(targetJD) {
    if (!this._eclipses || this._eclipses.length === 0) return null;
    
    let lo = 0, hi = this._eclipses.length - 1;
    while (lo < hi) {
      const mid = Math.floor((lo + hi) / 2);
      if (this._eclipses[mid].jd < targetJD) lo = mid + 1;
      else hi = mid;
    }
    
    // Check both lo and lo-1 to find closest
    const candidates = [];
    if (lo > 0) candidates.push(this._eclipses[lo - 1]);
    if (lo < this._eclipses.length) candidates.push(this._eclipses[lo]);
    
    let nearest = null;
    let minDist = Infinity;
    for (const e of candidates) {
      const dist = Math.abs(e.jd - targetJD);
      if (dist < minDist) {
        minDist = dist;
        nearest = e;
      }
    }
    return nearest;
  },
  
  // Check if a given date has a lunar eclipse (blood moon)
  // Returns true if there's a lunar eclipse within 0.5 days of the given date
  hasLunarEclipse(date) {
    if (!this._eclipses) {
      return false;
    }
    
    const jd = this._dateToJD(date);
    
    // Binary search to find nearby eclipses
    let lo = 0, hi = this._eclipses.length - 1;
    while (lo < hi) {
      const mid = Math.floor((lo + hi) / 2);
      if (this._eclipses[mid].jd < jd) lo = mid + 1;
      else hi = mid;
    }
    
    // Check nearby eclipses (within a day on either side)
    for (let i = Math.max(0, lo - 2); i < Math.min(this._eclipses.length, lo + 3); i++) {
      const e = this._eclipses[i];
      const diff = Math.abs(e.jd - jd);
      if (e.t === 'f' && diff < 1.0) {
        return true;
      }
    }
    return false;
  },
  
  // Helper to create Date with proper year handling (including negative years)
  _createDate(year, month, day, hour, minute, second) {
    // JavaScript Date.UTC interprets years 0-99 as 1900-1999
    // We need to use setUTCFullYear for all dates to be safe
    const date = new Date(Date.UTC(2000, month - 1, day, hour || 0, minute || 0, second || 0));
    date.setUTCFullYear(year);
    return date;
  },
  
  // Calculate the ŒîT offset between Swiss Ephemeris and NASA eclipse
  // This is the key to the hybrid approach
  _calculateOffset(nearYear, eclipseType) {
    const cacheKey = `${nearYear}_${eclipseType}`;
    if (this._offsetCache.has(cacheKey)) {
      return this._offsetCache.get(cacheKey);
    }
    
    if (!AstroEngines.swissEphemeris.isLoaded) {
      return 0;
    }
    
    // Find a NASA eclipse near the target year
    const midYearDate = this._createDate(nearYear, 7, 1, 0, 0, 0);
    const approxJD = this._dateToJD(midYearDate);
    
    const nasaEclipse = this._findEclipse(approxJD, eclipseType, -1) || 
                        this._findEclipse(approxJD, eclipseType, 1);
    
    if (!nasaEclipse) {
      return 0;
    }
    
    // Get what Swiss Ephemeris calculates for this same moon phase
    const searchStart = this._jdToDate(nasaEclipse.jd - 3);
    const phase = eclipseType === 'n' ? 0 : 180;
    
    try {
      const sweResult = AstroEngines.swissEphemeris.searchMoonPhase(phase, searchStart, 10);
      if (!sweResult || !sweResult.date) {
        return 0;
      }
      
      // Use JD directly if available (avoids Date round-trip issues with ancient dates)
      const sweJD = sweResult.jd || this._dateToJD(sweResult.date);
      
      // Sanity check - offset should be reasonable (less than a few days)
      const offset = nasaEclipse.jd - sweJD;
      if (!isFinite(offset) || Math.abs(offset) > 5) {
        return 0;
      }
      
      this._offsetCache.set(cacheKey, offset);
      return offset;
    } catch (err) {
      console.warn(`Error calculating offset for year ${nearYear}:`, err);
      return 0;
    }
  },
  
  // Hybrid moon phase search:
  // 1. Use Swiss Ephemeris for precise phase calculation
  // 2. Apply ŒîT correction from nearest NASA eclipse anchor
  searchMoonPhase(phase, startDate, limitDays) {
    try {
      if (!AstroEngines.swissEphemeris.isLoaded) {
        return this._searchMoonPhaseInterpolate(phase, startDate, limitDays);
      }
      
      if (!this.isLoaded || !this._eclipses) {
        return AstroEngines.swissEphemeris.searchMoonPhase(phase, startDate, limitDays);
      }
      
      const sweResult = AstroEngines.swissEphemeris.searchMoonPhase(phase, startDate, limitDays);
      if (!sweResult || !sweResult.date) return null;
      
      if (isNaN(sweResult.date.getTime())) {
        return this._searchMoonPhaseInterpolate(phase, startDate, limitDays);
      }
      
      // For modern dates (1600-2100 CE), Swiss Eph is already accurate
      const year = sweResult.date.getUTCFullYear();
      if (year >= 1600 && year <= 2100) {
        return sweResult;
      }
      
      // For ancient/future dates, apply NASA eclipse calibration
      const eclipseType = (phase === 0 || phase === 360) ? 'n' : 'f';
      const offset = this._calculateOffset(year, eclipseType);
      
      if (!isFinite(offset) || Math.abs(offset) < 0.001) {
        return sweResult;
      }
      
      // Apply the offset correction using JD directly if available
      const sweJD = sweResult.jd || this._dateToJD(sweResult.date);
      const correctedJD = sweJD + offset;
      
      if (!isFinite(correctedJD)) {
        return sweResult;
      }
      
      return { date: this._jdToDate(correctedJD) };
    } catch (err) {
      return this._searchMoonPhaseInterpolate(phase, startDate, limitDays);
    }
  },
  
  // Pure interpolation fallback (original algorithm)
  _searchMoonPhaseInterpolate(phase, startDate, limitDays) {
    if (!this.isLoaded || !this._eclipses) {
      return AstroEngines.astronomyEngine.searchMoonPhase(phase, startDate, limitDays);
    }
    
    const targetJD = this._dateToJD(startDate);
    const endJD = targetJD + limitDays;
    const SYNODIC_MONTH = 29.530588853;
    
    const wantNewMoon = (phase === 0 || phase === 360);
    const eclipseType = wantNewMoon ? 'n' : 'f';
    
    const eclipseBefore = this._findEclipse(targetJD, eclipseType, -1);
    const eclipseAfter = this._findEclipse(targetJD, eclipseType, 1);
    
    if (!eclipseBefore && !eclipseAfter) {
      return AstroEngines.astronomyEngine.searchMoonPhase(phase, startDate, limitDays);
    }
    
    let localSynodicMonth = SYNODIC_MONTH;
    if (eclipseBefore && eclipseAfter) {
      const span = eclipseAfter.jd - eclipseBefore.jd;
      const lunations = Math.round(span / SYNODIC_MONTH);
      if (lunations > 0) {
        localSynodicMonth = span / lunations;
      }
    }
    
    let anchorEclipse, direction;
    if (!eclipseBefore) {
      anchorEclipse = eclipseAfter;
      direction = -1;
    } else if (!eclipseAfter) {
      anchorEclipse = eclipseBefore;
      direction = 1;
    } else {
      const distBefore = targetJD - eclipseBefore.jd;
      const distAfter = eclipseAfter.jd - targetJD;
      if (distBefore <= distAfter) {
        anchorEclipse = eclipseBefore;
        direction = 1;
      } else {
        anchorEclipse = eclipseAfter;
        direction = -1;
      }
    }
    
    let resultJD;
    if (direction > 0) {
      const lunationsFromAnchor = Math.ceil((targetJD - anchorEclipse.jd) / localSynodicMonth);
      resultJD = anchorEclipse.jd + lunationsFromAnchor * localSynodicMonth;
    } else {
      const lunationsFromAnchor = Math.ceil((anchorEclipse.jd - targetJD) / localSynodicMonth);
      resultJD = anchorEclipse.jd - (lunationsFromAnchor - 1) * localSynodicMonth;
    }
    
    while (resultJD < targetJD) resultJD += localSynodicMonth;
    if (resultJD > endJD) return null;
    
    return { date: this._jdToDate(resultJD) };
  },
  
  // Use Swiss Ephemeris or astronomy-engine for other calculations
  getSeasons(year) {
    return AstroEngines.swissEphemeris.isLoaded 
      ? AstroEngines.swissEphemeris.getSeasons(year)
      : AstroEngines.astronomyEngine.getSeasons(year);
  },
  
  searchRiseSet(body, observer, direction, startDate, limitDays) {
    return AstroEngines.astronomyEngine.searchRiseSet(body, observer, direction, startDate, limitDays);
  },
  
  searchAltitude(body, observer, direction, startDate, limitDays, altitude) {
    return AstroEngines.astronomyEngine.searchAltitude(body, observer, direction, startDate, limitDays, altitude);
  },
  
  getEquator(body, date, observer) {
    return AstroEngines.swissEphemeris.isLoaded 
      ? AstroEngines.swissEphemeris.getEquator(body, date, observer)
      : AstroEngines.astronomyEngine.getEquator(body, date, observer);
  },
  
  getHorizon(date, observer, ra, dec) {
    return AstroEngines.astronomyEngine.getHorizon(date, observer, ra, dec);
  },
  
  getDeltaT(date) {
    // We don't have direct ŒîT values, but the eclipse times incorporate it
    return AstroEngines.swissEphemeris.isLoaded 
      ? AstroEngines.swissEphemeris.getDeltaT(date)
      : AstroEngines.astronomyEngine.getDeltaT(date);
  },
  
  createObserver(lat, lon, elevation = 0) {
    return new Astronomy.Observer(lat, lon, elevation);
  },
  
  // Estimate ŒîT uncertainty in hours based on year
  // Since we use NASA eclipse anchors for calibration, uncertainty is reduced
  // compared to raw ŒîT models. These values represent residual uncertainty.
  // Reference: https://eclipse.gsfc.nasa.gov/SEcat5/uncertainty.html
  getDeltaTUncertainty(year) {
    // Modern dates (1600-2100): uncertainty is negligible
    if (year >= 1600 && year <= 2100) {
      return 0;
    }
    
    // For ancient dates, uncertainty grows but our hybrid calibration helps
    // These are practical estimates for when day-boundary could be affected:
    // - 500 BC: ~0.5 hours
    // - 1000 BC: ~1 hour
    // - 2000 BC: ~2 hours
    // - 3000 BC: ~3-4 hours
    const yearsFromPresent = Math.abs(year - 2000);
    
    if (yearsFromPresent <= 500) return 0.25;
    if (yearsFromPresent <= 1000) return 0.5;
    if (yearsFromPresent <= 1500) return 1;
    if (yearsFromPresent <= 2000) return 1.5;
    if (yearsFromPresent <= 2500) return 2;
    if (yearsFromPresent <= 3000) return 2.5;
    if (yearsFromPresent <= 4000) return 3;
    if (yearsFromPresent <= 5000) return 4;
    return 6; // Very ancient dates
  }
};

// ============================================================================
// ENGINE MANAGEMENT FUNCTIONS
// ============================================================================

function getAstroEngine() {
  if (!activeAstroEngine) {
    activeAstroEngine = AstroEngines.astronomyEngine;
  }
  return activeAstroEngine;
}

async function setAstroEngine(engineId) {
  const engine = AstroEngines[engineId];
  if (!engine) {
    console.error(`Unknown astronomy engine: ${engineId}`);
    return false;
  }
  
  // If engine needs async loading, do it
  if (engine.load && !engine.isLoaded) {
    const loaded = await engine.load();
    if (!loaded) {
      console.error(`Failed to load engine: ${engineId}`);
      return false;
    }
  }
  
  activeAstroEngine = engine;
  state.astronomyEngine = engineId;
  saveState();
  
  // Update UI
  updateAstroEngineUI();
  
  return true;
}

function updateAstroEngineUI() {
  const engine = getAstroEngine();
  
  // Update engine info display
  const nameEl = document.getElementById('astro-engine-name');
  const deltaEl = document.getElementById('astro-engine-delta');
  
  if (nameEl) nameEl.textContent = `${engine.name} v${engine.version}`;
  if (deltaEl) deltaEl.textContent = engine.deltaTModel;
  
  // Update button states
  document.querySelectorAll('.astro-engine-btn').forEach(btn => {
    btn.classList.toggle('selected', btn.dataset.engine === state.astronomyEngine);
  });
}

// UI handler for selecting astronomy engine (currently disabled - Swiss Ephemeris requires self-hosting)
// The abstraction layer is in place for future engine support
function selectAstroEngine(engineId) {
  if (engineId !== 'astronomyEngine') {
    console.log('Swiss Ephemeris WASM requires self-hosting. Using astronomy-engine.');
  }
}

// Initialize astronomy engine - Hybrid approach combines Swiss Ephemeris precision with NASA eclipse calibration
async function initializeAstroEngine() {
  // Load Swiss Ephemeris for precise calculations
  let sweLoaded = false;
  try {
    sweLoaded = await AstroEngines.swissEphemeris.load();
  } catch (err) {
    console.warn('Swiss Ephemeris not available:', err.message);
  }
  
  // Load NASA Eclipse data for ŒîT calibration
  let nasaLoaded = false;
  try {
    nasaLoaded = await AstroEngines.nasaEclipse.load();
  } catch (err) {
    console.warn('NASA Eclipse data not available:', err.message);
  }
  
  // Choose the best available engine configuration
  if (nasaLoaded && sweLoaded) {
    // Best case: Hybrid mode - Swiss Ephemeris calibrated against NASA eclipses
    activeAstroEngine = AstroEngines.nasaEclipse;
    state.astronomyEngine = 'nasaEclipse';
    console.log('Using Hybrid mode: Swiss Ephemeris + NASA Eclipse calibration');
    console.log('  - Modern dates (1600-2100): Swiss Ephemeris direct');
    console.log('  - Ancient dates: Swiss Ephemeris with NASA ŒîT correction');
  } else if (nasaLoaded) {
    // NASA data but no Swiss Eph - use interpolation fallback
    activeAstroEngine = AstroEngines.nasaEclipse;
    state.astronomyEngine = 'nasaEclipse';
    console.log('Using NASA Eclipse interpolation (Swiss Ephemeris not available)');
  } else if (sweLoaded) {
    // Swiss Eph but no NASA data - use Swiss Eph alone
    activeAstroEngine = AstroEngines.swissEphemeris;
    state.astronomyEngine = 'swissEphemeris';
    console.log('Using Swiss Ephemeris (no NASA calibration)');
  } else {
    // Fallback to astronomy-engine
    activeAstroEngine = AstroEngines.astronomyEngine;
    state.astronomyEngine = 'astronomyEngine';
    console.log('Using astronomy-engine for calculations');
  }
  
  updateAstroEngineUI();
}

// Make these available globally
window.AstroEngines = AstroEngines;
window.getAstroEngine = getAstroEngine;
window.setAstroEngine = setAstroEngine;
window.updateAstroEngineUI = updateAstroEngineUI;
window.selectAstroEngine = selectAstroEngine;
window.initializeAstroEngine = initializeAstroEngine;

const MONTH_NAMES = [
  '1st Month', '2nd Month', '3rd Month', '4th Month', '5th Month', '6th Month',
  '7th Month', '8th Month', '9th Month', '10th Month', '11th Month', '12th Month', '13th Month'
];

// Shofar SVG icon for Renewed Moon - larger and more distinct
const SHOFAR_ICON = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 20" width="1.4em" height="1.2em" style="vertical-align:middle"><path fill="#A67C00" stroke="#5C4300" stroke-width="1" d="M21 3c-1 0-2 .5-3 1.2c-1.5 1-3 2.5-4 4.3c-1 1.8-2 3.5-3.5 5c-1.5 1.5-3.5 2.5-6 2.5c-1.5 0-2.5 1-2.5 2s1 2 2.5 2c2 0 4-.5 5.5-1.5c1.5-1 3-2.5 4-4c1-1.5 2-3 3-4.5c1-1.5 2-2.5 3-3c.8-.4 1.5-1 1.5-2S22 3 21 3z"/><circle fill="#5C4300" cx="4" cy="17" r="1.2"/></svg>';

// Order matters: single-day feasts should come AFTER multi-day feasts so they take priority
// Order matters for overlapping feasts: specific single-day feasts listed AFTER multi-day feasts take priority
const FEASTS = [
  // Renewed Moon Day - first day of every month (first light after full moon when waning moon is 12¬∞+ above western horizon)
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 1, day: 1, description: 'First light after full moon ‚Äî waning moon 12¬∞+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 2, day: 1, description: 'First light after full moon ‚Äî waning moon 12¬∞+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 3, day: 1, description: 'First light after full moon ‚Äî waning moon 12¬∞+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 4, day: 1, description: 'First light after full moon ‚Äî waning moon 12¬∞+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 5, day: 1, description: 'First light after full moon ‚Äî waning moon 12¬∞+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 6, day: 1, description: 'First light after full moon ‚Äî waning moon 12¬∞+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 7, day: 1, description: 'First light after full moon ‚Äî waning moon 12¬∞+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 8, day: 1, description: 'First light after full moon ‚Äî waning moon 12¬∞+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 9, day: 1, description: 'First light after full moon ‚Äî waning moon 12¬∞+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 10, day: 1, description: 'First light after full moon ‚Äî waning moon 12¬∞+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 11, day: 1, description: 'First light after full moon ‚Äî waning moon 12¬∞+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 12, day: 1, description: 'First light after full moon ‚Äî waning moon 12¬∞+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 13, day: 1, description: 'First light after full moon ‚Äî waning moon 12¬∞+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  // Specific feasts
  { name: 'Last Supper', shortName: 'Last Supper', icon: 'üçûüç∑', month: 1, day: 13, description: 'The Last Supper - bread and wine', chapter: '/chapters/18-appointed-times/#passover' },
  { name: 'Passover', shortName: 'Passover', icon: 'üêë‚Ä†', month: 1, day: 14, description: 'Lamb slain at twilight', chapter: '/chapters/18-appointed-times/#passover' },
  { name: 'Unleavened Bread', shortName: 'Unleavened', icon: 'ü´ì', month: 1, day: 15, endDay: 21, description: 'High Sabbath, no leaven for 7 days', chapter: '/chapters/18-appointed-times/#unleavened-bread' },
  { name: 'First Fruits', shortName: 'First Fruits', icon: 'üåæ', month: 1, day: 16, description: 'Wave sheaf offering (also Unleavened 2)', chapter: '/chapters/18-appointed-times/#first-fruits-of-barley' },
  { name: 'Atzeret of Unleavened', shortName: 'Atzeret', icon: 'üïç', month: 1, day: 21, description: 'Solemn assembly - 7th day of Unleavened Bread', chapter: '/chapters/18-appointed-times/#unleavened-bread' },
  { name: 'Shavuot', shortName: 'Shavuot', icon: 'üåæ', month: 3, day: 16, description: '7 complete weeks after First Fruits', chapter: '/chapters/18-appointed-times/#shavuot---first-fruits-of-wheat' },
  { name: 'Trumpets', shortName: 'Trumpets', icon: 'üé∫', month: 7, day: 1, description: 'Day of shouting/blowing', chapter: '/chapters/18-appointed-times/#trumpets---first-fruits-of-oil' },
  { name: 'Atonement', shortName: 'Atonement', icon: 'ü©∏', month: 7, day: 10, description: 'Yom Kippur - day of fasting', chapter: '/chapters/18-appointed-times/#day-of-atonement' },
  { name: 'Tabernacles', shortName: 'Tabernacles', icon: '‚õ∫', month: 7, day: 15, endDay: 21, description: 'Feast of Booths', chapter: '/chapters/18-appointed-times/#tabernacles' },
  { name: 'Atzeret', shortName: 'Atzeret', icon: 'üïç', month: 7, day: 22, description: 'Shemini Atzeret - Last Great Day', chapter: '/chapters/18-appointed-times/#atzeret---last-great-day' },
  { name: 'Hanukkah', shortName: 'Hanukkah', icon: 'üïé', month: 9, day: 25, endDay: 30, description: 'Festival of Dedication (8 days)', chapter: '/chapters/18-appointed-times/#hanukkah', continuesNextMonth: true },
  { name: 'Hanukkah', shortName: 'Hanukkah', icon: 'üïé', month: 10, day: 1, endDay: 2, description: 'Festival of Dedication (continued)', chapter: '/chapters/18-appointed-times/#hanukkah', startDayNum: 7 },
  { name: 'Atzeret of Hanukkah', shortName: 'Atzeret', icon: 'üïç', month: 10, day: 2, description: 'Atzeret - 8th day of Hanukkah', chapter: '/chapters/18-appointed-times/#hanukkah' },
  { name: 'Purim', shortName: 'Purim', icon: 'üìú', month: 12, day: 14, endDay: 15, description: 'Feast of Lots - deliverance from Haman', chapter: '/chapters/18-appointed-times/#purim' }
];

const SCRIPTURES = [
  { text: "It shall be established forever like the moon, even like the trustworthy witness in the sky.", ref: "Psalms 89:37" },
  { text: "He appointed the moon for seasons; the sun knows its going down.", ref: "Psalms 104:19" },
  { text: "And God said, Let there be lights in the firmament... for signs, and for seasons, and for days, and years.", ref: "Genesis 1:14" },
  { text: "Blow the trumpet at the new moon, at the full moon, on our feast day.", ref: "Psalms 81:3" }
];

// Central state object with defaults
const defaultState = {
  year: new Date().getFullYear(),
  lat: 31.7683,
  lon: 35.2137,
  city: '31.7683,35.2137', // Store the city select value directly
  moonPhase: 'full',
  dayStartTime: 'morning',  // 'evening' or 'morning'
  dayStartAngle: 12,        // 0, 6, 12, or 18 degrees below horizon
  yearStartRule: 'equinox', // 'equinox' or '13daysBefore'
  crescentThreshold: 18,    // Hours after conjunction for crescent visibility (12, 15.5, 18, or 24)
  sabbathMode: 'lunar',     // 'lunar', 'saturday', 'sunday', 'friday', 'none'
  selectedProfile: 'biblicalFull', // Currently selected profile ID
  astronomyEngine: 'astronomyEngine', // 'astronomyEngine' or 'swissEphemeris'
  lunarMonths: [],
  currentMonthIndex: 0,
  highlightedLunarDay: null,
  selectedTimestamp: null,  // UTC timestamp of selected moment
  pendingNavigationDate: null  // Used when switching profiles to navigate to same Gregorian date
};

// Migrate old crescentThreshold values (degrees) to new format (hours)
// Old format: 5, 8, 10, 12 degrees
// New format: 12, 15.5, 18, 24 hours
function migrateCrescentThreshold(value) {
  if (value === undefined) return 18; // Default
  // Valid new values
  if (value === 12 || value === 15.5 || value === 18 || value === 24) return value;
  // Old values that need migration - default to 18h
  if (value === 5 || value === 8 || value === 10) return 18;
  // Unknown value, use default
  return 18;
}

// Load saved state from localStorage or use defaults
function loadState() {
  const saved = localStorage.getItem('lunarCalendarState');
  if (saved) {
    try {
      const parsed = JSON.parse(saved);
      return {
        ...defaultState,
        year: parsed.year || defaultState.year,
        lat: parsed.lat || defaultState.lat,
        lon: parsed.lon || defaultState.lon,
        city: parsed.city || '',
        moonPhase: parsed.moonPhase || defaultState.moonPhase,
        dayStartTime: parsed.dayStartTime || defaultState.dayStartTime,
        dayStartAngle: parsed.dayStartAngle !== undefined ? parsed.dayStartAngle : defaultState.dayStartAngle,
        yearStartRule: parsed.yearStartRule || defaultState.yearStartRule,
        crescentThreshold: migrateCrescentThreshold(parsed.crescentThreshold),
        sabbathMode: parsed.sabbathMode || defaultState.sabbathMode,
        selectedProfile: parsed.selectedProfile || defaultState.selectedProfile
        // astronomyEngine is always 'astronomyEngine' for now (Swiss Ephemeris requires self-hosting)
      };
    } catch (e) {
      return { ...defaultState };
    }
  }
  return { ...defaultState };
}

// Save settings to localStorage
function saveState() {
  const toSave = {
    year: state.year,
    lat: state.lat,
    lon: state.lon,
    city: state.city,
    moonPhase: state.moonPhase,
    dayStartTime: state.dayStartTime,
    dayStartAngle: state.dayStartAngle,
    yearStartRule: state.yearStartRule,
    crescentThreshold: state.crescentThreshold,
    sabbathMode: state.sabbathMode,
    selectedProfile: state.selectedProfile
    // astronomyEngine not saved - always uses astronomy-engine for now
  };
  localStorage.setItem('lunarCalendarState', JSON.stringify(toSave));
}

// Update URL with current calendar state for sharing
function updateURL() {
  const params = new URLSearchParams();
  params.set('year', state.year);
  params.set('month', state.currentMonthIndex + 1); // 1-indexed for readability
  if (state.highlightedLunarDay) {
    params.set('day', state.highlightedLunarDay);
  }
  params.set('lat', state.lat);
  params.set('lon', state.lon);
  params.set('phase', state.moonPhase);
  
  const newURL = window.location.pathname + '?' + params.toString();
  window.history.replaceState({}, '', newURL);
}

// Load state from URL parameters (called after initial calendar generation)
function loadFromURL() {
  const params = new URLSearchParams(window.location.search);
  
  if (!params.has('year')) return; // No URL params, use defaults
  
  let needsRegenerate = false;
  
  // Year
  if (params.has('year')) {
    const urlYear = parseInt(params.get('year'));
    if (!isNaN(urlYear) && urlYear !== state.year) {
      state.year = urlYear;
      needsRegenerate = true;
    }
  }
  
  // Location
  if (params.has('lat') && params.has('lon')) {
    const urlLat = parseFloat(params.get('lat'));
    const urlLon = parseFloat(params.get('lon'));
    if (!isNaN(urlLat) && !isNaN(urlLon)) {
      if (urlLat !== state.lat || urlLon !== state.lon) {
        state.lat = urlLat;
        state.lon = urlLon;
        state.city = ''; // Clear city selection
        needsRegenerate = true;
      }
    }
  }
  
  // Moon phase
  if (params.has('phase')) {
    const urlPhase = params.get('phase');
    if (['full', 'dark', 'crescent'].includes(urlPhase) && urlPhase !== state.moonPhase) {
      state.moonPhase = urlPhase;
      needsRegenerate = true;
    }
  }
  
  // Regenerate if settings changed
  if (needsRegenerate) {
    updateUI();
    generateCalendar();
  }
  
  // Month and day (after calendar is generated)
  if (params.has('month')) {
    const urlMonth = parseInt(params.get('month')) - 1; // Convert to 0-indexed
    if (!isNaN(urlMonth) && urlMonth >= 0 && urlMonth < state.lunarMonths.length) {
      state.currentMonthIndex = urlMonth;
    }
  }
  
  if (params.has('day')) {
    const urlDay = parseInt(params.get('day'));
    if (!isNaN(urlDay) && urlDay >= 1 && urlDay <= 30) {
      state.highlightedLunarDay = urlDay;
      // Update the goto-date input and timestamp to match the highlighted day
      const month = state.lunarMonths[state.currentMonthIndex];
      const dayObj = month?.days.find(d => d.lunarDay === urlDay);
      if (dayObj) {
        // Set to sunrise time of that day
        state.selectedTimestamp = getSunriseTimestamp(dayObj.gregorianDate);
        document.getElementById('goto-date').value = formatLocalDatetime(state.selectedTimestamp);
        // Show the day detail panel
        showDayDetail(dayObj, month);
      }
    }
  }
  
  // Re-render with the URL state
  if (params.has('month') || params.has('day')) {
    renderMonth(state.lunarMonths[state.currentMonthIndex]);
    updateMonthButtons();
  }
  
  // Check for view=feasts parameter to open the feasts page
  if (params.has('view') && params.get('view') === 'feasts') {
    toggleExportModal(true); // Skip URL update since we're loading from URL
  }
}

const state = loadState();

// Update UI to reflect current state
function updateUI() {
  document.getElementById('year-input').value = state.year;
  // Show BC label only when needed (no AD suffix)
  const yearVal = state.year;
  if (yearVal <= 0) {
    document.getElementById('year-display').textContent = `(${Math.abs(yearVal - 1)} BC)`;
  } else {
    document.getElementById('year-display').textContent = '';  // No AD suffix for positive years
  }
  document.getElementById('feast-year').textContent = formatYear(state.year);
  document.getElementById('lat-input').value = state.lat;
  document.getElementById('lon-input').value = state.lon;
  document.getElementById('moon-phase-select').value = state.moonPhase;
  document.getElementById('city-select').value = state.city || '';
  
  // Update all button states
  updateMoonPhaseButtons();
  updateDayStartButtons();
  updateYearStartButtons();
  updateCrescentThresholdVisibility();
  updateCrescentThresholdButtons();
  updateProfileButtons();
  
  // Show/hide custom coordinates
  const customCoords = document.getElementById('custom-coords');
  if (customCoords) {
    customCoords.style.display = state.city === '' ? 'block' : 'none';
  }
}

// Navigation Menu Functions
function toggleNavMenu() {
  const overlay = document.getElementById('nav-menu-overlay');
  const menu = document.getElementById('nav-menu');
  
  if (menu.classList.contains('open')) {
    menu.classList.remove('open');
    overlay.classList.remove('open');
  } else {
    menu.classList.add('open');
    overlay.classList.add('open');
  }
}

function navigateTo(page) {
  // Close the menu if it's open (don't toggle)
  const menu = document.getElementById('nav-menu');
  const overlay = document.getElementById('nav-menu-overlay');
  if (menu.classList.contains('open')) {
    menu.classList.remove('open');
    overlay.classList.remove('open');
  }
  
  const calendarOutput = document.getElementById('calendar-output');
  const dayDetailPanel = document.getElementById('day-detail-panel');
  const settingsPage = document.getElementById('settings-page');
  const settingsOverlay = document.getElementById('settings-page-overlay');
  const exportPage = document.getElementById('export-page');
  
  // Hide all pages and reset body state
  document.documentElement.classList.remove('feasts-open');
  document.body.classList.remove('feasts-open');
  document.body.style.overflow = ''; // Restore scrolling
  
  // Close settings slide-in
  settingsPage.classList.remove('visible');
  settingsOverlay.classList.remove('visible');
  
  // Hide export page
  exportPage.style.display = 'none';
  
  switch(page) {
    case 'calendar':
      calendarOutput.style.display = 'block';
      if (state.highlightedLunarDay !== null) {
        dayDetailPanel.classList.remove('hidden');
        dayDetailPanel.style.display = '';
        refreshDayDetailIfVisible();
      }
      updateURL();
      break;
    case 'feasts':
      document.documentElement.classList.add('feasts-open');
      document.body.classList.add('feasts-open');
      calendarOutput.style.display = 'none';
      dayDetailPanel.style.display = 'none';
      exportPage.style.display = 'block';
      exportPage.scrollTop = 0;
      updateExportTable();
      updateURLWithView('feasts');
      break;
    case 'settings':
      // Show calendar in background, open settings slide-in
      calendarOutput.style.display = 'block';
      if (state.highlightedLunarDay !== null) {
        dayDetailPanel.classList.remove('hidden');
        dayDetailPanel.style.display = '';
      }
      settingsPage.classList.add('visible');
      settingsOverlay.classList.add('visible');
      document.body.style.overflow = 'hidden'; // Prevent background scrolling
      updateSettingsPageState();
      settingsPage.scrollTop = 0;
      break;
  }
}

function toggleSettings() {
  const settingsPage = document.getElementById('settings-page');
  const settingsOverlay = document.getElementById('settings-page-overlay');
  
  const isOpening = !settingsPage.classList.contains('visible');
  
  if (isOpening) {
    // Show settings slide-in
    settingsPage.classList.add('visible');
    settingsOverlay.classList.add('visible');
    document.body.style.overflow = 'hidden'; // Prevent background scrolling
    
    // Update settings page state
    updateSettingsPageState();
  } else {
    // Hide settings slide-in
    settingsPage.classList.remove('visible');
    settingsOverlay.classList.remove('visible');
    document.body.style.overflow = ''; // Restore scrolling
    
    // Refresh day detail if visible
    refreshDayDetailIfVisible();
  }
}

function toggleExportModal(skipUrlUpdate = false) {
  const calendarOutput = document.getElementById('calendar-output');
  const dayDetailPanel = document.getElementById('day-detail-panel');
  const exportPage = document.getElementById('export-page');
  const settingsPage = document.getElementById('settings-page');
  const settingsOverlay = document.getElementById('settings-page-overlay');
  
  const isOpening = exportPage.style.display === 'none';
  
  if (isOpening) {
    // Hide calendar and settings, show export
    calendarOutput.style.display = 'none';
    dayDetailPanel.style.display = 'none';
    
    // Close settings slide-in if open
    settingsPage.classList.remove('visible');
    settingsOverlay.classList.remove('visible');
    document.body.style.overflow = ''; // Restore scrolling temporarily
    
    exportPage.style.display = 'block';
    
    // Scroll to top of page (with timeout to ensure DOM update)
    window.scrollTo(0, 0);
    document.documentElement.scrollTop = 0;
    document.body.scrollTop = 0;
    setTimeout(() => {
      window.scrollTo(0, 0);
      exportPage.scrollTop = 0;
    }, 0);
    
    // Update export table with current feast data
    updateExportTable();
    
    // Update URL with view=feasts
    if (!skipUrlUpdate) {
      updateURLWithView('feasts');
    }
  } else {
    // Show calendar, hide export
    calendarOutput.style.display = 'block';
    exportPage.style.display = 'none';
    
    // Reset day detail panel display and refresh if a day was selected
    dayDetailPanel.style.display = '';  // Reset inline style
    if (state.highlightedLunarDay !== null) {
      dayDetailPanel.classList.remove('hidden');
      refreshDayDetailIfVisible();
    }
    
    // Remove view parameter from URL
    if (!skipUrlUpdate) {
      updateURL();
    }
  }
}

function updateURLWithView(view) {
  const params = new URLSearchParams();
  params.set('year', state.year);
  params.set('lat', state.lat);
  params.set('lon', state.lon);
  params.set('phase', state.moonPhase);
  params.set('view', view);
  
  const newURL = window.location.pathname + '?' + params.toString();
  window.history.replaceState({}, '', newURL);
}

function updateExportTable() {
  // Update the year display
  document.getElementById('export-year').textContent = formatYear(state.year);
  
  // Update settings context
  const contextEl = document.getElementById('export-context-text');
  if (contextEl) {
    const moonLabel = getMoonLabel();
    const dayStartLabel = getDayStartLabel();
    const yearStartLabel = state.yearStartRule === '13daysBefore' ? 'Passover after Equinox' : 'Renewed Moon after Equinox';
    
    // Get location name with coordinates
    const locationName = getCurrentLocationName();
    const coordStr = `${state.lat.toFixed(2)}¬∞${state.lat >= 0 ? 'N' : 'S'}, ${Math.abs(state.lon).toFixed(2)}¬∞${state.lon >= 0 ? 'E' : 'W'}`;
    const locationLabel = locationName !== 'Your Location' && !locationName.includes('/') 
      ? `${locationName} (${coordStr})`
      : coordStr;
    
    contextEl.innerHTML = `
      <span class="export-context-item">
        <span class="export-context-label">Month Start:</span>
        <span class="export-context-value">${moonLabel}</span>
      </span>
      <span class="export-context-item">
        <span class="export-context-label">Day Start:</span>
        <span class="export-context-value">${dayStartLabel}</span>
      </span>
      <span class="export-context-item">
        <span class="export-context-label">Year Start:</span>
        <span class="export-context-value">${yearStartLabel}</span>
      </span>
      <span class="export-context-item">
        <span class="export-context-label">Location:</span>
        <span class="export-context-value">${locationLabel}</span>
      </span>
    `;
  }
  
  // Copy the feast table content to the export modal
  const sourceTbody = document.getElementById('feast-tbody');
  const targetTbody = document.getElementById('export-feast-tbody');
  
  if (sourceTbody && targetTbody) {
    targetTbody.innerHTML = sourceTbody.innerHTML;
  }
}

function updateSettingsPageState() {
  // Update profile buttons
  updateProfileButtons();
  
  // Update moon phase buttons
  document.querySelectorAll('.settings-option-btn[data-phase]').forEach(btn => {
    btn.classList.toggle('selected', btn.dataset.phase === state.moonPhase);
  });
  
  // Update crescent threshold visibility and buttons
  updateCrescentThresholdVisibility();
  updateCrescentThresholdButtons();
  
  // Update day start buttons
  updateDayStartButtons();
  
  // Update year start buttons
  updateYearStartButtons();
  
  // Update sabbath buttons
  updateSabbathButtons();
  
  // Update city select
  const citySelect = document.getElementById('settings-city-select');
  const coordValue = `${state.lat},${state.lon}`;
  let found = false;
  
  for (let option of citySelect.options) {
    if (option.value === coordValue) {
      citySelect.value = coordValue;
      found = true;
      break;
    }
  }
  
  if (!found) {
    citySelect.value = 'custom';
    document.getElementById('settings-custom-coords').style.display = 'flex';
    document.getElementById('settings-lat-input').value = state.lat;
    document.getElementById('settings-lon-input').value = state.lon;
  } else {
    document.getElementById('settings-custom-coords').style.display = 'none';
  }
  
  // Render the map
  renderSettingsPageMap();
  
  // Update settings editability based on current profile
  updateSettingsEditability();
}

function renderSettingsPageMap() {
  const container = document.getElementById('settings-page-map');
  if (container && state.lunarMonths && state.lunarMonths[state.currentMonthIndex]) {
    const month = state.lunarMonths[state.currentMonthIndex];
    container.innerHTML = renderDatelineVisualization(month.moonEvent);
    // Update map editability after rendering
    updateMapEditability();
  }
}

function updateMoonPhaseButtons() {
  document.querySelectorAll('.moon-phase-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.phase === state.moonPhase);
  });
  // Also update settings page buttons
  document.querySelectorAll('.settings-option-btn[data-phase]').forEach(btn => {
    btn.classList.toggle('selected', btn.dataset.phase === state.moonPhase);
  });
}

function selectMoonPhase(phase) {
  // Don't allow changes on preset profiles
  const select = document.getElementById('profile-select');
  if (select && PRESET_PROFILES[select.value]) return;
  
  state.moonPhase = phase;
  document.getElementById('moon-phase-select').value = phase;
  updateMoonPhaseButtons();
  updateCrescentThresholdVisibility();
  updateYearStartButtons();  // Update year start icon to match moon phase
  updateProfileButtons();  // Check if settings match a profile
  saveState();
  regenerateCalendarPreservingScroll();
}

// Preset profiles (built-in, cannot be deleted)
// biblicalFull is first as it's the default (no location prompt)
const PRESET_PROFILES = {
  biblicalFull: {
    name: 'Biblical Full Moon',
    hint: 'Morning Nautical Twilight, Jerusalem',
    icon: 'üåï',
    moonPhase: 'full',
    dayStartTime: 'morning',
    dayStartAngle: 12,
    yearStartRule: 'equinox',
    crescentThreshold: 18,
    sabbathMode: 'lunar',
    lat: 31.7683,
    lon: 35.2137,
    city: '31.7683,35.2137'
  },
  fullMoon: {
    name: 'Full Moon',
    hint: 'Morning Nautical Twilight, Your Location',
    icon: 'üåï',
    moonPhase: 'full',
    dayStartTime: 'morning',
    dayStartAngle: 12,
    yearStartRule: 'equinox',
    crescentThreshold: 18,
    sabbathMode: 'lunar',
    useCurrentLocation: true
  },
  biblicalDark: {
    name: 'Biblical Dark Moon',
    hint: 'Evening Sunset, Jerusalem',
    icon: 'üåë',
    moonPhase: 'dark',
    dayStartTime: 'evening',
    dayStartAngle: 0,
    yearStartRule: 'equinox',
    crescentThreshold: 18,
    sabbathMode: 'lunar',
    lat: 31.7683,
    lon: 35.2137,
    city: '31.7683,35.2137'
  },
  biblicalCrescent: {
    name: 'Biblical Crescent Moon',
    hint: 'Evening Sunset, Jerusalem',
    icon: 'üåí',
    moonPhase: 'crescent',
    dayStartTime: 'evening',
    dayStartAngle: 0,
    yearStartRule: 'equinox',
    crescentThreshold: 18,
    sabbathMode: 'lunar',
    lat: 31.7683,
    lon: 35.2137,
    city: '31.7683,35.2137'
  }
};

// Combined profiles (presets + user-saved)
let PROFILES = { ...PRESET_PROFILES };

// Load custom profiles from localStorage
function loadCustomProfiles() {
  try {
    const saved = localStorage.getItem('customProfiles');
    if (saved) {
      const customProfiles = JSON.parse(saved);
      PROFILES = { ...PRESET_PROFILES, ...customProfiles };
    }
  } catch (e) {
    console.error('Error loading custom profiles:', e);
  }
}

// Save custom profiles to localStorage
function saveCustomProfiles() {
  const customProfiles = {};
  for (const [id, profile] of Object.entries(PROFILES)) {
    if (!PRESET_PROFILES[id]) {
      customProfiles[id] = profile;
    }
  }
  localStorage.setItem('customProfiles', JSON.stringify(customProfiles));
}

// Rebuild profile dropdown with all profiles
function rebuildProfileDropdown() {
  const select = document.getElementById('profile-select');
  if (!select) return;
  
  select.innerHTML = '';
  
  // Add preset profiles
  for (const [id, profile] of Object.entries(PRESET_PROFILES)) {
    const option = document.createElement('option');
    option.value = id;
    option.textContent = `${profile.icon} ${profile.name} ‚Äî ${profile.hint}`;
    select.appendChild(option);
  }
  
  // Add custom profiles (user-saved)
  const customIds = Object.keys(PROFILES).filter(id => !PRESET_PROFILES[id]);
  if (customIds.length > 0) {
    for (const id of customIds) {
      const profile = PROFILES[id];
      const option = document.createElement('option');
      option.value = id;
      option.textContent = `${profile.icon} ${profile.name}`;
      select.appendChild(option);
    }
  }
  
  // Restore selection from state if valid, otherwise default to biblicalFull
  const profileToSelect = state.selectedProfile || 'biblicalFull';
  if ([...select.options].some(o => o.value === profileToSelect)) {
    select.value = profileToSelect;
  } else {
    select.value = 'biblicalFull';
    state.selectedProfile = 'biblicalFull';
  }
}

// Get the icon for a moon phase
function getProfileIcon(phase) {
  if (phase === 'full') return 'üåï';
  if (phase === 'dark') return 'üåë';
  if (phase === 'crescent') return 'üåí';
  return 'üåï';
}

// Get the name of the currently selected profile
function getCurrentProfileName() {
  const select = document.getElementById('profile-select');
  if (!select) return '';
  const currentId = select.value;
  const profile = PROFILES[currentId];
  return profile ? profile.name : '';
}

// Known city coordinates for display lookup
const CITY_NAMES = {
  '31.7683,35.2137': 'Jerusalem',
  '40.7128,-74.006': 'New York',
  '34.0522,-118.2437': 'Los Angeles',
  '41.8781,-87.6298': 'Chicago',
  '29.7604,-95.3698': 'Houston',
  '33.749,-84.388': 'Atlanta',
  '47.6062,-122.3321': 'Seattle',
  '25.7617,-80.1918': 'Miami',
  '39.7392,-104.9903': 'Denver',
  '33.4484,-112.074': 'Phoenix',
  '51.5074,-0.1278': 'London',
  '48.8566,2.3522': 'Paris',
  '52.52,13.405': 'Berlin',
  '41.9028,12.4964': 'Rome',
  '55.7558,37.6173': 'Moscow',
  '35.6762,139.6503': 'Tokyo',
  '31.2304,121.4737': 'Shanghai',
  '22.3193,114.1694': 'Hong Kong',
  '1.3521,103.8198': 'Singapore',
  '-33.8688,151.2093': 'Sydney',
  '-23.5505,-46.6333': 'S√£o Paulo',
  '19.4326,-99.1332': 'Mexico City',
  '-34.6037,-58.3816': 'Buenos Aires',
  '30.0444,31.2357': 'Cairo',
  '28.6139,77.209': 'New Delhi',
  '-1.2921,36.8219': 'Nairobi'
};

// Get timezone name from longitude
function getTimezoneFromLongitude(lon) {
  // Calculate UTC offset based on longitude (15 degrees per hour)
  const offsetHours = Math.round(lon / 15);
  if (offsetHours === 0) {
    return 'UTC';
  } else if (offsetHours > 0) {
    return `UTC+${offsetHours}`;
  } else {
    return `UTC${offsetHours}`;
  }
}

// Get a display name for the current location
function getCurrentLocationName() {
  // Check if using current location
  if (state.city === 'current') {
    return 'Your Location';
  }
  
  // Check the profile for useCurrentLocation
  const profileSelect = document.getElementById('profile-select');
  if (profileSelect) {
    const profile = PROFILES[profileSelect.value];
    if (profile && profile.useCurrentLocation) {
      return 'Your Location';
    }
  }
  
  // Try to find city name from known cities
  const coordValue = `${state.lat},${state.lon}`;
  if (CITY_NAMES[coordValue]) {
    return CITY_NAMES[coordValue];
  }
  
  // Fall back to timezone based on longitude
  return getTimezoneFromLongitude(state.lon);
}

// Refresh geolocation if the current profile uses "Your Location"
function refreshLocationIfNeeded() {
  const select = document.getElementById('profile-select');
  if (!select) return;
  
  const currentId = select.value;
  const profile = PROFILES[currentId];
  
  // Only refresh for profiles with useCurrentLocation
  if (!profile || !profile.useCurrentLocation) return;
  
  if (!navigator.geolocation) return;
  
  navigator.geolocation.getCurrentPosition(
    (position) => {
      const newLat = Math.round(position.coords.latitude * 10000) / 10000;
      const newLon = Math.round(position.coords.longitude * 10000) / 10000;
      
      // Only update if location has changed significantly (>0.01 degrees ‚âà 1km)
      if (Math.abs(newLat - state.lat) > 0.01 || Math.abs(newLon - state.lon) > 0.01) {
        state.lat = newLat;
        state.lon = newLon;
        state.city = 'current';
        
        // Update UI
        document.getElementById('lat-input').value = state.lat;
        document.getElementById('lon-input').value = state.lon;
        
        // Regenerate calendar with new location
        saveState();
        generateCalendar({ preserveMonth: true });
        renderSettingsPageMap();
      }
    },
    (error) => {
      // Silently fail - keep existing location
      console.log('Geolocation refresh failed, keeping saved location');
    },
    { timeout: 5000, maximumAge: 0 }
  );
}

// Check if a profile name is unique
function isProfileNameUnique(name, excludeId = null) {
  const normalizedName = name.trim().toLowerCase();
  for (const [id, profile] of Object.entries(PROFILES)) {
    if (id !== excludeId && profile.name.toLowerCase() === normalizedName) {
      return false;
    }
  }
  return true;
}

// Track modal mode: 'create' or 'edit'
let profileModalMode = 'create';
let profileModalEditId = null;

// Clone current profile settings as a new custom profile
function cloneProfile() {
  const select = document.getElementById('profile-select');
  const currentId = select.value;
  const currentProfile = PROFILES[currentId];
  
  // Suggest a name based on current profile
  const suggestedName = currentProfile ? currentProfile.name + ' Copy' : 'My Profile';
  
  showProfileModal('create', suggestedName);
}

// Edit the name of the current custom profile
function editProfileName() {
  const select = document.getElementById('profile-select');
  const currentId = select.value;
  
  // Can't edit presets
  if (PRESET_PROFILES[currentId]) return;
  
  const currentProfile = PROFILES[currentId];
  if (!currentProfile) return;
  
  showProfileModal('edit', currentProfile.name, currentId);
}

function showProfileModal(mode, defaultName, editId = null) {
  profileModalMode = mode;
  profileModalEditId = editId;
  
  const overlay = document.getElementById('profile-modal-overlay');
  const input = document.getElementById('profile-modal-input');
  const error = document.getElementById('profile-modal-error');
  const title = document.getElementById('profile-modal-title');
  const saveBtn = document.getElementById('profile-modal-save-btn');
  
  title.textContent = mode === 'edit' ? 'Rename Profile' : 'Create New Profile';
  saveBtn.textContent = mode === 'edit' ? 'Save' : 'Create';
  
  input.value = defaultName || '';
  error.textContent = '';
  overlay.classList.add('visible');
  
  // Focus and select the input text
  setTimeout(() => {
    input.focus();
    input.select();
  }, 100);
}

function closeProfileModal(event) {
  // If event exists and target is not the overlay itself, don't close
  if (event && event.target !== event.currentTarget) return;
  
  const overlay = document.getElementById('profile-modal-overlay');
  overlay.classList.remove('visible');
  profileModalMode = 'create';
  profileModalEditId = null;
}

function handleProfileModalKeydown(event) {
  if (event.key === 'Enter') {
    saveProfileModal();
  } else if (event.key === 'Escape') {
    closeProfileModal();
  }
}

function saveProfileModal() {
  const input = document.getElementById('profile-modal-input');
  const error = document.getElementById('profile-modal-error');
  const select = document.getElementById('profile-select');
  
  let name = input.value.trim();
  
  if (!name) {
    error.textContent = 'Please enter a profile name.';
    input.focus();
    return;
  }
  
  // Check for unique name (exclude current profile when editing)
  if (!isProfileNameUnique(name, profileModalEditId)) {
    error.textContent = 'A profile with this name already exists.';
    input.focus();
    return;
  }
  
  if (profileModalMode === 'edit' && profileModalEditId) {
    // Edit existing profile name
    PROFILES[profileModalEditId].name = name;
    saveCustomProfiles();
    rebuildProfileDropdown();
    select.value = profileModalEditId;
  } else {
    // Create new profile
    const id = 'custom_' + Date.now();
    PROFILES[id] = {
      name: name,
      icon: getProfileIcon(state.moonPhase),
      moonPhase: state.moonPhase,
      dayStartTime: state.dayStartTime,
      dayStartAngle: state.dayStartAngle,
      yearStartRule: state.yearStartRule,
      crescentThreshold: state.crescentThreshold,
      sabbathMode: state.sabbathMode,
      lat: state.lat,
      lon: state.lon,
      city: state.city
    };
    
    saveCustomProfiles();
    
    // Select the new profile
    state.selectedProfile = id;
    rebuildProfileDropdown();
    select.value = id;
    saveState();
  }
  
  updateProfileButtonStates();
  updateSettingsEditability();
  
  // Close the modal
  closeProfileModal();
}

// Delete the currently selected custom profile
function deleteCustomProfile() {
  const select = document.getElementById('profile-select');
  const currentId = select.value;
  
  // Can't delete presets
  if (PRESET_PROFILES[currentId]) return;
  
  const profile = PROFILES[currentId];
  if (!confirm(`Delete profile "${profile.name}"?`)) return;
  
  delete PROFILES[currentId];
  saveCustomProfiles();
  rebuildProfileDropdown();
  
  // Switch to Biblical Full Moon preset (Jerusalem)
  applyProfile('biblicalFull');
}

// Update delete and edit button states based on current profile
function updateProfileButtonStates() {
  const select = document.getElementById('profile-select');
  const deleteBtn = document.getElementById('profile-delete-btn');
  const editBtn = document.getElementById('profile-edit-btn');
  
  if (!select) return;
  
  const currentId = select.value;
  const isPreset = !!PRESET_PROFILES[currentId];
  
  // Delete and edit enabled only for user-saved profiles (not presets)
  if (deleteBtn) deleteBtn.disabled = isPreset;
  if (editBtn) editBtn.disabled = isPreset;
}

// Enable/disable settings controls based on whether current profile is editable
function updateSettingsEditability() {
  const select = document.getElementById('profile-select');
  if (!select) return;
  
  const currentId = select.value;
  const isPreset = !!PRESET_PROFILES[currentId];
  
  // Get all settings controls
  const settingsContainer = document.getElementById('settings-page');
  if (!settingsContainer) return;
  
  // Toggle disabled state on settings buttons and selects (but not profile controls)
  const controls = settingsContainer.querySelectorAll('.settings-option-btn, .settings-select:not(#profile-select), #settings-lat-input, #settings-lon-input');
  controls.forEach(control => {
    if (isPreset) {
      control.disabled = true;
      control.classList.add('disabled');
    } else {
      control.disabled = false;
      control.classList.remove('disabled');
    }
  });
  
  // Also disable/enable the location button
  const locationBtn = settingsContainer.querySelector('.settings-location-btn');
  if (locationBtn) {
    locationBtn.disabled = isPreset;
    locationBtn.classList.toggle('disabled', isPreset);
  }
  
  // Update all maps to show disabled state
  updateMapEditability();
}

// Update map click hint and disabled state based on current profile
function updateMapEditability() {
  const select = document.getElementById('profile-select');
  const isPreset = select && !!PRESET_PROFILES[select.value];
  
  // Update all dateline maps
  document.querySelectorAll('.dateline-map').forEach(map => {
    map.classList.toggle('disabled', isPreset);
  });
  
  // Update click hints
  document.querySelectorAll('.dateline-click-hint').forEach(hint => {
    if (isPreset) {
      hint.style.display = 'none';
    } else {
      hint.style.display = '';
    }
  });
}

// Initialize custom profiles on load
loadCustomProfiles();

// Get feast icons for a given lunar month and day
function getFeastIconsForLunarDay(month, day) {
  const icons = [];
  for (const f of FEASTS) {
    if (f.month === month) {
      if (f.endDay) {
        // Multi-day feast
        if (day >= f.day && day <= f.endDay) {
          if (!icons.includes(f.icon)) icons.push(f.icon);
        }
      } else if (f.day === day) {
        // Single-day feast
        if (!icons.includes(f.icon)) icons.push(f.icon);
      }
    }
  }
  return icons;
}

// Switch to a profile and navigate to the same Gregorian date
function switchToProfileAndNavigate(profileId, timestamp) {
  // Store the target date to navigate to after calendar regenerates
  state.pendingNavigationDate = new Date(timestamp);
  
  // Apply the profile (this will trigger calendar regeneration)
  applyProfile(profileId);
}

// Navigate to a pending date after calendar regeneration
function navigateToPendingDate() {
  if (!state.pendingNavigationDate) return;
  
  const targetDateStr = state.pendingNavigationDate.toISOString().split('T')[0];
  state.pendingNavigationDate = null; // Clear the pending navigation
  
  // Find this Gregorian date in the new calendar
  for (let m = 0; m < state.lunarMonths.length; m++) {
    const month = state.lunarMonths[m];
    for (let d = 0; d < month.days.length; d++) {
      const day = month.days[d];
      if (day.gregorianDate.toISOString().split('T')[0] === targetDateStr) {
        state.currentMonthIndex = m;
        state.highlightedLunarDay = day.lunarDay;
        renderMonth(month);
        showDayDetail(day, month);
        return;
      }
    }
  }
}

function applyProfile(profileId) {
  const profile = PROFILES[profileId];
  if (!profile) return;
  
  state.selectedProfile = profileId;
  state.moonPhase = profile.moonPhase;
  state.dayStartTime = profile.dayStartTime;
  state.dayStartAngle = profile.dayStartAngle;
  state.yearStartRule = profile.yearStartRule;
  state.crescentThreshold = profile.crescentThreshold;
  state.sabbathMode = profile.sabbathMode || 'lunar';
  
  if (profile.useCurrentLocation && navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(
      (position) => {
        state.lat = position.coords.latitude;
        state.lon = position.coords.longitude;
        state.city = 'current';
        updateLocationUI();
        finishApplyProfile();
      },
      (error) => {
        console.log('Geolocation error, keeping current location');
        finishApplyProfile();
      }
    );
  } else if (profile.lat !== undefined) {
    state.lat = profile.lat;
    state.lon = profile.lon;
    state.city = profile.city;
    updateLocationUI();
    finishApplyProfile();
  } else {
    finishApplyProfile();
  }
}

function updateLocationUI() {
  document.getElementById('lat-input').value = state.lat;
  document.getElementById('lon-input').value = state.lon;
  document.getElementById('city-select').value = state.city || '';
  const settingsCitySelect = document.getElementById('settings-city-select');
  if (settingsCitySelect) settingsCitySelect.value = state.city || '';
}

function finishApplyProfile() {
  // Update all UI elements
  document.getElementById('moon-phase-select').value = state.moonPhase;
  updateMoonPhaseButtons();
  updateDayStartButtons();
  updateYearStartButtons();
  updateCrescentThresholdVisibility();
  updateCrescentThresholdButtons();
  updateSabbathButtons();
  updateProfileButtons();
  updateSettingsEditability();
  
  // Save and regenerate (preserving scroll position)
  saveState();
  regenerateCalendarPreservingScroll();
}

function getMatchingProfile() {
  // Determine which profile matches current state (if any)
  for (const [id, profile] of Object.entries(PROFILES)) {
    if (profile.moonPhase === state.moonPhase &&
        profile.dayStartTime === state.dayStartTime &&
        profile.dayStartAngle === state.dayStartAngle &&
        profile.yearStartRule === state.yearStartRule &&
        profile.crescentThreshold === state.crescentThreshold &&
        (profile.sabbathMode || 'lunar') === state.sabbathMode) {
      // Check location match for non-current-location profiles
      if (profile.useCurrentLocation) {
        // For "current location" profiles, any location works
        return id;
      } else if (Math.abs(profile.lat - state.lat) < 0.01 && Math.abs(profile.lon - state.lon) < 0.01) {
        return id;
      }
    }
  }
  return null; // No matching profile
}

function updateProfileButtons() {
  const select = document.getElementById('profile-select');
  if (!select) return;
  
  // When user edits settings on a custom profile, save the changes
  const currentId = select.value;
  if (!PRESET_PROFILES[currentId] && PROFILES[currentId]) {
    // Update the profile with current settings
    PROFILES[currentId].icon = getProfileIcon(state.moonPhase);
    PROFILES[currentId].moonPhase = state.moonPhase;
    PROFILES[currentId].dayStartTime = state.dayStartTime;
    PROFILES[currentId].dayStartAngle = state.dayStartAngle;
    PROFILES[currentId].yearStartRule = state.yearStartRule;
    PROFILES[currentId].crescentThreshold = state.crescentThreshold;
    PROFILES[currentId].sabbathMode = state.sabbathMode;
    PROFILES[currentId].lat = state.lat;
    PROFILES[currentId].lon = state.lon;
    PROFILES[currentId].city = state.city;
    saveCustomProfiles();
    rebuildProfileDropdown();
    select.value = currentId;
  }
  
  updateProfileButtonStates();
}

function onProfileSelectChange(profileId) {
  applyProfile(profileId);
  updateSettingsEditability();
}

function resetToDefaults() {
  // Apply Biblical Full Moon profile as default (Jerusalem, no location prompt)
  applyProfile('biblicalFull');
}

// Helper to regenerate calendar while preserving scroll position
function regenerateCalendarPreservingScroll() {
  const scrollTop = window.scrollY || document.documentElement.scrollTop;
  generateCalendar({ preserveMonth: true });
  updateURL();
  renderSettingsPageMap();
  
  // Check for pending navigation (from profile switching)
  if (state.pendingNavigationDate) {
    navigateToPendingDate();
  } else {
    refreshDayDetailIfVisible();
  }
  
  requestAnimationFrame(() => {
    window.scrollTo(0, scrollTop);
  });
}

function selectDayStartTime(time) {
  // Don't allow changes on preset profiles
  const select = document.getElementById('profile-select');
  if (select && PRESET_PROFILES[select.value]) return;
  
  state.dayStartTime = time;
  updateDayStartButtons();
  updateProfileButtons();  // Check if settings match a profile
  saveState();
  regenerateCalendarPreservingScroll();
}

function selectDayStartAngle(angle) {
  // Don't allow changes on preset profiles
  const select = document.getElementById('profile-select');
  if (select && PRESET_PROFILES[select.value]) return;
  
  state.dayStartAngle = angle;
  updateDayStartButtons();
  updateProfileButtons();  // Check if settings match a profile
  saveState();
  regenerateCalendarPreservingScroll();
}

function selectYearStartRule(rule) {
  // Don't allow changes on preset profiles
  const select = document.getElementById('profile-select');
  if (select && PRESET_PROFILES[select.value]) return;
  
  state.yearStartRule = rule;
  updateYearStartButtons();
  updateProfileButtons();  // Check if settings match a profile
  saveState();
  regenerateCalendarPreservingScroll();
}

function updateDayStartButtons() {
  // Update day start time buttons (evening/morning)
  document.querySelectorAll('.settings-option-btn[data-daystart]').forEach(btn => {
    btn.classList.toggle('selected', btn.dataset.daystart === state.dayStartTime);
  });
  // Update angle buttons
  document.querySelectorAll('.settings-option-btn[data-angle]').forEach(btn => {
    btn.classList.toggle('selected', parseInt(btn.dataset.angle) === state.dayStartAngle);
  });
}

function updateYearStartButtons() {
  document.querySelectorAll('.settings-option-btn[data-yearstart]').forEach(btn => {
    btn.classList.toggle('selected', btn.dataset.yearstart === state.yearStartRule);
  });
  
  // Update the "Renewed Moon after Equinox" icon to match current moon phase
  const iconEl = document.getElementById('yearstart-equinox-icon');
  if (iconEl) {
    iconEl.textContent = getMoonIcon();
  }
}

function selectCrescentThreshold(threshold) {
  // Don't allow changes on preset profiles
  const select = document.getElementById('profile-select');
  if (select && PRESET_PROFILES[select.value]) return;
  
  state.crescentThreshold = threshold;
  updateCrescentThresholdButtons();
  updateProfileButtons();  // Check if settings match a profile
  saveState();
  regenerateCalendarPreservingScroll();
}

function selectSabbathMode(mode) {
  // Don't allow changes on preset profiles
  const select = document.getElementById('profile-select');
  if (select && PRESET_PROFILES[select.value]) return;
  
  state.sabbathMode = mode;
  // Clear dropdown when selecting a button option
  const dropdown = document.getElementById('sabbath-day-select');
  if (dropdown) dropdown.value = '';
  updateSabbathButtons();
  updateProfileButtons();  // Check if settings match a profile
  saveState();
  regenerateCalendarPreservingScroll();
}

function updateSabbathButtons() {
  document.querySelectorAll('.settings-option-btn[data-sabbath]').forEach(btn => {
    btn.classList.toggle('selected', btn.dataset.sabbath === state.sabbathMode);
  });
  
  // Update the dropdown to reflect current selection
  const dropdown = document.getElementById('sabbath-day-select');
  if (dropdown) {
    const dropdownDays = ['none', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday'];
    if (dropdownDays.includes(state.sabbathMode)) {
      dropdown.value = state.sabbathMode;
    } else {
      dropdown.value = '';
    }
  }
}

function selectSabbathDayFromDropdown(day) {
  if (!day) return;
  
  // Don't allow changes on preset profiles
  const select = document.getElementById('profile-select');
  if (select && PRESET_PROFILES[select.value]) {
    // Reset dropdown to empty
    document.getElementById('sabbath-day-select').value = '';
    return;
  }
  
  state.sabbathMode = day;
  // Deselect the button options when selecting from dropdown
  document.querySelectorAll('.settings-option-btn[data-sabbath]').forEach(btn => {
    btn.classList.remove('selected');
  });
  updateSabbathButtons();
  updateProfileButtons();
  saveState();
  regenerateCalendarPreservingScroll();
}

// Determine if a day is a sabbath based on current sabbathMode
function isSabbath(day) {
  switch (state.sabbathMode) {
    case 'lunar':
      // Lunar sabbath: days 8, 15, 22, 29
      return [8, 15, 22, 29].includes(day.lunarDay);
    case 'sunday':
      return getCorrectWeekday(day.gregorianDate) === 0;
    case 'monday':
      return getCorrectWeekday(day.gregorianDate) === 1;
    case 'tuesday':
      return getCorrectWeekday(day.gregorianDate) === 2;
    case 'wednesday':
      return getCorrectWeekday(day.gregorianDate) === 3;
    case 'thursday':
      return getCorrectWeekday(day.gregorianDate) === 4;
    case 'friday':
      return getCorrectWeekday(day.gregorianDate) === 5;
    case 'saturday':
      return getCorrectWeekday(day.gregorianDate) === 6;
    case 'none':
      return false;
    default:
      return [8, 15, 22, 29].includes(day.lunarDay);
  }
}

function updateCrescentThresholdButtons() {
  document.querySelectorAll('.settings-option-btn[data-threshold]').forEach(btn => {
    btn.classList.toggle('selected', parseInt(btn.dataset.threshold) === state.crescentThreshold);
  });
}

function updateCrescentThresholdVisibility() {
  const section = document.getElementById('crescent-threshold-section');
  if (section) {
    section.style.display = state.moonPhase === 'crescent' ? 'block' : 'none';
  }
}

function renderSettingsMap() {
  const container = document.getElementById('settings-map-container');
  if (container && state.lunarMonths && state.lunarMonths[state.currentMonthIndex]) {
    const month = state.lunarMonths[state.currentMonthIndex];
    container.innerHTML = renderDatelineVisualization(month.moonEvent);
    // Update map editability after rendering
    updateMapEditability();
  }
}

// Month Picker Popup
function toggleMonthPicker() {
  const overlay = document.getElementById('month-picker-overlay');
  const picker = document.getElementById('month-picker');
  const isOpen = overlay.classList.contains('open');
  
  if (!isOpen) {
    // Opening - update the picker content
    updateMonthPicker();
  }
  
  overlay.classList.toggle('open');
  picker.style.display = isOpen ? 'none' : 'block';
}

function updateMonthPicker() {
  document.getElementById('picker-year').textContent = formatYear(state.year);
  
  const grid = document.getElementById('month-grid');
  grid.innerHTML = '';
  
  const monthNames = ['1st', '2nd', '3rd', '4th', '5th', '6th', '7th', '8th', '9th', '10th', '11th', '12th', 'üìÖ13th'];
  
  for (let i = 0; i < 13; i++) {
    const btn = document.createElement('button');
    btn.textContent = monthNames[i];
    
    if (i >= state.lunarMonths.length) {
      btn.classList.add('disabled');
      btn.disabled = true;
    } else if (i === state.currentMonthIndex) {
      btn.classList.add('active');
    }
    
    // Add tooltip for 13th month
    if (i === 12) {
      btn.title = 'Intercalary 13th month';
    }
    
    btn.onclick = () => {
      if (i < state.lunarMonths.length) {
        selectMonth(i);
        toggleMonthPicker();
      }
    };
    
    grid.appendChild(btn);
  }
}

function changePickerYear(delta) {
  state.year += delta;
  document.getElementById('year-input').value = state.year;
  generateCalendar();
  updateMonthPicker();
}

function showYearInput() {
  const display = document.getElementById('picker-year');
  const input = document.getElementById('picker-year-input');
  
  display.style.display = 'none';
  input.style.display = 'block';
  input.value = state.year;
  input.focus();
  input.select();
}

function hideYearInput() {
  const display = document.getElementById('picker-year');
  const input = document.getElementById('picker-year-input');
  
  display.style.display = '';
  input.style.display = 'none';
}

function applyYearInput() {
  const input = document.getElementById('picker-year-input');
  const newYear = parseInt(input.value);
  
  if (!isNaN(newYear) && newYear >= -4000 && newYear <= 4000) {
    state.year = newYear;
    document.getElementById('year-input').value = state.year;
    generateCalendar();
    updateMonthPicker();
  }
  
  hideYearInput();
}

// Date Jump Popup
function toggleDateJump() {
  const overlay = document.getElementById('date-jump-overlay');
  const popup = document.getElementById('date-jump-popup');
  const isOpen = overlay.classList.contains('open');
  
  if (!isOpen) {
    // Opening - sync the datetime input
    const gotoDate = document.getElementById('goto-date').value;
    const datetimeInput = document.getElementById('jump-datetime');
    const ancientDisplay = document.getElementById('jump-ancient-display');
    const ancientDateText = document.getElementById('jump-ancient-date');
    
    if (gotoDate) {
      // Modern date - show datetime picker
      datetimeInput.value = gotoDate;
      datetimeInput.style.display = 'block';
      ancientDisplay.style.display = 'none';
    } else if (state.selectedTimestamp) {
      // Ancient date - show text display instead
      const date = new Date(state.selectedTimestamp);
      const dateStr = formatDisplayDate(date);
      ancientDateText.textContent = dateStr;
      datetimeInput.style.display = 'none';
      ancientDisplay.style.display = 'block';
    }
  }
  
  overlay.classList.toggle('open');
  popup.style.display = isOpen ? 'none' : 'block';
}

function executeJumpToDate() {
  const datetime = document.getElementById('jump-datetime').value;
  if (!datetime) {
    alert('Please enter a date');
    return;
  }
  document.getElementById('goto-date').value = datetime;
  jumpToDate();
  toggleDateJump();
}

function jumpToTodayFromPopup() {
  toggleDateJump();
  jumpToToday();
}

function addDaysFromPopup(direction) {
  const datetime = document.getElementById('jump-datetime').value;
  const days = parseInt(document.getElementById('jump-days').value) || 1;
  
  // For ancient dates, datetime input will be empty, use selectedTimestamp
  let utcTimestamp;
  if (datetime) {
    utcTimestamp = parseDatetimeLocal(datetime);
  } else if (state.selectedTimestamp) {
    utcTimestamp = state.selectedTimestamp;
  } else {
    alert('Please select a date first');
    return;
  }
  const newTimestamp = utcTimestamp + (direction * days * 24 * 60 * 60 * 1000);
  
  const formattedDate = formatLocalDatetime(newTimestamp);
  if (formattedDate) {
    // Modern date - update datetime input
    document.getElementById('jump-datetime').value = formattedDate;
    document.getElementById('jump-datetime').style.display = 'block';
    document.getElementById('jump-ancient-display').style.display = 'none';
  } else {
    // Ancient date - update text display
    const date = new Date(newTimestamp);
    document.getElementById('jump-ancient-date').textContent = formatDisplayDate(date);
    document.getElementById('jump-datetime').style.display = 'none';
    document.getElementById('jump-ancient-display').style.display = 'block';
  }
  
  document.getElementById('goto-date').value = formattedDate;
  state.selectedTimestamp = newTimestamp;
  jumpToDate();
}

function handleMapClick(event) {
  // Don't allow map clicks when on a preset profile
  const select = document.getElementById('profile-select');
  if (select && PRESET_PROFILES[select.value]) {
    return; // Preset profiles are read-only
  }
  
  const mapEl = event.currentTarget;
  const rect = mapEl.getBoundingClientRect();
  
  // Calculate click position as percentage
  const xPercent = (event.clientX - rect.left) / rect.width;
  const yPercent = (event.clientY - rect.top) / rect.height;
  
  // Convert to lat/lon (equirectangular projection)
  // X: 0% = -180¬∞, 100% = 180¬∞
  // Y: 0% = 90¬∞ (north), 100% = -90¬∞ (south)
  const lon = (xPercent * 360) - 180;
  const lat = 90 - (yPercent * 180);
  
  // Round to 2 decimal places
  state.lat = Math.round(lat * 100) / 100;
  state.lon = Math.round(lon * 100) / 100;
  state.city = ''; // Clear city selection
  
  // Update main inputs
  document.getElementById('lat-input').value = state.lat;
  document.getElementById('lon-input').value = state.lon;
  document.getElementById('city-select').value = '';
  
  // Update settings page inputs
  const settingsLatInput = document.getElementById('settings-lat-input');
  const settingsLonInput = document.getElementById('settings-lon-input');
  const settingsCitySelect = document.getElementById('settings-city-select');
  const settingsCustomCoords = document.getElementById('settings-custom-coords');
  
  if (settingsLatInput) settingsLatInput.value = state.lat;
  if (settingsLonInput) settingsLonInput.value = state.lon;
  if (settingsCitySelect) settingsCitySelect.value = 'custom';
  if (settingsCustomCoords) settingsCustomCoords.style.display = 'flex';
  
  // Show custom coords on main page
  const customCoords = document.getElementById('custom-coords');
  if (customCoords) customCoords.style.display = 'block';
  
  // Save and regenerate (preserve current month for location changes)
  saveState();
  generateCalendar({ preserveMonth: true });
  updateURL();
  
  // Update the settings maps (both containers)
  renderSettingsMap();
  renderSettingsPageMap();
  refreshDayDetailIfVisible();
}

function useCurrentLocation() {
  const btn = document.querySelector('.location-btn');
  const originalText = btn.textContent;
  
  if (!navigator.geolocation) {
    alert('Geolocation is not supported by your browser');
    return;
  }
  
  btn.textContent = 'üìç Getting location...';
  btn.disabled = true;
  
  navigator.geolocation.getCurrentPosition(
    function(position) {
      // Success
      state.lat = Math.round(position.coords.latitude * 10000) / 10000;
      state.lon = Math.round(position.coords.longitude * 10000) / 10000;
      state.city = ''; // Clear city selection
      
      document.getElementById('lat-input').value = state.lat;
      document.getElementById('lon-input').value = state.lon;
      document.getElementById('city-select').value = '';
      document.getElementById('custom-coords').style.display = 'block';
      
      updateProfileButtons();  // Check if settings match a profile
      saveState();
      generateCalendar({ preserveMonth: true });
      updateURL();
      renderSettingsMap();
      refreshDayDetailIfVisible();
      
      btn.textContent = '‚úì Location set!';
      setTimeout(() => {
        btn.textContent = originalText;
        btn.disabled = false;
      }, 2000);
    },
    function(error) {
      // Error
      let message = 'Unable to get location';
      switch(error.code) {
        case error.PERMISSION_DENIED:
          message = 'Location access denied. Please enable location permissions.';
          break;
        case error.POSITION_UNAVAILABLE:
          message = 'Location information unavailable.';
          break;
        case error.TIMEOUT:
          message = 'Location request timed out.';
          break;
      }
      alert(message);
      btn.textContent = originalText;
      btn.disabled = false;
    },
    {
      enableHighAccuracy: false,
      timeout: 10000,
      maximumAge: 300000 // Cache for 5 minutes
    }
  );
}

document.getElementById('city-select').addEventListener('change', function() {
  const customCoords = document.getElementById('custom-coords');
  
  if (this.value === '') {
    // Custom selected - show coordinate inputs
    customCoords.style.display = 'block';
    state.city = '';
    return;
  }
  
  if (this.value) {
    customCoords.style.display = 'none';
    const [lat, lon] = this.value.split(',').map(Number);
    state.lat = lat;
    state.lon = lon;
    state.city = this.value;
    saveState();
    updateUI();
    generateCalendar({ preserveMonth: true });
    updateURL();
    renderSettingsMap();
    refreshDayDetailIfVisible();
  }
});

// Settings page city select handler
document.getElementById('settings-city-select').addEventListener('change', function() {
  // Don't allow changes on preset profiles
  const profileSelect = document.getElementById('profile-select');
  if (profileSelect && PRESET_PROFILES[profileSelect.value]) return;
  
  const customCoords = document.getElementById('settings-custom-coords');
  
  if (this.value === 'current') {
    // Use geolocation
    useCurrentLocationFromSettings();
    return;
  }
  
  if (this.value === 'custom') {
    customCoords.style.display = 'flex';
    state.city = '';
    return;
  }
  
  if (this.value) {
    customCoords.style.display = 'none';
    const [lat, lon] = this.value.split(',').map(Number);
    state.lat = lat;
    state.lon = lon;
    state.city = this.value;
    
    // Sync with old inputs
    document.getElementById('lat-input').value = state.lat;
    document.getElementById('lon-input').value = state.lon;
    document.getElementById('city-select').value = this.value;
    
    updateProfileButtons();  // Check if settings match a profile
    saveState();
    generateCalendar({ preserveMonth: true });
    updateURL();
    renderSettingsPageMap();
    refreshDayDetailIfVisible();
  }
});

// Settings page custom coordinate inputs
document.getElementById('settings-lat-input').addEventListener('change', function() {
  // Don't allow changes on preset profiles
  const profileSelect = document.getElementById('profile-select');
  if (profileSelect && PRESET_PROFILES[profileSelect.value]) return;
  
  state.lat = parseFloat(this.value);
  state.city = '';
  document.getElementById('lat-input').value = state.lat;
  updateProfileButtons();  // Check if settings match a profile
  saveState();
  generateCalendar({ preserveMonth: true });
  updateURL();
  renderSettingsPageMap();
  refreshDayDetailIfVisible();
});

document.getElementById('settings-lon-input').addEventListener('change', function() {
  // Don't allow changes on preset profiles
  const profileSelect = document.getElementById('profile-select');
  if (profileSelect && PRESET_PROFILES[profileSelect.value]) return;
  
  state.lon = parseFloat(this.value);
  state.city = '';
  document.getElementById('lon-input').value = state.lon;
  updateProfileButtons();  // Check if settings match a profile
  saveState();
  generateCalendar({ preserveMonth: true });
  updateURL();
  renderSettingsPageMap();
  refreshDayDetailIfVisible();
});

function useCurrentLocationFromSettings() {
  const select = document.getElementById('settings-city-select');
  
  if (!navigator.geolocation) {
    alert('Geolocation is not supported by your browser');
    // Reset to first city option
    select.value = '31.7683,35.2137';
    return;
  }
  
  navigator.geolocation.getCurrentPosition(
    function(position) {
      state.lat = Math.round(position.coords.latitude * 10000) / 10000;
      state.lon = Math.round(position.coords.longitude * 10000) / 10000;
      state.city = '';
      
      // Update both old and new inputs
      document.getElementById('lat-input').value = state.lat;
      document.getElementById('lon-input').value = state.lon;
      document.getElementById('settings-lat-input').value = state.lat;
      document.getElementById('settings-lon-input').value = state.lon;
      
      // Show custom coordinates with the detected location
      select.value = 'custom';
      document.getElementById('settings-custom-coords').style.display = 'flex';
      
      updateProfileButtons();  // Check if settings match a profile
      saveState();
      generateCalendar({ preserveMonth: true });
      updateURL();
      renderSettingsPageMap();
      refreshDayDetailIfVisible();
    },
    function(error) {
      alert('Unable to get your location. Please select a city or enter coordinates manually.');
      // Reset to first city option
      select.value = '31.7683,35.2137';
    },
    { timeout: 10000, enableHighAccuracy: true }
  );
}

// Auto-regenerate when inputs change
function regenerateAndUpdateURL() {
  generateCalendar();
  updateURL();
}
document.getElementById('year-input').addEventListener('change', regenerateAndUpdateURL);
document.getElementById('moon-phase-select').addEventListener('change', regenerateAndUpdateURL);
document.getElementById('lat-input').addEventListener('change', function() {
  state.city = ''; // Clear city selection when manually editing coordinates
  generateCalendar({ preserveMonth: true });
  updateURL();
  refreshDayDetailIfVisible();
});
document.getElementById('lon-input').addEventListener('change', function() {
  state.city = ''; // Clear city selection when manually editing coordinates
  generateCalendar({ preserveMonth: true });
  updateURL();
  refreshDayDetailIfVisible();
});

function changeYear(delta) {
  state.year += delta;
  state.highlightedLunarDay = null;
  state.selectedTimestamp = null;
  updateUI();
  generateCalendar();
  updateURL();
}

function addDaysToDate(direction) {
  const dateInput = document.getElementById('goto-date').value;
  const daysValue = parseInt(document.getElementById('add-days').value);
  
  if (!dateInput) {
    alert('Please select a date first');
    return;
  }
  
  if (isNaN(daysValue) || daysValue <= 0) {
    alert('Please enter a positive number of days');
    return;
  }
  
  const daysToAdd = daysValue * direction; // direction: 1 = forward, -1 = backward
  
  // Parse current datetime as local time at location, get UTC timestamp
  const utcTimestamp = parseDatetimeLocal(dateInput);
  // Add days in milliseconds
  const newTimestamp = utcTimestamp + daysToAdd * 24 * 60 * 60 * 1000;
  
  // Update the datetime input with new local time
  document.getElementById('goto-date').value = formatLocalDatetime(newTimestamp);
  
  // Jump to the new date
  jumpToDate();
}

function jumpToDate() {
  const dateInput = document.getElementById('goto-date').value;
  
  // For ancient dates, dateInput will be empty - use selectedTimestamp
  let utcTimestamp;
  if (dateInput) {
    utcTimestamp = parseDatetimeLocal(dateInput);
  } else if (state.selectedTimestamp) {
    utcTimestamp = state.selectedTimestamp;
  } else {
    alert('Please enter a date');
    return;
  }
  
  const targetDate = new Date(utcTimestamp);
  const targetYear = targetDate.getUTCFullYear();
  
  // Helper function to search in current lunar months
  function searchInCurrentMonths() {
    for (let m = 0; m < state.lunarMonths.length; m++) {
      const month = state.lunarMonths[m];
      for (let d = 0; d < month.days.length; d++) {
        const day = month.days[d];
        if (day.gregorianDate.toDateString() === targetDate.toDateString()) {
          return { month: m, dayIndex: d };
        }
      }
    }
    return null;
  }
  
  // First try current lunar months
  let found = searchInCurrentMonths();
  
  // If not found, try different lunar years
  // Lunar years span ~March to ~March, so we need to try year-1, year, and year+1
  if (!found) {
    const yearsToTry = [targetYear, targetYear - 1, targetYear + 1];
    
    for (const lunarYear of yearsToTry) {
      if (lunarYear === state.year) continue; // Already tried
      
      state.year = lunarYear;
      updateUI();
      generateCalendar(); // This also updates dateline overview
      
      found = searchInCurrentMonths();
      if (found) break;
    }
  }
  
  if (found) {
    state.currentMonthIndex = found.month;
    const dayObj = state.lunarMonths[found.month].days[found.dayIndex];
    state.highlightedLunarDay = dayObj.lunarDay;
    // Store the actual timestamp from the input (preserves time)
    state.selectedTimestamp = targetDate.getTime();
    renderMonth(state.lunarMonths[state.currentMonthIndex]);
    updateMonthButtons();
    updateURL();
    showDayDetail(dayObj, state.lunarMonths[found.month]);
  } else {
    alert('Date not found in lunar calendar. The Astronomy library may not support this date range.');
  }
}

function selectMonth(index) {
  // Preserve the current day number when switching months
  const previousDay = state.highlightedLunarDay || 1;
  state.currentMonthIndex = index;
  
  // Carry day selection to new month, clamping to valid range
  const newMonth = state.lunarMonths[index];
  const maxDay = newMonth.days.length;
  state.highlightedLunarDay = Math.min(previousDay, maxDay);
  
  // Update selectedTimestamp for the new month's day
  const dayObj = newMonth.days.find(d => d.lunarDay === state.highlightedLunarDay);
  if (dayObj) {
    state.selectedTimestamp = getSunriseTimestamp(dayObj.gregorianDate);
    document.getElementById('goto-date').value = formatLocalDatetime(state.selectedTimestamp);
  }
  
  renderMonth(state.lunarMonths[state.currentMonthIndex]);
  updateMonthButtons();
  updateURL();
  
  // Show day detail for the carried-over day
  if (dayObj) {
    showDayDetail(dayObj, newMonth);
  }
}

function navigateMonth(direction) {
  const newIndex = state.currentMonthIndex + direction;
  const previousDay = state.highlightedLunarDay || 1;
  
  if (newIndex < 0) {
    // Go to previous year, last month
    state.year -= 1;
    updateUI();
    generateCalendar();
    // Jump to last month of previous year
    state.currentMonthIndex = state.lunarMonths.length - 1;
    
    // Preserve day selection, clamped to valid range
    const newMonth = state.lunarMonths[state.currentMonthIndex];
    const maxDay = newMonth.days.length;
    state.highlightedLunarDay = Math.min(previousDay, maxDay);
    const dayObj = newMonth.days.find(d => d.lunarDay === state.highlightedLunarDay);
    if (dayObj) {
      state.selectedTimestamp = getSunriseTimestamp(dayObj.gregorianDate);
      document.getElementById('goto-date').value = formatLocalDatetime(state.selectedTimestamp);
      showDayDetail(dayObj, newMonth);
    }
    
    renderMonth(state.lunarMonths[state.currentMonthIndex]);
    updateMonthButtons();
    updateURL();
  } else if (newIndex >= state.lunarMonths.length) {
    // Go to next year, first month
    state.year += 1;
    updateUI();
    generateCalendar();
    // Already at first month (generateCalendar sets to 0)
    
    // Preserve day selection, clamped to valid range
    const newMonth = state.lunarMonths[state.currentMonthIndex];
    const maxDay = newMonth.days.length;
    state.highlightedLunarDay = Math.min(previousDay, maxDay);
    const dayObj = newMonth.days.find(d => d.lunarDay === state.highlightedLunarDay);
    if (dayObj) {
      state.selectedTimestamp = getSunriseTimestamp(dayObj.gregorianDate);
      document.getElementById('goto-date').value = formatLocalDatetime(state.selectedTimestamp);
      showDayDetail(dayObj, newMonth);
    }
    
    renderMonth(state.lunarMonths[state.currentMonthIndex]);
    updateURL();
  } else {
    // Normal month navigation within same year
    selectMonth(newIndex);
  }
}

function updateMonthButtons() {
  const buttons = document.querySelectorAll('.month-btn');
  buttons.forEach((btn, i) => {
    btn.classList.toggle('active', i === state.currentMonthIndex);
  });
}

function renderMonthButtons() {
  const container = document.getElementById('month-buttons');
  container.innerHTML = '';
  
  const has13Months = state.lunarMonths.length >= 13;
  
  // Month buttons 1-12 (always show)
  for (let i = 0; i < 12; i++) {
    const btn = document.createElement('button');
    btn.className = 'month-btn' + (i === state.currentMonthIndex ? ' active' : '');
    if (i >= state.lunarMonths.length) {
      btn.classList.add('disabled');
      btn.disabled = true;
    }
    btn.textContent = i + 1;
    btn.onclick = () => selectMonth(i);
    container.appendChild(btn);
  }
  
  // Month 13 button (hidden on mobile unless year has 13 months) - with calendar icon
  if (state.lunarMonths.length >= 13) {
    const btn13 = document.createElement('button');
    btn13.className = 'month-btn month-13' + (has13Months ? ' has-13' : '') + (12 === state.currentMonthIndex ? ' active' : '');
    btn13.innerHTML = '<span class="month-13-icon">üìÖ</span><span class="month-13-num">13</span>';
    btn13.title = 'Intercalary 13th month';
    btn13.onclick = () => selectMonth(12);
    container.appendChild(btn13);
  }
}

function formatYear(year) {
  if (year <= 0) {
    // Astronomical year 0 = 1 BC, -1 = 2 BC, etc.
    return Math.abs(year - 1) + ' BC';
  }
  return String(year);  // No "AD" suffix for positive years
}

// Gregorian calendar reform date: October 15, 1582
// Before this date, use Julian calendar (following NASA/Stellarium convention)
const GREGORIAN_REFORM_DATE = new Date(1582, 9, 15); // Oct 15, 1582

// Convert a JavaScript Date (which is proleptic Gregorian) to Julian calendar date
// Returns { year, month, day } in Julian calendar
function gregorianToJulian(date) {
  // JavaScript dates are in proleptic Gregorian calendar
  // We need to convert to Julian for dates before 1582-10-15
  const year = date.getFullYear();
  const month = date.getMonth(); // 0-indexed
  const day = date.getDate();
  
  // Calculate Julian Day Number from Gregorian date
  const a = Math.floor((14 - (month + 1)) / 12);
  const y = year + 4800 - a;
  const m = (month + 1) + 12 * a - 3;
  
  // Julian Day Number for Gregorian calendar
  const jdn = day + Math.floor((153 * m + 2) / 5) + 365 * y + Math.floor(y / 4) - Math.floor(y / 100) + Math.floor(y / 400) - 32045;
  
  // Convert JDN back to Julian calendar date
  const c = jdn + 32082;
  const d = Math.floor((4 * c + 3) / 1461);
  const e = c - Math.floor(1461 * d / 4);
  const n = Math.floor((5 * e + 2) / 153);
  
  const julianDay = e - Math.floor((153 * n + 2) / 5) + 1;
  const julianMonth = n + 3 - 12 * Math.floor(n / 10); // 1-indexed
  const julianYear = d - 4800 + Math.floor(n / 10);
  
  return { year: julianYear, month: julianMonth - 1, day: julianDay }; // month 0-indexed to match JS
}

// Check if a date is before the Gregorian reform
function isBeforeGregorianReform(date) {
  return date < GREGORIAN_REFORM_DATE;
}

// Calculate Julian Day Number from Julian calendar date (year, month 0-indexed, day)
function julianCalendarToJDN(year, month, day) {
  // Convert 0-indexed month to 1-indexed
  const m = month + 1;
  const a = Math.floor((14 - m) / 12);
  const y = year + 4800 - a;
  const mm = m + 12 * a - 3;
  // Julian calendar formula
  return day + Math.floor((153 * mm + 2) / 5) + 365 * y + Math.floor(y / 4) - 32083;
}

// Calculate day of week from Julian Day Number (0 = Sunday, 6 = Saturday)
function jdnToWeekday(jdn) {
  return (jdn + 1) % 7;
}

// Get correct weekday for a date (handles Julian calendar for ancient dates)
function getCorrectWeekday(date) {
  if (isBeforeGregorianReform(date)) {
    const year = date.getUTCFullYear();
    const month = date.getUTCMonth();
    const day = date.getUTCDate();
    const jdn = julianCalendarToJDN(year, month, day);
    return jdnToWeekday(jdn);
  }
  return date.getUTCDay();
}

// Get formatted date components (handles Julian calendar for pre-1582 dates)
// Note: Dates from _jdToDate() already have Julian calendar components stored,
// so we just use getFullYear/getMonth/getDate directly - no conversion needed.
function getFormattedDateParts(date) {
  const weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
  const months = ['January', 'February', 'March', 'April', 'May', 'June', 
                  'July', 'August', 'September', 'October', 'November', 'December'];
  const shortMonths = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  
  // For ancient dates, use UTC methods to avoid timezone issues
  // The astronomy engine's _jdToDate already stores Julian calendar values
  const year = date.getUTCFullYear();
  const month = date.getUTCMonth();
  const day = date.getUTCDate();
  const isJulian = isBeforeGregorianReform(date);
  
  // Calculate weekday from Julian Day Number for correct result
  // (JavaScript's getUTCDay() uses proleptic Gregorian internally, which is wrong for Julian dates)
  let weekday;
  if (isJulian) {
    const jdn = julianCalendarToJDN(year, month, day);
    weekday = jdnToWeekday(jdn);
  } else {
    weekday = date.getUTCDay();
  }
  
  // Year string: only BC suffix, never AD
  const yearStr = year <= 0 ? `${Math.abs(year - 1)} BC` : `${year}`;
  
  return {
    year,
    yearStr,
    month,
    day,
    weekday,
    weekdayName: weekdays[weekday],
    monthName: months[month],
    shortMonthName: shortMonths[month],
    isJulian,
    calendarSuffix: isJulian ? ' (Julian)' : ''
  };
}

// Format a date for display in day detail panel: "Monday, January 1, 2025"
function formatDisplayDate(date) {
  const parts = getFormattedDateParts(date);
  return `${parts.weekdayName}, ${parts.monthName} ${parts.day}, ${parts.yearStr}${parts.calendarSuffix}`;
}

function getMoonIcon() {
  if (state.moonPhase === 'full') return 'üåï';
  if (state.moonPhase === 'dark') return 'üåë';
  if (state.moonPhase === 'crescent') return 'üåí';
  return 'üåï';
}

// Get the moon phase icon for a specific date, but ONLY if a quarter phase
// (new moon 0¬∞, first quarter 90¬∞, full moon 180¬∞, last quarter 270¬∞) occurs during this lunar day
// Uses the calendar's day start/end definition (sunset, sunrise, etc.) rather than UTC midnight
function getMoonPhaseIconForDate(date) {
  try {
    // Get the lunar day start time for this date based on current calendar config
    const dayStartTs = getDayStartTime(date);
    
    // The lunar day runs from this day start to the next day's start
    // Calculate next day's start by getting the day start for tomorrow's Gregorian date
    const tomorrowGregorian = new Date(date.getTime());
    tomorrowGregorian.setUTCDate(tomorrowGregorian.getUTCDate() + 1);
    const dayEndTs = getDayStartTime(tomorrowGregorian);
    
    const startOfDay = new Date(dayStartTs);
    const endOfDay = new Date(dayEndTs);
    
    const elongStart = getElongationForDate(startOfDay);
    const elongEnd = getElongationForDate(endOfDay);
    
    if (elongStart === null || elongEnd === null) return '';
    
    // Check each of the 4 major quarters
    const quarters = [
      { angle: 0, icon: 'üåë' },    // New Moon
      { angle: 90, icon: 'üåì' },   // First Quarter
      { angle: 180, icon: 'üåï' },  // Full Moon
      { angle: 270, icon: 'üåó' }   // Last Quarter
    ];
    
    for (const quarter of quarters) {
      if (phaseOccursDuringDay(elongStart, elongEnd, quarter.angle)) {
        return quarter.icon;
      }
    }
    
    return ''; // No quarter phase on this day
  } catch (err) {
    console.warn('Error calculating moon phase:', err);
    return '';
  }
}

// Check if a phase angle is crossed between two elongation values
function phaseOccursDuringDay(elongStart, elongEnd, targetAngle) {
  // Elongation increases over time (moon moves ~12¬∞ per day relative to sun)
  // Handle the 360¬∞‚Üí0¬∞ wraparound for new moon
  
  if (targetAngle === 0) {
    // New moon: elongation wraps from ~350+ to ~10-
    // This happens when elongStart is high (>300) and elongEnd is lower OR 
    // when elongStart > 350 and elongEnd is small
    if (elongStart > 300 && elongEnd < elongStart) {
      // Could be wraparound or normal decrease (shouldn't normally decrease much)
      // If elongEnd is small (<60), it wrapped around
      if (elongEnd < 60) return true;
    }
    // Also check if we're very close to 0 on either end
    if (elongStart > 350 || elongEnd < 10) {
      if (elongStart > 350 && elongEnd < 60) return true;
    }
  } else {
    // For other phases (90, 180, 270): check if targetAngle is between start and end
    // Normal case: elongation increases
    if (elongStart <= targetAngle && elongEnd >= targetAngle) return true;
    
    // Edge case: day spans the 360‚Üí0 boundary but target is not 0
    // In this case, elongStart > elongEnd due to wraparound
    if (elongStart > elongEnd) {
      // Wrapped around - check both segments
      if (elongStart <= targetAngle || elongEnd >= targetAngle) return true;
    }
  }
  
  return false;
}

// Get moon-sun elongation for a date
function getElongationForDate(date) {
  // For Swiss Ephemeris, use the elongation function directly
  if (AstroEngines.swissEphemeris.isLoaded && AstroEngines.swissEphemeris._dateToJD) {
    const jd = AstroEngines.swissEphemeris._dateToJD(date);
    const elongation = AstroEngines.swissEphemeris._getMoonSunElongation(jd);
    if (elongation !== null) return elongation;
  }
  
  // Fallback: use astronomy-engine
  try {
    const engine = getAstroEngine();
    const observer = engine.createObserver(state.lat, state.lon, 0);
    const sunEq = engine.getEquator('sun', date, observer);
    const moonEq = engine.getEquator('moon', date, observer);
    
    if (sunEq && moonEq) {
      let sunRA = sunEq.ra * 15;
      let moonRA = moonEq.ra * 15;
      let elongation = moonRA - sunRA;
      while (elongation < 0) elongation += 360;
      while (elongation >= 360) elongation -= 360;
      return elongation;
    }
  } catch (err) {}
  
  return null;
}

// Calculate angular distance between two angles (0-360), handling wraparound
function angularDistance(a, b) {
  let diff = Math.abs(a - b);
  if (diff > 180) diff = 360 - diff;
  return diff;
}

function getMoonLabel() {
  if (state.moonPhase === 'full') return 'Full Moon';
  if (state.moonPhase === 'dark') return 'Dark Moon';
  if (state.moonPhase === 'crescent') return 'Crescent';
  return 'New Moon';
}

// Get dynamic description for Renewed Moon based on current moon phase setting
function getRenewedMoonDescription() {
  const dayStartLabel = getDayStartLabel();
  const isCrescentSunset = state.moonPhase === 'crescent' && 
                           state.dayStartTime === 'evening' && 
                           state.dayStartAngle === 0;
  
  if (state.moonPhase === 'full') {
    return `Month begins at ${dayStartLabel} after full moon`;
  } else if (state.moonPhase === 'dark') {
    return `Month begins at ${dayStartLabel} after dark moon (conjunction)`;
  } else if (state.moonPhase === 'crescent') {
    if (isCrescentSunset) {
      return 'Month begins at sunset when first crescent is sighted';
    }
    return `Month begins at ${dayStartLabel} after crescent sighting`;
  }
  return 'Beginning of the month';
}

function generateCalendar(options = {}) {
  const preserveSelection = options.preserveMonth || false;
  
  // Save the selected UTC timestamp before regenerating
  const savedTimestamp = state.selectedTimestamp;
  
  // Read from UI inputs into state
  state.year = parseInt(document.getElementById('year-input').value);
  state.lat = parseFloat(document.getElementById('lat-input').value);
  state.lon = parseFloat(document.getElementById('lon-input').value);
  state.moonPhase = document.getElementById('moon-phase-select').value;
  
  if (!preserveSelection) {
    state.currentMonthIndex = 0;
    state.highlightedLunarDay = null;
    state.selectedTimestamp = null;
  }
  
  // Save settings to localStorage
  saveState();
  
  // Update all UI to match state
  updateUI();
  
  const engine = getAstroEngine();
  const springEquinox = engine.getSeasons(state.year).mar_equinox.date;
  const nextSpringEquinox = engine.getSeasons(state.year + 1).mar_equinox.date;
  const moonEvents = findMoonEvents(state.year, state.moonPhase);
  
  // Get year start point based on yearStartRule setting
  const yearStartPoint = getYearStartPoint(state.year);
  const nextYearStartPoint = getYearStartPoint(state.year + 1);
  
  // Find first moon event on or after the year start point
  // The resulting month's Day 1 must start after the year start point
  let nissanMoon = moonEvents.find(m => m >= yearStartPoint);
  if (!nissanMoon) nissanMoon = moonEvents[0];
  
  // Store equinoxes and year start points in state for use in day details
  state.springEquinox = springEquinox;
  state.nextSpringEquinox = nextSpringEquinox;
  state.yearStartPoint = yearStartPoint;
  state.nextYearStartPoint = nextYearStartPoint;
  
  state.lunarMonths = buildLunarMonths(nissanMoon, moonEvents, springEquinox, nextYearStartPoint);
  
  // Guard against empty months array
  if (state.lunarMonths.length === 0) {
    console.error('No lunar months generated - check moon event data');
    console.error('nissanMoon:', nissanMoon);
    console.error('moonEvents count:', moonEvents.length);
    console.error('yearStartPoint:', yearStartPoint);
    console.error('nextYearStartPoint:', nextYearStartPoint);
    return;
  }
  
  // If preserving selection, find which lunar day contains the saved UTC timestamp
  if (preserveSelection && savedTimestamp) {
    const savedMoment = new Date(savedTimestamp);
    let found = false;
    
    for (let m = 0; m < state.lunarMonths.length && !found; m++) {
      const month = state.lunarMonths[m];
      for (let d = 0; d < month.days.length; d++) {
        const day = month.days[d];
        const dayStart = day.gregorianDate.getTime();
        // Day ends at start of next day (24 hours later)
        const dayEnd = dayStart + 24 * 60 * 60 * 1000;
        
        if (savedTimestamp >= dayStart && savedTimestamp < dayEnd) {
          state.currentMonthIndex = m;
          state.highlightedLunarDay = day.lunarDay;
          // Update the goto-date input to show local time at new location
          document.getElementById('goto-date').value = formatLocalDatetime(savedTimestamp);
          found = true;
          break;
        }
      }
    }
    // If timestamp not found in lunar months, just stay on month 0
    if (!found) {
      state.currentMonthIndex = 0;
      state.highlightedLunarDay = null;
    }
  }
  
  renderMonthButtons();
  renderMonth(state.lunarMonths[state.currentMonthIndex]);
  renderFeastTable(state.lunarMonths);
  
  // Show day detail panel if a day is highlighted
  if (state.highlightedLunarDay) {
    const month = state.lunarMonths[state.currentMonthIndex];
    const dayObj = month.days.find(d => d.lunarDay === state.highlightedLunarDay);
    if (dayObj) {
      showDayDetail(dayObj, month);
    }
  }
}

function findMoonEvents(year, phaseType) {
  const engine = getAstroEngine();
  const events = [];
  
  // Create dates with proper year handling for ancient dates
  // JavaScript Date constructor doesn't handle negative years correctly
  let searchDate = new Date(Date.UTC(2000, 11, 1));
  searchDate.setUTCFullYear(year - 1);
  
  let endDate = new Date(Date.UTC(2000, 5, 1));
  endDate.setUTCFullYear(year + 1); // Search through May of next year to cover full lunar year
  
  // Moon phase angles: 0 = new/dark, 90 = first quarter, 180 = full, 270 = last quarter
  let targetPhase;
  if (phaseType === 'full') {
    targetPhase = 180;
  } else if (phaseType === 'dark') {
    targetPhase = 0;
  } else if (phaseType === 'crescent') {
    targetPhase = 0; // We'll find conjunction then calculate first visibility
  }
  
  while (searchDate < endDate) {
    const result = engine.searchMoonPhase(targetPhase, searchDate, 40);
    if (result) {
      let eventDate = result.date;
      
      // For crescent, add offset to conjunction to create a "forged conjunction" time
      // This represents when the crescent becomes visible, treated as if it were the conjunction
      // The rest of the algorithm (before/after sunset check) works the same as dark moon
      // - 12h: Optimistic (perfect conditions + optical aids)
      // - 15.5h: Minimum viable (naked-eye record)
      // - 18h: Typical (standard naked-eye visibility)
      // - 24h: Conservative (easily visible to anyone)
      if (phaseType === 'crescent') {
        const conjunction = result.date;
        const crescentOffsetHours = state.crescentThreshold;
        eventDate = new Date(conjunction.getTime() + crescentOffsetHours * 60 * 60 * 1000);
      }
      
      events.push(eventDate);
      searchDate = new Date(result.date.getTime() + 20 * 24 * 60 * 60 * 1000);
    } else break;
  }
  return events;
}

// Convert UTC date to local date based on longitude (solar time)
function getLocalDateFromUTC(utcDate, longitude) {
  // Calculate timezone offset based on longitude
  // Each 15¬∞ of longitude = 1 hour offset
  const hourOffset = longitude / 15;
  
  // For ancient dates, _jdToDate stores Julian calendar components in the Date object.
  // We need to work with UTC components directly to avoid JavaScript's proleptic Gregorian timestamp issues.
  const utcHour = utcDate.getUTCHours() + utcDate.getUTCMinutes() / 60;
  const localHour = utcHour + hourOffset;
  
  // Get the base date components (these are already in the correct calendar from _jdToDate)
  let year = utcDate.getUTCFullYear();
  let month = utcDate.getUTCMonth();
  let day = utcDate.getUTCDate();
  
  // Adjust day if local time crosses midnight
  if (localHour >= 24) {
    day += 1;
    // Handle month/year rollover (simplified - assumes 30-day months for edge cases)
    const daysInMonth = new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    if (day > daysInMonth) {
      day = 1;
      month += 1;
      if (month > 11) {
        month = 0;
        year += 1;
      }
    }
  } else if (localHour < 0) {
    day -= 1;
    if (day < 1) {
      month -= 1;
      if (month < 0) {
        month = 11;
        year -= 1;
      }
      day = new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }
  }
  
  // Create date with correct components (use Date.UTC and setUTCFullYear for ancient dates)
  const result = new Date(Date.UTC(2000, month, day, 0, 0, 0));
  result.setUTCFullYear(year);
  return result;
}

// Calculate what lunar day a timestamp falls on for a given profile's settings
// Returns { day: number, month: number } or null if unable to calculate
function getLunarDayForTimestamp(timestamp, profile) {
  try {
    const date = new Date(timestamp);
    let year = date.getFullYear();
    
    // Temporarily store current state and apply profile settings
    const savedState = {
      moonPhase: state.moonPhase,
      dayStartTime: state.dayStartTime,
      dayStartAngle: state.dayStartAngle,
      yearStartRule: state.yearStartRule,
      crescentThreshold: state.crescentThreshold,
      lat: state.lat,
      lon: state.lon
    };
    
    // Apply profile settings temporarily
    state.moonPhase = profile.moonPhase;
    state.dayStartTime = profile.dayStartTime;
    state.dayStartAngle = profile.dayStartAngle;
    state.yearStartRule = profile.yearStartRule;
    state.crescentThreshold = profile.crescentThreshold;
    state.lat = profile.lat;
    state.lon = profile.lon;
    
    const engine = getAstroEngine();
    
    // Check if timestamp is before this year's spring equinox - if so, use previous year
    const thisYearEquinox = engine.getSeasons(year).mar_equinox.date;
    if (date < thisYearEquinox) {
      year = year - 1;
    }
    
    // Find moon events for the year (need events spanning into next year)
    const moonEvents = findMoonEvents(year, profile.moonPhase);
    if (!moonEvents || moonEvents.length === 0) {
      Object.assign(state, savedState);
      return null;
    }
    
    // Find the spring equinox for the lunar year
    const springEquinox = engine.getSeasons(year).mar_equinox.date;
    
    // Find the first moon event on or after the spring equinox for Nisan
    let nissanMoon = null;
    for (const event of moonEvents) {
      if (event >= springEquinox) {
        nissanMoon = event;
        break;
      }
    }
    
    // If no moon event after equinox, check the last one before
    if (!nissanMoon && moonEvents.length > 0) {
      for (let i = moonEvents.length - 1; i >= 0; i--) {
        if (moonEvents[i] < springEquinox) {
          nissanMoon = moonEvents[i];
          break;
        }
      }
    }
    
    if (!nissanMoon) {
      Object.assign(state, savedState);
      return null;
    }
    
    // Build simplified lunar months to find the day
    const observerLon = profile.lon;
    let currentMoonIdx = moonEvents.findIndex(m => Math.abs(m.getTime() - nissanMoon.getTime()) < 1000);
    if (currentMoonIdx === -1) currentMoonIdx = moonEvents.findIndex(m => m >= nissanMoon);
    
    // Iterate through months to find where the timestamp falls
    for (let m = 0; m < 13 && currentMoonIdx < moonEvents.length - 1; m++) {
      const moonEvent = moonEvents[currentMoonIdx];
      const nextMoonEvent = moonEvents[currentMoonIdx + 1];
      
      // Calculate month start date (similar to buildLunarMonths)
      const moonEventLocalDate = new Date(moonEvent.getTime());
      const monthStartDate = new Date(Date.UTC(
        moonEventLocalDate.getUTCFullYear(),
        moonEventLocalDate.getUTCMonth(),
        moonEventLocalDate.getUTCDate(),
        0, 0, 0
      ));
      
      // Apply day offset based on settings
      if ((profile.moonPhase === 'dark' || profile.moonPhase === 'full' || profile.moonPhase === 'crescent') && profile.dayStartTime === 'evening') {
        const sunsetOnMoonDate = getSunsetTimestamp(moonEventLocalDate);
        if (sunsetOnMoonDate != null) {
          const moonEventLocalTime = moonEvent.getTime() + (observerLon / 15) * 60 * 60 * 1000;
          const sunsetLocalTime = sunsetOnMoonDate + (observerLon / 15) * 60 * 60 * 1000;
          if (moonEventLocalTime > sunsetLocalTime) {
            monthStartDate.setUTCDate(monthStartDate.getUTCDate() + 1);
          }
        }
      }
      
      // Calculate next month start
      const nextMoonEventLocalDate = new Date(nextMoonEvent.getTime());
      const nextMonthStart = new Date(Date.UTC(
        nextMoonEventLocalDate.getUTCFullYear(),
        nextMoonEventLocalDate.getUTCMonth(),
        nextMoonEventLocalDate.getUTCDate(),
        0, 0, 0
      ));
      
      if ((profile.moonPhase === 'dark' || profile.moonPhase === 'full' || profile.moonPhase === 'crescent') && profile.dayStartTime === 'evening') {
        const sunsetOnNextMoonDate = getSunsetTimestamp(nextMoonEventLocalDate);
        if (sunsetOnNextMoonDate != null) {
          const nextMoonEventLocalTime = nextMoonEvent.getTime() + (observerLon / 15) * 60 * 60 * 1000;
          const nextSunsetLocalTime = sunsetOnNextMoonDate + (observerLon / 15) * 60 * 60 * 1000;
          if (nextMoonEventLocalTime > nextSunsetLocalTime) {
            nextMonthStart.setUTCDate(nextMonthStart.getUTCDate() + 1);
          }
        }
      }
      
      // Check if timestamp falls in this month
      const timestampDate = new Date(timestamp);
      const timestampDayStart = new Date(Date.UTC(
        timestampDate.getUTCFullYear(),
        timestampDate.getUTCMonth(),
        timestampDate.getUTCDate(),
        0, 0, 0
      ));
      
      if (timestampDayStart >= monthStartDate && timestampDayStart < nextMonthStart) {
        // Found the month - calculate the day
        const dayOffset = Math.floor((timestampDayStart - monthStartDate) / (24 * 60 * 60 * 1000));
        const lunarDay = dayOffset + 1;
        
        // Restore state
        Object.assign(state, savedState);
        return { day: lunarDay, month: m + 1 };
      }
      
      currentMoonIdx++;
    }
    
    // Restore state
    Object.assign(state, savedState);
    return null;
  } catch (e) {
    console.warn('Error calculating lunar day for profile:', e);
    return null;
  }
}

function buildLunarMonths(nissanMoon, allMoonEvents, springEquinox, nextYearStartPoint) {
  const months = [];
  
  // Use fuzzy timestamp comparison (within 1 second) to handle potential Date object differences
  let startIdx = allMoonEvents.findIndex(m => Math.abs(m.getTime() - nissanMoon.getTime()) < 1000);
  if (startIdx === -1) startIdx = allMoonEvents.findIndex(m => m >= nissanMoon);
  if (startIdx === -1) startIdx = 0; // Final fallback to first event
  
  // Get observer's longitude for local time calculation
  const observerLon = parseFloat(document.getElementById('lon-input')?.value) || 35.2137;
  
  
  for (let m = 0; m < 13 && (startIdx + m) < allMoonEvents.length - 1; m++) {
    const moonEvent = allMoonEvents[startIdx + m];
    
    // Stop if this moon event is after the next year's start point (belongs to next year)
    if (moonEvent >= nextYearStartPoint) break;
    
    const nextMoonEvent = allMoonEvents[startIdx + m + 1];
    
    // Calculate local date of moon event based on observer's longitude
    const moonEventLocalDate = getLocalDateFromUTC(moonEvent, observerLon);
    
    // Determine when Day 1 starts based on day start settings
    // General rule: Day 1 starts at the NEXT day start after the moon event
    let monthStartDate = new Date(moonEventLocalDate.getTime());
    
    // For dark/full/crescent moon with evening day start, check if moon event is before or after sunset
    if ((state.moonPhase === 'dark' || state.moonPhase === 'full' || state.moonPhase === 'crescent') && state.dayStartTime === 'evening') {
      // Get sunset time on the moon event's local date
      const sunsetOnMoonDate = getSunsetTimestamp(moonEventLocalDate);
      
      // Convert times to local for comparison
      const moonEventLocalTime = moonEvent.getTime() + (observerLon / 15) * 60 * 60 * 1000;
      const sunsetLocalTime = sunsetOnMoonDate + (observerLon / 15) * 60 * 60 * 1000;
      
      // Day 1 starts at the NEXT sunset after the moon event
      // - If moon event is AFTER sunset on its calendar date ‚Üí next sunset is tomorrow ‚Üí add 1 day
      // - Otherwise (before sunset, including early morning before sunrise) ‚Üí next sunset is today ‚Üí add 0 days
      if (moonEventLocalTime > sunsetLocalTime) {
        // Moon event is AFTER sunset - Day 1 starts at next day's sunset
        monthStartDate.setUTCDate(monthStartDate.getUTCDate() + 1);
      }
      // If moon event is before sunset (including early morning), Day 1 starts at same day's sunset (add 0 days)
    } else if ((state.moonPhase === 'dark' || state.moonPhase === 'full' || state.moonPhase === 'crescent') && state.dayStartTime === 'morning') {
      // For morning day start, check if moon event is before or after sunrise
      const sunriseOnMoonDate = getSunriseTimestamp(moonEventLocalDate);
      
      // Convert moon event to local time at observer's longitude for comparison
      const moonEventLocalTime = moonEvent.getTime() + (observerLon / 15) * 60 * 60 * 1000;
      const sunriseLocalTime = sunriseOnMoonDate + (observerLon / 15) * 60 * 60 * 1000;
      
      if (moonEventLocalTime >= sunriseLocalTime) {
        // Moon event is AT or AFTER sunrise - Day 1 starts at next sunrise (add 1 day)
        monthStartDate.setUTCDate(monthStartDate.getUTCDate() + 1);
      }
      // If moon event is BEFORE sunrise, Day 1 starts at same day's sunrise (add 0 days)
    } else {
      // For other modes, just add 1 day
      monthStartDate.setUTCDate(monthStartDate.getUTCDate() + 1);
    }
    
    // Same logic for next month start
    const nextMoonEventLocalDate = getLocalDateFromUTC(nextMoonEvent, observerLon);
    let nextMonthStart = new Date(nextMoonEventLocalDate.getTime());
    
    if ((state.moonPhase === 'dark' || state.moonPhase === 'full' || state.moonPhase === 'crescent') && state.dayStartTime === 'evening') {
      const sunsetOnNextMoonDate = getSunsetTimestamp(nextMoonEventLocalDate);
      const nextMoonEventLocalTime = nextMoonEvent.getTime() + (observerLon / 15) * 60 * 60 * 1000;
      const nextSunsetLocalTime = sunsetOnNextMoonDate + (observerLon / 15) * 60 * 60 * 1000;
      
      // Day 1 starts at the NEXT sunset after the moon event
      if (nextMoonEventLocalTime > nextSunsetLocalTime) {
        // Moon event is AFTER sunset - Day 1 starts at next day's sunset
        nextMonthStart.setUTCDate(nextMonthStart.getUTCDate() + 1);
      }
      // If moon event is before sunset, Day 1 starts at same day's sunset (add 0 days)
    } else if ((state.moonPhase === 'dark' || state.moonPhase === 'full' || state.moonPhase === 'crescent') && state.dayStartTime === 'morning') {
      // For morning day start, check if moon event is before or after sunrise
      const sunriseOnNextMoonDate = getSunriseTimestamp(nextMoonEventLocalDate);
      const nextMoonEventLocalTime = nextMoonEvent.getTime() + (observerLon / 15) * 60 * 60 * 1000;
      const nextSunriseLocalTime = sunriseOnNextMoonDate + (observerLon / 15) * 60 * 60 * 1000;
      
      if (nextMoonEventLocalTime >= nextSunriseLocalTime) {
        // Moon event is AT or AFTER sunrise - add 1 day
        nextMonthStart.setUTCDate(nextMonthStart.getUTCDate() + 1);
      }
      // If moon event is BEFORE sunrise, starts at same day's sunrise (add 0 days)
    } else {
      nextMonthStart.setUTCDate(nextMonthStart.getUTCDate() + 1);
    }
    
    const daysInMonth = Math.round((nextMonthStart - monthStartDate) / (24 * 60 * 60 * 1000));
    
    // Calculate date uncertainty for this month
    // If margin to sunset is within ŒîT uncertainty, dates could be off by 1 day
    // Direction: '+' means dates could be 1 day later, '-' means 1 day earlier
    let dateUncertainty = null; // null, '+', or '-'
    let dateUncertaintyProbability = 0; // Probability that dates are wrong (0-100%)
    
    if ((state.moonPhase === 'dark' || state.moonPhase === 'full') && state.dayStartTime === 'evening') {
      // Check margin for THIS month's moon event (determines if prior month could have more/fewer days)
      const sunsetOnMoonDate = getSunsetTimestamp(moonEventLocalDate);
      const moonEventLocalTime = moonEvent.getTime() + (observerLon / 15) * 60 * 60 * 1000;
      const sunsetLocalTime = sunsetOnMoonDate + (observerLon / 15) * 60 * 60 * 1000;
      const marginMs = Math.abs(moonEventLocalTime - sunsetLocalTime);
      const marginHours = marginMs / (1000 * 60 * 60);
      const eventYear = moonEvent.getUTCFullYear();
      const uncertaintyHours = AstroEngines.nasaEclipse.getDeltaTUncertainty(eventYear);
      
      if (uncertaintyHours > 0 && marginHours <= uncertaintyHours) {
        // Calculate probability that the date is wrong
        // If margin is M and uncertainty is ¬±U, probability = (U - M) / (2U)
        dateUncertaintyProbability = Math.round(((uncertaintyHours - marginHours) / (2 * uncertaintyHours)) * 100);
        
        // Conjunction was after sunset - prior month has 30 days
        // If conjunction was actually earlier, prior month would have 29 days
        // So dates in THIS month could be 1 day earlier (-)
        if (moonEventLocalTime >= sunsetLocalTime) {
          dateUncertainty = '-';
        } else {
          // Conjunction was before sunset - prior month has 29 days  
          // If conjunction was actually later, prior month would have 30 days
          // So dates in THIS month could be 1 day later (+)
          dateUncertainty = '+';
        }
      }
    }
    
    const days = [];
    for (let d = 1; d <= daysInMonth; d++) {
      const dayDate = new Date(monthStartDate.getTime());
      dayDate.setUTCDate(dayDate.getUTCDate() + d - 1);
      
      const isSabbath = [8, 15, 22, 29].includes(d);
      const isNewMoon = d === 1;
      // Day 30 with '+' is impossible (can't add days), so only show uncertainty for days 1-29 with '+', or all days with '-'
      const isUncertain = dateUncertainty !== null && (dateUncertainty === '-' || d < 30);
      
      // Find all feasts for this day (some days have multiple)
      let feasts = [];
      for (const f of FEASTS) {
        if (f.month === (m + 1)) {
          if (f.endDay) {
            if (d >= f.day && d <= f.endDay) {
              const dayNum = f.startDayNum ? (f.startDayNum + d - f.day) : (d - f.day + 1);
              feasts.push({ feast: f, dayNum });
            }
          } else if (d === f.day) {
            feasts.push({ feast: f, dayNum: null });
          }
        }
      }
      // For backwards compatibility
      const feast = feasts.length > 0 ? feasts[0].feast : null;
      const feastDayNum = feasts.length > 0 ? feasts[0].dayNum : null;
      
      // Calculate moon phase for this day
      // For Day 1, force the icon based on mode (since Day 1 IS the phase by definition)
      // For other days, calculate from astronomical position
      let moonPhase = '';
      if (d === 1) {
        // Day 1 always shows the mode-defining phase
        if (state.moonPhase === 'full') moonPhase = 'üåï';
        else if (state.moonPhase === 'dark') moonPhase = 'üåë';
        else if (state.moonPhase === 'crescent') moonPhase = 'üåí';
      } else {
        moonPhase = getMoonPhaseIconForDate(dayDate);
      }
      
      // Check if spring equinox falls on this day
      const dayStart = dayDate.getTime();
      const dayEnd = dayStart + 24 * 60 * 60 * 1000;
      let equinox = null;
      if (springEquinox && springEquinox.getTime() >= dayStart && springEquinox.getTime() < dayEnd) {
        equinox = { type: 'spring', date: springEquinox };
      } else if (state.nextSpringEquinox && state.nextSpringEquinox.getTime() >= dayStart && state.nextSpringEquinox.getTime() < dayEnd) {
        equinox = { type: 'spring', date: state.nextSpringEquinox };
      }
      
      // Check if there's a lunar eclipse (blood moon) - only on days with a full moon icon
      // For Day 1 in full moon mode, check against the month's moon event date
      let isBloodMoon = false;
      if (moonPhase === 'üåï') {
        const checkDate = (d === 1 && moonEvent) ? moonEvent : dayDate;
        isBloodMoon = AstroEngines.nasaEclipse.hasLunarEclipse(checkDate);
      }
      
      days.push({
        lunarDay: d,
        gregorianDate: dayDate,
        isSabbath,
        isNewMoon,
        isUncertain,  // True if this day (Day 30) might not exist due to ŒîT uncertainty
        feast,
        feastDayNum,
        feasts,  // Array of all feasts for this day
        moonPhase,
        equinox,  // Spring equinox if it falls on this day
        isBloodMoon  // True if there's a lunar eclipse on this day
      });
    }
    
    months.push({
      monthNumber: m + 1,
      name: MONTH_NAMES[m] || `Month ${m + 1}`,
      startDate: monthStartDate,
      moonEvent: moonEvent,
      daysInMonth,
      dateUncertainty,  // '+', '-', or null - direction dates could be off
      dateUncertaintyProbability,  // 0-100% probability that dates are wrong
      days
    });
  }
  
  return months;
}

function formatShortDate(date) {
  const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  // Use UTC methods - dates from _jdToDate already have correct calendar components stored
  return `${months[date.getUTCMonth()]} ${date.getUTCDate()}`;
}

// Calculate sunrise timestamp for a given date at the selected location
function getSunriseTimestamp(date) {
  const engine = getAstroEngine();
  const observer = engine.createObserver(state.lat, state.lon, 0);
  // Search for sunrise starting from midnight of that day (use UTC for ancient dates)
  const midnightUTC = new Date(Date.UTC(2000, date.getUTCMonth(), date.getUTCDate(), 0, 0, 0));
  midnightUTC.setUTCFullYear(date.getUTCFullYear());
  const sunrise = engine.searchRiseSet('sun', observer, +1, midnightUTC, 1);
  if (sunrise) {
    return sunrise.date.getTime();
  }
  // Fallback to 6am if no sunrise found (polar regions)
  return midnightUTC.getTime() + 6 * 60 * 60 * 1000;
}

// Calculate sunset timestamp for a given date at the selected location
function getSunsetTimestamp(date) {
  const engine = getAstroEngine();
  const observer = engine.createObserver(state.lat, state.lon, 0);
  // Use noon UTC as search start to find THIS day's sunset (not previous day's)
  const noonUTC = new Date(Date.UTC(2000, date.getUTCMonth(), date.getUTCDate(), 12, 0, 0));
  noonUTC.setUTCFullYear(date.getUTCFullYear());
  const sunset = engine.searchRiseSet('sun', observer, -1, noonUTC, 1);
  if (sunset) {
    return sunset.date.getTime();
  }
  // Fallback to 6pm if no sunset found (polar regions)
  return midnightUTC.getTime() + 18 * 60 * 60 * 1000;
}

// Get all astronomical times for a given date (first light, sunrise, sunset, nautical twilight)
function getAstronomicalTimes(date) {
  try {
    const engine = getAstroEngine();
    const observer = engine.createObserver(state.lat, state.lon, 0);
    
    // Use UTC for dates
    const midnightUTC = new Date(Date.UTC(2000, date.getUTCMonth(), date.getUTCDate(), 0, 0, 0));
    midnightUTC.setUTCFullYear(date.getUTCFullYear());
    
    // Sunrise (sun rises above horizon)
    const sunriseResult = engine.searchRiseSet('sun', observer, +1, midnightUTC, 1);
    const sunriseTs = sunriseResult ? sunriseResult.date.getTime() : null;
    
    // Sunset (sun sets below horizon)
    const sunsetResult = engine.searchRiseSet('sun', observer, -1, midnightUTC, 1);
    const sunsetTs = sunsetResult ? sunsetResult.date.getTime() : null;
    
    // First light (civil dawn) - sun is 6¬∞ below horizon in the morning
    // Search for sun reaching -6¬∞ altitude before sunrise
    let firstLightTs = null;
    if (sunriseTs) {
      const beforeSunrise = new Date(sunriseTs - 2 * 60 * 60 * 1000); // 2 hours before sunrise
      const civilDawn = engine.searchAltitude('sun', observer, +1, beforeSunrise, 1, -6);
      if (civilDawn) {
        firstLightTs = civilDawn.date.getTime();
      }
    }
    
    // Nautical twilight (end) - sun is 12¬∞ below horizon after sunset
    // Search for sun reaching -12¬∞ altitude after sunset
    let nauticalTwilightTs = null;
    if (sunsetTs) {
      const nauticalDusk = engine.searchAltitude('sun', observer, -1, new Date(sunsetTs), 1, -12);
      if (nauticalDusk) {
        nauticalTwilightTs = nauticalDusk.date.getTime();
      }
    }
    
    // Format times in observer's local time
    const formatTime = (ts) => {
      if (!ts) return '--:--';
      const localTime = utcToLocalTime(ts, state.lon);
      const hours = localTime.getUTCHours();
      const mins = String(localTime.getUTCMinutes()).padStart(2, '0');
      const ampm = hours >= 12 ? 'PM' : 'AM';
      const hour12 = hours % 12 || 12;
      return `${hour12}:${mins} ${ampm}`;
    };
    
    return {
      firstLight: formatTime(firstLightTs),
      sunrise: formatTime(sunriseTs),
      sunset: formatTime(sunsetTs),
      nauticalTwilight: formatTime(nauticalTwilightTs)
    };
  } catch (err) {
    console.warn('Error calculating astronomical times:', err);
    return null;
  }
}

// Calculate moon altitude at sunset for a given date
// Returns an object with sunset time, moon altitude, and elongation
function getMoonAltitudeAtSunset(date) {
  try {
    const engine = getAstroEngine();
    const observer = engine.createObserver(state.lat, state.lon, 0);
    const midnight = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0);
    
    // Find sunset on this day
    const sunset = engine.searchRiseSet('sun', observer, -1, midnight, 1);
    
    if (!sunset) {
      return null;
    }
    
    // Calculate moon position at sunset
    const moonEquator = engine.getEquator('moon', sunset.date, observer);
    const moonHorizon = engine.getHorizon(sunset.date, observer, moonEquator.ra, moonEquator.dec);
    
    // Calculate sun position at sunset
    const sunEquator = engine.getEquator('sun', sunset.date, observer);
    
    // Calculate elongation using spherical geometry (angular distance between RA/Dec positions)
    // Convert RA from hours to degrees
    const moonRaDeg = moonEquator.ra * 15;
    const sunRaDeg = sunEquator.ra * 15;
    const moonDecRad = moonEquator.dec * Math.PI / 180;
    const sunDecRad = sunEquator.dec * Math.PI / 180;
    const deltaRaRad = (moonRaDeg - sunRaDeg) * Math.PI / 180;
    
    // Spherical law of cosines for angular distance
    const cosAngle = Math.sin(sunDecRad) * Math.sin(moonDecRad) + 
                     Math.cos(sunDecRad) * Math.cos(moonDecRad) * Math.cos(deltaRaRad);
    const elongation = Math.acos(Math.max(-1, Math.min(1, cosAngle))) * 180 / Math.PI;
    
    return {
      sunsetTime: sunset.date,
      moonAltitude: moonHorizon.altitude,
      moonAzimuth: moonHorizon.azimuth,
      elongation: elongation
    };
  } catch (e) {
    console.error('Error calculating moon altitude at sunset:', e);
    return null;
  }
}

// Get the day start time for a given date based on current settings
// Returns a UTC timestamp for when the day starts
function getDayStartTime(date) {
  const engine = getAstroEngine();
  const observer = engine.createObserver(state.lat, state.lon, 0);
  
  // Use UTC methods to avoid timezone issues with ancient dates
  const midnightUTC = new Date(Date.UTC(2000, date.getUTCMonth(), date.getUTCDate(), 0, 0, 0));
  midnightUTC.setUTCFullYear(date.getUTCFullYear());
  
  // Direction: -1 for evening (descending sun), +1 for morning (ascending sun)
  const direction = state.dayStartTime === 'evening' ? -1 : +1;
  
  // For evening, we need to search from noon of the previous day
  // For morning, we search from midnight of this day
  let searchStart = midnightUTC;
  if (state.dayStartTime === 'evening') {
    // Search starting from noon of the previous day to find evening twilight
    searchStart = new Date(midnightUTC.getTime() - 12 * 60 * 60 * 1000);
  }
  
  let result;
  if (state.dayStartAngle === 0) {
    // Use sunrise/sunset (sun at horizon)
    result = engine.searchRiseSet('sun', observer, direction, searchStart, 1);
  } else {
    // Use twilight angle (sun below horizon)
    // SearchAltitude finds when sun reaches the specified altitude
    result = engine.searchAltitude('sun', observer, direction, searchStart, 1, -state.dayStartAngle);
  }
  
  if (result) {
    return result.date.getTime();
  }
  
  // Fallback for polar regions
  if (state.dayStartTime === 'morning') {
    return midnightUTC.getTime() + 6 * 60 * 60 * 1000; // 6am
  } else {
    return midnightUTC.getTime() - 6 * 60 * 60 * 1000; // 6pm previous day
  }
}

// Get the year start point based on yearStartRule setting
function getYearStartPoint(year) {
  const engine = getAstroEngine();
  const springEquinox = engine.getSeasons(year).mar_equinox.date;
  
  if (state.yearStartRule === '13daysBefore') {
    // Return 13 days before the equinox
    return new Date(springEquinox.getTime() - 13 * 24 * 60 * 60 * 1000);
  }
  
  return springEquinox;
}

// Get human-readable label for current day start setting
function getDayStartLabel() {
  const timeLabel = state.dayStartTime === 'evening' ? 'evening' : 'morning';
  
  let angleLabel;
  switch (state.dayStartAngle) {
    case 0: angleLabel = state.dayStartTime === 'evening' ? 'sunset' : 'sunrise'; break;
    case 6: angleLabel = 'civil twilight'; break;
    case 12: angleLabel = 'nautical twilight'; break;
    case 18: angleLabel = 'astronomical twilight'; break;
    default: angleLabel = `${state.dayStartAngle}¬∞ twilight`;
  }
  
  // Return "morning nautical twilight" instead of "nautical twilight (morning)"
  // For sunrise/sunset, just return that without time prefix
  if (state.dayStartAngle === 0) {
    return angleLabel;
  }
  return `${timeLabel} ${angleLabel}`;
}

// Convert UTC timestamp to local time at the selected longitude
function utcToLocalTime(utcTimestamp, longitude) {
  // Each 15¬∞ of longitude = 1 hour offset
  const hourOffset = longitude / 15;
  return new Date(utcTimestamp + hourOffset * 60 * 60 * 1000);
}

// Convert local time at selected longitude to UTC timestamp
function localTimeToUtc(localDate, longitude) {
  // Each 15¬∞ of longitude = 1 hour offset
  const hourOffset = longitude / 15;
  return localDate.getTime() - hourOffset * 60 * 60 * 1000;
}

// Format date for datetime-local input (YYYY-MM-DDTHH:MM)
// Uses UTC values since we pre-convert to local time
// Returns null for dates before year 1 (datetime-local doesn't support negative years)
function formatDatetimeLocal(date) {
  const year = date.getUTCFullYear();
  // datetime-local inputs don't support years before 1
  if (year < 1) return null;
  
  return year + '-' + 
    String(date.getUTCMonth() + 1).padStart(2, '0') + '-' +
    String(date.getUTCDate()).padStart(2, '0') + 'T' +
    String(date.getUTCHours()).padStart(2, '0') + ':' +
    String(date.getUTCMinutes()).padStart(2, '0');
}

// Format UTC timestamp as local time string at selected location
// Returns empty string for ancient dates (datetime-local doesn't support them)
function formatLocalDatetime(utcTimestamp) {
  const localDate = utcToLocalTime(utcTimestamp, state.lon);
  return formatDatetimeLocal(localDate) || '';
}

// Parse datetime-local input as local time at selected location, return UTC timestamp
function parseDatetimeLocal(datetimeStr) {
  // Parse the datetime-local string as if it were UTC
  const [datePart, timePart] = datetimeStr.split('T');
  const [year, month, day] = datePart.split('-').map(Number);
  const [hours, minutes] = timePart.split(':').map(Number);
  
  // Create date as UTC
  const localAsUtc = Date.UTC(year, month - 1, day, hours, minutes);
  
  // Convert from local time at longitude to actual UTC
  return localTimeToUtc(new Date(localAsUtc), state.lon);
}

function formatFullDate(date) {
  const months = ['January', 'February', 'March', 'April', 'May', 'June', 
                  'July', 'August', 'September', 'October', 'November', 'December'];
  
  // Use UTC methods - dates from _jdToDate already have correct calendar components stored
  const year = date.getUTCFullYear();
  const month = date.getUTCMonth();
  const day = date.getUTCDate();
  const isJulian = isBeforeGregorianReform(date);
  const calendarSuffix = isJulian ? ' (Julian)' : '';
  
  // Format year: only show BC suffix, never AD
  const yearStr = year <= 0 ? `${Math.abs(year - 1)} BC` : `${year}`;
  
  return `${months[month]} ${day}, ${yearStr}${calendarSuffix}`;
}

// Calculate the "dateline" longitude - the first place to start the new day
// At any UTC time H, solar noon is at longitude = (12 - H) * 15 degrees
// Sunrise occurs 90¬∞ to the WEST of the subsolar point (6 hours earlier in local time)
// Sunset occurs 90¬∞ to the EAST of the subsolar point (6 hours later in local time)
// The dateline is where the day start event is occurring at the moment of the moon event
// This is the first place on Earth to begin a new day
function calculateDatelineLongitude(moonEventDate, moonPhase) {
  // Get UTC hours as decimal
  const utcHours = moonEventDate.getUTCHours() + moonEventDate.getUTCMinutes() / 60;
  
  // The subsolar point (where it's local noon) at this UTC time
  // At UTC 12:00, noon is at 0¬∞ (Greenwich)
  // At UTC 0:00, noon is at 180¬∞ (International Date Line)
  const subsolarLon = (12 - utcHours) * 15;
  
  let datelineLon;
  if (state.dayStartTime === 'evening') {
    // Sunset is 90¬∞ to the EAST of the subsolar point
    // (At any instant, places east of noon are in afternoon/evening)
    datelineLon = subsolarLon + 90;
    // Adjust for twilight angle - evening twilight occurs BEFORE sunset (further east)
    // Roughly 4¬∞ of longitude per 1¬∞ of sun angle (varies by latitude)
    datelineLon += state.dayStartAngle * 4;
  } else {
    // Sunrise is 90¬∞ to the WEST of the subsolar point
    // (At any instant, places west of noon are in morning)
    datelineLon = subsolarLon - 90;
    // Adjust for twilight angle - morning twilight occurs BEFORE sunrise (further east)
    // For morning, twilight starts earlier, so we add to move east
    datelineLon += state.dayStartAngle * 4;
  }
  
  // Normalize to -180 to 180
  while (datelineLon > 180) datelineLon -= 360;
  while (datelineLon < -180) datelineLon += 360;
  
  return datelineLon;
}

function getDatelineCity(lon) {
  // Find approximate region for the dateline longitude
  if (lon >= 140 || lon < -170) return 'Pacific Ocean (Date Line)';
  if (lon >= 120) return 'Japan / Philippines';
  if (lon >= 100) return 'China / Southeast Asia';
  if (lon >= 70) return 'India / Central Asia';
  if (lon >= 35) return 'Middle East';
  if (lon >= 10) return 'Europe / Africa';
  if (lon >= -30) return 'Atlantic Ocean';
  if (lon >= -50) return 'South America (East)';
  if (lon >= -70) return 'South America (West) / Caribbean';
  if (lon >= -85) return 'Americas (Eastern US / Central America)';
  if (lon >= -105) return 'Americas (Central US / Mexico)';
  if (lon >= -120) return 'Americas (West Coast)';
  if (lon >= -150) return 'Alaska / Hawaii';
  return 'Pacific Ocean';
}

// Get the day start event name for display
function getDayStartEventName() {
  if (state.dayStartAngle === 0) {
    return state.dayStartTime === 'evening' ? 'Sunset' : 'Sunrise';
  } else if (state.dayStartAngle === 6) {
    return state.dayStartTime === 'evening' ? 'Civil Dusk' : 'Civil Dawn';
  } else if (state.dayStartAngle === 12) {
    return state.dayStartTime === 'evening' ? 'Nautical Dusk' : 'Nautical Dawn';
  } else if (state.dayStartAngle === 18) {
    return state.dayStartTime === 'evening' ? 'Astronomical Dusk' : 'Astronomical Dawn';
  }
  return state.dayStartTime === 'evening' ? 'Evening Twilight' : 'Morning Twilight';
}

// Get the day start icon for the marker
function getDayStartIcon() {
  return state.dayStartTime === 'evening' ? 'üåÖ' : '‚òÄ';
}

function renderDatelineVisualization(moonEventDate) {
  const utcHours = moonEventDate.getUTCHours() + moonEventDate.getUTCMinutes() / 60;
  const datelineLon = calculateDatelineLongitude(moonEventDate, state.moonPhase);
  
  // Convert longitude to percentage position (lon -180 = 0%, lon 180 = 100%)
  const position = ((datelineLon + 180) / 360) * 100;
  
  const region = getDatelineCity(datelineLon);
  const lonStr = datelineLon >= 0 
    ? `${Math.abs(datelineLon).toFixed(1)}¬∞E` 
    : `${Math.abs(datelineLon).toFixed(1)}¬∞W`;
  
  // Format moon event date for display
  const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  const moonDateStr = `${months[moonEventDate.getUTCMonth()]} ${moonEventDate.getUTCDate()}, ${moonEventDate.getUTCFullYear()}`;
  const utcTimeStr = `${Math.floor(utcHours).toString().padStart(2,'0')}:${Math.round((utcHours % 1) * 60).toString().padStart(2,'0')} UTC`;
  
  // Get day start event name and icon based on settings
  const dayStartEvent = getDayStartEventName();
  const dayStartIcon = getDayStartIcon();
  const markerLabel = dayStartEvent.toUpperCase();
  
  // Current location marker position
  const currentLat = parseFloat(document.getElementById('lat-input')?.value) || 31.7683;
  const currentLon = parseFloat(document.getElementById('lon-input')?.value) || 35.2137;
  const locX = ((currentLon + 180) / 360) * 100;
  const locY = ((90 - currentLat) / 180) * 100;
  
  // Get location display name (city name or region)
  const locationName = getCurrentLocationName();
  const coordStr = `${currentLat.toFixed(2)}¬∞${currentLat >= 0 ? 'N' : 'S'}, ${Math.abs(currentLon).toFixed(2)}¬∞${currentLon >= 0 ? 'E' : 'W'}`;
  const locationDisplay = locationName !== 'Your Location' && !locationName.includes('/') 
    ? `${locationName} (${coordStr})`
    : coordStr;
  
  return `
    <div class="dateline-container">
      <div class="dateline-label">${dayStartEvent} line at moment of ${getMoonLabel()} ‚Äî ${moonDateStr} ‚Äî ${utcTimeStr}</div>
      <div class="dateline-map" onclick="handleMapClick(event)">
        <div class="dateline-map-bg">
          <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/23/Blue_Marble_2002.png/1280px-Blue_Marble_2002.png" 
               alt="World Map"
               onerror="this.style.display='none'">
        </div>
        <div class="dateline-marker" style="left: ${position}%">
          <span class="dateline-marker-icon">${dayStartIcon}</span>
          <span class="dateline-marker-label">${markerLabel}</span>
        </div>
        <div class="dateline-location-marker" style="left: ${locX}%; top: ${locY}%" title="${locationName}: ${coordStr}"><div class="dateline-location-pin"></div></div>
      </div>
      <div class="dateline-cities">
        <span>180¬∞W</span>
        <span>90¬∞W</span>
        <span>0¬∞</span>
        <span>90¬∞E</span>
        <span>180¬∞E</span>
      </div>
      <div class="dateline-info">Day start line: ${lonStr} ‚Äî ${region}</div>
      <div class="dateline-info" style="color: #7ec8e3;">Your location: ${locationDisplay}</div>
      <div class="dateline-click-hint">Click map to change location ‚Ä¢ First to reach ${dayStartEvent.toLowerCase()} after ${getMoonLabel()} starts month first</div>
    </div>
  `;
}

function formatMoonDateTime(date) {
  const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
  
  // UTC date and time - use correct weekday calculation for ancient dates
  const utcDay = days[getCorrectWeekday(date)];
  const utcMonth = months[date.getUTCMonth()];
  const utcDate = date.getUTCDate();
  const utcHours = date.getUTCHours().toString().padStart(2, '0');
  const utcMins = date.getUTCMinutes().toString().padStart(2, '0');
  
  // Local date and time
  const localDay = days[date.getDay()];
  const localMonth = months[date.getMonth()];
  const localDate = date.getDate();
  const localHours = date.getHours().toString().padStart(2, '0');
  const localMins = date.getMinutes().toString().padStart(2, '0');
  
  // Get timezone abbreviation
  const tzName = Intl.DateTimeFormat('en-US', { timeZoneName: 'short' }).formatToParts(date)
    .find(part => part.type === 'timeZoneName')?.value || 'Local';
  
  // Check if UTC and local are on different calendar days
  const sameDay = (date.getUTCDate() === date.getDate() && 
                   date.getUTCMonth() === date.getMonth() &&
                   date.getUTCFullYear() === date.getFullYear());
  
  if (sameDay) {
    return `${localDay}, ${localMonth} ${localDate}<br>` +
           `UTC: ${utcHours}:${utcMins}<br>` +
           `${tzName}: ${localHours}:${localMins}`;
  } else {
    // Show both dates when they differ
    return `UTC: ${utcDay}, ${utcMonth} ${utcDate} ${utcHours}:${utcMins}<br>` +
           `${tzName}: ${localDay}, ${localMonth} ${localDate} ${localHours}:${localMins}`;
  }
}

function renderMonth(month) {
  const scripture = SCRIPTURES[month.monthNumber % SCRIPTURES.length];
  
  const container = document.getElementById('calendar-output');
  
  // Get today's date string for comparison (YYYY-MM-DD format)
  const today = new Date();
  const todayStr = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
  
  // Day 1 is New Moon shown in header
  // Days 2-8 form the first week, 9-15 second week, etc.
  // Sabbath (days 8, 15, 22, 29) is always in the rightmost column
  
  // Find Day 2's Gregorian weekday to determine the weekday labels
  const day2 = month.days.find(d => d.lunarDay === 2);
  const day2Weekday = day2 ? getCorrectWeekday(day2.gregorianDate) : 0;
  
  // Generate weekday labels starting from Day 2's weekday
  const weekdayNames = ['Sun.', 'Mon.', 'Tue.', 'Wed.', 'Thu.', 'Fri.', 'Sat.'];
  const shiftedWeekdays = [];
  for (let i = 0; i < 7; i++) {
    shiftedWeekdays.push(weekdayNames[(day2Weekday + i) % 7]);
  }
  
  // Determine which column header should be highlighted as Sabbath
  // For lunar sabbath: always column 7 (days 8, 15, 22, 29)
  // For weekday sabbaths: find which column corresponds to that weekday
  let sabbathColumnIndex = -1;
  if (state.sabbathMode === 'lunar') {
    sabbathColumnIndex = 6; // Column 7 (0-indexed)
  } else if (['saturday', 'sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday'].includes(state.sabbathMode)) {
    // Find which column has the sabbath weekday
    const sabbathWeekdayMap = { sunday: 0, monday: 1, tuesday: 2, wednesday: 3, thursday: 4, friday: 5, saturday: 6 };
    const sabbathWeekday = sabbathWeekdayMap[state.sabbathMode];
    // Day 2's weekday is in column 0, so find which column has the sabbath weekday
    for (let col = 0; col < 7; col++) {
      if ((day2Weekday + col) % 7 === sabbathWeekday) {
        sabbathColumnIndex = col;
        break;
      }
    }
  }
  
  // Generate day labels (Day 1 through Day 7)
  // For fixed weekday sabbaths, the sabbath column is always "Day 7"
  // For lunar sabbath, column 6 is always "Day 7"
  const getDayLabel = (colIndex) => {
    if (sabbathColumnIndex === -1) return colIndex + 1; // No sabbath mode
    // Calculate day number so sabbath column is always Day 7
    return ((colIndex - sabbathColumnIndex - 1 + 7) % 7) + 1;
  };
  
  // Get Day 1 info for header
  const day1 = month.days.find(d => d.lunarDay === 1);
  const day1UncertaintySuffix = (day1 && day1.isUncertain) ? month.dateUncertainty : '';
  const day1Date = day1 ? formatShortDate(day1.gregorianDate) + day1UncertaintySuffix : '';
  const day1Year = day1 ? formatYear(day1.gregorianDate.getUTCFullYear()) : '';
  const day1Weekday = day1 ? weekdayNames[getCorrectWeekday(day1.gregorianDate)] : '';
  
  // Check for feasts and equinox on day 1
  let day1FeastIcons = '';
  if (day1) {
    const icons = [];
    if (day1.feasts && day1.feasts.length > 0) {
      icons.push(...new Set(day1.feasts.map(f => f.feast.icon)));
    }
    if (day1.equinox) {
      icons.push('‚òÄÔ∏è‚öñÔ∏è');
    }
    if (icons.length > 0) {
      day1FeastIcons = `<div class="feast-icons">${icons.join('')}</div>`;
    }
  }
  
  // Check for ŒîT uncertainty warning on Day 1 (use the already-calculated flag)
  const day1UncertaintyIndicator = (day1 && day1.isUncertain) ? 'uncertain' : '';
  
  // Blood moon styling for Day 1
  const day1BloodMoonClass = (day1 && day1.isBloodMoon) ? ' blood-moon' : '';
  
  // Check if Day 1 is today
  const day1IsToday = day1 && day1.gregorianDate.toISOString().split('T')[0] === todayStr;
  
  // Calculate daylight percentage for day cycle bar based on Day 1's sunrise/sunset
  let daylightHours = 12; // default if we can't calculate
  let dayCycleGradient = '';
  if (day1 && day1.gregorianDate) {
    try {
      const sunriseTs = getSunriseTimestamp(day1.gregorianDate);
      const sunsetTs = getSunsetTimestamp(day1.gregorianDate);
      if (sunriseTs != null && sunsetTs != null && !isNaN(sunriseTs) && !isNaN(sunsetTs)) {
        const hours = (sunsetTs - sunriseTs) / (1000 * 60 * 60);
        if (hours > 0 && hours < 24) {
          daylightHours = hours;
        }
      }
    } catch (e) {
      console.warn('Could not calculate daylight hours:', e);
    }
  }
  
  // Clamp daylight hours to reasonable range (6-18 hours covers all latitudes/seasons)
  daylightHours = Math.max(6, Math.min(18, daylightHours));
  
  // Convert hours to percentages of 24-hour day
  const twilightHours = 1.5;
  const nightHours = 24 - daylightHours;
  
  const twi = (twilightHours / 24) * 100;  // ~6.25%
  const day = (daylightHours / 24) * 100;
  const night = (nightHours / 24) * 100;
  
  // Generate gradient based on day start time
  // Twilight transitions (~1.5hr) occur AT sunrise and sunset, not during day/night
  // Add small offset (1%) to make gradient start visible at edge
  const offset = 1;
  const twilight = twi * 2; // Full transition width (dawn or dusk)
  
  if (state.dayStartTime === 'evening') {
    // Evening start: 0% = sunset
    // Day just ended, dusk transition starts immediately
    const duskEnd = twilight - offset;
    const dawnStart = night - twilight + offset;
    const dawnEnd = night + twilight - offset;
    
    dayCycleGradient = `repeating-linear-gradient(90deg, 
      #7ab3d4 0%, 
      #0d1a2d ${duskEnd}%, 
      #0d1a2d ${dawnStart}%, 
      #7ab3d4 ${dawnEnd}%, 
      #7ab3d4 100%)`;
  } else {
    // Morning start: 0% = first light (dawn)
    // Night just ended, dawn transition starts immediately
    const dawnEnd = twilight - offset;
    const duskStart = day - twilight + offset;
    const duskEnd = day + twilight - offset;
    
    dayCycleGradient = `repeating-linear-gradient(90deg, 
      #0d1a2d 0%, 
      #7ab3d4 ${dawnEnd}%, 
      #7ab3d4 ${duskStart}%, 
      #0d1a2d ${duskEnd}%, 
      #0d1a2d 100%)`;
  }
  
  const daylightPercent = Math.round(day);
  
  // Get the year the lunar year started (from first month's day 1)
  const firstMonth = state.lunarMonths[0];
  const firstDay1 = firstMonth ? firstMonth.days.find(d => d.lunarDay === 1) : null;
  const lunarYearStart = firstDay1 ? firstDay1.gregorianDate.getUTCFullYear() : state.year;
  const displayYear = `from ${formatYear(lunarYearStart)}`;
  
  let html = `
    <div class="month-calendar">
      <div class="calendar-header">
        <div class="header-left">
          <div class="full-moon-info" onclick="navigateTo('settings')" title="Change moon phase or location">
            <div class="moon-icon-wrapper">
              <div class="moon-icon">${getMoonIcon()}</div>
              <div class="moon-gear-badge">‚öô</div>
            </div>
          </div>
          <div class="calendar-title" onclick="toggleMonthPicker()">
            <div class="profile-name">${getCurrentProfileName()}</div>
            <div class="month-name">${month.name} <span class="dropdown-arrow">‚ñº</span></div>
            <div class="year">${displayYear} ¬∑ ${getCurrentLocationName()}</div>
          </div>
        </div>
        <div class="new-moon-box day-cell new-moon${state.highlightedLunarDay === 1 ? ' highlighted' : ''}${day1 && day1.feasts && day1.feasts.length > 0 ? ' feast' : ''}${day1 && isSabbath(day1) ? ' sabbath' : ''}${day1UncertaintyIndicator ? ' date-uncertain' : ''}${day1IsToday ? ' today' : ''}" data-date="${day1 ? day1.gregorianDate.toISOString().split('T')[0] : ''}" data-lunar-day="1" title="${day1 && day1.isBloodMoon ? 'üî¥ Blood Moon (Lunar Eclipse)' : ''}">
          <div class="gregorian">${day1Date}<span class="day-year">${day1Year}</span></div>
          <div class="moon-phase${day1BloodMoonClass}">${day1 ? day1.moonPhase : ''}</div>
          <div class="lunar-day">1</div>
          ${day1FeastIcons}
        </div>
      </div>
      
      <div class="week-header">
        <div class="day-label${sabbathColumnIndex === 0 ? ' sabbath-header' : ''}"><div class="day-name">Day ${getDayLabel(0)}</div><div class="weekday">${shiftedWeekdays[0]}</div></div>
        <div class="day-label${sabbathColumnIndex === 1 ? ' sabbath-header' : ''}"><div class="day-name">Day ${getDayLabel(1)}</div><div class="weekday">${shiftedWeekdays[1]}</div></div>
        <div class="day-label${sabbathColumnIndex === 2 ? ' sabbath-header' : ''}"><div class="day-name">Day ${getDayLabel(2)}</div><div class="weekday">${shiftedWeekdays[2]}</div></div>
        <div class="day-label${sabbathColumnIndex === 3 ? ' sabbath-header' : ''}"><div class="day-name">Day ${getDayLabel(3)}</div><div class="weekday">${shiftedWeekdays[3]}</div></div>
        <div class="day-label${sabbathColumnIndex === 4 ? ' sabbath-header' : ''}"><div class="day-name">Day ${getDayLabel(4)}</div><div class="weekday">${shiftedWeekdays[4]}</div></div>
        <div class="day-label${sabbathColumnIndex === 5 ? ' sabbath-header' : ''}"><div class="day-name">Day ${getDayLabel(5)}</div><div class="weekday">${shiftedWeekdays[5]}</div></div>
        <div class="day-label${sabbathColumnIndex === 6 ? ' sabbath-header' : ''}"><div class="day-name">Day ${getDayLabel(6)}</div><div class="weekday">${shiftedWeekdays[6]}</div></div>
      </div>
      
      <div class="day-cycle-bar" style="background: ${dayCycleGradient}; background-size: calc(100% / 7) 100%;" title="Day/night cycle (~${daylightPercent}% daylight): Each column shows ${state.dayStartTime === 'evening' ? 'sunset ‚Üí night ‚Üí day ‚Üí sunset' : 'dawn ‚Üí day ‚Üí night ‚Üí dawn'}"></div>
      
      <div class="calendar-grid">
  `;
  
  // Build rows by lunar week structure: 2-8, 9-15, 16-22, 23-29
  // The last row (day 30 + scripture) is handled separately
  const lunarWeeks = [
    [2, 3, 4, 5, 6, 7, 8],
    [9, 10, 11, 12, 13, 14, 15],
    [16, 17, 18, 19, 20, 21, 22],
    [23, 24, 25, 26, 27, 28, 29]
  ];
  
  for (const week of lunarWeeks) {
    for (const lunarDay of week) {
      const day = month.days.find(d => d.lunarDay === lunarDay);
      
      if (!day) {
        // Day doesn't exist in this month
        html += `<div class="day-cell empty"></div>`;
        continue;
      }
      
      let classes = ['day-cell'];
      // Determine if this day is a sabbath based on sabbathMode
      const isSabbathDay = isSabbath(day);
      if (isSabbathDay) classes.push('sabbath');
      if (day.isNewMoon) classes.push('new-moon');
      if (day.feasts && day.feasts.length > 0) classes.push('feast');
      if (day.lunarDay === state.highlightedLunarDay) classes.push('highlighted');
      if (day.isUncertain) classes.push('date-uncertain');
      
      // Check if this day is today
      const dayDateStr = day.gregorianDate.toISOString().split('T')[0];
      if (dayDateStr === todayStr) classes.push('today');
      
      let feastLabel = '';
      const icons = [];
      if (day.feasts && day.feasts.length > 0) {
        // Show icons for feasts (unique icons only)
        icons.push(...new Set(day.feasts.map(f => f.feast.icon)));
      }
      // Add equinox icon if applicable
      if (day.equinox) {
        icons.push('‚òÄÔ∏è‚öñÔ∏è');
      }
      if (icons.length > 0) {
        feastLabel = `<div class="feast-icons">${icons.join('')}</div>`;
      }
      
      // Format date for data attribute (YYYY-MM-DD)
      const dateStr = day.gregorianDate.toISOString().split('T')[0];
      let titleText = day.feasts && day.feasts.length > 0 
        ? day.feasts.map(f => f.feast.name + ': ' + f.feast.description).join(' | ')
        : '';
      
      // Add uncertainty suffix to date display
      const uncertaintySuffix = day.isUncertain ? month.dateUncertainty : '';
      if (day.isUncertain) {
        const prob = month.dateUncertaintyProbability || 0;
        titleText = (titleText ? titleText + ' | ' : '') + 
          `~${prob}% chance date is 1 day ${month.dateUncertainty === '+' ? 'later' : 'earlier'}`;
      }
      
      const isHighlighted = day.lunarDay === state.highlightedLunarDay;
      const bloodMoonClass = day.isBloodMoon ? ' blood-moon' : '';
      // Use red full moon emoji for blood moon, or add title
      const bloodMoonTitle = day.isBloodMoon ? ' | üî¥ Blood Moon (Lunar Eclipse)' : '';
      html += `
        <div class="${classes.join(' ')}" data-date="${dateStr}" title="${titleText}${bloodMoonTitle}">
          <div class="gregorian">${formatShortDate(day.gregorianDate)}${uncertaintySuffix}</div>
          <div class="moon-phase${bloodMoonClass}">${day.moonPhase}</div>
          <div class="lunar-day">${day.lunarDay}</div>
          ${feastLabel}
        </div>
      `;
    }
  }
  
  // Last row: Day 30 (or spacer) + Prev + Scripture quote + Next
  // Layout: [Day30/spacer][Prev][Quote span-4][Next]
  const day30 = month.days.find(d => d.lunarDay === 30);
  const isFirstMonth = state.currentMonthIndex === 0;
  const isLastMonth = state.currentMonthIndex >= state.lunarMonths.length - 1;
  
  if (day30) {
    // Day 30 exists
    let classes = ['day-cell'];
    if (day30.feasts && day30.feasts.length > 0) classes.push('feast');
    if (day30.lunarDay === state.highlightedLunarDay) classes.push('highlighted');
    // Day 30 with '-' means it might not exist (only show uncertainty for '-' direction)
    const day30Uncertain = day30.isUncertain && month.dateUncertainty === '-';
    if (day30Uncertain) classes.push('date-uncertain');
    // Check if Day 30 is today
    if (day30.gregorianDate.toISOString().split('T')[0] === todayStr) classes.push('today');
    
    let feastLabel = '';
    const icons = [];
    if (day30.feasts && day30.feasts.length > 0) {
      icons.push(...new Set(day30.feasts.map(f => f.feast.icon)));
    }
    if (day30.equinox) {
      icons.push('‚òÄÔ∏è‚öñÔ∏è');
    }
    if (icons.length > 0) {
      feastLabel = `<div class="feast-icons">${icons.join('')}</div>`;
    }
    
    const dateStr = day30.gregorianDate.toISOString().split('T')[0];
    let titleText = day30.feasts && day30.feasts.length > 0 
      ? day30.feasts.map(f => f.feast.name + ': ' + f.feast.description).join(' | ')
      : '';
    if (day30Uncertain) {
      const prob = month.dateUncertaintyProbability || 0;
      titleText = (titleText ? titleText + ' | ' : '') + `~${prob}% chance this Day 30 does not exist`;
    }
    const isHighlighted30 = day30.lunarDay === state.highlightedLunarDay;
    
    // Day 30 with '-' shows the suffix, Day 30 with '+' doesn't exist scenario so no suffix
    const day30Suffix = day30Uncertain ? '-' : '';
    
    // Blood moon styling for Day 30
    const bloodMoonClass30 = day30.isBloodMoon ? ' blood-moon' : '';
    const bloodMoonTitle30 = day30.isBloodMoon ? ' | üî¥ Blood Moon (Lunar Eclipse)' : '';
    
    html += `
      <div class="${classes.join(' ')}" data-date="${dateStr}" title="${titleText}${bloodMoonTitle30}">
        <div class="gregorian">${formatShortDate(day30.gregorianDate)}${day30Suffix}</div>
        <div class="moon-phase${bloodMoonClass30}">${day30.moonPhase}</div>
        <div class="lunar-day">${day30.lunarDay}</div>
        ${feastLabel}
      </div>
    `;
  } else {
    // No day 30 - use empty height-setter cell
    html += `<div class="day-cell empty quote-row-spacer"></div>`;
  }
  
  // Prev button - goes to previous year if at first month
  html += `
    <div class="month-nav-cell" onclick="navigateMonth(-1)" title="${isFirstMonth ? 'Previous Year' : 'Previous Month'}">
      <span class="nav-arrow">${isFirstMonth ? '‚èÆ' : '‚óÄ'}</span>
    </div>
  `;
  
  // Scripture quote (span 4 columns)
  html += `
    <div class="scripture-quote span-4">
      "${scripture.text}" <span class="reference">${scripture.ref}</span>
    </div>
  `;
  
  // Next button - goes to next year if at last month
  html += `
    <div class="month-nav-cell" onclick="navigateMonth(1)" title="${isLastMonth ? 'Next Year' : 'Next Month'}">
      <span class="nav-arrow">${isLastMonth ? '‚è≠' : '‚ñ∂'}</span>
    </div>
  `;
  
  html += `
      </div>
    </div>
  `;
  
  container.innerHTML = html;
  
  // Update map editability based on current profile
  updateMapEditability();
}

function jumpToFeast(monthIdx, lunarDay) {
  if (monthIdx >= 0 && monthIdx < state.lunarMonths.length) {
    state.currentMonthIndex = monthIdx;
    state.highlightedLunarDay = lunarDay;
    // Store timestamp for the feast day (sunrise)
    const month = state.lunarMonths[monthIdx];
    const dayObj = month.days.find(d => d.lunarDay === lunarDay);
    if (dayObj) {
      state.selectedTimestamp = getSunriseTimestamp(dayObj.gregorianDate);
      document.getElementById('goto-date').value = formatLocalDatetime(state.selectedTimestamp);
      showDayDetail(dayObj, month);
    }
    renderMonth(month);
    updateMonthButtons();
    updateURL();
    // Navigate to calendar view
    navigateTo('calendar');
    // Scroll to calendar after navigation
    setTimeout(() => {
      document.querySelector('.month-calendar')?.scrollIntoView({ behavior: 'smooth' });
    }, 50);
  }
}

function renderFeastTable(months) {
  const tbody = document.getElementById('feast-tbody');
  tbody.innerHTML = '';
  
  // Track which feasts we've already shown (for multi-month feasts like Hanukkah)
  const shownFeasts = new Set();
  
  // Collect all feast entries first
  const feastEntries = [];
  
  for (const feast of FEASTS) {
    // Skip if this is a continuation entry we've already handled
    if (feast.continuesNextMonth === undefined && shownFeasts.has(feast.name)) continue;
    
    const month = months.find(m => m.monthNumber === feast.month);
    if (!month) continue;
    
    const day = month.days.find(d => d.lunarDay === feast.day);
    if (!day) continue;
    
    let dateStr, gregDate;
    
    // Handle Hanukkah spanning two months
    if (feast.name === 'Hanukkah' && feast.continuesNextMonth) {
      shownFeasts.add('Hanukkah');
      const nextMonth = months.find(m => m.monthNumber === feast.month + 1);
      dateStr = `Month ${feast.month} day 25 - Month ${feast.month + 1} day 2`;
      
      const endDay = nextMonth ? nextMonth.days.find(d => d.lunarDay === 2) : null;
      gregDate = endDay 
        ? `${formatShortDate(day.gregorianDate)} - ${formatShortDate(endDay.gregorianDate)}`
        : formatFullDate(day.gregorianDate) + ' (8 days)';
    } else if (feast.name === 'Hanukkah' && !feast.continuesNextMonth) {
      // Skip the continuation entry in table
      continue;
    } else {
      dateStr = feast.endDay 
        ? `Month ${feast.month} days ${feast.day}-${feast.endDay}`
        : `Month ${feast.month} day ${feast.day}`;
      
      gregDate = formatFullDate(day.gregorianDate);
      if (feast.endDay) {
        const endDay = month.days.find(d => d.lunarDay === feast.endDay);
        if (endDay) gregDate = `${formatShortDate(day.gregorianDate)} - ${formatShortDate(endDay.gregorianDate)}`;
      }
    }
    
    const monthIdx = months.findIndex(m => m.monthNumber === feast.month);
    const dayIdx = feast.day;
    
    feastEntries.push({
      feast,
      day,
      dateStr,
      gregDate,
      monthIdx,
      dayIdx,
      sortDate: day.gregorianDate
    });
  }
  
  // Sort by Gregorian date
  feastEntries.sort((a, b) => a.sortDate.getTime() - b.sortDate.getTime());
  
  // Render sorted entries
  for (const entry of feastEntries) {
    // Use dynamic description for Renewed Moon based on current moon phase setting
    const description = entry.feast.name === 'Renewed Moon' 
      ? getRenewedMoonDescription() 
      : entry.feast.description;
    
    tbody.innerHTML += `
      <tr>
        <td><a href="#" class="feast-jump" data-month="${entry.monthIdx}" data-day="${entry.dayIdx}" style="color: inherit; text-decoration: none;"><strong>${entry.feast.name}</strong></a></td>
        <td><a href="#" class="feast-jump" data-month="${entry.monthIdx}" data-day="${entry.dayIdx}" style="color: inherit; text-decoration: none;">
          <div>${entry.dateStr}</div>
          <div style="color: #666; font-size: 0.9em;">${entry.gregDate}</div>
        </a></td>
        <td><a href="${entry.feast.chapter}" style="color: #2c5282;">${description} ‚Üí</a></td>
      </tr>
    `;
  }
}

document.addEventListener('DOMContentLoaded', async function() {
  // Rebuild profile dropdown with any saved custom profiles
  rebuildProfileDropdown();
  
  // Initialize settings editability (presets are read-only)
  updateSettingsEditability();
  
  // Initialize astronomy engine (loads Swiss Ephemeris WASM)
  await initializeAstroEngine();
  
  // Check if URL has parameters - if so, load from URL, otherwise jump to today
  const params = new URLSearchParams(window.location.search);
  if (params.has('year') || params.has('view')) {
    // URL has state - restore from URL
    updateUI(); // Set UI from localStorage first
    generateCalendar();
    loadFromURL(); // Then override with URL params
  } else {
    // No URL params - always jump to today's date on fresh load
    jumpToToday();
    updateURL(); // Set initial URL
  }
  
  // Event delegation for feast table clicks
  document.getElementById('feast-tbody').addEventListener('click', function(e) {
    const link = e.target.closest('.feast-jump');
    if (link) {
      e.preventDefault();
      const monthIdx = parseInt(link.dataset.month);
      const lunarDay = parseInt(link.dataset.day);
      jumpToFeast(monthIdx, lunarDay);
    }
  });
  
  // Event delegation for calendar day cell clicks - update goto-date input and highlight
  document.getElementById('calendar-output').addEventListener('click', function(e) {
    // Check for day cell click
    const cell = e.target.closest('.day-cell[data-date]');
    if (cell) {
      // Find the lunar day for this cell and store the timestamp
      const lunarDayEl = cell.querySelector('.lunar-day');
      if (lunarDayEl) {
        const lunarDay = parseInt(lunarDayEl.textContent);
        const month = state.lunarMonths[state.currentMonthIndex];
        const dayObj = month.days.find(d => d.lunarDay === lunarDay);
        if (dayObj) {
          // Calculate sunrise time at selected location for this day
          state.selectedTimestamp = getSunriseTimestamp(dayObj.gregorianDate);
          document.getElementById('goto-date').value = formatLocalDatetime(state.selectedTimestamp);
          showDayDetail(dayObj, month);
        }
        state.highlightedLunarDay = lunarDay;
        renderMonth(state.lunarMonths[state.currentMonthIndex]);
        updateURL();
      }
      return;
    }
    
    // Check for new-moon-box (Day 1) click
    const newMoonBox = e.target.closest('.new-moon-box[data-date]');
    if (newMoonBox) {
      const month = state.lunarMonths[state.currentMonthIndex];
      const dayObj = month.days.find(d => d.lunarDay === 1);
      if (dayObj) {
        // Calculate sunrise time at selected location for this day
        state.selectedTimestamp = getSunriseTimestamp(dayObj.gregorianDate);
        document.getElementById('goto-date').value = formatLocalDatetime(state.selectedTimestamp);
        showDayDetail(dayObj, month);
      }
      state.highlightedLunarDay = 1;
      renderMonth(state.lunarMonths[state.currentMonthIndex]);
      updateURL();
    }
  });
});

// Helper function to refresh day detail panel if one is currently shown
function refreshDayDetailIfVisible() {
  if (state.highlightedLunarDay !== null && state.lunarMonths[state.currentMonthIndex]) {
    const month = state.lunarMonths[state.currentMonthIndex];
    const dayObj = month.days.find(d => d.lunarDay === state.highlightedLunarDay);
    if (dayObj) {
      showDayDetail(dayObj, month);
    }
  }
}

// Show the day detail panel with information about the selected day
function showDayDetail(dayObj, month) {
  const panel = document.getElementById('day-detail-panel');
  
  // Populate lunar date
  const ordinal = getOrdinalSuffix(month.monthNumber);
  const lunarDateStr = `Day ${dayObj.lunarDay} of the ${month.monthNumber}${ordinal} Month`;
  panel.querySelector('.day-detail-lunar').textContent = lunarDateStr;
  
  // Populate gregorian/julian date
  const gregDate = dayObj.gregorianDate;
  panel.querySelector('.day-detail-gregorian').textContent = formatDisplayDate(gregDate);
  
  // Populate feasts
  const feastsContainer = panel.querySelector('.day-detail-feasts');
  feastsContainer.innerHTML = '';
  
  if (dayObj.feasts && dayObj.feasts.length > 0) {
    for (const f of dayObj.feasts) {
      const feast = f.feast;
      const dayNum = f.dayNum;
      const nameText = dayNum ? `${feast.name} (Day ${dayNum})` : feast.name;
      
      // Check if this is a Renewed Moon feast and we have moon event data
      let basisHtml = '';
      if (feast.name === 'Renewed Moon' && dayObj.lunarDay === 1 && month.moonEvent) {
        const moonEventTime = month.moonEvent;
        const signName = getMoonLabel();
        
        // Format moon event date in a friendly way
        const moonEventDate = new Date(moonEventTime);
        const moonParts = getFormattedDateParts(moonEventDate);
        const dayOfWeek = moonParts.weekdayName;
        const monthName = moonParts.shortMonthName;
        const dayNum = moonParts.day;
        const daySuffix = getOrdinalSuffix(dayNum);
        const year = moonParts.yearStr;
        
        // Format times in observer's local time (based on longitude), not browser timezone
        const moonLocalTime = utcToLocalTime(moonEventDate.getTime(), state.lon);
        const moonTimeStr = `${moonLocalTime.getUTCHours() % 12 || 12}:${String(moonLocalTime.getUTCMinutes()).padStart(2, '0')} ${moonLocalTime.getUTCHours() >= 12 ? 'PM' : 'AM'}`;
        
        const dayStartLabel = getDayStartLabel();
        
        // For dark/full moon mode with evening start, calculate margin to same-day sunset
        // This is the key margin that determines whether a 30th day was added to the prior month
        let sameDaySunset = null;
        let marginToSunsetMs = 0;
        let conjunctionAfterSunset = false;
        
        if ((state.moonPhase === 'dark' || state.moonPhase === 'full') && state.dayStartTime === 'evening') {
          sameDaySunset = getSunsetTimestamp(moonEventDate);
          const sameDaySunrise = getSunriseTimestamp(moonEventDate);
          marginToSunsetMs = sameDaySunset - moonEventTime.getTime();
          
          // Key insight: if the moon event is between midnight and sunrise (early morning),
          // it's actually part of the PREVIOUS evening's "day" in Hebrew calendar terms.
          const moonLocalTime = moonEventTime.getTime() + (state.lon / 15) * 60 * 60 * 1000;
          const sunriseLocalTime = sameDaySunrise + (state.lon / 15) * 60 * 60 * 1000;
          const sunsetLocalTime = sameDaySunset + (state.lon / 15) * 60 * 60 * 1000;
          
          const isBeforeSunrise = moonLocalTime < sunriseLocalTime;
          const isAfterSunset = moonLocalTime > sunsetLocalTime;
          
          // For early morning events (before sunrise), calculate margin from previous sunset
          if (isBeforeSunrise) {
            const prevDate = new Date(moonEventDate.getTime());
            prevDate.setUTCDate(prevDate.getUTCDate() - 1);
            const prevSunset = getSunsetTimestamp(prevDate);
            marginToSunsetMs = prevSunset - moonEventTime.getTime(); // Will be negative (after sunset)
            conjunctionAfterSunset = true;
          } else {
            conjunctionAfterSunset = isAfterSunset;
          }
        }
        
        // Get the day start time (sunset that starts Day 1)
        const dayStartTimestamp = getDayStartTime(dayObj.gregorianDate);
        const dayStartLocalTime = utcToLocalTime(dayStartTimestamp, state.lon);
        const dayStartStr = `${dayStartLocalTime.getUTCHours() % 12 || 12}:${String(dayStartLocalTime.getUTCMinutes()).padStart(2, '0')} ${dayStartLocalTime.getUTCHours() >= 12 ? 'PM' : 'AM'}`;
        
        // For the margin calculation (used for uncertainty warning), use the same-day sunset margin
        // This tells us how close the conjunction was to sunset on that day
        const marginMs = sameDaySunset !== null ? Math.abs(marginToSunsetMs) : Math.abs(dayStartTimestamp - moonEventTime.getTime());
        const marginMins = Math.round(marginMs / (1000 * 60));
        const marginHours = Math.floor(marginMins / 60);
        const marginMinsRemainder = marginMins % 60;
        
        let marginStr = '';
        if (marginHours > 0 && marginMinsRemainder > 0) {
          marginStr = `${marginHours} hour${marginHours > 1 ? 's' : ''} ${marginMinsRemainder} minute${marginMinsRemainder > 1 ? 's' : ''}`;
        } else if (marginHours > 0) {
          marginStr = `${marginHours} hour${marginHours > 1 ? 's' : ''}`;
        } else {
          marginStr = `${marginMinsRemainder} minute${marginMinsRemainder > 1 ? 's' : ''}`;
        }
        
        // Determine tense based on whether the date is past or future
        const now = new Date();
        const isPast = moonEventDate < now;
        const occurVerb = isPast ? 'occurred' : 'will occur';
        
        // Check if this is crescent + sunset mode (special case where crescent day IS Day 1)
        const isCrescentSunset = state.moonPhase === 'crescent' && 
                                 state.dayStartTime === 'evening' && 
                                 state.dayStartAngle === 0;
        
        // Get moon altitude at sunset for crescent mode
        let crescentAltitudeInfo = '';
        if (state.moonPhase === 'crescent') {
          const moonData = getMoonAltitudeAtSunset(moonEventDate);
          if (moonData) {
            const altStr = moonData.moonAltitude.toFixed(1);
            const elongStr = moonData.elongation.toFixed(1);
            const sunsetStr = moonData.sunsetTime.toLocaleTimeString('en-US', { 
              hour: 'numeric', minute: '2-digit', hour12: true 
            });
            crescentAltitudeInfo = ` At sunset (${sunsetStr}), the moon was ${altStr}¬∞ above the horizon (threshold: ${state.crescentThreshold}¬∞, elongation: ${elongStr}¬∞).`;
          }
        }
        
        // Build explanation based on moon phase type and day start settings
        let explanationText = '';
        
        if ((state.moonPhase === 'dark' || state.moonPhase === 'full') && state.dayStartTime === 'evening') {
          // For dark/full moon with evening start, explain the margin to sunset
          const beforeAfterSunset = conjunctionAfterSunset ? 'after' : 'before';
          const moonLabel = state.moonPhase === 'dark' ? 'Dark Moon (conjunction)' : 'Full Moon';
          
          if (conjunctionAfterSunset) {
            // Conjunction was after sunset - a 30th day was added to the prior month
            explanationText = `The ${moonLabel} ${occurVerb} on ${dayOfWeek}, ${monthName} ${dayNum}${daySuffix}, ${year} at ${moonTimeStr}, ` +
              `which was ${marginStr} after sunset (${dayStartStr}). Since it occurred after sunset, ` +
              `the prior month had 30 days, and this month begins at the following evening's sunset.`;
          } else {
            // Conjunction was before sunset - month starts at this sunset
            explanationText = `The ${moonLabel} ${occurVerb} on ${dayOfWeek}, ${monthName} ${dayNum}${daySuffix}, ${year} at ${moonTimeStr}, ` +
              `which was ${marginStr} before sunset. The month begins at sunset (${dayStartStr}).`;
          }
        } else if (state.moonPhase === 'crescent') {
          if (isCrescentSunset) {
            explanationText = `The first visible Crescent Moon ${occurVerb} on ${dayOfWeek}, ${monthName} ${dayNum}${daySuffix}, ${year}. ` +
              `The month begins immediately at sunset following the sighting.${crescentAltitudeInfo}`;
          } else {
            explanationText = `The first visible Crescent Moon ${occurVerb} on ${dayOfWeek}, ${monthName} ${dayNum}${daySuffix}, ${year}. ` +
              `The month begins at the next ${dayStartLabel} (${dayStartStr}).${crescentAltitudeInfo}`;
          }
        } else {
          explanationText = `The ${signName} ${occurVerb} on ${dayOfWeek}, ${monthName} ${dayNum}${daySuffix}, ${year} at ${moonTimeStr}. ` +
            `The month begins at ${dayStartLabel} (${dayStartStr}).`;
        }
        
        // Check if the margin is within ŒîT uncertainty for ancient dates
        let uncertaintyWarningHtml = '';
        const eventYear = moonEventDate.getUTCFullYear();
        const uncertaintyHours = AstroEngines.nasaEclipse.getDeltaTUncertainty(eventYear);
        const marginHoursValue = marginMins / 60;
        
        if (uncertaintyHours > 0 && marginHoursValue <= uncertaintyHours) {
          // Get the prior month's day count to determine which direction the error could go
          // Lunar months are always 29 or 30 days
          const currentMonthIdx = state.lunarMonths.findIndex(m => m.monthNumber === month.monthNumber);
          const priorMonth = currentMonthIdx > 0 ? state.lunarMonths[currentMonthIdx - 1] : null;
          const priorMonthDays = priorMonth ? priorMonth.daysInMonth : 29;
          
          let warningExplanation = '';
          if (state.moonPhase === 'dark' || state.moonPhase === 'full') {
            if (priorMonthDays === 29) {
              // Prior month has 29 days - only possible error is it should be 30
              warningExplanation = `If the actual ${getMoonLabel()} occurred later than calculated, ` +
                `it may have been after sunset, meaning the prior month would have had 30 days, ` +
                `and all dates in this month would be one day later than shown.`;
            } else {
              // Prior month has 30 days - only possible error is it should be 29
              warningExplanation = `If the actual ${getMoonLabel()} occurred earlier than calculated, ` +
                `it may have been before sunset, meaning the prior month would have had only 29 days, ` +
                `and all dates in this month would be one day earlier than shown.`;
            }
          } else if (state.moonPhase === 'crescent') {
            warningExplanation = `If the crescent was actually visible earlier or later than calculated, ` +
              `Day 1 could fall on the previous or next day, shifting all dates in this month.`;
          } else {
            warningExplanation = `The actual Day 1 could potentially fall on the previous or next day.`;
          }
          
          uncertaintyWarningHtml = `
            <div class="uncertainty-warning">
              <span class="warning-icon">‚ö†Ô∏è</span>
              <strong>Date Uncertainty:</strong> The ${marginStr} margin between the ${getMoonLabel()} and sunset 
              is within the estimated ¬±${uncertaintyHours} hour uncertainty for astronomical calculations at this date. 
              ${warningExplanation}
            </div>
          `;
        }
        
        basisHtml = `
          <div class="feast-basis">
            ${explanationText}
          </div>
          ${uncertaintyWarningHtml}
        `;
      }
      
      // Generate dynamic description for Renewed Moon based on current moon phase setting
      const feastDescription = feast.name === 'Renewed Moon' 
        ? getRenewedMoonDescription() 
        : feast.description;
      
      const item = document.createElement('div');
      item.className = 'day-detail-feast-item';
      item.innerHTML = `
        <div class="day-detail-feast-icon">${feast.icon}</div>
        <div class="day-detail-feast-info">
          <div class="day-detail-feast-name">${nameText}</div>
          <div class="day-detail-feast-desc">${feastDescription}</div>
          ${basisHtml}
          ${feast.chapter ? `<a href="${feast.chapter}" class="day-detail-feast-link">Learn more &rarr;</a>` : ''}
        </div>
      `;
      feastsContainer.appendChild(item);
    }
  } else if (!dayObj.equinox) {
    feastsContainer.innerHTML = '<div class="day-detail-no-feast">No appointed times on this day</div>';
  }
  
  // Add equinox info if this day has the spring equinox
  if (dayObj.equinox) {
    const equinoxDate = dayObj.equinox.date;
    const eqParts = getFormattedDateParts(equinoxDate);
    const dayOfWeek = eqParts.weekdayName;
    const monthName = eqParts.monthName;
    const dayNum = eqParts.day;
    const daySuffix = getOrdinalSuffix(dayNum);
    const year = eqParts.yearStr;
    const timeStr = equinoxDate.toLocaleTimeString('en-US', { 
      hour: 'numeric', minute: '2-digit', hour12: true 
    });
    
    const now = new Date();
    const isPast = equinoxDate < now;
    const verb = isPast ? 'occurred' : 'will occur';
    
    const item = document.createElement('div');
    item.className = 'day-detail-feast-item';
    item.innerHTML = `
      <div class="day-detail-feast-icon">‚òÄÔ∏è‚öñÔ∏è</div>
      <div class="day-detail-feast-info">
        <div class="day-detail-feast-name">Spring Equinox</div>
        <div class="day-detail-feast-desc">The moment when day and night are equal in length, marking the astronomical beginning of spring.</div>
        <div class="feast-basis">
          The Spring Equinox ${verb} on ${dayOfWeek}, ${monthName} ${dayNum}${daySuffix}, ${year} at ${timeStr}.
        </div>
        <a href="/chapters/08-when-does-the-year-start/" class="day-detail-feast-link">Learn more &rarr;</a>
      </div>
    `;
    feastsContainer.appendChild(item);
  }
  
  // Add blood moon (lunar eclipse) info if this day has one
  if (dayObj.isBloodMoon) {
    const bloodMoonDate = dayObj.gregorianDate;
    const bmParts = getFormattedDateParts(bloodMoonDate);
    const dayOfWeek = bmParts.weekdayName;
    const monthName = bmParts.monthName;
    const dayNum = bmParts.day;
    const daySuffix = getOrdinalSuffix(dayNum);
    const year = bmParts.yearStr;
    
    const now = new Date();
    const isPast = bloodMoonDate < now;
    const verb = isPast ? 'occurred' : 'will occur';
    
    const item = document.createElement('div');
    item.className = 'day-detail-feast-item';
    item.innerHTML = `
      <div class="day-detail-feast-icon blood-moon-icon">üåï</div>
      <div class="day-detail-feast-info">
        <div class="day-detail-feast-name" style="color: #ff6b6b;">Blood Moon (Total Lunar Eclipse)</div>
        <div class="day-detail-feast-desc">A total lunar eclipse occurs when the Earth passes between the Sun and Moon, 
          casting Earth's shadow on the lunar surface. The Moon appears deep red due to sunlight filtered through Earth's atmosphere.</div>
        <div class="feast-basis">
          A total lunar eclipse ${verb} on ${dayOfWeek}, ${monthName} ${dayNum}${daySuffix}, ${year}. 
          In Scripture, blood moons are often associated with significant prophetic events (Joel 2:31, Acts 2:20, Revelation 6:12).
        </div>
      </div>
    `;
    feastsContainer.appendChild(item);
  }
  
  // Add uncertainty warning for any uncertain day
  if (dayObj.isUncertain && month.dateUncertainty) {
    const item = document.createElement('div');
    item.className = 'day-detail-feast-item';
    
    const prob = month.dateUncertaintyProbability || 0;
    let warningText = '';
    if (month.dateUncertainty === '-') {
      if (dayObj.lunarDay === 30) {
        warningText = `There is a ~${prob}% probability this Day 30 does not exist. The margin between this month's ${getMoonLabel()} and sunset 
          is within the estimated uncertainty for astronomical calculations at this ancient date. 
          If the ${getMoonLabel()} actually occurred before sunset, the prior month would have only 29 days, 
          and all dates in this month would be one day earlier than shown.`;
      } else {
        warningText = `There is a ~${prob}% probability this date is one day earlier than shown. The ${getMoonLabel()} occurred very close to sunset, 
          and if it was actually before sunset, the prior month would have only 29 days instead of 30.`;
      }
    } else if (month.dateUncertainty === '+') {
      warningText = `There is a ~${prob}% probability this date is one day later than shown. The ${getMoonLabel()} occurred very close to sunset, 
        and if it was actually after sunset, the prior month would have 30 days instead of 29.`;
    }
    
    item.innerHTML = `
      <div class="day-detail-feast-icon">‚ö†Ô∏è</div>
      <div class="day-detail-feast-info">
        <div class="day-detail-feast-name">Date Uncertainty: ~${prob}% chance dates are ${month.dateUncertainty === '-' ? 'earlier' : 'later'}</div>
        <div class="uncertainty-warning" style="margin-top: 0.5rem;">
          ${warningText}
        </div>
      </div>
    `;
    feastsContainer.appendChild(item);
  }
  
  // Add year start explanation for 1st day of 1st month, or 13th month explanation
  if (dayObj.lunarDay === 1 && (month.monthNumber === 1 || month.monthNumber === 13)) {
    const item = document.createElement('div');
    item.className = 'day-detail-feast-item day-detail-year-info';
    
    const totalMonths = state.lunarMonths.length;
    const has13thMonth = totalMonths === 13;
    const moonLabel = getMoonLabel();
    
    // Get spring equinox for this lunar year
    const springEquinox = getAstroEngine().getSeasons(state.year).mar_equinox.date;
    const seqParts = getFormattedDateParts(springEquinox);
    const equinoxDateStr = `${seqParts.weekdayName}, ${seqParts.monthName} ${seqParts.day}${getOrdinalSuffix(seqParts.day)}, ${seqParts.yearStr}${seqParts.calendarSuffix}`;
    
    // Check if we're in crescent + sunset mode
    const isCrescentSunset = state.moonPhase === 'crescent' && 
                             state.dayStartTime === 'evening' && 
                             state.dayStartAngle === 0;
    
    // Calculate time from equinox to month start (day 1 day-start)
    // For crescent+sunset, use the moon event time (crescent sighting = sunset)
    let day1StartTs;
    if (isCrescentSunset && month.moonEvent) {
      day1StartTs = month.moonEvent.getTime();
    } else {
      day1StartTs = getDayStartTime(dayObj.gregorianDate);
    }
    const diffMs = day1StartTs - springEquinox.getTime();
    const diffTotalHours = diffMs / (1000 * 60 * 60);
    const diffDays = Math.floor(Math.abs(diffTotalHours) / 24);
    const diffHours = Math.round(Math.abs(diffTotalHours) % 24);
    
    let timingStr = '';
    if (diffDays > 0 && diffHours > 0) {
      timingStr = `${diffDays} day${diffDays !== 1 ? 's' : ''} and ${diffHours} hour${diffHours !== 1 ? 's' : ''}`;
    } else if (diffDays > 0) {
      timingStr = `${diffDays} day${diffDays !== 1 ? 's' : ''}`;
    } else {
      timingStr = `${diffHours} hour${diffHours !== 1 ? 's' : ''}`;
    }
    const beforeAfter = diffMs >= 0 ? 'after' : 'before';
    
    if (month.monthNumber === 1) {
      // Positive reason: explain why year CAN start here using current moon phase setting
      const dayStartLabel = getDayStartLabel();
      const day1StartDate = new Date(day1StartTs);
      const day1StartStr = day1StartDate.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
      const day1Parts = getFormattedDateParts(day1StartDate);
      const day1DateStr = `${day1Parts.weekdayName}, ${day1Parts.monthName} ${day1Parts.day}${getOrdinalSuffix(day1Parts.day)}`;
      
      const yearMonthInfo = `Day 1 begins at ${dayStartLabel} (${day1DateStr} at ${day1StartStr}), which is ${timingStr} ${beforeAfter} the <a href="#" class="equinox-link" data-equinox-date="${springEquinox.toISOString()}">Spring Equinox (${equinoxDateStr})</a>. This qualifies as the 1st month of Lunar Year ${state.year}.`;
      
      item.innerHTML = `
        <div class="day-detail-feast-icon">üìÖ</div>
        <div class="day-detail-feast-info">
          <div class="day-detail-feast-name">Lunar Year ${state.year} Begins</div>
          <div class="day-detail-feast-desc">${yearMonthInfo}</div>
        </div>
      `;
      feastsContainer.appendChild(item);
      
      // Add click handler for equinox link
      const equinoxLink = item.querySelector('.equinox-link');
      if (equinoxLink) {
        equinoxLink.addEventListener('click', (e) => {
          e.preventDefault();
          jumpToEquinoxDate(springEquinox);
        });
      }
    } else if (month.monthNumber === 13) {
      // Explain why 13th month exists: its day-start is BEFORE the next year's start point
      const nextEquinox = getAstroEngine().getSeasons(state.year + 1).mar_equinox.date;
      const neqParts = getFormattedDateParts(nextEquinox);
      const nextEquinoxDateStr = `${neqParts.weekdayName}, ${neqParts.monthName} ${neqParts.day}${getOrdinalSuffix(neqParts.day)}, ${neqParts.yearStr}${neqParts.calendarSuffix}`;
      
      // Get the 13th month's moon event (crescent/full/dark)
      const month13MoonEvent = month.moonEvent;
      let moonEventStr = '';
      let dayStartStr = '';
      let timingExplanation = '';
      
      if (month13MoonEvent) {
        const moonParts = getFormattedDateParts(month13MoonEvent);
        const moonTimeStr = month13MoonEvent.toLocaleTimeString('en-US', { 
          hour: 'numeric', minute: '2-digit', hour12: true 
        });
        moonEventStr = `${moonParts.weekdayName}, ${moonParts.monthName} ${moonParts.day}${getOrdinalSuffix(moonParts.day)}, ${moonParts.yearStr} at ${moonTimeStr}`;
        
        // Check if we're in crescent + sunset mode
        const isCrescentSunset = state.moonPhase === 'crescent' && 
                                 state.dayStartTime === 'evening' && 
                                 state.dayStartAngle === 0;
        
        // Calculate when Day 1 starts (day-start time)
        // For crescent+sunset, the month starts at the crescent sighting time (which IS sunset)
        let dayStartTimestamp;
        if (isCrescentSunset) {
          dayStartTimestamp = month13MoonEvent.getTime();
        } else {
          dayStartTimestamp = getDayStartTime(dayObj.gregorianDate);
        }
        const dayStartDate = new Date(dayStartTimestamp);
        const dayStartLabel = getDayStartLabel();
        const dsTimeStr = dayStartDate.toLocaleTimeString('en-US', { 
          hour: 'numeric', minute: '2-digit', hour12: true 
        });
        const dsParts = getFormattedDateParts(dayStartDate);
        dayStartStr = `${dsParts.weekdayName}, ${dsParts.monthName} ${dsParts.day}${getOrdinalSuffix(dsParts.day)} at ${dsTimeStr}`;
        
        // Calculate time from 13th month day-start to next equinox
        const diffToEquinoxMs = nextEquinox.getTime() - dayStartTimestamp;
        const diffToEquinoxHours = diffToEquinoxMs / (1000 * 60 * 60);
        const diffDays = Math.floor(diffToEquinoxHours / 24);
        const diffHours = Math.round(diffToEquinoxHours % 24);
        
        let diffStr = '';
        if (diffDays > 0 && diffHours > 0) {
          diffStr = `${diffDays} day${diffDays !== 1 ? 's' : ''} and ${diffHours} hour${diffHours !== 1 ? 's' : ''}`;
        } else if (diffDays > 0) {
          diffStr = `${diffDays} day${diffDays !== 1 ? 's' : ''}`;
        } else {
          diffStr = `${diffHours} hour${diffHours !== 1 ? 's' : ''}`;
        }
        
        timingExplanation = `The ${moonLabel} for this month was sighted on ${moonEventStr}. ` +
          `Day 1 begins at ${dayStartLabel} (${dayStartStr}), which is ${diffStr} before the ` +
          `<a href="#" class="equinox-link" data-equinox-date="${nextEquinox.toISOString()}">Spring Equinox (${nextEquinoxDateStr})</a>. ` +
          `Since this day-start falls before the equinox, this qualifies as the 13th month of the current year rather than the 1st month of the next year.`;
      }
      
      item.innerHTML = `
        <div class="day-detail-feast-icon">üìÖ</div>
        <div class="day-detail-feast-info">
          <div class="day-detail-feast-name">13th Month (Intercalary)</div>
          <div class="day-detail-feast-desc">${timingExplanation}</div>
        </div>
      `;
      feastsContainer.appendChild(item);
      
      // Add click handler for equinox link
      const equinoxLink = item.querySelector('.equinox-link');
      if (equinoxLink) {
        equinoxLink.addEventListener('click', (e) => {
          e.preventDefault();
          jumpToEquinoxDate(nextEquinox);
        });
      }
    }
  }
  
  // Populate astronomical times in header (to the right of date info)
  const astroTimesContainer = panel.querySelector('.day-detail-astro-times');
  const astroTimes = getAstronomicalTimes(dayObj.gregorianDate);
  if (astroTimes) {
    astroTimesContainer.innerHTML = `
      <div class="astro-times-title">‚òÄÔ∏è Astronomical Times</div>
      <div class="astro-times-row">
        <div class="astro-times-group">
          <div class="astro-time"><span class="astro-label">Daybreak:</span> <span class="astro-value">${astroTimes.firstLight}</span></div>
          <div class="astro-time"><span class="astro-label">Sunrise:</span> <span class="astro-value">${astroTimes.sunrise}</span></div>
        </div>
        <div class="astro-times-group">
          <div class="astro-time"><span class="astro-label">Sunset:</span> <span class="astro-value">${astroTimes.sunset}</span></div>
          <div class="astro-time"><span class="astro-label">Twilight:</span> <span class="astro-value">${astroTimes.nauticalTwilight}</span></div>
        </div>
      </div>
    `;
  } else {
    astroTimesContainer.innerHTML = '';
  }
  
  // Populate additional info
  const infoContainer = panel.querySelector('.day-detail-info');
  let infoHtml = '';
  
  if (isSabbath(dayObj)) {
    const sabbathLabel = state.sabbathMode === 'lunar' ? 'Lunar Sabbath' : 
                         state.sabbathMode === 'saturday' ? 'Shabbat' :
                         state.sabbathMode === 'sunday' ? 'Lord\'s Day' :
                         state.sabbathMode === 'friday' ? 'Jumu\'ah' : 
                         'Rest Day';
    infoHtml += `<div class="day-detail-sabbath">üïØÔ∏è ${sabbathLabel}</div>`;
  }
  
  if (dayObj.moonPhase && dayObj.lunarDay !== 1) {
    infoHtml += `<div>Moon phase: ${dayObj.moonPhase}</div>`;
  }
  
  infoContainer.innerHTML = infoHtml;
  
  // Populate dateline visualization for Day 1
  const datelineContainer = panel.querySelector('.day-detail-dateline');
  if (dayObj.lunarDay === 1 && month.moonEvent) {
    const datelineHtml = renderDatelineVisualization(month.moonEvent);
    datelineContainer.innerHTML = datelineHtml;
  } else {
    datelineContainer.innerHTML = '';
  }
  
  // Populate profile comparison section
  const compareContainer = panel.querySelector('.day-detail-profile-compare');
  const now = new Date();
  const checkTimestamp = dayObj.gregorianDate.getTime();
  
  // Always show profile comparison for modern dates
  if (Object.keys(PRESET_PROFILES).length > 1) {
    let compareHtml = `<div class="profile-compare-title">üìÖ This Moment on Other Calendars</div>`;
    compareHtml += `<div class="profile-compare-grid">`;
    
    let hasResults = false;
    for (const [profileId, profile] of Object.entries(PRESET_PROFILES)) {
      const isCurrent = profileId === state.selectedProfile;
      const lunarDayInfo = getLunarDayForTimestamp(checkTimestamp, profile);
      
      if (lunarDayInfo) {
        hasResults = true;
        
        // Get feast icons for this lunar day/month
        const feastIcons = getFeastIconsForLunarDay(lunarDayInfo.month, lunarDayInfo.day);
        const feastHtml = feastIcons.length > 0 ? `<div class="profile-compare-feasts">${feastIcons.join('')}</div>` : '';
        
        compareHtml += `
          <div class="profile-compare-item${isCurrent ? ' current' : ''}" data-profile-id="${profileId}" onclick="switchToProfileAndNavigate('${profileId}', ${checkTimestamp})">
            <span class="profile-compare-name">${profile.icon} ${profile.name}</span>
            <span class="profile-compare-day">Day ${lunarDayInfo.day} of Month ${lunarDayInfo.month}</span>
            ${feastHtml}
          </div>
        `;
      }
    }
    
    compareHtml += `</div>`;
    
    if (hasResults) {
      compareContainer.innerHTML = compareHtml;
    } else {
      compareContainer.innerHTML = '';
    }
  } else {
    compareContainer.innerHTML = '';
  }
  
  // Show the panel (reset both inline style and class)
  panel.style.display = '';  // Reset any inline display:none from settings page
  panel.classList.remove('hidden');
  
  // Scroll panel into view on mobile
  if (window.innerWidth <= 768) {
    panel.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
  }
}

function closeDayDetail() {
  document.getElementById('day-detail-panel').classList.add('hidden');
}

function getOrdinalSuffix(n) {
  const s = ['th', 'st', 'nd', 'rd'];
  const v = n % 100;
  return s[(v - 20) % 10] || s[v] || s[0];
}

// Jump to a specific equinox date and highlight that day
function jumpToEquinoxDate(equinoxDate) {
  const targetDate = new Date(equinoxDate);
  
  // Find this date in the current lunar months
  for (let m = 0; m < state.lunarMonths.length; m++) {
    const month = state.lunarMonths[m];
    for (let d = 0; d < month.days.length; d++) {
      const day = month.days[d];
      // Check if equinox falls on this day
      if (day.equinox && day.equinox.date.toDateString() === targetDate.toDateString()) {
        state.currentMonthIndex = m;
        state.highlightedLunarDay = day.lunarDay;
        state.selectedTimestamp = getSunriseTimestamp(day.gregorianDate);
        document.getElementById('goto-date').value = formatLocalDatetime(state.selectedTimestamp);
        renderMonth(state.lunarMonths[state.currentMonthIndex]);
        updateMonthButtons();
        updateURL();
        showDayDetail(day, month);
        return;
      }
    }
  }
  
  // If not found in current year's months, the equinox might be in a different year
  // Navigate to that year first
  const equinoxYear = targetDate.getFullYear();
  if (equinoxYear !== state.year) {
    state.year = equinoxYear;
    updateUI();
    generateCalendar();
    // Try again after regenerating
    jumpToEquinoxDate(equinoxDate);
  }
}

function jumpToToday() {
  const now = new Date();
  const utcTimestamp = now.getTime();
  
  // Get the current date at the selected location (based on longitude)
  // utcToLocalTime returns a Date where UTC methods give local time at location
  const localDateAtLocation = utcToLocalTime(utcTimestamp, state.lon);
  const targetYear = localDateAtLocation.getUTCFullYear();
  const targetMonth = localDateAtLocation.getUTCMonth();
  const targetDay = localDateAtLocation.getUTCDate();
  
  // Update goto-date input with local time at selected location
  document.getElementById('goto-date').value = formatLocalDatetime(utcTimestamp);
  
  // Determine which lunar year today belongs to
  // Use UTC comparison - the calendar builds months based on UTC moon events
  const springEquinox = getAstroEngine().getSeasons(targetYear).mar_equinox.date;
  const lunarYear = utcTimestamp < springEquinox.getTime() ? targetYear - 1 : targetYear;
  
  // Update state year (keep other settings from localStorage)
  state.year = lunarYear;
  
  // Update UI with all state (including saved location/moon phase settings)
  updateUI();
  
  // Generate calendar for today's lunar year
  generateCalendar();
  
  // Find today in the generated months
  // Calendar dates are stored as browser-local Date objects but represent the date at the location
  for (let m = 0; m < state.lunarMonths.length; m++) {
    const month = state.lunarMonths[m];
    for (let d = 0; d < month.days.length; d++) {
      const day = month.days[d];
      const gd = day.gregorianDate;
      // Compare year/month/day - both represent the date at the observer's location
      if (gd.getFullYear() === targetYear && 
          gd.getMonth() === targetMonth && 
          gd.getDate() === targetDay) {
        state.currentMonthIndex = m;
        state.highlightedLunarDay = day.lunarDay;
        state.selectedTimestamp = utcTimestamp;
        renderMonth(state.lunarMonths[m]);
        updateMonthButtons();
        showDayDetail(day, month);
        return;
      }
    }
  }
  
  // Fallback: if today not found, just show first month
  state.currentMonthIndex = 0;
  renderMonth(state.lunarMonths[0]);
  updateMonthButtons();
}

// Open ICS directly in calendar app
async function openInCalendar() {
  const icsContent = generateICSContent();
  if (!icsContent) return;
  
  const filename = `lunar-sabbath-calendar-${state.year}.ics`;
  const blob = new Blob([icsContent], { type: 'text/calendar' });
  const file = new File([blob], filename, { type: 'text/calendar' });
  
  // Try Web Share API first (works great on mobile and some desktop)
  if (navigator.share && navigator.canShare && navigator.canShare({ files: [file] })) {
    try {
      await navigator.share({
        files: [file],
        title: 'Lunar Sabbath Calendar',
        text: `Sabbaths and Feasts for ${formatYear(state.year)}`
      });
      return;
    } catch (err) {
      if (err.name !== 'AbortError') {
        console.log('Share failed, falling back to download');
      } else {
        return; // User cancelled
      }
    }
  }
  
  // Fallback: Download the file
  exportToICS();
  
  // Close the export modal after successful download
  const exportPage = document.getElementById('export-page');
  if (exportPage && exportPage.style.display !== 'none') {
    toggleExportModal();
  }
}

// Generate ICS content for calendar export
function generateICSContent() {
  if (!state.lunarMonths || state.lunarMonths.length === 0) {
    alert('Please generate a calendar first');
    return null;
  }
  
  const events = [];
  const yearLabel = formatYear(state.year);
  
  // Collect all Sabbaths and Feasts
  for (const month of state.lunarMonths) {
    for (const day of month.days) {
      // Add Sabbaths
      if (isSabbath(day)) {
        const sabbathLabel = state.sabbathMode === 'lunar' ? 'Lunar Sabbath' : 
                             state.sabbathMode === 'saturday' ? 'Shabbat' :
                             state.sabbathMode === 'sunday' ? 'Lord\'s Day' :
                             state.sabbathMode === 'friday' ? 'Jumu\'ah' : 
                             'Rest Day';
        events.push({
          date: day.gregorianDate,
          title: `${sabbathLabel} (${MONTH_NAMES[month.monthNumber - 1]} ${day.lunarDay})`,
          description: `${sabbathLabel} - Day ${day.lunarDay} of ${MONTH_NAMES[month.monthNumber - 1]}`,
          allDay: true
        });
      }
      
      // Add Feasts
      if (day.feast) {
        let title = day.feast.name;
        if (day.feastDayNum) {
          title += ` Day ${day.feastDayNum}`;
        }
        events.push({
          date: day.gregorianDate,
          title: title,
          description: day.feast.description + ` (${MONTH_NAMES[month.monthNumber - 1]} ${day.lunarDay})`,
          allDay: true
        });
      }
      
      // Add New Moon days
      if (day.isNewMoon) {
        events.push({
          date: day.gregorianDate,
          title: `New Moon - ${MONTH_NAMES[month.monthNumber - 1]}`,
          description: `Start of ${MONTH_NAMES[month.monthNumber - 1]} (Lunar Month ${month.monthNumber})`,
          allDay: true
        });
      }
    }
  }
  
  // Sort events by date
  events.sort((a, b) => a.date.getTime() - b.date.getTime());
  
  // Generate ICS content
  let ics = [
    'BEGIN:VCALENDAR',
    'VERSION:2.0',
    'PRODID:-//LunarSabbath.net//Lunar Sabbath Calendar//EN',
    'CALSCALE:GREGORIAN',
    'METHOD:PUBLISH',
    `X-WR-CALNAME:Lunar Sabbath Calendar ${yearLabel}`
  ];
  
  for (const event of events) {
    const dateStr = formatICSDate(event.date);
    const uid = `${dateStr}-${event.title.replace(/\s+/g, '-')}@lunarsabbath.net`;
    
    ics.push('BEGIN:VEVENT');
    ics.push(`UID:${uid}`);
    ics.push(`DTSTART;VALUE=DATE:${dateStr}`);
    ics.push(`DTEND;VALUE=DATE:${dateStr}`);
    ics.push(`SUMMARY:${escapeICS(event.title)}`);
    ics.push(`DESCRIPTION:${escapeICS(event.description)}`);
    ics.push('END:VEVENT');
  }
  
  ics.push('END:VCALENDAR');
  
  return ics.join('\r\n');
}

// Export Sabbaths and Feasts to ICS file for calendar import
function exportToICS() {
  const icsContent = generateICSContent();
  if (!icsContent) return;
  
  // Download the file
  const blob = new Blob([icsContent], { type: 'text/calendar;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = `lunar-sabbath-calendar-${state.year}.ics`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

function formatICSDate(date) {
  const year = date.getFullYear();
  const month = (date.getMonth() + 1).toString().padStart(2, '0');
  const day = date.getDate().toString().padStart(2, '0');
  return `${year}${month}${day}`;
}

function escapeICS(text) {
  // Escape special characters for ICS format
  return text
    .replace(/\\/g, '\\\\')
    .replace(/;/g, '\\;')
    .replace(/,/g, '\\,')
    .replace(/\n/g, '\\n');
}

// Register Service Worker for PWA functionality
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js')
      .then((registration) => {
        console.log('ServiceWorker registered:', registration.scope);
      })
      .catch((error) => {
        console.log('ServiceWorker registration failed:', error);
      });
  });
}
</script>
</body>
</html>

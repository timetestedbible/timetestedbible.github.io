---
layout: null
title: "Lunar Sabbath Calendar"
---
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#1a3a5c">
  <meta name="description" content="A time-tested lunar calendar for tracking Sabbaths and appointed times">
  <title>{{ page.title }}</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@600;700;900&display=swap" rel="stylesheet">
  <link rel="icon" type="image/svg+xml" href="/icons/icon.svg">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/icon-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/icon-16.png">
  <link rel="manifest" href="/manifest.json">
  <link rel="apple-touch-icon" href="/icons/icon-192.png">
  <link rel="stylesheet" href="/styles.css">
</head>
<body>

<!-- About Modal -->
<div id="about-modal-overlay" class="about-modal-overlay" onclick="closeAboutModal(event)">
  <div class="about-modal" onclick="event.stopPropagation()">
    <div class="about-modal-header">
      <div class="about-modal-logo">
        <span class="moon-phase">ğŸŒ’</span>
        <span class="moon-phase primary">ğŸŒ•</span>
        <span class="moon-phase">ğŸŒ‘</span>
      </div>
      <h2 class="about-modal-title">LunarSabbath.net</h2>
      <p class="about-modal-subtitle">A Time Tested Tradition</p>
    </div>
    
    <div class="about-modal-content">
      <ul class="about-features">
        <li>
          <span class="feature-icon">ğŸŒ•</span>
          <span class="feature-text"><strong>Any Month Start</strong> â€” Full Moon, Dark Moon, or Crescent Moon</span>
        </li>
        <li>
          <span class="feature-icon">ğŸª</span>
          <span class="feature-text"><strong>Any Sabbath</strong> â€” Lunar, Saturday, or Custom cycles</span>
        </li>
        <li>
          <span class="feature-icon">ğŸŒ</span>
          <span class="feature-text"><strong>Any Location</strong> â€” Moon phases calculated for your coordinates</span>
        </li>
        <li>
          <span class="feature-icon">â˜€ï¸</span>
          <span class="feature-text"><strong>Any Day Start</strong> â€” Morning twilight or evening sunset</span>
        </li>
        <li>
          <span class="feature-icon">ğŸ“†</span>
          <span class="feature-text"><strong>Any Year</strong> â€” From Exodus to Christ's Return</span>
        </li>
        <li>
          <span class="feature-icon"><img src="/icons/menorah.png" alt="Menorah" class="feature-img"></span>
          <span class="feature-text"><strong>Export Feasts</strong> â€” Add feasts to your calendar app</span>
        </li>
        <li>
          <span class="feature-icon">ğŸ“²</span>
          <span class="feature-text"><strong>Installable App</strong> â€” Works offline on any device</span>
        </li>
      </ul>
      
      <button class="about-start-btn" onclick="closeAboutModal()">Test Everything</button>
      
      <div class="about-cta">
        <p>Discover which historical events align with different calendar interpretations and why communities chose their traditions.</p>
      </div>
    </div>
  </div>
</div>

<!-- Top Navigation Bar -->
<nav class="top-nav">
  <div class="top-nav-inner">
    <div class="top-nav-brand" onclick="navigateTo('calendar')" style="cursor: pointer;">
      <span class="top-nav-icon">ğŸŒ•</span>
      <div class="top-nav-text">
        <div class="top-nav-title">Lunar Sabbath</div>
        <div class="top-nav-tagline">a time tested tradition</div>
      </div>
    </div>
    <button class="hamburger-btn" onclick="toggleNavMenu()" aria-label="Menu">â˜°</button>
  </div>
</nav>

<!-- Navigation Menu Overlay -->
<div id="nav-menu-overlay" class="nav-menu-overlay" onclick="toggleNavMenu()"></div>

<!-- Navigation Menu -->
<div id="nav-menu" class="nav-menu">
  <div class="nav-menu-header">
    <h3>Menu</h3>
    <button class="nav-menu-close" onclick="toggleNavMenu()">âœ•</button>
  </div>
  <div class="nav-menu-items">
    <button class="nav-menu-item" onclick="navigateTo('calendar')">
      <span class="icon">ğŸ“…</span>
      <span>Calendar</span>
    </button>
    <button class="nav-menu-item" onclick="navigateTo('feasts')">
      <span class="icon">ğŸº</span>
      <span>Feasts</span>
    </button>
    <button class="nav-menu-item" onclick="navigateTo('settings')">
      <span class="icon">âš™ï¸</span>
      <span>Profiles</span>
    </button>
    <button class="nav-menu-item" onclick="navigateTo('sabbath-tester')">
      <span class="icon">ğŸ”¬</span>
      <span>Sabbath Tester</span>
    </button>
    <div class="nav-menu-divider"></div>
    <button class="nav-menu-item" id="install-app-btn" style="display: none;" onclick="handleInstallClick()">
      <span class="icon">ğŸ“²</span>
      <span>Install App</span>
    </button>
    <div class="book-ad">
      <div class="book-ad-top">
        <div class="book-ad-title">TIME</div>
        <div class="book-ad-subtitle">Tested Tradition</div>
        <div class="book-ad-tagline">The Renewed Biblical Calendar</div>
      </div>
      <div class="book-ad-bottom">
        <div class="book-ad-author">By Daniel Larimer</div>
        <a class="book-ad-download" href="/media/time-tested-tradition.pdf" download onclick="trackBookDownload()">
          <span class="icon">ğŸ“¥</span>
          <span>Download PDF</span>
        </a>
      </div>
    </div>
    <a class="nav-menu-item" href="/book/">
      <span class="icon">ğŸ“–</span>
      <span>Browse Book</span>
    </a>
    <button class="nav-menu-item" onclick="navigateTo('about')">
      <span class="icon">â„¹ï¸</span>
      <span>About</span>
    </button>
  </div>
</div>

<!-- iOS Install Instructions Modal -->
<div id="ios-install-overlay" class="ios-install-overlay" onclick="closeIOSInstallModal(event)">
  <div class="ios-install-modal" onclick="event.stopPropagation()">
    <button class="ios-install-close" onclick="closeIOSInstallModal()">âœ•</button>
    <div class="ios-install-header">
      <span class="ios-install-icon">ğŸ“²</span>
      <h3>Install LunarSabbath</h3>
    </div>
    <p class="ios-install-intro">Add this app to your home screen for quick access and an app-like experience.</p>
    <div class="ios-install-steps">
      <div class="ios-install-step">
        <div class="step-number">1</div>
        <div class="step-content">
          <p>Tap the <strong>Share</strong> button <span class="ios-share-icon">â¬†ï¸</span> in Safari's toolbar</p>
        </div>
      </div>
      <div class="ios-install-step">
        <div class="step-number">2</div>
        <div class="step-content">
          <p>Scroll down and tap <strong>"Add to Home Screen"</strong></p>
        </div>
      </div>
      <div class="ios-install-step">
        <div class="step-number">3</div>
        <div class="step-content">
          <p>Tap <strong>"Add"</strong> in the top right corner</p>
        </div>
      </div>
    </div>
    <button class="ios-install-done-btn" onclick="closeIOSInstallModal()">Got it!</button>
  </div>
</div>

<div class="calendar-app">
  <!-- Settings Dialog (hidden by default) -->
  <div id="settings-overlay" class="settings-overlay" onclick="if(event.target === this) toggleSettings()"></div>
  <div id="settings-dialog" class="settings-dialog">
    <div class="settings-header">
      <h3>Month Sign & Location</h3>
      <button onclick="toggleSettings()" class="close-btn">âœ•</button>
    </div>
    <div class="settings-content">
      <div class="setting-group">
        <label>Month Starts At</label>
        <div class="moon-phase-buttons">
          <button class="moon-phase-btn" data-phase="full" onclick="selectMoonPhase('full')">
            <span class="phase-icon">ğŸŒ•</span>
            <span class="phase-name">Full Moon</span>
          </button>
          <button class="moon-phase-btn" data-phase="dark" onclick="selectMoonPhase('dark')">
            <span class="phase-icon">ğŸŒ‘</span>
            <span class="phase-name">Dark Moon</span>
          </button>
          <button class="moon-phase-btn" data-phase="crescent" onclick="selectMoonPhase('crescent')">
            <span class="phase-icon">ğŸŒ’</span>
            <span class="phase-name">Crescent</span>
          </button>
        </div>
        <select id="moon-phase-select" style="display: none;">
          <option value="full">Full Moon</option>
          <option value="dark">Dark Moon (Conjunction)</option>
          <option value="crescent">Crescent Moon (First Visible)</option>
        </select>
      </div>
      
      <div class="setting-group">
        <label>Default Location</label>
        <div id="settings-map-container"></div>
        <select id="city-select" class="city-select-styled">
          <optgroup label="Biblical">
            <option value="31.7683,35.2137">Jerusalem</option>
          </optgroup>
          <optgroup label="United States">
            <option value="40.7128,-74.0060">New York (Eastern)</option>
            <option value="41.8781,-87.6298">Chicago (Central)</option>
            <option value="39.7392,-104.9903">Denver (Mountain)</option>
            <option value="34.0522,-118.2437">Los Angeles (Pacific)</option>
            <option value="61.2181,-149.9003">Anchorage (Alaska)</option>
            <option value="21.3069,-157.8583">Honolulu (Hawaii)</option>
          </optgroup>
          <optgroup label="International">
            <option value="51.5074,-0.1278">London</option>
            <option value="48.8566,2.3522">Paris</option>
            <option value="35.6762,139.6503">Tokyo</option>
            <option value="-33.8688,151.2093">Sydney</option>
          </optgroup>
          <option value="">Custom Coordinates...</option>
        </select>
        <div class="setting-group" id="custom-coords" style="display: none;">
          <div style="display: flex; gap: 10px; margin-top: 10px;">
            <input type="number" id="lat-input" value="31.7683" step="0.0001" placeholder="Latitude">
            <input type="number" id="lon-input" value="35.2137" step="0.0001" placeholder="Longitude">
          </div>
        </div>
        <button type="button" class="location-btn" onclick="useCurrentLocation()">ğŸ“ Use My Current Location</button>
      </div>
      
      <div class="setting-info">
        The location determines when the lunar day begins for you.
      </div>
    </div>
  </div>

  <!-- Hidden inputs for state -->
  <input type="number" id="year-input" value="2026" min="-4000" max="4000" style="display: none;">
  <span id="year-display" style="display: none;"></span>
  <input type="datetime-local" id="goto-date" step="60" style="display: none;">
  <input type="number" id="add-days" value="1" min="1" style="display: none;">
  
  <!-- Month Picker Popup -->
  <div id="month-picker-overlay" class="month-picker-overlay" onclick="if(event.target === this) toggleMonthPicker()"></div>
  <div id="month-picker" class="month-picker" style="display: none;">
    <div class="month-picker-header">
      <h3>Select Month</h3>
      <button class="close-btn" onclick="toggleMonthPicker()">âœ•</button>
    </div>
    <div class="year-nav">
      <button onclick="changePickerYear(-1)">â—€</button>
      <div class="year-display-container">
        <span id="picker-year" class="year-display" onclick="showYearInput()" title="Click to enter year"></span>
        <input type="number" id="picker-year-input" class="year-input" min="1" max="4000"
               onkeydown="if(event.key==='Enter') applyYearInput(); if(event.key==='Escape') hideYearInput();"
               onblur="applyYearInput()">
      </div>
      <button onclick="changePickerYear(1)">â–¶</button>
      <select id="era-select" class="era-select" onchange="changeEra(this.value)">
        <option value="AD">AD</option>
        <option value="BC">BC</option>
      </select>
    </div>
    <div id="month-grid" class="month-grid"></div>
  </div>
  
  <!-- City Picker Modal -->
  <div id="city-picker-overlay" class="city-picker-overlay" onclick="if(event.target === this) toggleCityPicker()"></div>
  <div id="city-picker" class="city-picker" style="display: none;">
    <div class="city-picker-header">
      <h3>Select Location</h3>
      <button class="close-btn" onclick="toggleCityPicker()">âœ•</button>
    </div>
    <div class="city-picker-controls">
      <button class="city-action-btn" onclick="useMyLocationFromPicker()">ğŸ“ Use My Location</button>
      <select id="city-picker-select" class="city-picker-select" onchange="selectCityFromDropdown(this.value)">
        <option value="">-- Select a city --</option>
      </select>
    </div>
    <div id="city-picker-map"></div>
  </div>
  
  <!-- Profile Picker Modal -->
  <div id="profile-picker-overlay" class="profile-picker-overlay" onclick="if(event.target === this) toggleProfilePicker()"></div>
  <div id="profile-picker" class="profile-picker" style="display: none;">
    <div class="profile-picker-header">
      <h3>Select Calendar Profile</h3>
      <button class="profile-add-btn" onclick="toggleProfilePicker(); navigateTo('settings');" title="Customize Settings">+</button>
    </div>
    <div id="profile-picker-list" class="profile-picker-list">
      <!-- Populated by JavaScript -->
    </div>
  </div>
  
  <!-- Date Jump Popup -->
  <div id="date-jump-overlay" class="date-jump-overlay" onclick="if(event.target === this) toggleDateJump()"></div>
  <div id="date-jump-popup" class="date-jump-popup" style="display: none;">
    <button class="close-btn" onclick="toggleDateJump()">âœ•</button>
    <h3>Jump to Date</h3>
    <div id="jump-ancient-display" style="display: none; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 4px; margin-bottom: 10px; text-align: center;">
      <div style="color: #d4a017; font-size: 1.1em;" id="jump-ancient-date"></div>
      <div style="color: #888; font-size: 0.85em; margin-top: 4px;">Date picker unavailable for BC dates</div>
    </div>
    <input type="datetime-local" id="jump-datetime" step="60">
    <div class="btn-row">
      <button class="btn secondary" onclick="jumpToTodayFromPopup()">Jump to Today</button>
    </div>
    <div class="days-jump">
      <button onclick="addDaysFromPopup(-1)">â—€</button>
      <input type="number" id="jump-days" value="1" min="1">
      <button onclick="addDaysFromPopup(1)">â–¶</button>
      <span>days</span>
    </div>
  </div>
  
  <!-- Hidden month buttons container (for compatibility) -->
  <div id="month-buttons" style="display: none;"></div>

  <div id="calendar-output"></div>

  <!-- Settings Page Overlay -->
  <div id="settings-page-overlay" class="settings-page-overlay" onclick="toggleSettings()"></div>
  
  <!-- Settings Page - slides in from right -->
  <div id="settings-page" class="settings-page">
    <div class="settings-page-header">
      <h2>Profiles</h2>
      <button class="close-btn" onclick="navigateTo('calendar')" aria-label="Close">âœ•</button>
    </div>
    
    <div class="settings-section">
      <h3>Profile</h3>
      <p class="settings-description">Select a preset or customize settings below.</p>
      <div class="profile-row">
        <select id="profile-select" class="profile-select" onchange="onProfileSelectChange(this.value)">
          <option value="timeTested">ğŸŒ• Time-Tested â€” Full Moon, Morning Twilight, Lunar Sabbath</option>
          <option value="ancientTraditional">ğŸŒ’ Ancient Traditional â€” Crescent, Evening, Saturday</option>
          <option value="ministries119">ğŸŒ‘ 119 Ministries â€” Dark Moon, Evening, Saturday</option>
        </select>
        <button id="profile-clone-btn" class="profile-icon-btn" onclick="cloneProfile()" title="Clone as new profile">+</button>
        <button id="profile-edit-btn" class="profile-icon-btn" onclick="editProfileName()" title="Rename profile" disabled>âœï¸</button>
        <button id="profile-delete-btn" class="profile-icon-btn" onclick="deleteCustomProfile()" title="Delete profile" disabled>ğŸ—‘ï¸</button>
      </div>
    </div>
    
    <div class="settings-section">
      <h3>Month Starts At</h3>
      <p class="settings-description">Choose which lunar phase marks the beginning of each month.</p>
      <div class="settings-options">
        <button class="settings-option-btn" data-phase="full" onclick="selectMoonPhase('full')">
          <span class="option-icon">ğŸŒ•</span>
          <span class="option-label">Full Moon</span>
        </button>
        <button class="settings-option-btn" data-phase="dark" onclick="selectMoonPhase('dark')">
          <span class="option-icon">ğŸŒ‘</span>
          <span class="option-label">Dark Moon</span>
        </button>
        <button class="settings-option-btn" data-phase="crescent" onclick="selectMoonPhase('crescent')">
          <span class="option-icon">ğŸŒ’</span>
          <span class="option-label">Crescent</span>
        </button>
      </div>
    </div>
    
    <div id="crescent-threshold-section" class="settings-section" style="display: none;">
      <h3>Crescent Visibility Timing</h3>
      <p class="settings-description">Hours after conjunction when crescent moon is considered visible.</p>
      <div class="settings-options">
        <button class="settings-option-btn" data-threshold="12" onclick="selectCrescentThreshold(12)">
          <span class="option-label">12h Optimistic</span>
          <span class="option-hint">Perfect conditions + optical aids</span>
        </button>
        <button class="settings-option-btn" data-threshold="15.5" onclick="selectCrescentThreshold(15.5)">
          <span class="option-label">15.5h Minimum</span>
          <span class="option-hint">Naked-eye record, ideal conditions</span>
        </button>
        <button class="settings-option-btn" data-threshold="18" onclick="selectCrescentThreshold(18)">
          <span class="option-label">18h Typical</span>
          <span class="option-hint">Standard naked-eye visibility</span>
        </button>
        <button class="settings-option-btn" data-threshold="24" onclick="selectCrescentThreshold(24)">
          <span class="option-label">24h Conservative</span>
          <span class="option-hint">Easily visible to anyone</span>
        </button>
      </div>
    </div>
    
    <div class="settings-section">
      <h3>Day Starts At</h3>
      <p class="settings-description">Choose when each day begins.</p>
      <div class="settings-options" style="margin-bottom: 15px;">
        <button class="settings-option-btn" data-daystart="evening" onclick="selectDayStartTime('evening')">
          <span class="option-icon">ğŸŒ…</span>
          <span class="option-label">Evening</span>
        </button>
        <button class="settings-option-btn" data-daystart="morning" onclick="selectDayStartTime('morning')">
          <span class="option-icon">ğŸŒ„</span>
          <span class="option-label">Morning</span>
        </button>
      </div>
      <p class="settings-description">Sun position below horizon:</p>
      <div class="settings-options">
        <button class="settings-option-btn" data-angle="0" onclick="selectDayStartAngle(0)">
          <span class="option-label">0Â° Horizon</span>
          <span class="option-hint">Sun at horizon</span>
        </button>
        <button class="settings-option-btn" data-angle="6" onclick="selectDayStartAngle(6)">
          <span class="option-label">6Â° Civil</span>
          <span class="option-hint">Bright stars visible</span>
        </button>
        <button class="settings-option-btn" data-angle="12" onclick="selectDayStartAngle(12)">
          <span class="option-label">12Â° Nautical</span>
          <span class="option-hint">Most stars visible</span>
        </button>
        <button class="settings-option-btn" data-angle="18" onclick="selectDayStartAngle(18)">
          <span class="option-label">18Â° Astronomical</span>
          <span class="option-hint">Fully dark</span>
        </button>
      </div>
    </div>
    
    <div class="settings-section">
      <h3>Year Starts At</h3>
      <p class="settings-description">Choose the rule for determining the first month of the year.</p>
      <div class="settings-options">
        <button class="settings-option-btn" data-yearstart="equinox" onclick="selectYearStartRule('equinox')">
          <span class="option-icon" id="yearstart-equinox-icon">ğŸŒ•</span>
          <span class="option-label">Renewed Moon after Equinox</span>
          <span class="option-hint" id="yearstart-equinox-hint">Month 1 starts after spring equinox</span>
        </button>
        <button class="settings-option-btn" data-yearstart="13daysBefore" onclick="selectYearStartRule('13daysBefore')">
          <span class="option-icon">ğŸ‘</span>
          <span class="option-label">Passover after Equinox</span>
          <span class="option-hint" id="yearstart-passover-hint">Day 15 (Unleavened) on or after equinox</span>
        </button>
        <button class="settings-option-btn" data-yearstart="virgoFeet" onclick="selectYearStartRule('virgoFeet')">
          <span class="option-icon">â™</span>
          <span class="option-label">Moon Under Virgo's Feet</span>
          <span class="option-hint" id="yearstart-virgo-hint">Full moon below Spica (Rev 12:1)</span>
        </button>
      </div>
      <div class="settings-info-box" id="equinox-rule-explanation" style="display: none;">
        <!-- Content populated dynamically by updateYearStartButtons() using getEquinoxMethodologyHtml() -->
      </div>
      <div class="settings-info-box" id="lamb-rule-explanation" style="display: none;">
        <!-- Content populated dynamically by updateYearStartButtons() using getPassoverMethodologyHtml() -->
      </div>
      <div class="settings-info-box" id="virgo-rule-explanation" style="display: none;">
        <!-- Content populated dynamically by updateYearStartButtons() using getVirgoMethodologyHtml() -->
      </div>
    </div>
    
    <div class="settings-section">
      <h3>Sabbath Day</h3>
      <p class="settings-description">Choose how the Sabbath day is determined and highlighted.</p>
      <div class="settings-options">
        <button class="settings-option-btn" data-sabbath="lunar" onclick="selectSabbathMode('lunar')">
          <span class="option-icon">ğŸŒ•</span>
          <span class="option-label">Lunar Sabbath</span>
          <span class="option-hint">Days 8, 15, 22, 29 of each month</span>
        </button>
        <button class="settings-option-btn" data-sabbath="saturday" onclick="selectSabbathMode('saturday')">
          <span class="option-icon">ğŸª</span>
          <span class="option-label">Saturday</span>
          <span class="option-hint">Fixed weekly Sabbath</span>
        </button>
        <button class="settings-option-btn" data-sabbath="sunday" onclick="selectSabbathMode('sunday')">
          <span class="option-icon">â˜€ï¸</span>
          <span class="option-label">Sunday</span>
          <span class="option-hint">Christian day of rest</span>
        </button>
      </div>
      <div class="settings-row" style="margin-top: 15px;">
        <label class="settings-row-label">Other fixed day:</label>
        <select id="sabbath-day-select" class="settings-select" onchange="selectSabbathDayFromDropdown(this.value)">
          <option value="">â€” Choose â€”</option>
          <option value="none">None</option>
          <option value="monday">Monday</option>
          <option value="tuesday">Tuesday</option>
          <option value="wednesday">Wednesday</option>
          <option value="thursday">Thursday</option>
          <option value="friday">Friday</option>
        </select>
      </div>
    </div>
    
    <div class="settings-section">
      <h3>Default Location</h3>
      <p class="settings-description">The default location determines the timing of sunrise, sunset, and twilight for this profile.</p>
      <div id="settings-page-map"></div>
      <div class="settings-location-buttons">
        <button type="button" class="exact-location-btn settings-location-btn" onclick="getExactLocation()">ğŸ“ Use My Location</button>
        <span class="settings-location-hint">Saves as your default location</span>
      </div>
      <select id="settings-city-select" class="settings-select">
        <option value="current">ğŸ“ Auto-detect via IP (approximate)</option>
        <optgroup label="Biblical">
          <option value="31.7683,35.2137">Jerusalem</option>
        </optgroup>
        <optgroup label="United States">
          <option value="40.7128,-74.0060">New York (Eastern)</option>
          <option value="41.8781,-87.6298">Chicago (Central)</option>
          <option value="39.7392,-104.9903">Denver (Mountain)</option>
          <option value="34.0522,-118.2437">Los Angeles (Pacific)</option>
          <option value="61.2181,-149.9003">Anchorage (Alaska)</option>
          <option value="21.3069,-157.8583">Honolulu (Hawaii)</option>
        </optgroup>
        <optgroup label="International">
          <option value="51.5074,-0.1278">London</option>
          <option value="48.8566,2.3522">Paris</option>
          <option value="35.6762,139.6503">Tokyo</option>
          <option value="-33.8688,151.2093">Sydney</option>
        </optgroup>
        <option value="custom">Custom Coordinates...</option>
      </select>
      <div id="settings-custom-coords" class="settings-custom-coords" style="display: none;">
        <input type="number" id="settings-lat-input" step="0.0001" placeholder="Latitude">
        <input type="number" id="settings-lon-input" step="0.0001" placeholder="Longitude">
      </div>
    </div>
    
    <div class="settings-section">
      <h3>Astronomy Engine & Î”T Uncertainty</h3>
      <p class="settings-description">Technical details about astronomical calculations and historical date accuracy.</p>
      
      <div id="astro-engine-info" class="settings-engine-info">
        <div class="engine-info-row">
          <span class="engine-info-label">Library:</span>
          <span id="astro-engine-name" class="engine-info-value">astronomy-engine v2.1.19</span>
        </div>
        <div class="engine-info-row">
          <span class="engine-info-label">Î”T Model:</span>
          <span id="astro-engine-delta" class="engine-info-value">NASA Eclipse with historical calibration</span>
        </div>
      </div>
      
      <div class="settings-info-box" style="display: block; margin-top: 15px;">
        <p><strong>What is Î”T (Delta T)?</strong></p>
        <p>Î”T is the difference between <em>Terrestrial Time</em> (uniform, based on atomic clocks) and <em>Universal Time</em> (based on Earth's rotation). Earth's rotation is gradually slowing due to tidal friction, causing Î”T to grow over centuries.</p>
        
        <p><strong>Why does this matter for ancient calendars?</strong></p>
        <p>When calculating ancient lunar phases, the uncertainty in Î”T means we cannot know the <em>exact</em> moment a conjunction or full moon occurred. If the moon event was close to sunset, this uncertainty could shift whether Day 1 started on that evening or the next.</p>
        
        <p><strong>Î”T Uncertainty Thresholds Used:</strong></p>
        <table style="width: 100%; border-collapse: collapse; margin: 10px 0; font-size: 0.9em;">
          <thead>
            <tr style="border-bottom: 1px solid rgba(255,255,255,0.3);">
              <th style="text-align: left; padding: 5px;">Era</th>
              <th style="text-align: right; padding: 5px;">Uncertainty</th>
              <th style="text-align: left; padding: 5px 5px 5px 15px;">Notes</th>
            </tr>
          </thead>
          <tbody style="color: rgba(255,255,255,0.8);">
            <tr><td style="padding: 4px 5px;">1600â€“2100 AD</td><td style="text-align: right; padding: 4px 5px;">~0 hours</td><td style="padding: 4px 5px 4px 15px;">Modern records, negligible error</td></tr>
            <tr><td style="padding: 4px 5px;">1000â€“1600 AD</td><td style="text-align: right; padding: 4px 5px;">Â±0.25 hours</td><td style="padding: 4px 5px 4px 15px;">Medieval eclipse records</td></tr>
            <tr><td style="padding: 4px 5px;">500â€“1000 AD</td><td style="text-align: right; padding: 4px 5px;">Â±0.5 hours</td><td style="padding: 4px 5px 4px 15px;">Late antiquity</td></tr>
            <tr><td style="padding: 4px 5px;">1â€“500 AD</td><td style="text-align: right; padding: 4px 5px;">Â±1 hour</td><td style="padding: 4px 5px 4px 15px;">Roman era</td></tr>
            <tr><td style="padding: 4px 5px;">500â€“1 BC</td><td style="text-align: right; padding: 4px 5px;">Â±1.5 hours</td><td style="padding: 4px 5px 4px 15px;">Classical antiquity</td></tr>
            <tr><td style="padding: 4px 5px;">1000â€“500 BC</td><td style="text-align: right; padding: 4px 5px;">Â±2 hours</td><td style="padding: 4px 5px 4px 15px;">Iron Age, Babylonian records</td></tr>
            <tr><td style="padding: 4px 5px;">1500â€“1000 BC</td><td style="text-align: right; padding: 4px 5px;">Â±3 hours</td><td style="padding: 4px 5px 4px 15px;">Late Bronze Age (Exodus era)</td></tr>
            <tr><td style="padding: 4px 5px;">2000â€“1500 BC</td><td style="text-align: right; padding: 4px 5px;">Â±4 hours</td><td style="padding: 4px 5px 4px 15px;">Middle Bronze Age</td></tr>
            <tr><td style="padding: 4px 5px;">Before 2000 BC</td><td style="text-align: right; padding: 4px 5px;">Â±5+ hours</td><td style="padding: 4px 5px 4px 15px;">Early Bronze Age and earlier</td></tr>
          </tbody>
        </table>
        
        <p style="font-size: 0.85em; color: rgba(255,255,255,0.6); margin-top: 10px;">
          <strong>Source:</strong> Based on NASA eclipse calibration data and Espenak-Meeus polynomial models. 
          See <a href="https://eclipse.gsfc.nasa.gov/SEcat5/deltat.html" target="_blank" style="color: #7ec8e3;">NASA Î”T page</a>.
        </p>
      </div>
    </div>
  </div>

  <!-- Day Detail Panel - slides up when a day is selected -->
  <div id="day-detail-panel" class="day-detail-panel hidden">
    <div class="day-detail-header">
      <div class="day-detail-date">
        <span class="day-detail-lunar"></span>
        <span class="day-detail-gregorian-row">
          <span class="day-detail-gregorian"></span>
          <button class="day-detail-jump-btn" onclick="toggleDateJump()" title="Jump to another date">â‡¥</button>
        </span>
      </div>
      <div class="day-detail-astro-times"></div>
    </div>
    <div class="day-detail-content">
      <div class="day-detail-feasts"></div>
      <div class="day-detail-info"></div>
      <div class="day-detail-dateline"></div>
      <div class="day-detail-profile-compare"></div>
    </div>
  </div>

  <!-- Feast table hidden from main page - shown in export modal -->
  <div class="feast-list" style="display: none;">
    <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px; margin-bottom: 15px;">
      <h3 style="margin: 0;">Appointed Times for <span id="feast-year">2026</span></h3>
      <button class="btn" onclick="openInCalendar()" title="Download all Sabbaths and Feasts for this year">ğŸ“… Export Year to Calendar App</button>
    </div>
    <div class="feast-table-container">
    <table class="feast-table">
      <thead>
        <tr>
          <th>Feast</th>
          <th>Date</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody id="feast-tbody"></tbody>
    </table>
    </div>
  </div>
</div>

<!-- Profile Name Modal -->
<div id="profile-modal-overlay" class="profile-modal-overlay" onclick="closeProfileModal(event)">
  <div class="profile-modal" onclick="event.stopPropagation()">
    <h3 id="profile-modal-title">Create New Profile</h3>
    <input type="text" id="profile-modal-input" class="profile-modal-input" placeholder="Enter profile name" onkeydown="handleProfileModalKeydown(event)">
    <div id="profile-modal-error" class="profile-modal-error"></div>
    <div class="profile-modal-buttons">
      <button class="profile-modal-btn cancel" onclick="closeProfileModal()">Cancel</button>
      <button id="profile-modal-save-btn" class="profile-modal-btn save" onclick="saveProfileModal()">Create</button>
    </div>
  </div>
</div>

<!-- Sabbath Tester Page -->
<div id="sabbath-tester-page" style="display: none;">
  <div class="sabbath-tester-header">
    <h2>ğŸ”¬ Sabbath Theory Tester</h2>
    <button class="close-btn" onclick="navigateTo('calendar')" aria-label="Close">âœ•</button>
  </div>
  <div class="sabbath-tester-content">
    <div class="sabbath-tester-intro" style="background: rgba(0,0,0,0.2); padding: 16px; border-radius: 10px; margin-bottom: 20px; color: #ccc; line-height: 1.6;">
      <p style="margin: 0 0 10px 0;">This tool tests various <strong style="color: #7ec8e3;">lunar calendar theories</strong> against historical biblical events where specific weekdays are mentioned in Scripture.</p>
      <p style="margin: 0 0 14px 0;">All tests assume a <strong style="color: #7ec8e3;">fixed Saturday Sabbath</strong> and <strong style="color: #7ec8e3;">Jerusalem location</strong>. The goal is to determine which combination of moon phase (Full, Dark, or Crescent) and day-start time (Daybreak or Sunset) produces dates that align with the biblical record.</p>
      <div style="display: flex; flex-wrap: wrap; gap: 16px; padding-top: 10px; border-top: 1px solid rgba(126, 200, 227, 0.2);">
        <div style="display: flex; align-items: center; gap: 6px;">
          <span style="font-size: 1.2em;">âš–ï¸</span>
          <span><strong style="color: #7ec8e3;">Scale</strong> â€” New Moon on or after Spring Equinox</span>
        </div>
        <div style="display: flex; align-items: center; gap: 6px;">
          <span style="font-size: 1.2em;">ğŸ‘</span>
          <span><strong style="color: #7ec8e3;">Lamb</strong> â€” Day 15 (Unleavened) on or after Spring Equinox</span>
        </div>
      </div>
    </div>
    <div id="sabbath-tester-loading" class="sabbath-test-loading">
      Loading tests...
    </div>
    <div id="sabbath-tester-results"></div>
  </div>
</div>

<!-- Export/Feasts Page -->
<div id="export-page" class="export-page" style="display: none;">
  <div class="settings-page-header export-header">
    <h2>Appointed Times for <span id="export-year">2026</span></h2>
    <button class="btn export-download-btn" onclick="openInCalendar()">ğŸ“… Export</button>
  </div>
  <div class="export-settings-context">
    <span id="export-context-text">Loading settings...</span>
  </div>
  <div class="settings-content" style="padding-top: 0;">
    <div class="feast-table-container">
      <table class="feast-table">
        <thead>
          <tr>
            <th>Feast</th>
            <th>Date</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody id="export-feast-tbody"></tbody>
      </table>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/astronomy-engine@2.1.19/astronomy.browser.min.js"></script>
<!-- offline-geocode-city: Currently has browser compatibility bug (GitHub issue #2)
     Keeping reference for when it's fixed. Falls back to CITY_SLUGS. -->
<!-- <script src="https://cdn.jsdelivr.net/npm/offline-geocode-city@1.0.2/dist/index.iife.js"></script> -->
<script src="/lunar-calendar-engine.js"></script>
<script src="/sabbath-tester.js"></script>
<script src="/astronomy-utils.js"></script>
<script src="/calendar-core.js"></script>
<script src="/day-detail.js"></script>
<script src="/settings-profiles.js"></script>
<script src="/navigation-routing.js"></script>
<script>
// ============================================================================
// ASTRONOMY ENGINE ABSTRACTION LAYER
// ============================================================================
// This abstraction allows switching between different astronomy calculation
// libraries (astronomy-engine, Swiss Ephemeris WASM, etc.) without changing
// the rest of the codebase.

// Available engines registry
const AstroEngines = {
  // Cache for Virgo rule calculations, keyed by year
  virgoCache: {}
};

// Currently active engine instance
let activeAstroEngine = null;

// Engine interface definition (for documentation):
// {
//   name: string,                          // Human-readable name
//   version: string,                       // Library version
//   deltaTModel: string,                   // Î”T model used
//   isLoaded: boolean,                     // Whether engine is ready
//   
//   // Core methods:
//   searchMoonPhase(phase, startDate, limitDays) => { date: Date } | null
//   getSeasons(year) => { mar_equinox: { date: Date }, ... }
//   searchRiseSet(body, observer, direction, startDate, limitDays) => { date: Date } | null
//   searchAltitude(body, observer, direction, startDate, limitDays, altitude) => { date: Date } | null
//   getEquator(body, date, observer) => { ra: number, dec: number }
//   getHorizon(date, observer, ra, dec) => { altitude: number, azimuth: number }
//   getDeltaT(date) => number (in seconds)
//   createObserver(lat, lon, elevation) => observer object
// }

// ============================================================================
// ASTRONOMY-ENGINE IMPLEMENTATION
// ============================================================================
AstroEngines.astronomyEngine = {
  name: 'astronomy-engine',
  version: '2.1.19',
  deltaTModel: 'Espenak-Meeus polynomial',
  deltaTNote: 'Good for modern dates; ~9.5h Î”T uncertainty at 1500 BC',
  isLoaded: true, // Loaded synchronously via script tag
  
  searchMoonPhase(phase, startDate, limitDays) {
    return Astronomy.SearchMoonPhase(phase, startDate, limitDays);
  },
  
  getSeasons(year) {
    return Astronomy.Seasons(year);
  },
  
  searchRiseSet(body, observer, direction, startDate, limitDays) {
    const astroBody = body === 'sun' ? Astronomy.Body.Sun : Astronomy.Body.Moon;
    return Astronomy.SearchRiseSet(astroBody, observer, direction, startDate, limitDays);
  },
  
  searchAltitude(body, observer, direction, startDate, limitDays, altitude) {
    const astroBody = body === 'sun' ? Astronomy.Body.Sun : Astronomy.Body.Moon;
    return Astronomy.SearchAltitude(astroBody, observer, direction, startDate, limitDays, altitude);
  },
  
  getEquator(body, date, observer) {
    // Validate date before calling astronomy-engine
    if (!date || isNaN(date.getTime())) {
      return { ra: 0, dec: 0 };
    }
    try {
      const astroBody = body === 'sun' ? Astronomy.Body.Sun : Astronomy.Body.Moon;
      const result = Astronomy.Equator(astroBody, date, observer, true, true);
      
      // Validate result
      if (result && isFinite(result.ra) && isFinite(result.dec)) {
        return result;
      }
      return { ra: 0, dec: 0 };
    } catch (err) {
      return { ra: 0, dec: 0 };
    }
  },
  
  getHorizon(date, observer, ra, dec) {
    // Validate inputs before calling astronomy-engine
    if (!date || isNaN(date.getTime()) || !isFinite(ra) || !isFinite(dec)) {
      return { altitude: 0, azimuth: 0 };
    }
    try {
      const result = Astronomy.Horizon(date, observer, ra, dec, 'normal');
      if (result && isFinite(result.altitude) && isFinite(result.azimuth)) {
        return result;
      }
      return { altitude: 0, azimuth: 0 };
    } catch (err) {
      return { altitude: 0, azimuth: 0 };
    }
  },
  
  getDeltaT(date) {
    // astronomy-engine doesn't expose DeltaT directly, but we can calculate it
    // from the difference between TT and UT
    const astroTime = new Astronomy.AstroTime(date);
    return (astroTime.tt - astroTime.ut) * 86400; // Convert days to seconds
  },
  
  createObserver(lat, lon, elevation = 0) {
    return new Astronomy.Observer(lat, lon, elevation);
  }
};

// ============================================================================
// SWISS EPHEMERIS WASM IMPLEMENTATION (@swisseph/browser - self-hosted)
// ============================================================================
AstroEngines.swissEphemeris = {
  name: 'Swiss Ephemeris',
  version: 'Loading...',
  deltaTModel: 'Moshier Ephemeris',
  deltaTNote: 'Built-in analytical ephemeris; good for dates from 3000 BC to 3000 AD',
  isLoaded: false,
  _swe: null,
  _module: null,
  _loadPromise: null,
  
  async load() {
    if (this.isLoaded) return true;
    if (this._loadPromise) return this._loadPromise;
    
    this._loadPromise = (async () => {
      try {
        // Dynamic import of self-hosted @swisseph/browser
        const module = await import('/lib/swisseph/swisseph-browser.js');
        this._module = module;
        
        // Create SwissEphemeris instance and initialize WASM with explicit path
        this._swe = new module.SwissEphemeris();
        await this._swe.init('/lib/swisseph/swisseph.wasm');
        
        this.version = '1.1.0';
        this.isLoaded = true;
        console.log('Swiss Ephemeris WASM loaded successfully');
        return true;
      } catch (err) {
        console.error('Failed to load Swiss Ephemeris WASM:', err);
        this.isLoaded = false;
        return false;
      }
    })();
    
    return this._loadPromise;
  },
  
  // Julian Day conversion helpers
  _dateToJD(date) {
    const y = date.getUTCFullYear();
    const m = date.getUTCMonth() + 1;
    const d = date.getUTCDate();
    const h = date.getUTCHours() + date.getUTCMinutes() / 60 + date.getUTCSeconds() / 3600;
    
    const a = Math.floor((14 - m) / 12);
    const yy = y + 4800 - a;
    const mm = m + 12 * a - 3;
    
    // Julian calendar for dates before Oct 15, 1582
    // Gregorian calendar for dates on or after Oct 15, 1582
    let jdn;
    if (y < 1582 || (y === 1582 && (m < 10 || (m === 10 && d < 15)))) {
      jdn = d + Math.floor((153 * mm + 2) / 5) + 365 * yy + Math.floor(yy / 4) - 32083;
    } else {
      jdn = d + Math.floor((153 * mm + 2) / 5) + 365 * yy + Math.floor(yy / 4) - Math.floor(yy / 100) + Math.floor(yy / 400) - 32045;
    }
    return jdn + (h - 12) / 24;
  },
  
  _jdToDate(jd) {
    // Helper to create Date with proper year handling (including negative years)
    const createDate = (year, month, day, h, min, sec) => {
      // JavaScript Date.UTC interprets years 0-99 as 1900-1999
      // We need to use setUTCFullYear for ancient dates
      const date = new Date(Date.UTC(2000, month - 1, day, h, min, sec));
      date.setUTCFullYear(year);
      return date;
    };
    
    if (!this._swe) {
      // Manual Julian Day to calendar date conversion
      const z = Math.floor(jd + 0.5);
      const f = jd + 0.5 - z;
      let a = z;
      if (z >= 2299161) {
        const alpha = Math.floor((z - 1867216.25) / 36524.25);
        a = z + 1 + alpha - Math.floor(alpha / 4);
      }
      const b = a + 1524;
      const c = Math.floor((b - 122.1) / 365.25);
      const d = Math.floor(365.25 * c);
      const e = Math.floor((b - d) / 30.6001);
      
      const day = b - d - Math.floor(30.6001 * e);
      const month = e < 14 ? e - 1 : e - 13;
      const year = month > 2 ? c - 4716 : c - 4715;
      
      const hours = f * 24;
      const h = Math.floor(hours);
      const minutes = (hours - h) * 60;
      const min = Math.floor(minutes);
      const sec = Math.floor((minutes - min) * 60);
      
      return createDate(year, month, day, h, min, sec);
    }
    
    // Use library's conversion
    try {
      const cal = this._swe.julianDayToDate(jd);
      // The library might return hours as a decimal or separate hour/minute/second fields
      let h = 0, min = 0, sec = 0;
      if (typeof cal.hours === 'number') {
        h = Math.floor(cal.hours);
        min = Math.floor((cal.hours % 1) * 60);
        sec = Math.floor(((cal.hours % 1) * 60 % 1) * 60);
      } else if (typeof cal.hour === 'number') {
        h = cal.hour;
        min = cal.minute || 0;
        sec = Math.floor(cal.second || 0);
      }
      
      return createDate(cal.year, cal.month, cal.day, h, min, sec);
    } catch (err) {
      console.warn('Swiss Ephemeris julianDayToDate failed, using manual conversion:', err);
      // Fall through to manual calculation
      const z = Math.floor(jd + 0.5);
      const f = jd + 0.5 - z;
      let a = z;
      if (z >= 2299161) {
        const alpha = Math.floor((z - 1867216.25) / 36524.25);
        a = z + 1 + alpha - Math.floor(alpha / 4);
      }
      const b = a + 1524;
      const c = Math.floor((b - 122.1) / 365.25);
      const d = Math.floor(365.25 * c);
      const e = Math.floor((b - d) / 30.6001);
      
      const day = b - d - Math.floor(30.6001 * e);
      const month = e < 14 ? e - 1 : e - 13;
      const year = month > 2 ? c - 4716 : c - 4715;
      
      const hours = f * 24;
      const hh = Math.floor(hours);
      const minutes = (hours - hh) * 60;
      const mm = Math.floor(minutes);
      const ss = Math.floor((minutes - mm) * 60);
      
      return createDate(year, month, day, hh, mm, ss);
    }
  },
  
  // Get Moon-Sun elongation for phase calculations
  _getMoonSunElongation(jd) {
    if (!this._swe || !this._module) return null;
    
    try {
      const Planet = this._module.Planet;
      const sunPos = this._swe.calculatePosition(jd, Planet.Sun);
      const moonPos = this._swe.calculatePosition(jd, Planet.Moon);
      
      if (sunPos.longitude === undefined || moonPos.longitude === undefined) {
        return null;
      }
      
      let elongation = moonPos.longitude - sunPos.longitude;
      while (elongation < 0) elongation += 360;
      while (elongation >= 360) elongation -= 360;
      return elongation;
    } catch (err) {
      return null;
    }
  },
  
  searchMoonPhase(phase, startDate, limitDays) {
    if (!this.isLoaded || !this._swe) {
      return AstroEngines.astronomyEngine.searchMoonPhase(phase, startDate, limitDays);
    }
    
    const startJD = this._dateToJD(startDate);
    const endJD = startJD + limitDays;
    const step = 1;
    
    let prevJD = startJD;
    let prevElong = this._getMoonSunElongation(prevJD);
    if (prevElong === null) {
      return AstroEngines.astronomyEngine.searchMoonPhase(phase, startDate, limitDays);
    }
    
    const targetPhase = phase % 360;
    
    for (let jd = startJD + step; jd <= endJD; jd += step) {
      let elong = this._getMoonSunElongation(jd);
      if (elong === null) continue;
      
      // Check for phase crossing (handling 360â†’0 wrap)
      let crossed = false;
      if (targetPhase === 0) {
        // New moon: elongation wraps from ~359Â° down to ~1Â° (crosses 0Â°)
        // This happens when prevElong is high (>300) and elong is low (<60)
        if (prevElong > 300 && elong < 60) crossed = true;
      } else if (targetPhase === 180) {
        // Full moon: elongation crossing 180 from below
        if (prevElong < 180 && elong >= 180) crossed = true;
      } else {
        // Other phases
        if ((prevElong < targetPhase && elong >= targetPhase) ||
            (prevElong > targetPhase && elong <= targetPhase && Math.abs(prevElong - elong) < 180)) {
          crossed = true;
        }
      }
      
      if (crossed) {
        // Refine with bisection
        let lo = prevJD, hi = jd;
        for (let i = 0; i < 20; i++) { // ~1 second precision
          const mid = (lo + hi) / 2;
          const midElong = this._getMoonSunElongation(mid);
          if (midElong === null) break;
          
          if (targetPhase === 0) {
            // New moon: we want to find where elongation is closest to 0
            // If midElong > 180, we're before the crossing (moon catching up)
            if (midElong > 180) lo = mid; else hi = mid;
          } else if (targetPhase === 180) {
            if (midElong < 180) lo = mid; else hi = mid;
          } else {
            if (midElong < targetPhase) lo = mid; else hi = mid;
          }
        }
        
        const resultJD = (lo + hi) / 2;
        return { date: this._jdToDate(resultJD), jd: resultJD };
      }
      
      prevJD = jd;
      prevElong = elong;
    }
    
    return null;
  },
  
  getSeasons(year) {
    if (!this.isLoaded || !this._swe || !this._module) {
      return AstroEngines.astronomyEngine.getSeasons(year);
    }
    
    try {
      const Planet = this._module.Planet;
      
      // Start search around March 1
      // Use setUTCFullYear for proper handling of negative/ancient years
      const startDate = new Date(Date.UTC(2000, 2, 1));
      startDate.setUTCFullYear(year);
      let jd = this._dateToJD(startDate);
      const endJD = jd + 30;
      
      let prevLon = null;
      for (; jd <= endJD; jd += 0.5) {
        const sunPos = this._swe.calculatePosition(jd, Planet.Sun);
        const lon = sunPos.longitude;
        
        // Spring equinox: Sun crossing 0Â° from ~359Â° to ~1Â°
        if (prevLon !== null && prevLon > 350 && lon < 10) {
          // Refine with bisection
          let lo = jd - 0.5, hi = jd;
          for (let i = 0; i < 20; i++) {
            const mid = (lo + hi) / 2;
            const midPos = this._swe.calculatePosition(mid, Planet.Sun);
            const midLon = midPos.longitude;
            if (midLon > 180) lo = mid; else hi = mid;
          }
          
          return {
            mar_equinox: { date: this._jdToDate((lo + hi) / 2) }
          };
        }
        prevLon = lon;
      }
    } catch (err) {
      console.warn('Error finding equinox with Swiss Ephemeris:', err);
    }
    
    // Fallback
    return AstroEngines.astronomyEngine.getSeasons(year);
  },
  
  searchRiseSet(body, observer, direction, startDate, limitDays) {
    // Swiss Ephemeris rise/set calculation is complex, use fallback for now
    return AstroEngines.astronomyEngine.searchRiseSet(body, observer, direction, startDate, limitDays);
  },
  
  searchAltitude(body, observer, direction, startDate, limitDays, altitude) {
    return AstroEngines.astronomyEngine.searchAltitude(body, observer, direction, startDate, limitDays, altitude);
  },
  
  getEquator(body, date, observer) {
    if (!this.isLoaded || !this._swe || !this._module) {
      return AstroEngines.astronomyEngine.getEquator(body, date, observer);
    }
    
    try {
      const Planet = this._module.Planet;
      const CalculationFlag = this._module.CalculationFlag;
      const planet = body === 'sun' ? Planet.Sun : Planet.Moon;
      const jd = this._dateToJD(date);
      
      // Get equatorial coordinates
      const pos = this._swe.calculatePosition(jd, planet, CalculationFlag.Equatorial);
      
      // Validate result - if invalid, fall back to astronomy-engine
      if (pos && isFinite(pos.rightAscension) && isFinite(pos.declination)) {
        return {
          ra: pos.rightAscension / 15, // Convert degrees to hours
          dec: pos.declination
        };
      }
      
      // Invalid result, fall back
      return AstroEngines.astronomyEngine.getEquator(body, date, observer);
    } catch (err) {
      return AstroEngines.astronomyEngine.getEquator(body, date, observer);
    }
  },
  
  getHorizon(date, observer, ra, dec) {
    // Use astronomy-engine for horizon conversion (simpler)
    return AstroEngines.astronomyEngine.getHorizon(date, observer, ra, dec);
  },
  
  getDeltaT(date) {
    if (!this.isLoaded || !this._swe) {
      return AstroEngines.astronomyEngine.getDeltaT(date);
    }
    
    try {
      const jd = this._dateToJD(date);
      const deltaT = this._swe.deltaT(jd);
      return deltaT * 86400; // Convert days to seconds
    } catch (err) {
      return AstroEngines.astronomyEngine.getDeltaT(date);
    }
  },
  
  createObserver(lat, lon, elevation = 0) {
    // Use astronomy-engine observer format for compatibility
    return new Astronomy.Observer(lat, lon, elevation);
  }
};

// ============================================================================
// HYBRID ENGINE: Swiss Ephemeris calibrated against NASA Eclipse anchors
// ============================================================================
// This approach uses Swiss Ephemeris for precise local calculations, but
// calibrates the Î”T model against NASA eclipse data to reduce drift for 
// ancient dates. NASA eclipses are observable historical events with known
// times, providing ground truth for Î”T corrections.
// ============================================================================
AstroEngines.nasaEclipse = {
  name: 'Hybrid (Swiss Eph + NASA)',
  version: '1.0',
  deltaTModel: 'NASA Eclipse Calibrated',
  deltaTNote: 'Swiss Ephemeris calculations aligned to NASA eclipse anchors',
  isLoaded: false,
  _eclipses: null,  // Array of {jd, y, t} where t='n' (new) or 'f' (full)
  _loadPromise: null,
  _offsetCache: new Map(), // Cache offset calculations by year
  
  async load() {
    if (this.isLoaded) return true;
    if (this._loadPromise) return this._loadPromise;
    
    this._loadPromise = (async () => {
      try {
        const response = await fetch('/data/eclipses.json');
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        this._eclipses = await response.json();
        this.isLoaded = true;
        console.log(`NASA Eclipse data loaded: ${this._eclipses.length} eclipses`);
        return true;
      } catch (err) {
        console.error('Failed to load NASA eclipse data:', err);
        this.isLoaded = false;
        return false;
      }
    })();
    
    return this._loadPromise;
  },
  
  // Julian Day conversion (handles both Julian and Gregorian calendars)
  _dateToJD(date) {
    const y = date.getUTCFullYear();
    const m = date.getUTCMonth() + 1;
    const d = date.getUTCDate();
    const h = date.getUTCHours() + date.getUTCMinutes() / 60 + date.getUTCSeconds() / 3600;
    
    const a = Math.floor((14 - m) / 12);
    const yy = y + 4800 - a;
    const mm = m + 12 * a - 3;
    
    // Julian calendar for dates before Oct 15, 1582
    // Gregorian calendar for dates on or after Oct 15, 1582
    let jdn;
    if (y < 1582 || (y === 1582 && (m < 10 || (m === 10 && d < 15)))) {
      // Julian calendar
      jdn = d + Math.floor((153 * mm + 2) / 5) + 365 * yy + Math.floor(yy / 4) - 32083;
    } else {
      // Gregorian calendar
      jdn = d + Math.floor((153 * mm + 2) / 5) + 365 * yy + Math.floor(yy / 4) - Math.floor(yy / 100) + Math.floor(yy / 400) - 32045;
    }
    return jdn + (h - 12) / 24;
  },
  
  _jdToDate(jd) {
    const createDate = (year, month, day, h, min, sec) => {
      const date = new Date(Date.UTC(2000, month - 1, day, h, min, sec));
      date.setUTCFullYear(year);
      return date;
    };
    
    const z = Math.floor(jd + 0.5);
    const f = jd + 0.5 - z;
    let a = z;
    if (z >= 2299161) {
      const alpha = Math.floor((z - 1867216.25) / 36524.25);
      a = z + 1 + alpha - Math.floor(alpha / 4);
    }
    const b = a + 1524;
    const c = Math.floor((b - 122.1) / 365.25);
    const d = Math.floor(365.25 * c);
    const e = Math.floor((b - d) / 30.6001);
    
    const day = b - d - Math.floor(30.6001 * e);
    const month = e < 14 ? e - 1 : e - 13;
    const year = month > 2 ? c - 4716 : c - 4715;
    
    const hours = f * 24;
    const hh = Math.floor(hours);
    const minutes = (hours - hh) * 60;
    const mm = Math.floor(minutes);
    const ss = Math.floor((minutes - mm) * 60);
    
    return createDate(year, month, day, hh, mm, ss);
  },
  
  // Find eclipse of given type before or after a JD
  _findEclipse(targetJD, type, direction) {
    if (!this._eclipses) return null;
    
    // Binary search for approximate position
    let lo = 0, hi = this._eclipses.length - 1;
    while (lo < hi) {
      const mid = Math.floor((lo + hi) / 2);
      if (this._eclipses[mid].jd < targetJD) lo = mid + 1;
      else hi = mid;
    }
    
    if (direction < 0) {
      // Search backward for eclipse of this type
      for (let i = lo - 1; i >= 0; i--) {
        if (this._eclipses[i].t === type) return this._eclipses[i];
      }
    } else {
      // Search forward for eclipse of this type
      for (let i = lo; i < this._eclipses.length; i++) {
        if (this._eclipses[i].t === type) return this._eclipses[i];
      }
    }
    return null;
  },
  
  // Find the nearest eclipse (any type) to a given JD
  _findNearestEclipse(targetJD) {
    if (!this._eclipses || this._eclipses.length === 0) return null;
    
    let lo = 0, hi = this._eclipses.length - 1;
    while (lo < hi) {
      const mid = Math.floor((lo + hi) / 2);
      if (this._eclipses[mid].jd < targetJD) lo = mid + 1;
      else hi = mid;
    }
    
    // Check both lo and lo-1 to find closest
    const candidates = [];
    if (lo > 0) candidates.push(this._eclipses[lo - 1]);
    if (lo < this._eclipses.length) candidates.push(this._eclipses[lo]);
    
    let nearest = null;
    let minDist = Infinity;
    for (const e of candidates) {
      const dist = Math.abs(e.jd - targetJD);
      if (dist < minDist) {
        minDist = dist;
        nearest = e;
      }
    }
    return nearest;
  },
  
  // Check if a given date has a lunar eclipse (blood moon)
  // Returns true if there's a lunar eclipse within 0.5 days of the given date
  hasLunarEclipse(date) {
    if (!this._eclipses) {
      return false;
    }
    
    const jd = this._dateToJD(date);
    
    // Binary search to find nearby eclipses
    let lo = 0, hi = this._eclipses.length - 1;
    while (lo < hi) {
      const mid = Math.floor((lo + hi) / 2);
      if (this._eclipses[mid].jd < jd) lo = mid + 1;
      else hi = mid;
    }
    
    // Check nearby eclipses (within a day on either side)
    for (let i = Math.max(0, lo - 2); i < Math.min(this._eclipses.length, lo + 3); i++) {
      const e = this._eclipses[i];
      const diff = Math.abs(e.jd - jd);
      if (e.t === 'f' && diff < 1.0) {
        return true;
      }
    }
    return false;
  },
  
  // Get the exact time of a lunar eclipse for a given date
  // Returns a Date object or null if no eclipse found
  getLunarEclipseTime(date) {
    if (!this._eclipses) {
      return null;
    }
    
    const jd = this._dateToJD(date);
    
    // Binary search to find nearby eclipses
    let lo = 0, hi = this._eclipses.length - 1;
    while (lo < hi) {
      const mid = Math.floor((lo + hi) / 2);
      if (this._eclipses[mid].jd < jd) lo = mid + 1;
      else hi = mid;
    }
    
    // Check nearby eclipses (within a day on either side)
    for (let i = Math.max(0, lo - 2); i < Math.min(this._eclipses.length, lo + 3); i++) {
      const e = this._eclipses[i];
      const diff = Math.abs(e.jd - jd);
      if (e.t === 'f' && diff < 1.0) {
        // Convert JD to Date
        return this._jdToDate(e.jd);
      }
    }
    return null;
  },
  
  // Helper to create Date with proper year handling (including negative years)
  _createDate(year, month, day, hour, minute, second) {
    // JavaScript Date.UTC interprets years 0-99 as 1900-1999
    // We need to use setUTCFullYear for all dates to be safe
    const date = new Date(Date.UTC(2000, month - 1, day, hour || 0, minute || 0, second || 0));
    date.setUTCFullYear(year);
    return date;
  },
  
  // Calculate the Î”T offset between Swiss Ephemeris and NASA eclipse
  // This is the key to the hybrid approach
  _calculateOffset(nearYear, eclipseType) {
    const cacheKey = `${nearYear}_${eclipseType}`;
    if (this._offsetCache.has(cacheKey)) {
      return this._offsetCache.get(cacheKey);
    }
    
    if (!AstroEngines.swissEphemeris.isLoaded) {
      return 0;
    }
    
    // Find a NASA eclipse near the target year
    const midYearDate = this._createDate(nearYear, 7, 1, 0, 0, 0);
    const approxJD = this._dateToJD(midYearDate);
    
    const nasaEclipse = this._findEclipse(approxJD, eclipseType, -1) || 
                        this._findEclipse(approxJD, eclipseType, 1);
    
    if (!nasaEclipse) {
      return 0;
    }
    
    // Get what Swiss Ephemeris calculates for this same moon phase
    const searchStart = this._jdToDate(nasaEclipse.jd - 3);
    const phase = eclipseType === 'n' ? 0 : 180;
    
    try {
      const sweResult = AstroEngines.swissEphemeris.searchMoonPhase(phase, searchStart, 10);
      if (!sweResult || !sweResult.date) {
        return 0;
      }
      
      // Use JD directly if available (avoids Date round-trip issues with ancient dates)
      const sweJD = sweResult.jd || this._dateToJD(sweResult.date);
      
      // Sanity check - offset should be reasonable (less than a few days)
      const offset = nasaEclipse.jd - sweJD;
      if (!isFinite(offset) || Math.abs(offset) > 5) {
        return 0;
      }
      
      this._offsetCache.set(cacheKey, offset);
      return offset;
    } catch (err) {
      console.warn(`Error calculating offset for year ${nearYear}:`, err);
      return 0;
    }
  },
  
  // Hybrid moon phase search:
  // 1. Use Swiss Ephemeris for precise phase calculation
  // 2. Apply Î”T correction from nearest NASA eclipse anchor
  searchMoonPhase(phase, startDate, limitDays) {
    try {
      if (!AstroEngines.swissEphemeris.isLoaded) {
        return this._searchMoonPhaseInterpolate(phase, startDate, limitDays);
      }
      
      if (!this.isLoaded || !this._eclipses) {
        return AstroEngines.swissEphemeris.searchMoonPhase(phase, startDate, limitDays);
      }
      
      const sweResult = AstroEngines.swissEphemeris.searchMoonPhase(phase, startDate, limitDays);
      if (!sweResult || !sweResult.date) return null;
      
      if (isNaN(sweResult.date.getTime())) {
        return this._searchMoonPhaseInterpolate(phase, startDate, limitDays);
      }
      
      // For modern dates (1600-2100 CE), Swiss Eph is already accurate
      const year = sweResult.date.getUTCFullYear();
      if (year >= 1600 && year <= 2100) {
        return sweResult;
      }
      
      // For ancient/future dates, apply NASA eclipse calibration
      const eclipseType = (phase === 0 || phase === 360) ? 'n' : 'f';
      const offset = this._calculateOffset(year, eclipseType);
      
      if (!isFinite(offset) || Math.abs(offset) < 0.001) {
        return sweResult;
      }
      
      // Apply the offset correction using JD directly if available
      const sweJD = sweResult.jd || this._dateToJD(sweResult.date);
      const correctedJD = sweJD + offset;
      
      if (!isFinite(correctedJD)) {
        return sweResult;
      }
      
      return { date: this._jdToDate(correctedJD) };
    } catch (err) {
      return this._searchMoonPhaseInterpolate(phase, startDate, limitDays);
    }
  },
  
  // Pure interpolation fallback (original algorithm)
  _searchMoonPhaseInterpolate(phase, startDate, limitDays) {
    if (!this.isLoaded || !this._eclipses) {
      return AstroEngines.astronomyEngine.searchMoonPhase(phase, startDate, limitDays);
    }
    
    const targetJD = this._dateToJD(startDate);
    const endJD = targetJD + limitDays;
    const SYNODIC_MONTH = 29.530588853;
    
    const wantNewMoon = (phase === 0 || phase === 360);
    const eclipseType = wantNewMoon ? 'n' : 'f';
    
    const eclipseBefore = this._findEclipse(targetJD, eclipseType, -1);
    const eclipseAfter = this._findEclipse(targetJD, eclipseType, 1);
    
    if (!eclipseBefore && !eclipseAfter) {
      return AstroEngines.astronomyEngine.searchMoonPhase(phase, startDate, limitDays);
    }
    
    let localSynodicMonth = SYNODIC_MONTH;
    if (eclipseBefore && eclipseAfter) {
      const span = eclipseAfter.jd - eclipseBefore.jd;
      const lunations = Math.round(span / SYNODIC_MONTH);
      if (lunations > 0) {
        localSynodicMonth = span / lunations;
      }
    }
    
    let anchorEclipse, direction;
    if (!eclipseBefore) {
      anchorEclipse = eclipseAfter;
      direction = -1;
    } else if (!eclipseAfter) {
      anchorEclipse = eclipseBefore;
      direction = 1;
    } else {
      const distBefore = targetJD - eclipseBefore.jd;
      const distAfter = eclipseAfter.jd - targetJD;
      if (distBefore <= distAfter) {
        anchorEclipse = eclipseBefore;
        direction = 1;
      } else {
        anchorEclipse = eclipseAfter;
        direction = -1;
      }
    }
    
    let resultJD;
    if (direction > 0) {
      const lunationsFromAnchor = Math.ceil((targetJD - anchorEclipse.jd) / localSynodicMonth);
      resultJD = anchorEclipse.jd + lunationsFromAnchor * localSynodicMonth;
    } else {
      const lunationsFromAnchor = Math.ceil((anchorEclipse.jd - targetJD) / localSynodicMonth);
      resultJD = anchorEclipse.jd - (lunationsFromAnchor - 1) * localSynodicMonth;
    }
    
    while (resultJD < targetJD) resultJD += localSynodicMonth;
    if (resultJD > endJD) return null;
    
    return { date: this._jdToDate(resultJD) };
  },
  
  // Use Swiss Ephemeris or astronomy-engine for other calculations
  getSeasons(year) {
    return AstroEngines.swissEphemeris.isLoaded 
      ? AstroEngines.swissEphemeris.getSeasons(year)
      : AstroEngines.astronomyEngine.getSeasons(year);
  },
  
  searchRiseSet(body, observer, direction, startDate, limitDays) {
    return AstroEngines.astronomyEngine.searchRiseSet(body, observer, direction, startDate, limitDays);
  },
  
  searchAltitude(body, observer, direction, startDate, limitDays, altitude) {
    return AstroEngines.astronomyEngine.searchAltitude(body, observer, direction, startDate, limitDays, altitude);
  },
  
  getEquator(body, date, observer) {
    return AstroEngines.swissEphemeris.isLoaded 
      ? AstroEngines.swissEphemeris.getEquator(body, date, observer)
      : AstroEngines.astronomyEngine.getEquator(body, date, observer);
  },
  
  getHorizon(date, observer, ra, dec) {
    return AstroEngines.astronomyEngine.getHorizon(date, observer, ra, dec);
  },
  
  getDeltaT(date) {
    // We don't have direct Î”T values, but the eclipse times incorporate it
    return AstroEngines.swissEphemeris.isLoaded 
      ? AstroEngines.swissEphemeris.getDeltaT(date)
      : AstroEngines.astronomyEngine.getDeltaT(date);
  },
  
  createObserver(lat, lon, elevation = 0) {
    return new Astronomy.Observer(lat, lon, elevation);
  },
  
  // Estimate Î”T uncertainty in hours based on year
  // Since we use NASA eclipse anchors for calibration, uncertainty is reduced
  // compared to raw Î”T models. These values represent residual uncertainty.
  // Reference: https://eclipse.gsfc.nasa.gov/SEcat5/uncertainty.html
  getDeltaTUncertainty(year) {
    // Modern dates (1600-2100): uncertainty is negligible
    if (year >= 1600 && year <= 2100) {
      return 0;
    }
    
    // For ancient dates, uncertainty grows but our hybrid calibration helps
    // These are practical estimates for when day-boundary could be affected:
    // - 500 BC: ~0.5 hours
    // - 1000 BC: ~1 hour
    // - 2000 BC: ~2 hours
    // - 3000 BC: ~3-4 hours
    const yearsFromPresent = Math.abs(year - 2000);
    
    if (yearsFromPresent <= 500) return 0.25;
    if (yearsFromPresent <= 1000) return 0.5;
    if (yearsFromPresent <= 1500) return 1;
    if (yearsFromPresent <= 2000) return 1.5;
    if (yearsFromPresent <= 2500) return 2;
    if (yearsFromPresent <= 3000) return 2.5;
    if (yearsFromPresent <= 4000) return 3;
    if (yearsFromPresent <= 5000) return 4;
    return 6; // Very ancient dates
  }
};

// ============================================================================
// ENGINE MANAGEMENT FUNCTIONS
// ============================================================================

function getAstroEngine() {
  if (!activeAstroEngine) {
    activeAstroEngine = AstroEngines.astronomyEngine;
  }
  return activeAstroEngine;
}

async function setAstroEngine(engineId) {
  const engine = AstroEngines[engineId];
  if (!engine) {
    console.error(`Unknown astronomy engine: ${engineId}`);
    return false;
  }
  
  // If engine needs async loading, do it
  if (engine.load && !engine.isLoaded) {
    const loaded = await engine.load();
    if (!loaded) {
      console.error(`Failed to load engine: ${engineId}`);
      return false;
    }
  }
  
  activeAstroEngine = engine;
  state.astronomyEngine = engineId;
  saveState();
  
  // Update UI
  updateAstroEngineUI();
  
  return true;
}

function updateAstroEngineUI() {
  const engine = getAstroEngine();
  
  // Update engine info display
  const nameEl = document.getElementById('astro-engine-name');
  const deltaEl = document.getElementById('astro-engine-delta');
  
  if (nameEl) nameEl.textContent = `${engine.name} v${engine.version}`;
  if (deltaEl) deltaEl.textContent = engine.deltaTModel;
  
  // Update button states
  document.querySelectorAll('.astro-engine-btn').forEach(btn => {
    btn.classList.toggle('selected', btn.dataset.engine === state.astronomyEngine);
  });
}

// UI handler for selecting astronomy engine (currently disabled - Swiss Ephemeris requires self-hosting)
// The abstraction layer is in place for future engine support
function selectAstroEngine(engineId) {
  if (engineId !== 'astronomyEngine') {
    console.log('Swiss Ephemeris WASM requires self-hosting. Using astronomy-engine.');
  }
}

// Initialize astronomy engine - Hybrid approach combines Swiss Ephemeris precision with NASA eclipse calibration
async function initializeAstroEngine() {
  // Load Swiss Ephemeris for precise calculations
  let sweLoaded = false;
  try {
    sweLoaded = await AstroEngines.swissEphemeris.load();
  } catch (err) {
    console.warn('Swiss Ephemeris not available:', err.message);
  }
  
  // Load NASA Eclipse data for Î”T calibration
  let nasaLoaded = false;
  try {
    nasaLoaded = await AstroEngines.nasaEclipse.load();
  } catch (err) {
    console.warn('NASA Eclipse data not available:', err.message);
  }
  
  // Choose the best available engine configuration
  if (nasaLoaded && sweLoaded) {
    // Best case: Hybrid mode - Swiss Ephemeris calibrated against NASA eclipses
    activeAstroEngine = AstroEngines.nasaEclipse;
    state.astronomyEngine = 'nasaEclipse';
    console.log('Using Hybrid mode: Swiss Ephemeris + NASA Eclipse calibration');
    console.log('  - Modern dates (1600-2100): Swiss Ephemeris direct');
    console.log('  - Ancient dates: Swiss Ephemeris with NASA Î”T correction');
  } else if (nasaLoaded) {
    // NASA data but no Swiss Eph - use interpolation fallback
    activeAstroEngine = AstroEngines.nasaEclipse;
    state.astronomyEngine = 'nasaEclipse';
    console.log('Using NASA Eclipse interpolation (Swiss Ephemeris not available)');
  } else if (sweLoaded) {
    // Swiss Eph but no NASA data - use Swiss Eph alone
    activeAstroEngine = AstroEngines.swissEphemeris;
    state.astronomyEngine = 'swissEphemeris';
    console.log('Using Swiss Ephemeris (no NASA calibration)');
  } else {
    // Fallback to astronomy-engine
    activeAstroEngine = AstroEngines.astronomyEngine;
    state.astronomyEngine = 'astronomyEngine';
    console.log('Using astronomy-engine for calculations');
  }
  
  updateAstroEngineUI();
}

// Make these available globally
window.AstroEngines = AstroEngines;
window.getAstroEngine = getAstroEngine;
window.setAstroEngine = setAstroEngine;
window.updateAstroEngineUI = updateAstroEngineUI;
window.selectAstroEngine = selectAstroEngine;
window.initializeAstroEngine = initializeAstroEngine;

const MONTH_NAMES = [
  '1st Month', '2nd Month', '3rd Month', '4th Month', '5th Month', '6th Month',
  '7th Month', '8th Month', '9th Month', '10th Month', '11th Month', '12th Month', '13th Month'
];

// Shofar SVG icon for Renewed Moon - larger and more distinct
const SHOFAR_ICON = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 20" width="1.4em" height="1.2em" style="vertical-align:middle"><path fill="#A67C00" stroke="#5C4300" stroke-width="1" d="M21 3c-1 0-2 .5-3 1.2c-1.5 1-3 2.5-4 4.3c-1 1.8-2 3.5-3.5 5c-1.5 1.5-3.5 2.5-6 2.5c-1.5 0-2.5 1-2.5 2s1 2 2.5 2c2 0 4-.5 5.5-1.5c1.5-1 3-2.5 4-4c1-1.5 2-3 3-4.5c1-1.5 2-2.5 3-3c.8-.4 1.5-1 1.5-2S22 3 21 3z"/><circle fill="#5C4300" cx="4" cy="17" r="1.2"/></svg>';

// Order matters: single-day feasts should come AFTER multi-day feasts so they take priority
// Order matters for overlapping feasts: specific single-day feasts listed AFTER multi-day feasts take priority
const FEASTS = [
  // Renewed Moon Day - first day of every month (first light after full moon when waning moon is 12Â°+ above western horizon)
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 1, day: 1, description: 'First light after full moon â€” waning moon 12Â°+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 2, day: 1, description: 'First light after full moon â€” waning moon 12Â°+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 3, day: 1, description: 'First light after full moon â€” waning moon 12Â°+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 4, day: 1, description: 'First light after full moon â€” waning moon 12Â°+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 5, day: 1, description: 'First light after full moon â€” waning moon 12Â°+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 6, day: 1, description: 'First light after full moon â€” waning moon 12Â°+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 7, day: 1, description: 'First light after full moon â€” waning moon 12Â°+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 8, day: 1, description: 'First light after full moon â€” waning moon 12Â°+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 9, day: 1, description: 'First light after full moon â€” waning moon 12Â°+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 10, day: 1, description: 'First light after full moon â€” waning moon 12Â°+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 11, day: 1, description: 'First light after full moon â€” waning moon 12Â°+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 12, day: 1, description: 'First light after full moon â€” waning moon 12Â°+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  { name: 'Renewed Moon', shortName: 'New Moon', icon: SHOFAR_ICON, month: 13, day: 1, description: 'First light after full moon â€” waning moon 12Â°+ above western horizon', chapter: '/chapters/18-appointed-times/#new-moon' },
  // Specific feasts
  { name: 'Last Supper', shortName: 'Last Supper', icon: 'ğŸğŸ·', month: 1, day: 13, description: 'The Last Supper - bread and wine', chapter: '/chapters/18-appointed-times/#passover' },
  { name: 'Passover', shortName: 'Passover', icon: 'ğŸ‘â€ ', month: 1, day: 14, description: 'Lamb slain at twilight', chapter: '/chapters/18-appointed-times/#passover' },
  { name: 'Unleavened Bread', shortName: 'Unleavened', icon: 'ğŸ«“', month: 1, day: 15, endDay: 21, description: 'High Sabbath, no leaven for 7 days', chapter: '/chapters/18-appointed-times/#unleavened-bread' },
  { name: 'First Fruits', shortName: 'First Fruits', icon: 'ğŸŒ¾', month: 1, day: 16, description: 'Wave sheaf offering (also Unleavened 2)', chapter: '/chapters/18-appointed-times/#first-fruits-of-barley' },
  { name: 'Atzeret of Unleavened', shortName: 'Atzeret', icon: 'ğŸ•', month: 1, day: 21, description: 'Solemn assembly - 7th day of Unleavened Bread', chapter: '/chapters/18-appointed-times/#unleavened-bread' },
  { name: 'Shavuot', shortName: 'Shavuot', icon: 'ğŸŒ¾', month: 3, day: 16, description: '7 complete weeks after First Fruits', chapter: '/chapters/18-appointed-times/#shavuot---first-fruits-of-wheat' },
  { name: 'Trumpets', shortName: 'Trumpets', icon: 'ğŸº', month: 7, day: 1, description: 'Day of shouting/blowing', chapter: '/chapters/18-appointed-times/#trumpets---first-fruits-of-oil' },
  { name: 'Atonement', shortName: 'Atonement', icon: 'ğŸ©¸', month: 7, day: 10, description: 'Yom Kippur - day of fasting', chapter: '/chapters/18-appointed-times/#day-of-atonement' },
  { name: 'Tabernacles', shortName: 'Tabernacles', icon: 'â›º', month: 7, day: 15, endDay: 21, description: 'Feast of Booths', chapter: '/chapters/18-appointed-times/#tabernacles' },
  { name: 'Atzeret', shortName: 'Atzeret', icon: 'ğŸ•', month: 7, day: 22, description: 'Shemini Atzeret - Last Great Day', chapter: '/chapters/18-appointed-times/#atzeret---last-great-day' },
  { name: 'Hanukkah', shortName: 'Hanukkah', icon: 'ğŸ•', month: 9, day: 25, endDay: 30, description: 'Festival of Dedication (8 days)', chapter: '/chapters/18-appointed-times/#hanukkah', continuesNextMonth: true },
  { name: 'Hanukkah', shortName: 'Hanukkah', icon: 'ğŸ•', month: 10, day: 1, endDay: 2, description: 'Festival of Dedication (continued)', chapter: '/chapters/18-appointed-times/#hanukkah', startDayNum: 7 },
  { name: 'Atzeret of Hanukkah', shortName: 'Atzeret', icon: 'ğŸ•', month: 10, day: 2, description: 'Atzeret - 8th day of Hanukkah', chapter: '/chapters/18-appointed-times/#hanukkah' },
  { name: 'Purim', shortName: 'Purim', icon: 'ğŸ“œ', month: 12, day: 14, endDay: 15, description: 'Feast of Lots - deliverance from Haman', chapter: '/chapters/18-appointed-times/#purim' }
];

const SCRIPTURES = [
  { text: "It shall be established forever like the moon, even like the trustworthy witness in the sky.", ref: "Psalms 89:37" },
  { text: "He appointed the moon for seasons; the sun knows its going down.", ref: "Psalms 104:19" },
  { text: "And God said, Let there be lights in the firmament... for signs, and for seasons, and for days, and years.", ref: "Genesis 1:14" },
  { text: "Blow the trumpet at the new moon, at the full moon, on our feast day.", ref: "Psalms 81:3" }
];

// Central state object with defaults
const defaultState = {
  year: new Date().getFullYear(),
  lat: 31.7683,
  lon: 35.2137,
  city: '31.7683,35.2137', // Store the city select value directly
  moonPhase: 'full',
  dayStartTime: 'morning',  // 'evening' or 'morning'
  dayStartAngle: 12,        // 0, 6, 12, or 18 degrees below horizon
  yearStartRule: 'equinox', // 'equinox', '13daysBefore', or 'virgoFeet'
  crescentThreshold: 18,    // Hours after conjunction for crescent visibility (12, 15.5, 18, or 24)
  sabbathMode: 'lunar',     // 'lunar', 'saturday', 'sunday', 'friday', 'none'
  selectedProfile: 'timeTested', // Currently selected profile ID
  astronomyEngine: 'astronomyEngine', // 'astronomyEngine' or 'swissEphemeris'
  lunarMonths: [],
  currentMonthIndex: 0,
  highlightedLunarDay: 1,  // Default to day 1
  selectedTimestamp: null,  // UTC timestamp of selected moment
  pendingNavigationDate: null,  // Used when switching profiles to navigate to same Gregorian date
  viewTime: null  // Custom view time (null = use current time)
};

// Migrate old crescentThreshold values (degrees) to new format (hours)
// Old format: 5, 8, 10, 12 degrees
// New format: 12, 15.5, 18, 24 hours
function migrateCrescentThreshold(value) {
  if (value === undefined) return 18; // Default
  // Valid new values
  if (value === 12 || value === 15.5 || value === 18 || value === 24) return value;
  // Old values that need migration - default to 18h
  if (value === 5 || value === 8 || value === 10) return 18;
  // Unknown value, use default
  return 18;
}

// Load saved state from localStorage or use defaults
function loadState() {
  const saved = localStorage.getItem('lunarCalendarState');
  if (saved) {
    try {
      const parsed = JSON.parse(saved);
      return {
        ...defaultState,
        year: parsed.year || defaultState.year,
        lat: parsed.lat || defaultState.lat,
        lon: parsed.lon || defaultState.lon,
        city: parsed.city || '',
        moonPhase: parsed.moonPhase || defaultState.moonPhase,
        dayStartTime: parsed.dayStartTime || defaultState.dayStartTime,
        dayStartAngle: parsed.dayStartAngle !== undefined ? parsed.dayStartAngle : defaultState.dayStartAngle,
        yearStartRule: parsed.yearStartRule || defaultState.yearStartRule,
        crescentThreshold: migrateCrescentThreshold(parsed.crescentThreshold),
        sabbathMode: parsed.sabbathMode || defaultState.sabbathMode,
        selectedProfile: parsed.selectedProfile || defaultState.selectedProfile
        // astronomyEngine is always 'astronomyEngine' for now (Swiss Ephemeris requires self-hosting)
      };
    } catch (e) {
      return { ...defaultState };
    }
  }
  return { ...defaultState };
}

// ============================================================================
// WORLD CLOCK - Profile + Location combinations for comparison
// ============================================================================

// Get default world clock entries (stable - not dependent on current navigation state)
function getDefaultWorldClockEntries() {
  const entries = [];
  const seen = new Set();
  
  // Helper to add unique entries
  const addEntry = (profileId, locationSlug, locationName) => {
    const key = `${profileId}:${locationSlug}`;
    if (seen.has(key)) return;
    seen.add(key);
    entries.push({ profileId, locationSlug, locationName });
  };
  
  // User's saved GPS location (from localStorage) - stable across navigation
  const savedLoc = getSavedUserLocation();
  if (savedLoc) {
    const savedSlug = getClosestCitySlug(savedLoc.lat, savedLoc.lon, Infinity) || 'jerusalem';
    const savedName = savedLoc.city || formatCitySlug(savedSlug);
    // Add Time-Tested at user's location first
    addEntry('timeTested', savedSlug, savedName);
  }
  
  // All presets in Jerusalem
  for (const [profileId, profile] of Object.entries(PRESET_PROFILES)) {
    addEntry(profileId, 'jerusalem', 'Jerusalem');
  }
  
  return entries;
}

// Load world clock entries from localStorage
function loadWorldClockEntries() {
  try {
    const saved = localStorage.getItem('worldClockEntries');
    if (saved) {
      return JSON.parse(saved);
    }
  } catch (e) {
    console.error('Error loading world clock entries:', e);
  }
  return null;  // null means use defaults
}

// Save world clock entries to localStorage
function saveWorldClockEntries(entries) {
  try {
    localStorage.setItem('worldClockEntries', JSON.stringify(entries));
  } catch (e) {
    console.error('Error saving world clock entries:', e);
  }
}

// Get current world clock entries (saved or defaults)
// Once defaults are generated, they're saved to keep the list stable
function getWorldClockEntries() {
  let entries = loadWorldClockEntries();
  if (!entries) {
    entries = getDefaultWorldClockEntries();
    saveWorldClockEntries(entries);  // Save so list stays stable
  }
  return entries;
}

// Add a world clock entry
function addWorldClockEntry(profileId, locationSlug, locationName) {
  const entries = getWorldClockEntries();
  const key = `${profileId}:${locationSlug}`;
  
  // Check for duplicates
  const exists = entries.some(e => `${e.profileId}:${e.locationSlug}` === key);
  if (exists) return false;
  
  entries.push({ profileId, locationSlug, locationName });
  saveWorldClockEntries(entries);
  return true;
}

// Remove a world clock entry
function removeWorldClockEntry(index) {
  const entries = getWorldClockEntries();
  if (index >= 0 && index < entries.length) {
    entries.splice(index, 1);
    saveWorldClockEntries(entries);
    return true;
  }
  return false;
}

// Reset world clock to defaults
function resetWorldClockEntries() {
  localStorage.removeItem('worldClockEntries');
}

// Format city slug for display
// formatCitySlug moved to settings-profiles.js

// ============================================================================
// VIEW TIME - Current time being viewed (for "This Moment" comparisons)
// ============================================================================

let viewTimeInterval = null;

// Get the current view time - returns UTC timestamp
// getViewTime moved to calendar-core.js

// Get current local time at the set location
function getLocalTimeAtCurrentLocation() {
  const now = new Date();
  const tzOffsetHours = Math.round(state.lon / 15);
  const localMs = now.getTime() + (tzOffsetHours * 60 * 60 * 1000);
  return new Date(localMs);
}

// Start live time updates - DISABLED: time only updates on explicit user action
function startLiveTimeUpdates() {
  // No longer auto-update - time is set once and stays until user changes it
  // User must explicitly click "Use Current Time" to update to now
}

// ============================================================================
// ABOUT MODAL
// ============================================================================

function showAboutModal() {
  const overlay = document.getElementById('about-modal-overlay');
  if (overlay) {
    overlay.classList.add('visible');
  } else {
    console.error('About modal overlay not found - modal HTML may be missing');
  }
}

function closeAboutModal(event) {
  // If called from overlay click, only close if clicking the overlay itself
  if (event && event.target !== event.currentTarget) return;
  
  const overlay = document.getElementById('about-modal-overlay');
  
  // Track dismissals: increment count and store today's date
  const dismissCount = parseInt(localStorage.getItem('aboutModalDismissCount') || '0');
  const newCount = dismissCount + 1;
  localStorage.setItem('aboutModalDismissCount', newCount.toString());
  
  // Store today's date (YYYY-MM-DD format)
  const today = new Date().toISOString().split('T')[0];
  localStorage.setItem('aboutModalLastDismissDate', today);
  
  if (overlay) {
    overlay.classList.remove('visible');
  }
  
  // If URL is /about, navigate back to calendar
  if (window.location.pathname === '/about' || window.location.pathname === '/about/') {
    updateURL();
  }
}

function shouldShowAboutModal() {
  // Never show if dismissed 3+ times
  const dismissCount = parseInt(localStorage.getItem('aboutModalDismissCount') || '0');
  if (dismissCount >= 3) {
    return false;
  }
  
  // Check if already shown today
  const lastDismissDate = localStorage.getItem('aboutModalLastDismissDate');
  const today = new Date().toISOString().split('T')[0];
  
  // Show if never dismissed, or if last dismissal was on a different day
  return !lastDismissDate || lastDismissDate !== today;
}

function resetAboutModal() {
  localStorage.removeItem('aboutModalDismissCount');
  localStorage.removeItem('aboutModalLastDismissDate');
}

// ============================================================================
// PWA INSTALL FUNCTIONALITY
// ============================================================================

let deferredInstallPrompt = null;

// Check if running as installed PWA
function isInstalledPWA() {
  return window.matchMedia('(display-mode: standalone)').matches ||
         window.navigator.standalone === true;
}

// Check if iOS
function isIOS() {
  return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
}

// Initialize install button visibility
function initInstallButton() {
  const installBtn = document.getElementById('install-app-btn');
  if (!installBtn) return;
  
  // Don't show if already installed
  if (isInstalledPWA()) {
    installBtn.style.display = 'none';
    return;
  }
  
  // On iOS, always show (since no beforeinstallprompt)
  if (isIOS()) {
    installBtn.style.display = '';
    return;
  }
  
  // On other platforms, wait for beforeinstallprompt event
  // Button stays hidden until event fires
}

// Listen for the beforeinstallprompt event
window.addEventListener('beforeinstallprompt', (e) => {
  // Prevent the mini-infobar from appearing on mobile
  e.preventDefault();
  // Stash the event so it can be triggered later
  deferredInstallPrompt = e;
  // Show the install button
  const installBtn = document.getElementById('install-app-btn');
  if (installBtn) {
    installBtn.style.display = '';
  }
});

// Listen for successful install
window.addEventListener('appinstalled', () => {
  // Hide the install button
  const installBtn = document.getElementById('install-app-btn');
  if (installBtn) {
    installBtn.style.display = 'none';
  }
  deferredInstallPrompt = null;
  console.log('PWA was installed');
});

// Handle install button click
async function handleInstallClick() {
  // Close the menu
  const menu = document.getElementById('nav-menu');
  const overlay = document.getElementById('nav-menu-overlay');
  if (menu.classList.contains('open')) {
    menu.classList.remove('open');
    overlay.classList.remove('open');
  }
  
  // iOS - show instructions modal
  if (isIOS()) {
    showIOSInstallModal();
    return;
  }
  
  // Other platforms - use the deferred prompt
  if (!deferredInstallPrompt) {
    // Fallback: show generic instructions or the prompt wasn't available
    console.log('Install prompt not available');
    return;
  }
  
  // Show the install prompt
  deferredInstallPrompt.prompt();
  
  // Wait for the user's response
  const { outcome } = await deferredInstallPrompt.userChoice;
  console.log(`User response to install prompt: ${outcome}`);
  
  // Clear the deferred prompt - it can only be used once
  deferredInstallPrompt = null;
  
  // Hide the install button if accepted
  if (outcome === 'accepted') {
    const installBtn = document.getElementById('install-app-btn');
    if (installBtn) {
      installBtn.style.display = 'none';
    }
  }
}

// iOS install modal functions
function showIOSInstallModal() {
  const overlay = document.getElementById('ios-install-overlay');
  if (overlay) {
    overlay.classList.add('visible');
  }
}

function closeIOSInstallModal(event) {
  if (event && event.target !== event.currentTarget) return;
  const overlay = document.getElementById('ios-install-overlay');
  if (overlay) {
    overlay.classList.remove('visible');
  }
}

// Update the time display in the header (shows local time at current location)
// updateTimeDisplay moved to calendar-core.js

// Show time picker modal
function showTimePicker() {
  let modal = document.getElementById('time-picker-modal');
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'time-picker-modal';
    modal.className = 'time-picker-modal';
    modal.innerHTML = `
      <div class="time-picker-content">
        <div class="time-picker-header">
          <h3>Set Date Time</h3>
          <button class="close-btn" onclick="hideTimePicker()">Ã—</button>
        </div>
        <div class="time-picker-form">
          <div class="time-picker-row">
            <label>Date:</label>
            <input type="date" id="time-picker-date">
          </div>
          <div class="time-picker-row">
            <label id="time-picker-time-label">Time:</label>
            <input type="time" id="time-picker-time">
          </div>
          <div class="time-picker-buttons">
            <button class="btn secondary" onclick="setTimeToNowInPicker()">Set to Now</button>
            <button class="btn primary" onclick="applyTimePickerAndClose()">Apply</button>
          </div>
        </div>
      </div>
    `;
    document.body.appendChild(modal);
  }
  
  // Pre-fill with currently selected calendar date and view time
  // Get the date from the currently highlighted day in the calendar
  const monthData = state.lunarMonths?.[state.currentMonthIndex];
  const dayData = monthData?.days?.find(d => d.lunarDay === state.highlightedLunarDay);
  
  // Get the UTC timestamp to convert to location's local time
  let utcTimestamp;
  if (dayData?.gregorianDate) {
    // Use selectedTimestamp if available (more precise), otherwise use sunrise of the day
    utcTimestamp = state.selectedTimestamp || getSunriseTimestamp(dayData.gregorianDate);
  } else {
    // Fallback to view time
    utcTimestamp = getViewTime().getTime();
  }
  
  // Convert UTC timestamp to local time at the selected location
  const localTimeAtLocation = utcToLocalTime(utcTimestamp, state.lon);
  
  // Update the time label to show the current location
  const locationName = getCurrentLocationName();
  const timeLabel = document.getElementById('time-picker-time-label');
  if (timeLabel) {
    timeLabel.textContent = `${locationName} Time:`;
  }
  
  // Format date as YYYY-MM-DD (using UTC methods since utcToLocalTime returns a Date where UTC methods give local time)
  const year = localTimeAtLocation.getUTCFullYear();
  const month = String(localTimeAtLocation.getUTCMonth() + 1).padStart(2, '0');
  const day = String(localTimeAtLocation.getUTCDate()).padStart(2, '0');
  document.getElementById('time-picker-date').value = `${year}-${month}-${day}`;
  
  // Format time as HH:MM (from local time at location)
  const hours = String(localTimeAtLocation.getUTCHours()).padStart(2, '0');
  const minutes = String(localTimeAtLocation.getUTCMinutes()).padStart(2, '0');
  document.getElementById('time-picker-time').value = `${hours}:${minutes}`;
  
  modal.style.display = 'flex';
}

// Hide time picker
function hideTimePicker() {
  const modal = document.getElementById('time-picker-modal');
  if (modal) modal.style.display = 'none';
}

// Update the picker inputs to show current date/time (doesn't change state)
function setTimeToNowInPicker() {
  const now = new Date();
  const tzOffsetHours = Math.round(state.lon / 15);
  const localMs = now.getTime() + (tzOffsetHours * 60 * 60 * 1000);
  const localDate = new Date(localMs);
  
  // Format date as YYYY-MM-DD
  const year = localDate.getUTCFullYear();
  const month = String(localDate.getUTCMonth() + 1).padStart(2, '0');
  const day = String(localDate.getUTCDate()).padStart(2, '0');
  document.getElementById('time-picker-date').value = `${year}-${month}-${day}`;
  
  // Format time as HH:MM
  const hours = String(localDate.getUTCHours()).padStart(2, '0');
  const minutes = String(localDate.getUTCMinutes()).padStart(2, '0');
  document.getElementById('time-picker-time').value = `${hours}:${minutes}`;
}

// Apply the picker values to state and close the dialog
function applyTimePickerAndClose() {
  const dateVal = document.getElementById('time-picker-date').value;
  const timeVal = document.getElementById('time-picker-time').value;
  
  if (dateVal && timeVal) {
    // Parse as local time at current location
    const [year, month, day] = dateVal.split('-').map(Number);
    const [hours, minutes] = timeVal.split(':').map(Number);
    const localMs = Date.UTC(year, month - 1, day, hours, minutes, 0);
    
    // Convert from location's local time back to UTC
    const tzOffsetHours = Math.round(state.lon / 15);
    const utcMs = localMs - (tzOffsetHours * 60 * 60 * 1000);
    
    state.viewTime = utcMs;
    state.selectedTimestamp = utcMs;  // Also update selectedTimestamp so day detail refreshes
    
    // Navigate to the selected date
    navigateToTimestamp(utcMs, year, month - 1, day);
    updateTimeDisplay();
    refreshDayDetailIfVisible();  // Refresh day detail to update "This Moment on Other Calendars"
  }
  
  hideTimePicker();
}

// navigateToTimestamp moved to calendar-core.js

// Get current UTC time
function getCurrentUTCTime() {
  return new Date();
}

// Get local time string for a location based on longitude
function getLocalTimeForLocation(lat, lon) {
  const viewTime = getViewTime();
  // Approximate timezone from longitude (1 hour per 15 degrees)
  const tzOffsetHours = Math.round(lon / 15);
  // Convert UTC time to local time at that longitude
  const utcMs = viewTime.getTime();
  const localMs = utcMs + (tzOffsetHours * 60 * 60 * 1000);
  const localDate = new Date(localMs);
  // Format as HH:MM using UTC methods since we already adjusted
  const hours = localDate.getUTCHours();
  const minutes = localDate.getUTCMinutes();
  const ampm = hours >= 12 ? 'PM' : 'AM';
  const h12 = hours % 12 || 12;
  return `${h12}:${minutes.toString().padStart(2, '0')} ${ampm}`;
}

// Navigate to a world clock entry
// navigateToWorldClockEntry moved to navigation-routing.js

// Remove world clock entry and refresh the UI
function removeWorldClockEntryAndRefresh(index) {
  removeWorldClockEntry(index);
  refreshDayDetailIfVisible();
}

// ============================================================================
// UNIFIED LOCATION PICKER - Used for header location and World Clock
// ============================================================================

// Current picker mode and callback
let locationPickerMode = 'header';  // 'header' or 'worldclock'
let locationPickerCallback = null;

// Open location picker for header (changes current location)
function openLocationPickerForHeader() {
  locationPickerMode = 'header';
  locationPickerCallback = null;  // Changes applied during preview
  showUnifiedLocationPicker('Select Location', false);
}

// Open location picker for World Clock (adds new entry)
function openLocationPickerForWorldClock() {
  locationPickerMode = 'worldclock';
  locationPickerCallback = (locationSlug, locationName, coords, profileId) => {
    if (addWorldClockEntry(profileId, locationSlug, locationName)) {
      refreshDayDetailIfVisible();
    } else {
      alert('This calendar is already in your list.');
    }
  };
  showUnifiedLocationPicker('Add Calendar', true);
}

// Show the unified location picker
function showUnifiedLocationPicker(title, showProfileSelect) {
  const picker = document.getElementById('city-picker');
  const overlay = document.getElementById('city-picker-overlay');
  const header = picker.querySelector('.city-picker-header h3');
  
  // Reset preview state
  previewedLocationSlug = null;
  previewedLocationCoords = null;
  
  // Update title
  if (header) header.textContent = title;
  
  // Show/hide profile selector
  let profileRow = document.getElementById('city-picker-profile-row');
  if (showProfileSelect) {
    if (!profileRow) {
      // Create profile selector row
      profileRow = document.createElement('div');
      profileRow.id = 'city-picker-profile-row';
      profileRow.className = 'city-picker-profile-row';
      profileRow.innerHTML = `
        <label>Profile:</label>
        <select id="city-picker-profile-select" class="city-picker-select"></select>
      `;
      const controls = picker.querySelector('.city-picker-controls');
      controls.parentNode.insertBefore(profileRow, controls);
    }
    profileRow.style.display = 'flex';
    populatePickerProfileSelect();
  } else if (profileRow) {
    profileRow.style.display = 'none';
  }
  
  // Show/hide confirm button for World Clock mode
  let confirmRow = document.getElementById('city-picker-confirm-row');
  if (showProfileSelect) {
    if (!confirmRow) {
      confirmRow = document.createElement('div');
      confirmRow.id = 'city-picker-confirm-row';
      confirmRow.className = 'city-picker-confirm-row';
      confirmRow.innerHTML = `
        <button class="btn secondary" onclick="toggleCityPicker()">Cancel</button>
        <button class="btn primary" onclick="confirmWorldClockAdd()">Add Calendar</button>
      `;
      picker.appendChild(confirmRow);
    }
    confirmRow.style.display = 'flex';
  } else if (confirmRow) {
    confirmRow.style.display = 'none';
  }
  
  picker.style.display = 'block';
  overlay.classList.add('visible');
  document.body.style.overflow = 'hidden';
  renderCityPickerMap();
  populateCityDropdown();
  updateCityPickerLocationName();
}

// Confirm adding a World Clock entry
function confirmWorldClockAdd() {
  // Use the previewed location, or current selection from dropdown
  let slug = previewedLocationSlug;
  let coords = previewedLocationCoords;
  
  if (!slug) {
    // Fallback to dropdown selection
    const select = document.getElementById('city-picker-select');
    slug = select ? select.value : null;
    coords = slug ? CITY_SLUGS[slug] : null;
  }
  
  if (!slug || !coords) {
    alert('Please select a location first.');
    return;
  }
  
  const locationName = formatCitySlug(slug);
  confirmLocationSelection(slug, locationName, coords);
}

// Populate profile select in the picker
function populatePickerProfileSelect() {
  const select = document.getElementById('city-picker-profile-select');
  if (!select) return;
  
  select.innerHTML = '';
  for (const [id, profile] of Object.entries(PROFILES)) {
    const opt = document.createElement('option');
    opt.value = id;
    opt.textContent = `${renderProfileIconText(profile)} ${profile.name}`;
    if (id === (state.selectedProfile || 'timeTested')) {
      opt.selected = true;
    }
    select.appendChild(opt);
  }
}

// Get currently selected profile in picker (for World Clock mode)
function getPickerSelectedProfile() {
  const select = document.getElementById('city-picker-profile-select');
  return select ? select.value : (state.selectedProfile || 'timeTested');
}

// Called when a location is confirmed in the picker
function confirmLocationSelection(locationSlug, locationName, coords) {
  if (locationPickerCallback) {
    const profileId = locationPickerMode === 'worldclock' ? getPickerSelectedProfile() : null;
    locationPickerCallback(locationSlug, locationName, coords, profileId);
  }
  toggleCityPicker();
}

// Show modal to add new world clock entry (now uses unified picker)
function showAddWorldClockModal() {
  openLocationPickerForWorldClock();
}

// Legacy function for compatibility
function hideAddWorldClockModal() {
  toggleCityPicker();
}

// Legacy function kept for old modal (no longer used but kept for safety)
function addWorldClockFromModal() {
  // Now handled by confirmLocationSelection
}

// Save settings to localStorage
function saveState() {
  const toSave = {
    year: state.year,
    lat: state.lat,
    lon: state.lon,
    city: state.city,
    moonPhase: state.moonPhase,
    dayStartTime: state.dayStartTime,
    dayStartAngle: state.dayStartAngle,
    yearStartRule: state.yearStartRule,
    crescentThreshold: state.crescentThreshold,
    sabbathMode: state.sabbathMode,
    selectedProfile: state.selectedProfile
    // astronomyEngine not saved - always uses astronomy-engine for now
  };
  localStorage.setItem('lunarCalendarState', JSON.stringify(toSave));
}

// updateURL moved to navigation-routing.js
// loadFromURL moved to navigation-routing.js

const state = loadState();

// Track which profile is being edited in the settings page (separate from active calendar profile)
let editingProfileId = null;

// Update UI to reflect current state
function updateUI() {
  document.getElementById('year-input').value = state.year;
  // Show BC label only when needed (no AD suffix)
  const yearVal = state.year;
  if (yearVal <= 0) {
    document.getElementById('year-display').textContent = `(${Math.abs(yearVal - 1)} BC)`;
  } else {
    document.getElementById('year-display').textContent = '';  // No AD suffix for positive years
  }
  document.getElementById('feast-year').textContent = formatYear(state.year);
  document.getElementById('lat-input').value = state.lat;
  document.getElementById('lon-input').value = state.lon;
  document.getElementById('moon-phase-select').value = state.moonPhase;
  document.getElementById('city-select').value = state.city || '';
  
  // Update all button states
  updateMoonPhaseButtons();
  updateDayStartButtons();
  updateYearStartButtons();
  updateCrescentThresholdVisibility();
  updateCrescentThresholdButtons();
  updateProfileButtons();
  
  // Show/hide custom coordinates
  const customCoords = document.getElementById('custom-coords');
  if (customCoords) {
    customCoords.style.display = state.city === '' ? 'block' : 'none';
  }
}

// Navigation Menu Functions
function toggleNavMenu() {
  const overlay = document.getElementById('nav-menu-overlay');
  const menu = document.getElementById('nav-menu');
  
  if (menu.classList.contains('open')) {
    menu.classList.remove('open');
    overlay.classList.remove('open');
  } else {
    menu.classList.add('open');
    overlay.classList.add('open');
  }
}

// navigateTo moved to navigation-routing.js

// toggleSettings moved to settings-profiles.js
// openLocationPicker moved to settings-profiles.js
// toggleProfilePicker moved to settings-profiles.js
// populateProfilePicker moved to settings-profiles.js
// generateProfileHint moved to settings-profiles.js
// getCurrentProfileId moved to settings-profiles.js
// selectProfile moved to settings-profiles.js

// toggleCityPicker moved to settings-profiles.js
// renderCityPickerMap moved to settings-profiles.js
// handleCityPickerMapClick moved to settings-profiles.js
// previewLocationSelection moved to settings-profiles.js (variables previewedLocationSlug, previewedLocationCoords remain in index.html)
// updateCityDropdownSelection moved to settings-profiles.js
// DROPDOWN_CITIES constant moved to settings-profiles.js
// isInDropdownList moved to settings-profiles.js
// populateCityDropdown moved to settings-profiles.js
// selectCityFromDropdown moved to settings-profiles.js

// Track the currently previewed location for World Clock mode
let previewedLocationSlug = null;
let previewedLocationCoords = null;

function useMyLocationFromPicker() {
  if (!navigator.geolocation) {
    alert('Geolocation is not supported by your browser');
    return;
  }
  
  // Show loading state
  const btn = document.querySelector('#city-picker .city-action-btn');
  const originalText = btn.textContent;
  btn.textContent = 'ğŸ“ Locating...';
  btn.disabled = true;
  
  navigator.geolocation.getCurrentPosition(
    (position) => {
      const gpsLat = position.coords.latitude;
      const gpsLon = position.coords.longitude;
      
      // Find nearest city to snap to
      const nearestSlug = getClosestCitySlug(gpsLat, gpsLon, Infinity);
      const coords = nearestSlug ? CITY_SLUGS[nearestSlug] : { lat: 31.7683, lon: 35.2137 };
      const locationName = nearestSlug ? formatCitySlug(nearestSlug) : 'Jerusalem';
      const slug = nearestSlug || 'jerusalem';
      
      // Save as user's default location
      saveUserLocation(coords.lat, coords.lon, locationName);
      
      // Reset button
      btn.textContent = originalText;
      btn.disabled = false;
      
      // Always preview - don't close dialog
      previewLocationSelection(slug, coords);
    },
    (error) => {
      btn.textContent = originalText;
      btn.disabled = false;
      console.warn('Geolocation failed:', error);
      alert('Could not get your location. Please select a city from the dropdown or click on the map.');
    },
    { enableHighAccuracy: true, timeout: 10000 }
  );
}

// updateCityPickerLocationName moved to settings-profiles.js

function toggleExportModal(skipUrlUpdate = false) {
  const calendarOutput = document.getElementById('calendar-output');
  const dayDetailPanel = document.getElementById('day-detail-panel');
  const exportPage = document.getElementById('export-page');
  const settingsPage = document.getElementById('settings-page');
  const settingsOverlay = document.getElementById('settings-page-overlay');
  
  const isOpening = exportPage.style.display === 'none';
  
  if (isOpening) {
    // Hide calendar and settings, show export
    calendarOutput.style.display = 'none';
    dayDetailPanel.style.display = 'none';
    
    // Close settings slide-in if open
    settingsPage.classList.remove('visible');
    settingsOverlay.classList.remove('visible');
    document.body.style.overflow = ''; // Restore scrolling temporarily
    
    exportPage.style.display = 'block';
    
    // Scroll to top of page (with timeout to ensure DOM update)
    window.scrollTo(0, 0);
    document.documentElement.scrollTop = 0;
    document.body.scrollTop = 0;
    setTimeout(() => {
      window.scrollTo(0, 0);
      exportPage.scrollTop = 0;
    }, 0);
    
    // Update export table with current feast data
    updateExportTable();
    
    // Update URL with view=feasts
    if (!skipUrlUpdate) {
      updateURLWithView('feasts');
    }
  } else {
    // Show calendar, hide export
    calendarOutput.style.display = 'block';
    exportPage.style.display = 'none';
    
    // Reset day detail panel display and refresh if a day was selected
    dayDetailPanel.style.display = '';  // Reset inline style
    if (state.highlightedLunarDay !== null) {
      dayDetailPanel.classList.remove('hidden');
      refreshDayDetailIfVisible();
    }
    
    // Remove view parameter from URL
    if (!skipUrlUpdate) {
      updateURL();
    }
  }
}

// updateURLWithView moved to navigation-routing.js

function updateExportTable() {
  // Update the year display
  document.getElementById('export-year').textContent = formatYear(state.year);
  
  // Update settings context
  const contextEl = document.getElementById('export-context-text');
  if (contextEl) {
    const moonLabel = getMoonLabel();
    const dayStartLabel = getDayStartLabel();
    const yearStartLabel = getYearStartLabel();
    
    // Get location name with coordinates
    const locationName = getCurrentLocationName();
    const coordStr = `${state.lat.toFixed(2)}Â°${state.lat >= 0 ? 'N' : 'S'}, ${Math.abs(state.lon).toFixed(2)}Â°${state.lon >= 0 ? 'E' : 'W'}`;
    // Show city name with coordinates, or just coordinates if it's a timezone region
    const locationLabel = !locationName.includes('/') 
      ? `${locationName} (${coordStr})`
      : coordStr;
    
    contextEl.innerHTML = `
      <span class="export-context-item">
        <span class="export-context-label">Month Start:</span>
        <span class="export-context-value">${moonLabel}</span>
      </span>
      <span class="export-context-item">
        <span class="export-context-label">Day Start:</span>
        <span class="export-context-value">${dayStartLabel}</span>
      </span>
      <span class="export-context-item">
        <span class="export-context-label">Year Start:</span>
        <span class="export-context-value">${yearStartLabel}</span>
      </span>
      <span class="export-context-item">
        <span class="export-context-label">Location:</span>
        <span class="export-context-value">${locationLabel}</span>
      </span>
    `;
  }
  
  // Copy the feast table content to the export modal
  const sourceTbody = document.getElementById('feast-tbody');
  const targetTbody = document.getElementById('export-feast-tbody');
  
  if (sourceTbody && targetTbody) {
    targetTbody.innerHTML = sourceTbody.innerHTML;
  }
}

// updateSettingsPageState moved to settings-profiles.js
// renderSettingsPageMap moved to settings-profiles.js
// updateMoonPhaseButtons moved to settings-profiles.js
// selectMoonPhase moved to settings-profiles.js

// ============================================================================
// ARCHITECTURE OVERVIEW
// ============================================================================
//
// PROFILES vs STATE:
//   - Profile = Calendar interpretation rules (how to calculate the calendar)
//   - State = Viewing context (what you're looking at: when, where)
//
// PROFILE FORMAT (compatible with LunarCalendarEngine.configure()):
//   {
//     // Engine configuration (required)
//     moonPhase: 'full' | 'dark' | 'crescent',
//     dayStartTime: 'morning' | 'evening',
//     dayStartAngle: 0 | 6 | 12 | 18,  // degrees below horizon
//     yearStartRule: 'equinox' | '13daysBefore' | 'virgoFeet',
//     sabbathMode: 'lunar' | 'saturday',  // not used by engine, UI only
//
//     // Crescent-specific (only used when moonPhase === 'crescent')
//     crescentThreshold: 18,  // hours after conjunction for visibility
//
//     // UI metadata
//     name: string,
//     icon: string,
//     hint: string,
//
//     // Location behavior
//     useLocalLocation: true,  // For presets: use saved/IP location
//     // OR for custom profiles with fixed location:
//     lat: number,
//     lon: number,
//     city: string
//   }
//
// STATE FORMAT (viewing context + active config):
//   {
//     selectedProfile: string,  // Profile ID
//     year: number,
//     currentMonthIndex: number,
//     highlightedLunarDay: number | null,
//     selectedTimestamp: number | null,
//     lat: number,
//     lon: number,
//     locationSource: 'saved' | 'ip' | 'gps' | 'url' | 'fixed',
//     lunarMonths: [...],  // Generated calendar data
//
//     // Active engine config (copied from profile or custom)
//     moonPhase, dayStartTime, dayStartAngle, yearStartRule, sabbathMode,
//     crescentThreshold,  // Only relevant when moonPhase === 'crescent'
//   }
//
// URL FORMAT:
//   Preset profiles: /profile/year/[month/[day/]]location/
//   Custom profiles: /custom/moon/[threshold?]/dayStart/sabbath/yearStart/year/[month/[day/]]location/
//
//   - Profile segment uses URL slugs (time-tested, ancient-traditional, 119-ministries)
//   - Custom profile encodes settings in path:
//     - moon: full, dark, crescent
//     - threshold (crescent only): opt (12h), min (15.5h), con (24h), or omitted (18h default)
//     - dayStart: morning, evening
//     - sabbath: lunar, saturday, sunday, friday, none
//     - yearStart: equinox, passover
//   - Location is city slug or lat,lon coordinates
//   - ?angle=N query param for dayStartAngle (0, 6, 12, 18)
//
// URL EXAMPLES:
//   /time-tested/2025/jerusalem/
//   /custom/full/morning/lunar/equinox/2025/jerusalem/
//   /custom/crescent/opt/evening/saturday/passover/2025/jerusalem/
//   /custom/crescent/evening/lunar/equinox/2025/jerusalem/ (default 18h threshold)
//
// URL CANONICALIZATION:
//   - If custom URL params match a built-in profile â†’ redirect to canonical URL
//   - This prevents duplicate content for SEO
//
// ============================================================================

// Preset profiles (built-in, cannot be deleted)
// timeTested is first as it's the default
const PRESET_PROFILES = {
  timeTested: {
    name: 'Time-Tested',
    hint: 'Full Moon, Morning Twilight, Lunar Sabbath',
    icon: 'ğŸŒ•',
    moonPhase: 'full',
    dayStartTime: 'morning',
    dayStartAngle: 12,
    yearStartRule: 'equinox',
    crescentThreshold: 18,
    sabbathMode: 'lunar',
    useLocalLocation: true  // Uses saved location or IP detection
  },
  ancientTraditional: {
    name: 'Ancient Traditional',
    hint: 'Crescent Moon, Evening, Saturday Sabbath, Passover Rule',
    icon: 'ğŸŒ’',
    moonPhase: 'crescent',
    dayStartTime: 'evening',
    dayStartAngle: 0,
    yearStartRule: '13daysBefore',
    crescentThreshold: 18,
    sabbathMode: 'saturday',
    useLocalLocation: true
  },
  ministries119: {
    name: '119 Ministries',
    hint: 'Dark Moon, Evening, Saturday Sabbath',
    icon: 'ğŸŒ‘',
    moonPhase: 'dark',
    dayStartTime: 'evening',
    dayStartAngle: 0,
    yearStartRule: 'equinox',
    crescentThreshold: 18,
    sabbathMode: 'saturday',
    useLocalLocation: true
  },
  creatorsCalendar: {
    name: "Creator's Calendar",
    hint: 'Full Moon, Evening, Virgo Rule, Lunar Sabbath',
    icon: 'ğŸŒ•',
    moonPhase: 'full',
    dayStartTime: 'evening',
    dayStartAngle: 0,
    yearStartRule: 'virgoFeet',
    crescentThreshold: 18,
    sabbathMode: 'lunar',
    useLocalLocation: true
  },
  traditionalLunar: {
    name: 'Traditional Lunar',
    hint: 'Crescent Moon, Evening, Lunar Sabbath',
    icon: 'ğŸŒ’',
    moonPhase: 'crescent',
    dayStartTime: 'evening',
    dayStartAngle: 0,
    yearStartRule: 'equinox',
    crescentThreshold: 18,
    sabbathMode: 'lunar',
    useLocalLocation: true
  }
};

// Combined profiles (presets + user-saved)
let PROFILES = { ...PRESET_PROFILES };

// Load custom profiles from localStorage
function loadCustomProfiles() {
  try {
    const saved = localStorage.getItem('customProfiles');
    if (saved) {
      const customProfiles = JSON.parse(saved);
      PROFILES = { ...PRESET_PROFILES, ...customProfiles };
    }
  } catch (e) {
    console.error('Error loading custom profiles:', e);
  }
}

// Save custom profiles to localStorage
function saveCustomProfiles() {
  const customProfiles = {};
  for (const [id, profile] of Object.entries(PROFILES)) {
    if (!PRESET_PROFILES[id]) {
      customProfiles[id] = profile;
    }
  }
  localStorage.setItem('customProfiles', JSON.stringify(customProfiles));
}

// Rebuild profile dropdown with all profiles
function rebuildProfileDropdown() {
  const select = document.getElementById('profile-select');
  if (!select) return;
  
  select.innerHTML = '';
  
  // Add preset profiles
  for (const [id, profile] of Object.entries(PRESET_PROFILES)) {
    const option = document.createElement('option');
    option.value = id;
    option.textContent = `${renderProfileIconText(profile)} ${profile.name} â€” ${profile.hint}`;
    select.appendChild(option);
  }
  
  // Add custom profiles (user-saved)
  const customIds = Object.keys(PROFILES).filter(id => !PRESET_PROFILES[id]);
  if (customIds.length > 0) {
    for (const id of customIds) {
      const profile = PROFILES[id];
      const option = document.createElement('option');
      option.value = id;
      option.textContent = `${renderProfileIconText(profile)} ${profile.name}`;
      select.appendChild(option);
    }
  }
  
  // Restore selection from state if valid, otherwise default to timeTested
  const profileToSelect = state.selectedProfile || 'timeTested';
  if ([...select.options].some(o => o.value === profileToSelect)) {
    select.value = profileToSelect;
  } else {
    select.value = 'timeTested';
    state.selectedProfile = 'timeTested';
  }
}

// getProfileIcon moved to settings-profiles.js
// renderProfileIcon moved to settings-profiles.js
// renderProfileIconText moved to settings-profiles.js

// Extract engine-compatible config from a profile
// This is what gets passed to LunarCalendarEngine.configure()
function getEngineConfig(profile) {
  return {
    moonPhase: profile.moonPhase,
    dayStartTime: profile.dayStartTime,
    dayStartAngle: profile.dayStartAngle,
    yearStartRule: profile.yearStartRule,
    crescentThreshold: profile.crescentThreshold || 18
  };
}

// Check if current state matches a named profile's engine settings
function matchesProfile(profileId) {
  const profile = PROFILES[profileId];
  if (!profile) return false;
  
  const baseMatch = state.moonPhase === profile.moonPhase &&
         state.dayStartTime === profile.dayStartTime &&
         state.dayStartAngle === profile.dayStartAngle &&
         state.yearStartRule === profile.yearStartRule &&
         state.sabbathMode === (profile.sabbathMode || 'lunar');
  
  // For crescent profiles, also check crescentThreshold
  if (profile.moonPhase === 'crescent') {
    return baseMatch && state.crescentThreshold === (profile.crescentThreshold || 18);
  }
  
  return baseMatch;
}

// getCurrentProfileName moved to settings-profiles.js

// Known city coordinates for display lookup
const CITY_NAMES = {
  '31.7683,35.2137': 'Jerusalem',
  '40.7128,-74.006': 'New York',
  '34.0522,-118.2437': 'Los Angeles',
  '41.8781,-87.6298': 'Chicago',
  '29.7604,-95.3698': 'Houston',
  '33.749,-84.388': 'Atlanta',
  '47.6062,-122.3321': 'Seattle',
  '25.7617,-80.1918': 'Miami',
  '39.7392,-104.9903': 'Denver',
  '33.4484,-112.074': 'Phoenix',
  '51.5074,-0.1278': 'London',
  '48.8566,2.3522': 'Paris',
  '52.52,13.405': 'Berlin',
  '41.9028,12.4964': 'Rome',
  '55.7558,37.6173': 'Moscow',
  '35.6762,139.6503': 'Tokyo',
  '31.2304,121.4737': 'Shanghai',
  '22.3193,114.1694': 'Hong Kong',
  '1.3521,103.8198': 'Singapore',
  '-33.8688,151.2093': 'Sydney',
  '-23.5505,-46.6333': 'SÃ£o Paulo',
  '19.4326,-99.1332': 'Mexico City',
  '-34.6037,-58.3816': 'Buenos Aires',
  '30.0444,31.2357': 'Cairo',
  '28.6139,77.209': 'New Delhi',
  '-1.2921,36.8219': 'Nairobi'
};

// ========================================
// SEO-FRIENDLY URL ROUTING
// ========================================

// City slugs for URL routing (slug -> coordinates)
const CITY_SLUGS = {
  // Biblical / Middle East
  'jerusalem': { lat: 31.7683, lon: 35.2137 },
  'bethlehem': { lat: 31.7054, lon: 35.2024 },
  'nazareth': { lat: 32.6996, lon: 35.3035 },
  'jericho': { lat: 31.8500, lon: 35.4500 },
  'hebron': { lat: 31.5326, lon: 35.0998 },
  'ramses': { lat: 30.7879, lon: 31.8332 },  // Pi-Ramesses, ancient Egyptian capital (near modern Qantir)
  'goshen': { lat: 30.7833, lon: 31.5000 },  // Land of Goshen, eastern Nile Delta
  'wilderness-of-sin': { lat: 29.1500, lon: 33.4000 },  // Between Elim and Sinai
  'cairo': { lat: 30.0444, lon: 31.2357 },
  'baghdad': { lat: 33.3152, lon: 44.3661 },
  'damascus': { lat: 33.5138, lon: 36.2765 },
  'amman': { lat: 31.9454, lon: 35.9284 },
  'beirut': { lat: 33.8938, lon: 35.5018 },
  'tel-aviv': { lat: 32.0853, lon: 34.7818 },
  'alexandria': { lat: 31.2001, lon: 29.9187 },
  'mt-sinai-saudi': { lat: 28.5653, lon: 35.4058 },  // Jabal al-Maqla (Ron Wyatt site), Jabal al-Lawz range
  'mecca': { lat: 21.4225, lon: 39.8262 },
  'medina': { lat: 24.5247, lon: 39.5692 },
  'riyadh': { lat: 24.7136, lon: 46.6753 },
  'istanbul': { lat: 41.0082, lon: 28.9784 },
  'tehran': { lat: 35.6892, lon: 51.3890 },
  // North America
  'new-york': { lat: 40.7128, lon: -74.006 },
  'los-angeles': { lat: 34.0522, lon: -118.2437 },
  'chicago': { lat: 41.8781, lon: -87.6298 },
  'houston': { lat: 29.7604, lon: -95.3698 },
  'phoenix': { lat: 33.4484, lon: -112.074 },
  'philadelphia': { lat: 39.9526, lon: -75.1652 },
  'san-antonio': { lat: 29.4241, lon: -98.4936 },
  'san-diego': { lat: 32.7157, lon: -117.1611 },
  'dallas': { lat: 32.7767, lon: -96.7970 },
  'san-jose': { lat: 37.3382, lon: -121.8863 },
  'austin': { lat: 30.2672, lon: -97.7431 },
  'jacksonville': { lat: 30.3322, lon: -81.6557 },
  'fort-worth': { lat: 32.7555, lon: -97.3308 },
  'columbus': { lat: 39.9612, lon: -82.9988 },
  'charlotte': { lat: 35.2271, lon: -80.8431 },
  'san-francisco': { lat: 37.7749, lon: -122.4194 },
  'indianapolis': { lat: 39.7684, lon: -86.1581 },
  'seattle': { lat: 47.6062, lon: -122.3321 },
  'denver': { lat: 39.7392, lon: -104.9903 },
  'washington-dc': { lat: 38.9072, lon: -77.0369 },
  'boston': { lat: 42.3601, lon: -71.0589 },
  'nashville': { lat: 36.1627, lon: -86.7816 },
  'detroit': { lat: 42.3314, lon: -83.0458 },
  'portland': { lat: 45.5152, lon: -122.6784 },
  'las-vegas': { lat: 36.1699, lon: -115.1398 },
  'memphis': { lat: 35.1495, lon: -90.0490 },
  'louisville': { lat: 38.2527, lon: -85.7585 },
  'baltimore': { lat: 39.2904, lon: -76.6122 },
  'milwaukee': { lat: 43.0389, lon: -87.9065 },
  'albuquerque': { lat: 35.0844, lon: -106.6504 },
  'tucson': { lat: 32.2226, lon: -110.9747 },
  'atlanta': { lat: 33.749, lon: -84.388 },
  'miami': { lat: 25.7617, lon: -80.1918 },
  'minneapolis': { lat: 44.9778, lon: -93.2650 },
  'salt-lake-city': { lat: 40.7608, lon: -111.8910 },
  'anchorage': { lat: 61.2181, lon: -149.9003 },
  'honolulu': { lat: 21.3069, lon: -157.8583 },
  'toronto': { lat: 43.6532, lon: -79.3832 },
  'vancouver': { lat: 49.2827, lon: -123.1207 },
  'montreal': { lat: 45.5017, lon: -73.5673 },
  'mexico-city': { lat: 19.4326, lon: -99.1332 },
  // Europe
  'london': { lat: 51.5074, lon: -0.1278 },
  'paris': { lat: 48.8566, lon: 2.3522 },
  'berlin': { lat: 52.52, lon: 13.405 },
  'madrid': { lat: 40.4168, lon: -3.7038 },
  'rome': { lat: 41.9028, lon: 12.4964 },
  'vienna': { lat: 48.2082, lon: 16.3738 },
  'amsterdam': { lat: 52.3676, lon: 4.9041 },
  'brussels': { lat: 50.8503, lon: 4.3517 },
  'stockholm': { lat: 59.3293, lon: 18.0686 },
  'oslo': { lat: 59.9139, lon: 10.7522 },
  'copenhagen': { lat: 55.6761, lon: 12.5683 },
  'helsinki': { lat: 60.1699, lon: 24.9384 },
  'dublin': { lat: 53.3498, lon: -6.2603 },
  'lisbon': { lat: 38.7223, lon: -9.1393 },
  'barcelona': { lat: 41.3851, lon: 2.1734 },
  'munich': { lat: 48.1351, lon: 11.5820 },
  'milan': { lat: 45.4642, lon: 9.1900 },
  'zurich': { lat: 47.3769, lon: 8.5417 },
  'geneva': { lat: 46.2044, lon: 6.1432 },
  'moscow': { lat: 55.7558, lon: 37.6173 },
  'saint-petersburg': { lat: 59.9311, lon: 30.3609 },
  'kiev': { lat: 50.4501, lon: 30.5234 },
  'warsaw': { lat: 52.2297, lon: 21.0122 },
  'prague': { lat: 50.0755, lon: 14.4378 },
  'budapest': { lat: 47.4979, lon: 19.0402 },
  'bucharest': { lat: 44.4268, lon: 26.1025 },
  'athens': { lat: 37.9838, lon: 23.7275 },
  // Asia
  'tokyo': { lat: 35.6762, lon: 139.6503 },
  'osaka': { lat: 34.6937, lon: 135.5023 },
  'seoul': { lat: 37.5665, lon: 126.9780 },
  'beijing': { lat: 39.9042, lon: 116.4074 },
  'shanghai': { lat: 31.2304, lon: 121.4737 },
  'hong-kong': { lat: 22.3193, lon: 114.1694 },
  'taipei': { lat: 25.0330, lon: 121.5654 },
  'singapore': { lat: 1.3521, lon: 103.8198 },
  'bangkok': { lat: 13.7563, lon: 100.5018 },
  'kuala-lumpur': { lat: 3.1390, lon: 101.6869 },
  'jakarta': { lat: -6.2088, lon: 106.8456 },
  'manila': { lat: 14.5995, lon: 120.9842 },
  'hanoi': { lat: 21.0285, lon: 105.8542 },
  'ho-chi-minh': { lat: 10.8231, lon: 106.6297 },
  'mumbai': { lat: 19.0760, lon: 72.8777 },
  'new-delhi': { lat: 28.6139, lon: 77.209 },
  'bangalore': { lat: 12.9716, lon: 77.5946 },
  'kolkata': { lat: 22.5726, lon: 88.3639 },
  'chennai': { lat: 13.0827, lon: 80.2707 },
  'karachi': { lat: 24.8607, lon: 67.0011 },
  'lahore': { lat: 31.5204, lon: 74.3587 },
  'dhaka': { lat: 23.8103, lon: 90.4125 },
  // Oceania
  'sydney': { lat: -33.8688, lon: 151.2093 },
  'melbourne': { lat: -37.8136, lon: 144.9631 },
  'brisbane': { lat: -27.4698, lon: 153.0251 },
  'perth': { lat: -31.9505, lon: 115.8605 },
  'auckland': { lat: -36.8485, lon: 174.7633 },
  'wellington': { lat: -41.2865, lon: 174.7762 },
  // South America
  'sao-paulo': { lat: -23.5505, lon: -46.6333 },
  'rio-de-janeiro': { lat: -22.9068, lon: -43.1729 },
  'buenos-aires': { lat: -34.6037, lon: -58.3816 },
  'bogota': { lat: 4.7110, lon: -74.0721 },
  'lima': { lat: -12.0464, lon: -77.0428 },
  'santiago': { lat: -33.4489, lon: -70.6693 },
  'caracas': { lat: 10.4806, lon: -66.9036 },
  // Africa
  'johannesburg': { lat: -26.2041, lon: 28.0473 },
  'cape-town': { lat: -33.9249, lon: 18.4241 },
  'lagos': { lat: 6.5244, lon: 3.3792 },
  'nairobi': { lat: -1.2921, lon: 36.8219 },
  'addis-ababa': { lat: 9.0320, lon: 38.7469 },
  'casablanca': { lat: 33.5731, lon: -7.5898 },
  'tunis': { lat: 36.8065, lon: 10.1815 },
  'algiers': { lat: 36.7538, lon: 3.0588 },
  'accra': { lat: 5.6037, lon: -0.1870 },
  'dakar': { lat: 14.7167, lon: -17.4677 }
};

// COORDS_TO_SLUG, PROFILE_CONFIGS, YEAR_START_URL_MAP, YEAR_START_INTERNAL_TO_URL,
// CRESCENT_THRESHOLD_TO_URL, CRESCENT_THRESHOLD_FROM_URL moved to navigation-routing.js

// Find closest city slug from coordinates (within ~100km)
// getClosestCitySlug moved to settings-profiles.js
// haversineDistance moved to settings-profiles.js

// getCurrentProfileSlug moved to navigation-routing.js
// getLocationSlug moved to navigation-routing.js
// buildPathURL moved to navigation-routing.js
// parseYearFromURL moved to navigation-routing.js
// formatYearForURL moved to navigation-routing.js

// parsePathURL moved to navigation-routing.js
// applyURLState moved to navigation-routing.js
// updatePathURL moved to navigation-routing.js
// navigateToPathURL moved to navigation-routing.js
// julianToGregorian moved to navigation-routing.js
// handleGregorianLookup moved to navigation-routing.js
// handleJulianLookup moved to navigation-routing.js

// getTimezoneFromLongitude moved to astronomy-utils.js

// Get a display name for the current location
// Always shows the actual location name, never "Your Area (via IP)" etc.
// Optionally accepts lat/lon to look up a specific location
// getCurrentLocationName moved to settings-profiles.js

// Refresh location via IP if the current profile uses "Your Location"
function refreshLocationIfNeeded() {
  const profileId = state.selectedProfile || 'timeTested';
  const profile = PROFILES[profileId];
  
  // Only refresh for profiles with useCurrentLocation
  if (!profile || !profile.useCurrentLocation) return;
  
  // Use IP-based geolocation (no permission prompt)
  getLocationFromIP()
    .then(location => {
      if (location) {
        const newLat = Math.round(location.lat * 10000) / 10000;
        const newLon = Math.round(location.lon * 10000) / 10000;
        
        // Only update if location has changed significantly (>0.01 degrees â‰ˆ 1km)
        if (Math.abs(newLat - state.lat) > 0.01 || Math.abs(newLon - state.lon) > 0.01) {
          state.lat = newLat;
          state.lon = newLon;
          state.city = 'ip-based';
          state.locationSource = 'ip';
          
          // Update UI
          document.getElementById('lat-input').value = state.lat;
          document.getElementById('lon-input').value = state.lon;
          
          // Regenerate calendar with new location
          saveState();
          generateCalendar({ preserveMonth: true });
          renderSettingsPageMap();
        }
      }
    })
    .catch(error => {
      // Silently fail - keep existing location
      console.log('IP geolocation refresh failed, keeping saved location');
    });
}

// Check if a profile name is unique
// isProfileNameUnique moved to settings-profiles.js
// Track modal mode: 'create' or 'edit' (variables remain in index.html)
let profileModalMode = 'create';
let profileModalEditId = null;
// cloneProfile moved to settings-profiles.js
// editProfileName moved to settings-profiles.js
// showProfileModal moved to settings-profiles.js
// closeProfileModal moved to settings-profiles.js
// handleProfileModalKeydown moved to settings-profiles.js
// saveProfileModal moved to settings-profiles.js
// deleteCustomProfile moved to settings-profiles.js
// updateProfileButtonStates moved to settings-profiles.js
// updateSettingsEditability moved to settings-profiles.js
// updateMapEditability moved to settings-profiles.js

// Initialize custom profiles on load
loadCustomProfiles();

// Get feast icons for a given lunar month and day
function getFeastIconsForLunarDay(month, day) {
  const icons = [];
  for (const f of FEASTS) {
    if (f.month === month) {
      if (f.endDay) {
        // Multi-day feast
        if (day >= f.day && day <= f.endDay) {
          if (!icons.includes(f.icon)) icons.push(f.icon);
        }
      } else if (f.day === day) {
        // Single-day feast
        if (!icons.includes(f.icon)) icons.push(f.icon);
      }
    }
  }
  return icons;
}

// Switch to a profile and navigate to the same Gregorian date
function switchToProfileAndNavigate(profileId, timestamp) {
  // Store the target date to navigate to after calendar regenerates
  state.pendingNavigationDate = new Date(timestamp);
  
  // Apply the profile (this will trigger calendar regeneration)
  applyProfile(profileId);
}

// navigateToPendingDate moved to navigation-routing.js

function applyProfile(profileId) {
  const profile = PROFILES[profileId];
  if (!profile) return;
  
  state.selectedProfile = profileId;
  state.moonPhase = profile.moonPhase;
  state.dayStartTime = profile.dayStartTime;
  state.dayStartAngle = profile.dayStartAngle;
  state.yearStartRule = profile.yearStartRule;
  state.crescentThreshold = profile.crescentThreshold;
  state.sabbathMode = profile.sabbathMode || 'lunar';
  
  if (profile.useLocalLocation) {
    // Use saved location first, then fall back to IP detection
    const savedLocation = getSavedUserLocation();
    if (savedLocation) {
      state.lat = savedLocation.lat;
      state.lon = savedLocation.lon;
      state.city = savedLocation.city || 'saved';
      state.locationSource = 'saved';
      updateLocationUI();
      finishApplyProfile();
    } else {
      // No saved location - use IP-based geolocation
      getLocationFromIP()
        .then(location => {
          if (location) {
            state.lat = location.lat;
            state.lon = location.lon;
            state.city = 'ip-based';
            state.locationSource = 'ip';
            updateLocationUI();
          }
          finishApplyProfile();
        })
        .catch(error => {
          console.log('IP geolocation error, keeping current location');
          finishApplyProfile();
        });
    }
  } else if (profile.lat !== undefined) {
    // Custom profile with fixed location
    state.lat = profile.lat;
    state.lon = profile.lon;
    state.city = profile.city;
    state.locationSource = 'fixed';
    updateLocationUI();
    finishApplyProfile();
  } else {
    finishApplyProfile();
  }
}

// Get saved user location from localStorage
function getSavedUserLocation() {
  try {
    const saved = localStorage.getItem('userDefaultLocation');
    if (saved) {
      return JSON.parse(saved);
    }
  } catch (e) {
    console.error('Error loading saved location:', e);
  }
  return null;
}

// Save user location preference to localStorage
function saveUserLocation(lat, lon, city) {
  try {
    localStorage.setItem('userDefaultLocation', JSON.stringify({ lat, lon, city }));
  } catch (e) {
    console.error('Error saving location:', e);
  }
}

// Get approximate location from IP (no permission required)
async function getLocationFromIP() {
  try {
    // Try ipapi.co first (HTTPS, reliable)
    const response = await fetch('https://ipapi.co/json/', { 
      timeout: 5000,
      cache: 'no-store'
    });
    if (response.ok) {
      const data = await response.json();
      if (data.latitude && data.longitude) {
        return { 
          lat: data.latitude, 
          lon: data.longitude,
          city: data.city,
          country: data.country_name
        };
      }
    }
  } catch (e) {
    console.log('IP geolocation failed:', e);
  }
  return null;
}

// Get exact GPS location (requires user permission) - used in profile editor
function getExactLocation() {
  const profileId = editingProfileId || state.selectedProfile;
  
  // Don't allow changes on preset profiles
  if (PRESET_PROFILES[profileId]) return;
  
  if (!navigator.geolocation) {
    alert('GPS is not available on this device');
    return;
  }
  
  // Show loading indicator
  const btn = document.querySelector('.exact-location-btn');
  if (btn) {
    btn.textContent = 'ğŸ“ Getting location...';
    btn.disabled = true;
  }
  
  navigator.geolocation.getCurrentPosition(
    (position) => {
      const lat = Math.round(position.coords.latitude * 10000) / 10000;
      const lon = Math.round(position.coords.longitude * 10000) / 10000;
      
      // Find nearest city to snap to
      const nearestSlug = getClosestCitySlug(lat, lon, Infinity);
      const nearestCoords = nearestSlug ? CITY_SLUGS[nearestSlug] : { lat, lon };
      const finalLat = nearestCoords.lat;
      const finalLon = nearestCoords.lon;
      
      // Profile editor only updates the profile's location
      if (PROFILES[profileId]) {
        PROFILES[profileId].lat = finalLat;
        PROFILES[profileId].lon = finalLon;
        PROFILES[profileId].city = nearestSlug || 'gps';
        saveCustomProfiles();
      }
      
      // Update settings page inputs
      const settingsLatInput = document.getElementById('settings-lat-input');
      const settingsLonInput = document.getElementById('settings-lon-input');
      const settingsCitySelect = document.getElementById('settings-city-select');
      const settingsCustomCoords = document.getElementById('settings-custom-coords');
      
      // Try to select the nearest city in the dropdown
      const coordValue = `${finalLat},${finalLon}`;
      let found = false;
      if (settingsCitySelect) {
        for (let option of settingsCitySelect.options) {
          if (option.value === coordValue) {
            settingsCitySelect.value = coordValue;
            found = true;
            break;
          }
        }
      }
      
      if (!found) {
        if (settingsCitySelect) settingsCitySelect.value = 'custom';
        if (settingsCustomCoords) settingsCustomCoords.style.display = 'flex';
        if (settingsLatInput) settingsLatInput.value = finalLat;
        if (settingsLonInput) settingsLonInput.value = finalLon;
      } else {
        if (settingsCustomCoords) settingsCustomCoords.style.display = 'none';
      }
      
      renderSettingsPageMap();
      
      // Update button
      if (btn) {
        btn.textContent = 'ğŸ“ Location Saved!';
        setTimeout(() => {
          btn.textContent = 'ğŸ“ Use My Location';
          btn.disabled = false;
        }, 2000);
      }
    },
    (error) => {
      console.log('GPS error:', error);
      alert('Could not get your exact location. Please check your browser permissions.');
      if (btn) {
        btn.textContent = 'ğŸ“ Use Exact Location';
        btn.disabled = false;
      }
    },
    { enableHighAccuracy: true, timeout: 10000 }
  );
}

function updateLocationUI() {
  document.getElementById('lat-input').value = state.lat;
  document.getElementById('lon-input').value = state.lon;
  document.getElementById('city-select').value = state.city || '';
  const settingsCitySelect = document.getElementById('settings-city-select');
  if (settingsCitySelect) settingsCitySelect.value = state.city || '';
}

function finishApplyProfile() {
  // Update all UI elements
  document.getElementById('moon-phase-select').value = state.moonPhase;
  updateMoonPhaseButtons();
  updateDayStartButtons();
  updateYearStartButtons();
  updateCrescentThresholdVisibility();
  updateCrescentThresholdButtons();
  updateSabbathButtons();
  updateProfileButtons();
  updateSettingsEditability();
  
  // Save and regenerate (preserving scroll position)
  saveState();
  regenerateCalendarPreservingScroll();
}

function getMatchingProfile() {
  // Determine which profile matches current state (if any)
  for (const [id, profile] of Object.entries(PROFILES)) {
    if (profile.moonPhase === state.moonPhase &&
        profile.dayStartTime === state.dayStartTime &&
        profile.dayStartAngle === state.dayStartAngle &&
        profile.yearStartRule === state.yearStartRule &&
        profile.crescentThreshold === state.crescentThreshold &&
        (profile.sabbathMode || 'lunar') === state.sabbathMode) {
      // Check location match for non-current-location profiles
      if (profile.useCurrentLocation) {
        // For "current location" profiles, any location works
        return id;
      } else if (Math.abs(profile.lat - state.lat) < 0.01 && Math.abs(profile.lon - state.lon) < 0.01) {
        return id;
      }
    }
  }
  return null; // No matching profile
}

// updateProfileButtons moved to settings-profiles.js

// onProfileSelectChange moved to settings-profiles.js
// displayProfileSettings moved to settings-profiles.js

function resetToDefaults() {
  // Apply Time-Tested profile as default (Jerusalem, no location prompt)
  applyProfile('timeTested');
}

// Sabbath Tester code is loaded from sabbath-tester.js





// Sabbath Tester code moved to sabbath-tester.js

// Helper to regenerate calendar while preserving scroll position
function regenerateCalendarPreservingScroll() {
  const scrollTop = window.scrollY || document.documentElement.scrollTop;
  generateCalendar({ preserveMonth: true });
  updateURL();
  renderSettingsPageMap();
  
  // Check for pending navigation (from profile switching)
  if (state.pendingNavigationDate) {
    navigateToPendingDate();
  } else {
    refreshDayDetailIfVisible();
  }
  
  requestAnimationFrame(() => {
    window.scrollTo(0, scrollTop);
  });
}

// selectDayStartTime moved to settings-profiles.js
// selectDayStartAngle moved to settings-profiles.js
// selectYearStartRule moved to settings-profiles.js
// updateDayStartButtons moved to settings-profiles.js
// updateYearStartButtons moved to settings-profiles.js

// selectCrescentThreshold moved to settings-profiles.js
// selectSabbathMode moved to settings-profiles.js
// updateSabbathButtons moved to settings-profiles.js
// selectSabbathDayFromDropdown moved to settings-profiles.js

// Determine if a day is a sabbath based on current sabbathMode
function isSabbath(day) {
  switch (state.sabbathMode) {
    case 'lunar':
      // Lunar sabbath: days 8, 15, 22, 29
      return [8, 15, 22, 29].includes(day.lunarDay);
    case 'sunday':
      return getCorrectWeekday(day.gregorianDate) === 0;
    case 'monday':
      return getCorrectWeekday(day.gregorianDate) === 1;
    case 'tuesday':
      return getCorrectWeekday(day.gregorianDate) === 2;
    case 'wednesday':
      return getCorrectWeekday(day.gregorianDate) === 3;
    case 'thursday':
      return getCorrectWeekday(day.gregorianDate) === 4;
    case 'friday':
      return getCorrectWeekday(day.gregorianDate) === 5;
    case 'saturday':
      return getCorrectWeekday(day.gregorianDate) === 6;
    case 'none':
      return false;
    default:
      return [8, 15, 22, 29].includes(day.lunarDay);
  }
}

// updateCrescentThresholdButtons moved to settings-profiles.js
// updateCrescentThresholdVisibility moved to settings-profiles.js

function renderSettingsMap() {
  const container = document.getElementById('settings-map-container');
  if (container && state.lunarMonths && state.lunarMonths[state.currentMonthIndex]) {
    const month = state.lunarMonths[state.currentMonthIndex];
    container.innerHTML = renderDatelineVisualization(month.moonEvent);
    // Update map editability after rendering
    updateMapEditability();
  }
}

// Month Picker Popup
function toggleMonthPicker() {
  const overlay = document.getElementById('month-picker-overlay');
  const picker = document.getElementById('month-picker');
  const isOpen = overlay.classList.contains('open');
  
  if (!isOpen) {
    // Opening - update the picker content
    updateMonthPicker();
  }
  
  overlay.classList.toggle('open');
  picker.style.display = isOpen ? 'none' : 'block';
}

function updateMonthPicker() {
  // Just show the year number (no BC/AD suffix - the dropdown handles that)
  const displayYear = state.year <= 0 ? Math.abs(state.year - 1) : state.year;
  document.getElementById('picker-year').textContent = displayYear;
  updateEraButtons();
  
  const grid = document.getElementById('month-grid');
  grid.innerHTML = '';
  
  const monthNames = ['1st', '2nd', '3rd', '4th', '5th', '6th', '7th', '8th', '9th', '10th', '11th', '12th', 'ğŸ“…13th'];
  
  for (let i = 0; i < 13; i++) {
    const btn = document.createElement('button');
    btn.textContent = monthNames[i];
    
    if (i >= state.lunarMonths.length) {
      btn.classList.add('disabled');
      btn.disabled = true;
    } else if (i === state.currentMonthIndex) {
      btn.classList.add('active');
    }
    
    // Add tooltip for 13th month
    if (i === 12) {
      btn.title = 'Intercalary 13th month';
    }
    
    btn.onclick = () => {
      if (i < state.lunarMonths.length) {
        selectMonth(i);
        toggleMonthPicker();
      }
    };
    
    grid.appendChild(btn);
  }
  
  // Add "Today" button - positioned in 4th column (under 12th month)
  // First add an empty spacer for the 3rd column position
  const spacer1 = document.createElement('div');
  spacer1.style.visibility = 'hidden';
  grid.appendChild(spacer1);
  
  const spacer2 = document.createElement('div');
  spacer2.style.visibility = 'hidden';
  grid.appendChild(spacer2);
  
  const todayBtn = document.createElement('button');
  todayBtn.textContent = 'Today';
  todayBtn.className = 'today-btn';
  todayBtn.title = 'Jump to today';
  todayBtn.onclick = () => {
    toggleMonthPicker();
    jumpToToday();
  };
  grid.appendChild(todayBtn);
}

function showYearInput() {
  const display = document.getElementById('picker-year');
  const input = document.getElementById('picker-year-input');
  
  display.style.visibility = 'hidden';
  input.classList.add('visible');
  
  // Convert internal year to display year (always positive)
  if (state.year <= 0) {
    input.value = Math.abs(state.year - 1);
  } else {
    input.value = state.year;
  }
  
  input.focus();
  input.select();
}

function hideYearInput() {
  const display = document.getElementById('picker-year');
  const input = document.getElementById('picker-year-input');
  
  display.style.visibility = '';
  input.classList.remove('visible');
}

function getPickerEra() {
  return state.year <= 0 ? 'BC' : 'AD';
}

function changeEra(era) {
  const input = document.getElementById('picker-year-input');
  const currentEra = getPickerEra();
  
  if (era === currentEra) return;
  
  // Get current display year
  let displayYear;
  if (input.classList.contains('visible')) {
    displayYear = parseInt(input.value) || 1;
  } else {
    displayYear = state.year <= 0 ? Math.abs(state.year - 1) : state.year;
  }
  
  // Convert to new era
  let newInternalYear;
  if (era === 'BC') {
    newInternalYear = -(displayYear - 1);
  } else {
    newInternalYear = displayYear;
  }
  
  // Validate range
  if (newInternalYear >= -3999 && newInternalYear <= 4000) {
    state.year = newInternalYear;
    document.getElementById('year-input').value = state.year;
    generateCalendar();
    updateMonthPicker();
  }
}

function updateEraButtons() {
  const eraSelect = document.getElementById('era-select');
  if (eraSelect) {
    eraSelect.value = state.year <= 0 ? 'BC' : 'AD';
  }
}

function applyYearInput() {
  const input = document.getElementById('picker-year-input');
  let displayYear = parseInt(input.value);
  
  if (isNaN(displayYear) || displayYear < 1 || displayYear > 4000) {
    hideYearInput();
    return;
  }
  
  // Convert display year to internal year based on current era
  const isBC = state.year <= 0;
  let internalYear;
  if (isBC) {
    internalYear = -(displayYear - 1);
  } else {
    internalYear = displayYear;
  }
  
  // Validate range: -3999 (4000 BC) to 4000 (4000 AD)
  if (internalYear >= -3999 && internalYear <= 4000) {
    state.year = internalYear;
    document.getElementById('year-input').value = state.year;
    generateCalendar();
    updateMonthPicker();
  }
  
  hideYearInput();
}

function changePickerYear(delta) {
  const newYear = state.year + delta;
  
  // Validate range: -3999 (4000 BC) to 4000 (4000 AD)
  if (newYear >= -3999 && newYear <= 4000) {
    state.year = newYear;
    document.getElementById('year-input').value = state.year;
    generateCalendar();
    updateMonthPicker();
    updateEraButtons();
  }
}

// toggleDateJump moved to day-detail.js
// executeJumpToDate moved to day-detail.js
// jumpToTodayFromPopup moved to day-detail.js
// addDaysFromPopup moved to day-detail.js

function handleMapClick(event) {
  // Don't allow map clicks when on a preset profile
  const profileId = editingProfileId || state.selectedProfile;
  if (PRESET_PROFILES[profileId]) {
    return; // Preset profiles are read-only
  }
  
  const mapEl = event.currentTarget;
  const rect = mapEl.getBoundingClientRect();
  
  // Calculate click position as percentage
  const xPercent = (event.clientX - rect.left) / rect.width;
  const yPercent = (event.clientY - rect.top) / rect.height;
  
  // Convert to lat/lon (equirectangular projection)
  // X: 0% = -180Â°, 100% = 180Â°
  // Y: 0% = 90Â° (north), 100% = -90Â° (south)
  const lon = (xPercent * 360) - 180;
  const lat = 90 - (yPercent * 180);
  
  // Round to 2 decimal places
  const roundedLat = Math.round(lat * 100) / 100;
  const roundedLon = Math.round(lon * 100) / 100;
  
  // Check if we're in profile editor mode (settings page is visible with editingProfileId set)
  const settingsPage = document.getElementById('settings-page');
  const isInProfileEditor = settingsPage && settingsPage.classList.contains('visible') && editingProfileId;
  
  if (isInProfileEditor) {
    // Profile editor mode - only update the profile's location, not state
    if (PROFILES[profileId]) {
      PROFILES[profileId].lat = roundedLat;
      PROFILES[profileId].lon = roundedLon;
      PROFILES[profileId].city = '';
      saveCustomProfiles();
    }
    
    // Update settings page inputs only
    const settingsLatInput = document.getElementById('settings-lat-input');
    const settingsLonInput = document.getElementById('settings-lon-input');
    const settingsCitySelect = document.getElementById('settings-city-select');
    const settingsCustomCoords = document.getElementById('settings-custom-coords');
    
    if (settingsLatInput) settingsLatInput.value = roundedLat;
    if (settingsLonInput) settingsLonInput.value = roundedLon;
    if (settingsCitySelect) settingsCitySelect.value = 'custom';
    if (settingsCustomCoords) settingsCustomCoords.style.display = 'flex';
    
    renderSettingsPageMap();
  } else {
    // Calendar page mode - update state
    state.lat = roundedLat;
    state.lon = roundedLon;
    state.city = ''; // Clear city selection
    
    // Update main inputs
    document.getElementById('lat-input').value = state.lat;
    document.getElementById('lon-input').value = state.lon;
    document.getElementById('city-select').value = '';
    
    // Show custom coords on main page
    const customCoords = document.getElementById('custom-coords');
    if (customCoords) customCoords.style.display = 'block';
    
    // Save and regenerate (preserve current month for location changes)
    saveState();
    generateCalendar({ preserveMonth: true });
    updateURL();
    
    // Update the settings maps (both containers)
    renderSettingsMap();
    refreshDayDetailIfVisible();
  }
}

function useCurrentLocation() {
  const btn = document.querySelector('.location-btn');
  const originalText = btn.textContent;
  
  if (!navigator.geolocation) {
    alert('Geolocation is not supported by your browser');
    return;
  }
  
  btn.textContent = 'ğŸ“ Getting location...';
  btn.disabled = true;
  
  navigator.geolocation.getCurrentPosition(
    function(position) {
      // Success
      state.lat = Math.round(position.coords.latitude * 10000) / 10000;
      state.lon = Math.round(position.coords.longitude * 10000) / 10000;
      state.city = ''; // Clear city selection
      
      document.getElementById('lat-input').value = state.lat;
      document.getElementById('lon-input').value = state.lon;
      document.getElementById('city-select').value = '';
      document.getElementById('custom-coords').style.display = 'block';
      
      updateProfileButtons();  // Check if settings match a profile
      saveState();
      generateCalendar({ preserveMonth: true });
      updateURL();
      renderSettingsMap();
      refreshDayDetailIfVisible();
      
      btn.textContent = 'âœ“ Location set!';
      setTimeout(() => {
        btn.textContent = originalText;
        btn.disabled = false;
      }, 2000);
    },
    function(error) {
      // Error
      let message = 'Unable to get location';
      switch(error.code) {
        case error.PERMISSION_DENIED:
          message = 'Location access denied. Please enable location permissions.';
          break;
        case error.POSITION_UNAVAILABLE:
          message = 'Location information unavailable.';
          break;
        case error.TIMEOUT:
          message = 'Location request timed out.';
          break;
      }
      alert(message);
      btn.textContent = originalText;
      btn.disabled = false;
    },
    {
      enableHighAccuracy: false,
      timeout: 10000,
      maximumAge: 300000 // Cache for 5 minutes
    }
  );
}

document.getElementById('city-select').addEventListener('change', function() {
  const customCoords = document.getElementById('custom-coords');
  
  if (this.value === '') {
    // Custom selected - show coordinate inputs
    customCoords.style.display = 'block';
    state.city = '';
    return;
  }
  
  if (this.value) {
    customCoords.style.display = 'none';
    const [lat, lon] = this.value.split(',').map(Number);
    state.lat = lat;
    state.lon = lon;
    state.city = this.value;
    saveState();
    updateUI();
    generateCalendar({ preserveMonth: true });
    updateURL();
    renderSettingsMap();
    refreshDayDetailIfVisible();
  }
});

// Settings page city select handler
document.getElementById('settings-city-select').addEventListener('change', function() {
  // Don't allow changes on preset profiles
  const profileId = editingProfileId || state.selectedProfile;
  if (PRESET_PROFILES[profileId]) return;
  
  const customCoords = document.getElementById('settings-custom-coords');
  
  if (this.value === 'current') {
    // Use geolocation
    useCurrentLocationFromSettings();
    return;
  }
  
  if (this.value === 'custom') {
    customCoords.style.display = 'flex';
    state.city = '';
    return;
  }
  
  if (this.value) {
    customCoords.style.display = 'none';
    const [lat, lon] = this.value.split(',').map(Number);
    
    // Profile editor only updates the profile's location, not state
    if (!PRESET_PROFILES[profileId] && PROFILES[profileId]) {
      PROFILES[profileId].lat = lat;
      PROFILES[profileId].lon = lon;
      PROFILES[profileId].city = this.value;
      saveCustomProfiles();
    }
    
    renderSettingsPageMap();
  }
});

// Settings page custom coordinate inputs
document.getElementById('settings-lat-input').addEventListener('change', function() {
  // Don't allow changes on preset profiles
  const profileId = editingProfileId || state.selectedProfile;
  if (PRESET_PROFILES[profileId]) return;
  
  const lat = parseFloat(this.value);
  
  // Profile editor only updates the profile's location, not state
  if (PROFILES[profileId]) {
    PROFILES[profileId].lat = lat;
    PROFILES[profileId].city = '';
    saveCustomProfiles();
  }
  
  renderSettingsPageMap();
});

document.getElementById('settings-lon-input').addEventListener('change', function() {
  // Don't allow changes on preset profiles
  const profileId = editingProfileId || state.selectedProfile;
  if (PRESET_PROFILES[profileId]) return;
  
  const lon = parseFloat(this.value);
  
  // Profile editor only updates the profile's location, not state
  if (PROFILES[profileId]) {
    PROFILES[profileId].lon = lon;
    PROFILES[profileId].city = '';
    saveCustomProfiles();
  }
  
  renderSettingsPageMap();
});

function useCurrentLocationFromSettings() {
  const select = document.getElementById('settings-city-select');
  const profileId = editingProfileId || state.selectedProfile;
  
  // Don't allow changes on preset profiles
  if (PRESET_PROFILES[profileId]) return;
  
  if (!navigator.geolocation) {
    alert('Geolocation is not supported by your browser');
    // Reset to first city option
    select.value = '31.7683,35.2137';
    return;
  }
  
  navigator.geolocation.getCurrentPosition(
    function(position) {
      const lat = Math.round(position.coords.latitude * 10000) / 10000;
      const lon = Math.round(position.coords.longitude * 10000) / 10000;
      
      // Profile editor only updates the profile's location, not state
      if (PROFILES[profileId]) {
        PROFILES[profileId].lat = lat;
        PROFILES[profileId].lon = lon;
        PROFILES[profileId].city = '';
        saveCustomProfiles();
      }
      
      // Update settings inputs to show the detected location
      document.getElementById('settings-lat-input').value = lat;
      document.getElementById('settings-lon-input').value = lon;
      
      // Show custom coordinates with the detected location
      select.value = 'custom';
      document.getElementById('settings-custom-coords').style.display = 'flex';
      
      renderSettingsPageMap();
    },
    function(error) {
      alert('Unable to get your location. Please select a city or enter coordinates manually.');
      // Reset to first city option
      select.value = '31.7683,35.2137';
    },
    { timeout: 10000, enableHighAccuracy: true }
  );
}

// Auto-regenerate when inputs change
function regenerateAndUpdateURL() {
  generateCalendar();
  updateURL();
}
document.getElementById('year-input').addEventListener('change', regenerateAndUpdateURL);
document.getElementById('moon-phase-select').addEventListener('change', regenerateAndUpdateURL);
document.getElementById('lat-input').addEventListener('change', function() {
  state.city = ''; // Clear city selection when manually editing coordinates
  generateCalendar({ preserveMonth: true });
  updateURL();
  refreshDayDetailIfVisible();
});
document.getElementById('lon-input').addEventListener('change', function() {
  state.city = ''; // Clear city selection when manually editing coordinates
  generateCalendar({ preserveMonth: true });
  updateURL();
  refreshDayDetailIfVisible();
});

function changeYear(delta) {
  state.year += delta;
  state.highlightedLunarDay = 1;  // Default to day 1
  state.selectedTimestamp = null;
  updateUI();
  generateCalendar();
  updateURL();
}

function addDaysToDate(direction) {
  const dateInput = document.getElementById('goto-date').value;
  const daysValue = parseInt(document.getElementById('add-days').value);
  
  if (!dateInput) {
    alert('Please select a date first');
    return;
  }
  
  if (isNaN(daysValue) || daysValue <= 0) {
    alert('Please enter a positive number of days');
    return;
  }
  
  const daysToAdd = daysValue * direction; // direction: 1 = forward, -1 = backward
  
  // Parse current datetime as local time at location, get UTC timestamp
  const utcTimestamp = parseDatetimeLocal(dateInput);
  // Add days in milliseconds
  const newTimestamp = utcTimestamp + daysToAdd * 24 * 60 * 60 * 1000;
  
  // Update the datetime input with new local time
  document.getElementById('goto-date').value = formatLocalDatetime(newTimestamp);
  
  // Jump to the new date
  jumpToDate();
}

function jumpToDate() {
  const dateInput = document.getElementById('goto-date').value;
  
  // For ancient dates, dateInput will be empty - use selectedTimestamp
  let utcTimestamp;
  if (dateInput) {
    utcTimestamp = parseDatetimeLocal(dateInput);
  } else if (state.selectedTimestamp) {
    utcTimestamp = state.selectedTimestamp;
  } else {
    alert('Please enter a date');
    return;
  }
  
  const targetDate = new Date(utcTimestamp);
  const targetYear = targetDate.getUTCFullYear();
  
  // Helper function to search in current lunar months
  function searchInCurrentMonths() {
    for (let m = 0; m < state.lunarMonths.length; m++) {
      const month = state.lunarMonths[m];
      for (let d = 0; d < month.days.length; d++) {
        const day = month.days[d];
        if (day.gregorianDate.toDateString() === targetDate.toDateString()) {
          return { month: m, dayIndex: d };
        }
      }
    }
    return null;
  }
  
  // First try current lunar months
  let found = searchInCurrentMonths();
  
  // If not found, try different lunar years
  // Lunar years span ~March to ~March, so we need to try year-1, year, and year+1
  if (!found) {
    const yearsToTry = [targetYear, targetYear - 1, targetYear + 1];
    
    for (const lunarYear of yearsToTry) {
      if (lunarYear === state.year) continue; // Already tried
      
      state.year = lunarYear;
      updateUI();
      generateCalendar(); // This also updates dateline overview
      
      found = searchInCurrentMonths();
      if (found) break;
    }
  }
  
  if (found) {
    state.currentMonthIndex = found.month;
    const dayObj = state.lunarMonths[found.month].days[found.dayIndex];
    state.highlightedLunarDay = dayObj.lunarDay;
    // Store the actual timestamp from the input (preserves time)
    state.selectedTimestamp = targetDate.getTime();
    renderMonth(state.lunarMonths[state.currentMonthIndex]);
    updateMonthButtons();
    updateURL();
    showDayDetail(dayObj, state.lunarMonths[found.month]);
  } else {
    alert('Date not found in lunar calendar. The Astronomy library may not support this date range.');
  }
}

function selectMonth(index) {
  // Preserve the current day number when switching months
  const previousDay = state.highlightedLunarDay || 1;
  state.currentMonthIndex = index;
  
  // Carry day selection to new month, clamping to valid range
  const newMonth = state.lunarMonths[index];
  const maxDay = newMonth.days.length;
  state.highlightedLunarDay = Math.min(previousDay, maxDay);
  
  // Update selectedTimestamp for the new month's day
  const dayObj = newMonth.days.find(d => d.lunarDay === state.highlightedLunarDay);
  if (dayObj) {
    state.selectedTimestamp = getSunriseTimestamp(dayObj.gregorianDate);
    document.getElementById('goto-date').value = formatLocalDatetime(state.selectedTimestamp);
  }
  
  renderMonth(state.lunarMonths[state.currentMonthIndex]);
  updateMonthButtons();
  updateURL();
  
  // Show day detail for the carried-over day
  if (dayObj) {
    showDayDetail(dayObj, newMonth);
  }
}

function navigateMonth(direction) {
  const newIndex = state.currentMonthIndex + direction;
  const previousDay = state.highlightedLunarDay || 1;
  
  if (newIndex < 0) {
    // Go to previous year, last month
    state.year -= 1;
    updateUI();
    generateCalendar();
    // Jump to last month of previous year
    state.currentMonthIndex = state.lunarMonths.length - 1;
    
    // Preserve day selection, clamped to valid range
    const newMonth = state.lunarMonths[state.currentMonthIndex];
    const maxDay = newMonth.days.length;
    state.highlightedLunarDay = Math.min(previousDay, maxDay);
    const dayObj = newMonth.days.find(d => d.lunarDay === state.highlightedLunarDay);
    if (dayObj) {
      state.selectedTimestamp = getSunriseTimestamp(dayObj.gregorianDate);
      document.getElementById('goto-date').value = formatLocalDatetime(state.selectedTimestamp);
      showDayDetail(dayObj, newMonth);
    }
    
    renderMonth(state.lunarMonths[state.currentMonthIndex]);
    updateMonthButtons();
    updateURL();
  } else if (newIndex >= state.lunarMonths.length) {
    // Go to next year, first month
    state.year += 1;
    updateUI();
    generateCalendar();
    // Already at first month (generateCalendar sets to 0)
    
    // Preserve day selection, clamped to valid range
    const newMonth = state.lunarMonths[state.currentMonthIndex];
    const maxDay = newMonth.days.length;
    state.highlightedLunarDay = Math.min(previousDay, maxDay);
    const dayObj = newMonth.days.find(d => d.lunarDay === state.highlightedLunarDay);
    if (dayObj) {
      state.selectedTimestamp = getSunriseTimestamp(dayObj.gregorianDate);
      document.getElementById('goto-date').value = formatLocalDatetime(state.selectedTimestamp);
      showDayDetail(dayObj, newMonth);
    }
    
    renderMonth(state.lunarMonths[state.currentMonthIndex]);
    updateURL();
  } else {
    // Normal month navigation within same year
    selectMonth(newIndex);
  }
}

// updateMonthButtons moved to calendar-core.js
// renderMonthButtons moved to calendar-core.js

// formatYear moved to calendar-core.js
// GREGORIAN_REFORM_DATE moved to calendar-core.js

// Convert a JavaScript Date (which is proleptic Gregorian) to Julian calendar date
// Returns { year, month, day } in Julian calendar
function gregorianToJulian(date) {
  // JavaScript dates are in proleptic Gregorian calendar
  // We need to convert to Julian for dates before 1582-10-15
  const year = date.getFullYear();
  const month = date.getMonth(); // 0-indexed
  const day = date.getDate();
  
  // Calculate Julian Day Number from Gregorian date
  const a = Math.floor((14 - (month + 1)) / 12);
  const y = year + 4800 - a;
  const m = (month + 1) + 12 * a - 3;
  
  // Julian Day Number for Gregorian calendar
  const jdn = day + Math.floor((153 * m + 2) / 5) + 365 * y + Math.floor(y / 4) - Math.floor(y / 100) + Math.floor(y / 400) - 32045;
  
  // Convert JDN back to Julian calendar date
  const c = jdn + 32082;
  const d = Math.floor((4 * c + 3) / 1461);
  const e = c - Math.floor(1461 * d / 4);
  const n = Math.floor((5 * e + 2) / 153);
  
  const julianDay = e - Math.floor((153 * n + 2) / 5) + 1;
  const julianMonth = n + 3 - 12 * Math.floor(n / 10); // 1-indexed
  const julianYear = d - 4800 + Math.floor(n / 10);
  
  return { year: julianYear, month: julianMonth - 1, day: julianDay }; // month 0-indexed to match JS
}

// isBeforeGregorianReform moved to calendar-core.js

// Calculate Julian Day Number from Julian calendar date (year, month 0-indexed, day)
// julianCalendarToJDN moved to day-detail.js
// jdnToWeekday moved to day-detail.js
// getFormattedDateParts moved to day-detail.js
// formatDisplayDate moved to day-detail.js

// getMoonIcon moved to settings-profiles.js

// Get the moon phase icon for a specific date, but ONLY if a quarter phase
// (new moon 0Â°, first quarter 90Â°, full moon 180Â°, last quarter 270Â°) occurs during this lunar day
// Uses the calendar's day start/end definition (sunset, sunrise, etc.) rather than UTC midnight
function getMoonPhaseIconForDate(date) {
  try {
    // Get the lunar day start time for this date based on current calendar config
    const dayStartTs = getDayStartTime(date);
    
    // The lunar day runs from this day start to the next day's start
    // Calculate next day's start by getting the day start for tomorrow's Gregorian date
    const tomorrowGregorian = new Date(date.getTime());
    tomorrowGregorian.setUTCDate(tomorrowGregorian.getUTCDate() + 1);
    const dayEndTs = getDayStartTime(tomorrowGregorian);
    
    const startOfDay = new Date(dayStartTs);
    const endOfDay = new Date(dayEndTs);
    
    const elongStart = getElongationForDate(startOfDay);
    const elongEnd = getElongationForDate(endOfDay);
    
    if (elongStart === null || elongEnd === null) return '';
    
    // Check each of the 4 major quarters
    const quarters = [
      { angle: 0, icon: 'ğŸŒ‘' },    // New Moon
      { angle: 90, icon: 'ğŸŒ“' },   // First Quarter
      { angle: 180, icon: 'ğŸŒ•' },  // Full Moon
      { angle: 270, icon: 'ğŸŒ—' }   // Last Quarter
    ];
    
    for (const quarter of quarters) {
      if (phaseOccursDuringDay(elongStart, elongEnd, quarter.angle)) {
        return quarter.icon;
      }
    }
    
    return ''; // No quarter phase on this day
  } catch (err) {
    console.warn('Error calculating moon phase:', err);
    return '';
  }
}

// Check if a phase angle is crossed between two elongation values
function phaseOccursDuringDay(elongStart, elongEnd, targetAngle) {
  // Elongation increases over time (moon moves ~12Â° per day relative to sun)
  // Handle the 360Â°â†’0Â° wraparound for new moon
  
  if (targetAngle === 0) {
    // New moon: elongation wraps from ~350+ to ~10-
    // This happens when elongStart is high (>300) and elongEnd is lower OR 
    // when elongStart > 350 and elongEnd is small
    if (elongStart > 300 && elongEnd < elongStart) {
      // Could be wraparound or normal decrease (shouldn't normally decrease much)
      // If elongEnd is small (<60), it wrapped around
      if (elongEnd < 60) return true;
    }
    // Also check if we're very close to 0 on either end
    if (elongStart > 350 || elongEnd < 10) {
      if (elongStart > 350 && elongEnd < 60) return true;
    }
  } else {
    // For other phases (90, 180, 270): check if targetAngle is between start and end
    // Normal case: elongation increases
    if (elongStart <= targetAngle && elongEnd >= targetAngle) return true;
    
    // Edge case: day spans the 360â†’0 boundary but target is not 0
    // In this case, elongStart > elongEnd due to wraparound
    if (elongStart > elongEnd) {
      // Wrapped around - check both segments
      if (elongStart <= targetAngle || elongEnd >= targetAngle) return true;
    }
  }
  
  return false;
}

// Get moon-sun elongation for a date
function getElongationForDate(date) {
  // For Swiss Ephemeris, use the elongation function directly
  if (AstroEngines.swissEphemeris.isLoaded && AstroEngines.swissEphemeris._dateToJD) {
    const jd = AstroEngines.swissEphemeris._dateToJD(date);
    const elongation = AstroEngines.swissEphemeris._getMoonSunElongation(jd);
    if (elongation !== null) return elongation;
  }
  
  // Fallback: use astronomy-engine
  try {
    const engine = getAstroEngine();
    const observer = engine.createObserver(state.lat, state.lon, 0);
    const sunEq = engine.getEquator('sun', date, observer);
    const moonEq = engine.getEquator('moon', date, observer);
    
    if (sunEq && moonEq) {
      let sunRA = sunEq.ra * 15;
      let moonRA = moonEq.ra * 15;
      let elongation = moonRA - sunRA;
      while (elongation < 0) elongation += 360;
      while (elongation >= 360) elongation -= 360;
      return elongation;
    }
  } catch (err) {}
  
  return null;
}

// Calculate angular distance between two angles (0-360), handling wraparound
function angularDistance(a, b) {
  let diff = Math.abs(a - b);
  if (diff > 180) diff = 360 - diff;
  return diff;
}

function getMoonLabel() {
  if (state.moonPhase === 'full') return 'Full Moon';
  if (state.moonPhase === 'dark') return 'Dark Moon';
  if (state.moonPhase === 'crescent') return 'Crescent';
  return 'New Moon';
}

// Get dynamic description for Renewed Moon based on current moon phase setting
function getRenewedMoonDescription() {
  const dayStartLabel = getDayStartLabel();
  const isCrescentSunset = state.moonPhase === 'crescent' && 
                           state.dayStartTime === 'evening' && 
                           state.dayStartAngle === 0;
  
  if (state.moonPhase === 'full') {
    return `Month begins at ${dayStartLabel} after full moon`;
  } else if (state.moonPhase === 'dark') {
    return `Month begins at ${dayStartLabel} after dark moon (conjunction)`;
  } else if (state.moonPhase === 'crescent') {
    if (isCrescentSunset) {
      return 'Month begins at sunset when first crescent is sighted';
    }
    return `Month begins at ${dayStartLabel} after crescent sighting`;
  }
  return 'Beginning of the month';
}

// generateCalendar moved to calendar-core.js

// findMoonEvents moved to calendar-core.js

// getLocalDateFromUTC moved to astronomy-utils.js

// Calculate what lunar day a timestamp falls on for a given profile's settings
// Returns { day: number, month: number } or null if unable to calculate
function getLunarDayForTimestamp(timestamp, profile) {
  try {
    const date = new Date(timestamp);
    let year = date.getFullYear();
    
    // Temporarily store current state and apply profile settings
    const savedState = {
      moonPhase: state.moonPhase,
      dayStartTime: state.dayStartTime,
      dayStartAngle: state.dayStartAngle,
      yearStartRule: state.yearStartRule,
      crescentThreshold: state.crescentThreshold,
      lat: state.lat,
      lon: state.lon
    };
    
    // Apply profile settings temporarily (with defaults for undefined values)
    state.moonPhase = profile.moonPhase || 'full';
    state.dayStartTime = profile.dayStartTime || 'morning';
    state.dayStartAngle = profile.dayStartAngle ?? 12;
    state.yearStartRule = profile.yearStartRule || 'equinox';
    state.crescentThreshold = profile.crescentThreshold ?? 18;
    state.lat = profile.lat ?? 31.7683;
    state.lon = profile.lon ?? 35.2137;
    
    const engine = getAstroEngine();
    
    // Check if timestamp is before this year's spring equinox - if so, use previous year
    const thisYearEquinox = engine.getSeasons(year).mar_equinox.date;
    if (date < thisYearEquinox) {
      year = year - 1;
    }
    
    // Find moon events for the year (need events spanning into next year)
    const moonEvents = findMoonEvents(year, profile.moonPhase);
    if (!moonEvents || moonEvents.length === 0) {
      Object.assign(state, savedState);
      return null;
    }
    
    // Find the spring equinox for the lunar year
    const springEquinox = engine.getSeasons(year).mar_equinox.date;
    
    // Find the first moon event on or after the spring equinox for Nisan
    let nissanMoon = null;
    for (const event of moonEvents) {
      if (event >= springEquinox) {
        nissanMoon = event;
        break;
      }
    }
    
    // If no moon event after equinox, check the last one before
    if (!nissanMoon && moonEvents.length > 0) {
      for (let i = moonEvents.length - 1; i >= 0; i--) {
        if (moonEvents[i] < springEquinox) {
          nissanMoon = moonEvents[i];
          break;
        }
      }
    }
    
    if (!nissanMoon) {
      Object.assign(state, savedState);
      return null;
    }
    
    // Build simplified lunar months to find the day
    const observerLon = profile.lon;
    let currentMoonIdx = moonEvents.findIndex(m => Math.abs(m.getTime() - nissanMoon.getTime()) < 1000);
    if (currentMoonIdx === -1) currentMoonIdx = moonEvents.findIndex(m => m >= nissanMoon);
    
    // Iterate through months to find where the timestamp falls
    for (let m = 0; m < 13 && currentMoonIdx < moonEvents.length - 1; m++) {
      const moonEvent = moonEvents[currentMoonIdx];
      const nextMoonEvent = moonEvents[currentMoonIdx + 1];
      
      // Calculate month start date (similar to buildLunarMonths)
      const moonEventLocalDate = new Date(moonEvent.getTime());
      const monthStartDate = new Date(Date.UTC(
        moonEventLocalDate.getUTCFullYear(),
        moonEventLocalDate.getUTCMonth(),
        moonEventLocalDate.getUTCDate(),
        0, 0, 0
      ));
      
      // Apply day offset based on settings
      if ((profile.moonPhase === 'dark' || profile.moonPhase === 'full' || profile.moonPhase === 'crescent') && profile.dayStartTime === 'evening') {
        const sunsetOnMoonDate = getSunsetTimestamp(moonEventLocalDate);
        if (sunsetOnMoonDate != null) {
          const moonEventLocalTime = moonEvent.getTime() + (observerLon / 15) * 60 * 60 * 1000;
          const sunsetLocalTime = sunsetOnMoonDate + (observerLon / 15) * 60 * 60 * 1000;
          if (moonEventLocalTime > sunsetLocalTime) {
            monthStartDate.setUTCDate(monthStartDate.getUTCDate() + 1);
          }
        }
      }
      
      // Calculate next month start
      const nextMoonEventLocalDate = new Date(nextMoonEvent.getTime());
      const nextMonthStart = new Date(Date.UTC(
        nextMoonEventLocalDate.getUTCFullYear(),
        nextMoonEventLocalDate.getUTCMonth(),
        nextMoonEventLocalDate.getUTCDate(),
        0, 0, 0
      ));
      
      if ((profile.moonPhase === 'dark' || profile.moonPhase === 'full' || profile.moonPhase === 'crescent') && profile.dayStartTime === 'evening') {
        const sunsetOnNextMoonDate = getSunsetTimestamp(nextMoonEventLocalDate);
        if (sunsetOnNextMoonDate != null) {
          const nextMoonEventLocalTime = nextMoonEvent.getTime() + (observerLon / 15) * 60 * 60 * 1000;
          const nextSunsetLocalTime = sunsetOnNextMoonDate + (observerLon / 15) * 60 * 60 * 1000;
          if (nextMoonEventLocalTime > nextSunsetLocalTime) {
            nextMonthStart.setUTCDate(nextMonthStart.getUTCDate() + 1);
          }
        }
      }
      
      // Check if timestamp falls in this month
      const timestampDate = new Date(timestamp);
      const timestampDayStart = new Date(Date.UTC(
        timestampDate.getUTCFullYear(),
        timestampDate.getUTCMonth(),
        timestampDate.getUTCDate(),
        0, 0, 0
      ));
      
      if (timestampDayStart >= monthStartDate && timestampDayStart < nextMonthStart) {
        // Found the month - calculate the day
        const dayOffset = Math.floor((timestampDayStart - monthStartDate) / (24 * 60 * 60 * 1000));
        const lunarDay = dayOffset + 1;
        
        // Restore state
        Object.assign(state, savedState);
        return { day: lunarDay, month: m + 1 };
      }
      
      currentMoonIdx++;
    }
    
    // Restore state
    Object.assign(state, savedState);
    return null;
  } catch (e) {
    console.warn('Error calculating lunar day for profile:', e);
    return null;
  }
}

// buildLunarMonths moved to calendar-core.js

// formatShortDate moved to calendar-core.js
// formatFullDate moved to calendar-core.js

// Calculate the "dateline" longitude - the first place to start the new day
// At any UTC time H, solar noon is at longitude = (12 - H) * 15 degrees
// Sunrise occurs 90Â° to the WEST of the subsolar point (6 hours earlier in local time)
// Sunset occurs 90Â° to the EAST of the subsolar point (6 hours later in local time)
// The dateline is where the day start event is occurring at the moment of the moon event
// This is the first place on Earth to begin a new day
function calculateDatelineLongitude(moonEventDate, moonPhase) {
  // Get UTC hours as decimal
  const utcHours = moonEventDate.getUTCHours() + moonEventDate.getUTCMinutes() / 60;
  
  // The subsolar point (where it's local noon) at this UTC time
  // At UTC 12:00, noon is at 0Â° (Greenwich)
  // At UTC 0:00, noon is at 180Â° (International Date Line)
  const subsolarLon = (12 - utcHours) * 15;
  
  let datelineLon;
  if (state.dayStartTime === 'evening') {
    // Sunset is 90Â° to the EAST of the subsolar point
    // (At any instant, places east of noon are in afternoon/evening)
    datelineLon = subsolarLon + 90;
    // Adjust for twilight angle - evening twilight occurs BEFORE sunset (further east)
    // Roughly 4Â° of longitude per 1Â° of sun angle (varies by latitude)
    datelineLon += state.dayStartAngle * 4;
  } else {
    // Sunrise is 90Â° to the WEST of the subsolar point
    // (At any instant, places west of noon are in morning)
    datelineLon = subsolarLon - 90;
    // Adjust for twilight angle - morning twilight occurs BEFORE sunrise (further east)
    // For morning, twilight starts earlier, so we add to move east
    datelineLon += state.dayStartAngle * 4;
  }
  
  // Normalize to -180 to 180
  while (datelineLon > 180) datelineLon -= 360;
  while (datelineLon < -180) datelineLon += 360;
  
  return datelineLon;
}

function getDatelineCity(lon) {
  // Find approximate region for the dateline longitude
  if (lon >= 140 || lon < -170) return 'Pacific Ocean (Date Line)';
  if (lon >= 120) return 'Japan / Philippines';
  if (lon >= 100) return 'China / Southeast Asia';
  if (lon >= 70) return 'India / Central Asia';
  if (lon >= 35) return 'Middle East';
  if (lon >= 10) return 'Europe / Africa';
  if (lon >= -30) return 'Atlantic Ocean';
  if (lon >= -50) return 'South America (East)';
  if (lon >= -70) return 'South America (West) / Caribbean';
  if (lon >= -85) return 'Americas (Eastern US / Central America)';
  if (lon >= -105) return 'Americas (Central US / Mexico)';
  if (lon >= -120) return 'Americas (West Coast)';
  if (lon >= -150) return 'Alaska / Hawaii';
  return 'Pacific Ocean';
}

// Get the day start event name for display
function getDayStartEventName() {
  if (state.dayStartAngle === 0) {
    return state.dayStartTime === 'evening' ? 'Sunset' : 'Sunrise';
  } else if (state.dayStartAngle === 6) {
    return state.dayStartTime === 'evening' ? 'Civil Dusk' : 'Civil Dawn';
  } else if (state.dayStartAngle === 12) {
    return state.dayStartTime === 'evening' ? 'Nautical Dusk' : 'Nautical Dawn';
  } else if (state.dayStartAngle === 18) {
    return state.dayStartTime === 'evening' ? 'Astronomical Dusk' : 'Astronomical Dawn';
  }
  return state.dayStartTime === 'evening' ? 'Evening Twilight' : 'Morning Twilight';
}

// Get the day start icon for the marker
function getDayStartIcon() {
  return state.dayStartTime === 'evening' ? 'ğŸŒ…' : 'â˜€';
}

function renderDatelineVisualization(moonEventDate, options = {}) {
  const utcHours = moonEventDate.getUTCHours() + moonEventDate.getUTCMinutes() / 60;
  const datelineLon = calculateDatelineLongitude(moonEventDate, state.moonPhase);
  
  // Convert longitude to percentage position (lon -180 = 0%, lon 180 = 100%)
  const position = ((datelineLon + 180) / 360) * 100;
  
  const region = getDatelineCity(datelineLon);
  const lonStr = datelineLon >= 0 
    ? `${Math.abs(datelineLon).toFixed(1)}Â°E` 
    : `${Math.abs(datelineLon).toFixed(1)}Â°W`;
  
  // Format moon event date for display
  const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  const moonDateStr = `${months[moonEventDate.getUTCMonth()]} ${moonEventDate.getUTCDate()}, ${moonEventDate.getUTCFullYear()}`;
  const utcTimeStr = `${Math.floor(utcHours).toString().padStart(2,'0')}:${Math.round((utcHours % 1) * 60).toString().padStart(2,'0')} UTC`;
  
  // Get day start event name and icon based on settings
  const dayStartEvent = getDayStartEventName();
  const dayStartIcon = getDayStartIcon();
  const markerLabel = dayStartEvent.toUpperCase();
  
  // Current location marker position - use provided options or fall back to state
  const currentLat = options.lat ?? state.lat ?? 31.7683;
  const currentLon = options.lon ?? state.lon ?? 35.2137;
  const locX = ((currentLon + 180) / 360) * 100;
  const locY = ((90 - currentLat) / 180) * 100;
  
  // Get location display name (city name or region) - use the provided coordinates
  const locationName = getCurrentLocationName(currentLat, currentLon);
  const coordStr = `${currentLat.toFixed(2)}Â°${currentLat >= 0 ? 'N' : 'S'}, ${Math.abs(currentLon).toFixed(2)}Â°${currentLon >= 0 ? 'E' : 'W'}`;
  // Show city name with coordinates, or just coordinates if it's a timezone region
  const locationDisplay = !locationName.includes('/') 
    ? `${locationName} (${coordStr})`
    : coordStr;
  
  return `
    <div class="dateline-container">
      <div class="dateline-label">${dayStartEvent} line at moment of ${getMoonLabel()} â€” ${moonDateStr} â€” ${utcTimeStr}</div>
      <div class="dateline-map" onclick="handleMapClick(event)">
        <div class="dateline-map-bg">
          <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/23/Blue_Marble_2002.png/1280px-Blue_Marble_2002.png" 
               alt="World Map"
               draggable="false"
               style="user-select: none; -webkit-user-drag: none; pointer-events: none;"
               onerror="this.style.display='none'">
        </div>
        <div class="dateline-marker" style="left: ${position}%">
          <span class="dateline-marker-icon">${dayStartIcon}</span>
          <span class="dateline-marker-label">${markerLabel}</span>
        </div>
        <div class="dateline-location-marker" style="left: ${locX}%; top: ${locY}%" title="${locationName}: ${coordStr}"><div class="dateline-location-pin"></div></div>
      </div>
      <div class="dateline-cities">
        <span>180Â°W</span>
        <span>90Â°W</span>
        <span>0Â°</span>
        <span>90Â°E</span>
        <span>180Â°E</span>
      </div>
      <div class="dateline-info">Day start line: ${lonStr} â€” ${region}</div>
      <div class="dateline-info" style="color: #7ec8e3;">Your location: ${locationDisplay}</div>
      <div class="dateline-click-hint">Click map to change location â€¢ First to reach ${dayStartEvent.toLowerCase()} after ${getMoonLabel()} starts month first</div>
    </div>
  `;
}

function formatMoonDateTime(date) {
  const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
  
  // UTC date and time - use correct weekday calculation for ancient dates
  const utcDay = days[getCorrectWeekday(date)];
  const utcMonth = months[date.getUTCMonth()];
  const utcDate = date.getUTCDate();
  const utcHours = date.getUTCHours().toString().padStart(2, '0');
  const utcMins = date.getUTCMinutes().toString().padStart(2, '0');
  
  // Local date and time
  const localDay = days[date.getDay()];
  const localMonth = months[date.getMonth()];
  const localDate = date.getDate();
  const localHours = date.getHours().toString().padStart(2, '0');
  const localMins = date.getMinutes().toString().padStart(2, '0');
  
  // Get timezone abbreviation
  const tzName = Intl.DateTimeFormat('en-US', { timeZoneName: 'short' }).formatToParts(date)
    .find(part => part.type === 'timeZoneName')?.value || 'Local';
  
  // Check if UTC and local are on different calendar days
  const sameDay = (date.getUTCDate() === date.getDate() && 
                   date.getUTCMonth() === date.getMonth() &&
                   date.getUTCFullYear() === date.getFullYear());
  
  if (sameDay) {
    return `${localDay}, ${localMonth} ${localDate}<br>` +
           `UTC: ${utcHours}:${utcMins}<br>` +
           `${tzName}: ${localHours}:${localMins}`;
  } else {
    // Show both dates when they differ
    return `UTC: ${utcDay}, ${utcMonth} ${utcDate} ${utcHours}:${utcMins}<br>` +
           `${tzName}: ${localDay}, ${localMonth} ${localDate} ${localHours}:${localMins}`;
  }
}

// renderMonth moved to calendar-core.js

// jumpToFeast moved to calendar-core.js
// renderFeastTable moved to calendar-core.js

// Handle browser back/forward buttons
window.addEventListener('popstate', function(event) {
  // Parse the path-based URL
  const urlState = parsePathURL();
  
  if (urlState.view === 'sabbath-tester') {
    // Navigate back to sabbath tester
    const sabbathTesterPage = document.getElementById('sabbath-tester-page');
    const calendarOutput = document.getElementById('calendar-output');
    const dayDetailPanel = document.getElementById('day-detail-panel');
    const exportPage = document.getElementById('export-page');
    
    calendarOutput.style.display = 'none';
    dayDetailPanel.style.display = 'none';
    exportPage.style.display = 'none';
    sabbathTesterPage.style.display = 'block';
    renderSabbathTester();
  } else if (urlState.view === 'feasts') {
    navigateTo('feasts');
  } else {
    // Navigate to calendar with URL state
    const { needsRegenerate, month, day } = applyURLState(urlState);
    if (needsRegenerate) {
      updateUI();
      generateCalendar();
    }
    if (month !== null || day !== null) {
      if (month !== null) state.currentMonthIndex = month - 1;
      if (day !== null) state.highlightedLunarDay = day;
      renderMonth(state.lunarMonths[state.currentMonthIndex]);
      updateMonthButtons();
    }
    navigateTo('calendar');
  }
});

document.addEventListener('DOMContentLoaded', async function() {
  // Clear any lingering overflow classes from previous sessions
  document.body.classList.remove('sabbath-tester-open', 'feasts-open');
  document.documentElement.classList.remove('feasts-open');
  document.body.style.overflow = '';
  
  // Check for redirect path from 404 page (GitHub Pages SPA routing)
  const redirectPath = sessionStorage.getItem('redirectPath');
  if (redirectPath) {
    sessionStorage.removeItem('redirectPath');
    // Replace the current URL with the intended path
    window.history.replaceState({}, '', redirectPath);
  }
  
  // Rebuild profile dropdown with any saved custom profiles
  rebuildProfileDropdown();
  
  // Initialize settings editability (presets are read-only)
  updateSettingsEditability();
  
  // Initialize astronomy engine (loads Swiss Ephemeris WASM)
  await initializeAstroEngine();
  
  // Check if URL has path data or query params - if so, load from URL
  const path = window.location.pathname;
  const hasPathData = path !== '/' && path !== '/index.html';
  const hasQueryData = window.location.search.length > 0;
  
  if (hasPathData || hasQueryData) {
    // URL has state - restore from URL
    updateUI(); // Set UI from localStorage first
    generateCalendar();
    loadFromURL(); // Then override with URL params/path
  } else {
    // No URL data - always jump to today's date on fresh load
    jumpToToday();
    updateURL(); // Set initial URL
  }
  
  // Start live time updates for header display
  updateTimeDisplay();
  startLiveTimeUpdates();
  
  // Show about modal on page load (greeting) - at most once per day, max 3 dismissals
  // Wait for calendar to be fully rendered before showing modal
  setTimeout(() => {
    if (shouldShowAboutModal()) {
      showAboutModal();
    }
  }, 1000);  // Increased delay to ensure calendar is rendered
  
  // Initialize PWA install button
  initInstallButton();
  
  // Event delegation for feast table clicks
  document.getElementById('feast-tbody').addEventListener('click', function(e) {
    const link = e.target.closest('.feast-jump');
    if (link) {
      e.preventDefault();
      const monthIdx = parseInt(link.dataset.month);
      const lunarDay = parseInt(link.dataset.day);
      jumpToFeast(monthIdx, lunarDay);
    }
  });
  
  // Event delegation for calendar day cell clicks - update goto-date input and highlight
  document.getElementById('calendar-output').addEventListener('click', function(e) {
    // Check for day cell click
    const cell = e.target.closest('.day-cell[data-date]');
    if (cell) {
      // Find the lunar day for this cell and store the timestamp
      const lunarDayEl = cell.querySelector('.lunar-day');
      if (lunarDayEl) {
        const lunarDay = parseInt(lunarDayEl.textContent);
        const month = state.lunarMonths[state.currentMonthIndex];
        const dayObj = month.days.find(d => d.lunarDay === lunarDay);
        if (dayObj) {
          // Calculate sunrise time at selected location for this day
          state.selectedTimestamp = getSunriseTimestamp(dayObj.gregorianDate);
          document.getElementById('goto-date').value = formatLocalDatetime(state.selectedTimestamp);
          showDayDetail(dayObj, month);
        }
        state.highlightedLunarDay = lunarDay;
        renderMonth(state.lunarMonths[state.currentMonthIndex]);
        updateURL();
      }
      return;
    }
    
    // Check for new-moon-box (Day 1) click
    const newMoonBox = e.target.closest('.new-moon-box[data-date]');
    if (newMoonBox) {
      const month = state.lunarMonths[state.currentMonthIndex];
      const dayObj = month.days.find(d => d.lunarDay === 1);
      if (dayObj) {
        // Calculate sunrise time at selected location for this day
        state.selectedTimestamp = getSunriseTimestamp(dayObj.gregorianDate);
        document.getElementById('goto-date').value = formatLocalDatetime(state.selectedTimestamp);
        showDayDetail(dayObj, month);
      }
      state.highlightedLunarDay = 1;
      renderMonth(state.lunarMonths[state.currentMonthIndex]);
      updateURL();
    }
  });
});

// refreshDayDetailIfVisible moved to day-detail.js
// showDayDetail moved to day-detail.js
// closeDayDetail moved to day-detail.js
// getOrdinalSuffix moved to day-detail.js
// jumpToEquinoxDate moved to day-detail.js
// getFormattedDateParts moved to day-detail.js
// formatDisplayDate moved to day-detail.js
// julianCalendarToJDN moved to day-detail.js
// jdnToWeekday moved to day-detail.js

// jumpToEquinoxDate moved to day-detail.js

function jumpToToday() {
  const now = new Date();
  const utcTimestamp = now.getTime();
  
  // Get the current date at the selected location (based on longitude)
  // utcToLocalTime returns a Date where UTC methods give local time at location
  const localDateAtLocation = utcToLocalTime(utcTimestamp, state.lon);
  const targetYear = localDateAtLocation.getUTCFullYear();
  const targetMonth = localDateAtLocation.getUTCMonth();
  const targetDay = localDateAtLocation.getUTCDate();
  
  // Update goto-date input with local time at selected location
  document.getElementById('goto-date').value = formatLocalDatetime(utcTimestamp);
  
  // Determine which lunar year today belongs to
  // Use UTC comparison - the calendar builds months based on UTC moon events
  const springEquinox = getAstroEngine().getSeasons(targetYear).mar_equinox.date;
  const lunarYear = utcTimestamp < springEquinox.getTime() ? targetYear - 1 : targetYear;
  
  // Update state year (keep other settings from localStorage)
  state.year = lunarYear;
  
  // Update UI with all state (including saved location/moon phase settings)
  updateUI();
  
  // Generate calendar for today's lunar year
  generateCalendar();
  
  // Find today in the generated months
  // Calendar dates are stored as browser-local Date objects but represent the date at the location
  for (let m = 0; m < state.lunarMonths.length; m++) {
    const month = state.lunarMonths[m];
    for (let d = 0; d < month.days.length; d++) {
      const day = month.days[d];
      const gd = day.gregorianDate;
      // Compare year/month/day - both represent the date at the observer's location
      if (gd.getFullYear() === targetYear && 
          gd.getMonth() === targetMonth && 
          gd.getDate() === targetDay) {
        state.currentMonthIndex = m;
        state.highlightedLunarDay = day.lunarDay;
        state.selectedTimestamp = utcTimestamp;
        renderMonth(state.lunarMonths[m]);
        updateMonthButtons();
        showDayDetail(day, month);
        return;
      }
    }
  }
  
  // Fallback: if today not found, just show first month
  state.currentMonthIndex = 0;
  renderMonth(state.lunarMonths[0]);
  updateMonthButtons();
}

// Open ICS directly in calendar app
async function openInCalendar() {
  const icsContent = generateICSContent();
  if (!icsContent) return;
  
  const filename = `lunar-sabbath-calendar-${state.year}.ics`;
  const blob = new Blob([icsContent], { type: 'text/calendar' });
  const file = new File([blob], filename, { type: 'text/calendar' });
  
  // Try Web Share API first (works great on mobile and some desktop)
  if (navigator.share && navigator.canShare && navigator.canShare({ files: [file] })) {
    try {
      await navigator.share({
        files: [file],
        title: 'Lunar Sabbath Calendar',
        text: `Sabbaths and Feasts for ${formatYear(state.year)}`
      });
      return;
    } catch (err) {
      if (err.name !== 'AbortError') {
        console.log('Share failed, falling back to download');
      } else {
        return; // User cancelled
      }
    }
  }
  
  // Fallback: Download the file
  exportToICS();
  
  // Close the export modal after successful download
  const exportPage = document.getElementById('export-page');
  if (exportPage && exportPage.style.display !== 'none') {
    toggleExportModal();
  }
}

// Generate ICS content for calendar export
function generateICSContent() {
  if (!state.lunarMonths || state.lunarMonths.length === 0) {
    alert('Please generate a calendar first');
    return null;
  }
  
  const events = [];
  const yearLabel = formatYear(state.year);
  
  // Collect all Sabbaths and Feasts
  for (const month of state.lunarMonths) {
    for (const day of month.days) {
      // Add Sabbaths
      if (isSabbath(day)) {
        const sabbathLabel = state.sabbathMode === 'lunar' ? 'Lunar Sabbath' : 
                             state.sabbathMode === 'saturday' ? 'Shabbat' :
                             state.sabbathMode === 'sunday' ? 'Lord\'s Day' :
                             state.sabbathMode === 'friday' ? 'Jumu\'ah' : 
                             'Rest Day';
        events.push({
          date: day.gregorianDate,
          title: `${sabbathLabel} (${MONTH_NAMES[month.monthNumber - 1]} ${day.lunarDay})`,
          description: `${sabbathLabel} - Day ${day.lunarDay} of ${MONTH_NAMES[month.monthNumber - 1]}`,
          allDay: true
        });
      }
      
      // Add Feasts
      if (day.feast) {
        let title = day.feast.name;
        if (day.feastDayNum) {
          title += ` Day ${day.feastDayNum}`;
        }
        events.push({
          date: day.gregorianDate,
          title: title,
          description: day.feast.description + ` (${MONTH_NAMES[month.monthNumber - 1]} ${day.lunarDay})`,
          allDay: true
        });
      }
      
      // Add New Moon days
      if (day.isNewMoon) {
        events.push({
          date: day.gregorianDate,
          title: `New Moon - ${MONTH_NAMES[month.monthNumber - 1]}`,
          description: `Start of ${MONTH_NAMES[month.monthNumber - 1]} (Lunar Month ${month.monthNumber})`,
          allDay: true
        });
      }
    }
  }
  
  // Sort events by date
  events.sort((a, b) => a.date.getTime() - b.date.getTime());
  
  // Generate ICS content
  let ics = [
    'BEGIN:VCALENDAR',
    'VERSION:2.0',
    'PRODID:-//LunarSabbath.net//Lunar Sabbath Calendar//EN',
    'CALSCALE:GREGORIAN',
    'METHOD:PUBLISH',
    `X-WR-CALNAME:Lunar Sabbath Calendar ${yearLabel}`
  ];
  
  for (const event of events) {
    const dateStr = formatICSDate(event.date);
    const uid = `${dateStr}-${event.title.replace(/\s+/g, '-')}@lunarsabbath.net`;
    
    ics.push('BEGIN:VEVENT');
    ics.push(`UID:${uid}`);
    ics.push(`DTSTART;VALUE=DATE:${dateStr}`);
    ics.push(`DTEND;VALUE=DATE:${dateStr}`);
    ics.push(`SUMMARY:${escapeICS(event.title)}`);
    ics.push(`DESCRIPTION:${escapeICS(event.description)}`);
    ics.push('END:VEVENT');
  }
  
  ics.push('END:VCALENDAR');
  
  return ics.join('\r\n');
}

// Export Sabbaths and Feasts to ICS file for calendar import
function exportToICS() {
  const icsContent = generateICSContent();
  if (!icsContent) return;
  
  // Download the file
  const blob = new Blob([icsContent], { type: 'text/calendar;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = `lunar-sabbath-calendar-${state.year}.ics`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

function formatICSDate(date) {
  const year = date.getFullYear();
  const month = (date.getMonth() + 1).toString().padStart(2, '0');
  const day = date.getDate().toString().padStart(2, '0');
  return `${year}${month}${day}`;
}

function escapeICS(text) {
  // Escape special characters for ICS format
  return text
    .replace(/\\/g, '\\\\')
    .replace(/;/g, '\\;')
    .replace(/,/g, '\\,')
    .replace(/\n/g, '\\n');
}

// Register Service Worker for PWA functionality
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js')
      .then((registration) => {
        console.log('ServiceWorker registered:', registration.scope);
      })
      .catch((error) => {
        console.log('ServiceWorker registration failed:', error);
      });
  });
}

// Track book PDF download with GoatCounter
function trackBookDownload() {
  if (typeof goatcounter !== 'undefined' && goatcounter.count) {
    goatcounter.count({
      path: '/download/book-pdf',
      title: 'Book PDF Download',
      event: true
    });
  }
}
</script>

<!-- GoatCounter Analytics -->
<script data-goatcounter="https://lunarsabbath.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
</body>
</html>
